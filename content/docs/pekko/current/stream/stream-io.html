<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="Apache Pekko is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala.">
<meta name="generator" content="Paradox, paradox-material-theme=0.6.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="Apache Pekko is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala.">
<link rel="shortcut icon" href="../assets/images/pekko_favicon.png">
<title>Working with streaming IO Â· Apache Pekko Documentation</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../assets/stylesheets/application-palette.22915126.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
<link rel="stylesheet" href="../assets/stylesheets/pekko-theme.css">
</head>
<body
data-md-color-primary="white"
data-md-color-accent="orange"
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="Apache Pekko Documentation" class="md-header-nav__button md-logo">
<img src="../assets/images/pekko_logo.png" width="24" height="24">
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Apache Pekko Documentation
</span>
<span class="md-header-nav__topic">
Working with streaming IO
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/apache/incubator-pekko"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="Apache Pekko Documentation" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<img src="../assets/images/pekko_logo.png" width="24" height="24">
</a>
<a href="../index.html" title="Apache Pekko Documentation">
Apache Pekko Documentation
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/apache/incubator-pekko"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko
</div>
</a>

</div>
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a>
  <ul>
    <li><a href="../security/index.html#receiving-security-advisories" class="header">Receiving Security Advisories</a></li>
    <li><a href="../security/index.html#reporting-vulnerabilities" class="header">Reporting Vulnerabilities</a></li>
    <li><a href="../security/index.html#security-related-documentation" class="header">Security Related Documentation</a></li>
  </ul></li>
  <li><a href="../typed/guide/index.html" class="page">Getting Started Guide</a>
  <ul>
    <li><a href="../typed/guide/introduction.html" class="page">Introduction to Apache Pekko</a></li>
    <li><a href="../typed/guide/actors-motivation.html" class="page">Why modern systems need a new programming model</a></li>
    <li><a href="../typed/guide/actors-intro.html" class="page">How the Actor Model Meets the Needs of Modern, Distributed Systems</a></li>
    <li><a href="../typed/guide/modules.html" class="page">Overview of Apache Pekko libraries and modules</a></li>
    <li><a href="../typed/guide/tutorial.html" class="page">Introduction to the Example</a></li>
    <li><a href="../typed/guide/tutorial_1.html" class="page">Part 1: Actor Architecture</a></li>
    <li><a href="../typed/guide/tutorial_2.html" class="page">Part 2: Creating the First Actor</a></li>
    <li><a href="../typed/guide/tutorial_3.html" class="page">Part 3: Working with Device Actors</a></li>
    <li><a href="../typed/guide/tutorial_4.html" class="page">Part 4: Working with Device Groups</a></li>
    <li><a href="../typed/guide/tutorial_5.html" class="page">Part 5: Querying Device Groups</a></li>
  </ul></li>
  <li><a href="../general/index.html" class="page">General Concepts</a>
  <ul>
    <li><a href="../general/terminology.html" class="page">Terminology, Concepts</a></li>
    <li><a href="../general/actor-systems.html" class="page">Actor Systems</a></li>
    <li><a href="../general/actors.html" class="page">What is an Actor?</a></li>
    <li><a href="../general/supervision.html" class="page">Supervision and Monitoring</a></li>
    <li><a href="../general/addressing.html" class="page">Actor References, Paths and Addresses</a></li>
    <li><a href="../general/remoting.html" class="page">Location Transparency</a></li>
    <li><a href="../general/jmm.html" class="page">Apache Pekko and the Java Memory Model</a></li>
    <li><a href="../general/message-delivery-reliability.html" class="page">Message Delivery Reliability</a></li>
    <li><a href="../general/configuration.html" class="page">Configuration</a></li>
    <li><a href="../general/configuration-reference.html" class="page">Default configuration</a></li>
  </ul></li>
  <li><a href="../typed/index.html" class="page">Actors</a>
  <ul>
    <li><a href="../typed/actors.html" class="page">Introduction to Actors</a></li>
    <li><a href="../typed/actor-lifecycle.html" class="page">Actor lifecycle</a></li>
    <li><a href="../typed/interaction-patterns.html" class="page">Interaction Patterns</a></li>
    <li><a href="../typed/fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="../typed/actor-discovery.html" class="page">Actor discovery</a></li>
    <li><a href="../typed/routers.html" class="page">Routers</a></li>
    <li><a href="../typed/stash.html" class="page">Stash</a></li>
    <li><a href="../typed/fsm.html" class="page">Behaviors as finite state machines</a></li>
    <li><a href="../coordinated-shutdown.html" class="page">Coordinated Shutdown</a></li>
    <li><a href="../typed/dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="../typed/mailboxes.html" class="page">Mailboxes</a></li>
    <li><a href="../typed/testing.html" class="page">Testing</a></li>
    <li><a href="../typed/coexisting.html" class="page">Coexistence</a></li>
    <li><a href="../typed/style-guide.html" class="page">Style guide</a></li>
    <li><a href="../typed/from-classic.html" class="page">Learning Pekko Typed from Classic</a></li>
  </ul></li>
  <li><a href="../typed/index-cluster.html" class="page">Cluster</a>
  <ul>
    <li><a href="../typed/cluster.html" class="page">Cluster Usage</a></li>
    <li><a href="../typed/cluster-concepts.html" class="page">Cluster Specification</a></li>
    <li><a href="../typed/cluster-membership.html" class="page">Cluster Membership Service</a></li>
    <li><a href="../typed/failure-detector.html" class="page">Phi Accrual Failure Detector</a></li>
    <li><a href="../typed/distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="../typed/cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="../typed/cluster-sharding.html" class="page">Cluster Sharding</a></li>
    <li><a href="../typed/cluster-sharding-concepts.html" class="page">Cluster Sharding concepts</a></li>
    <li><a href="../typed/cluster-sharded-daemon-process.html" class="page">Sharded Daemon Process</a></li>
    <li><a href="../typed/cluster-dc.html" class="page">Multi-DC Cluster</a></li>
    <li><a href="../typed/distributed-pub-sub.html" class="page">Distributed Publish Subscribe in Cluster</a></li>
    <li><a href="../typed/reliable-delivery.html" class="page">Reliable delivery</a></li>
    <li><a href="../serialization.html" class="page">Serialization</a></li>
    <li><a href="../serialization-jackson.html" class="page">Serialization with Jackson</a></li>
    <li><a href="../multi-jvm-testing.html" class="page">Multi JVM Testing</a></li>
    <li><a href="../multi-node-testing.html" class="page">Multi Node Testing</a></li>
    <li><a href="../remoting-artery.html" class="page">Artery Remoting</a></li>
    <li><a href="../remoting.html" class="page">Classic Remoting (Deprecated)</a></li>
    <li><a href="../split-brain-resolver.html" class="page">Split Brain Resolver</a></li>
    <li><a href="../coordination.html" class="page">Coordination</a></li>
    <li><a href="../typed/choosing-cluster.html" class="page">Choosing Pekko Cluster</a></li>
  </ul></li>
  <li><a href="../typed/index-persistence.html" class="page">Persistence (Event Sourcing)</a>
  <ul>
    <li><a href="../typed/persistence.html" class="page">Event Sourcing</a></li>
    <li><a href="../typed/replicated-eventsourcing.html" class="page">Replicated Event Sourcing</a></li>
    <li><a href="../typed/cqrs.html" class="page">CQRS</a></li>
    <li><a href="../typed/persistence-style.html" class="page">Style Guide</a></li>
    <li><a href="../typed/persistence-snapshot.html" class="page">Snapshotting</a></li>
    <li><a href="../typed/persistence-testing.html" class="page">Testing</a></li>
    <li><a href="../typed/persistence-fsm.html" class="page">EventSourced behaviors as finite state machines</a></li>
    <li><a href="../persistence-schema-evolution.html" class="page">Schema Evolution for Event Sourced Actors</a></li>
    <li><a href="../persistence-query.html" class="page">Apache Persistence Query</a></li>
    <li><a href="../persistence-query-leveldb.html" class="page">Persistence Query for LevelDB</a></li>
    <li><a href="../persistence-plugins.html" class="page">Persistence Plugins</a></li>
    <li><a href="../persistence-journals.html" class="page">Persistence - Building a storage backend</a></li>
    <li><a href="../typed/replicated-eventsourcing-examples.html" class="page">Replicated Event Sourcing Examples</a></li>
  </ul></li>
  <li><a href="../typed/index-persistence-durable-state.html" class="page">Persistence (Durable State)</a>
  <ul>
    <li><a href="../typed/durable-state/persistence.html" class="page">Durable State</a></li>
    <li><a href="../typed/durable-state/persistence-style.html" class="page">Style Guide</a></li>
    <li><a href="../typed/durable-state/cqrs.html" class="page">CQRS</a></li>
    <li><a href="../durable-state/persistence-query.html" class="page">Persistence Query</a></li>
  </ul></li>
  <li><a href="../stream/index.html" class="page">Streams</a>
  <ul>
    <li><a href="../stream/index.html#module-info" class="header">Module info</a></li>
    <li><a href="../stream/stream-introduction.html" class="page">Introduction</a></li>
    <li><a href="../stream/stream-quickstart.html" class="page">Streams Quickstart Guide</a></li>
    <li><a href="../general/stream/stream-design.html" class="page">Design Principles behind Apache Pekko Streams</a></li>
    <li><a href="../stream/stream-flows-and-basics.html" class="page">Basics and working with Flows</a></li>
    <li><a href="../stream/stream-graphs.html" class="page">Working with Graphs</a></li>
    <li><a href="../stream/stream-composition.html" class="page">Modularity, Composition and Hierarchy</a></li>
    <li><a href="../stream/stream-rate.html" class="page">Buffers and working with rate</a></li>
    <li><a href="../stream/stream-context.html" class="page">Context Propagation</a></li>
    <li><a href="../stream/stream-dynamic.html" class="page">Dynamic stream handling</a></li>
    <li><a href="../stream/stream-customize.html" class="page">Custom stream processing</a></li>
    <li><a href="../stream/futures-interop.html" class="page">Futures interop</a></li>
    <li><a href="../stream/actor-interop.html" class="page">Actors interop</a></li>
    <li><a href="../stream/reactive-streams-interop.html" class="page">Reactive Streams Interop</a></li>
    <li><a href="../stream/stream-error.html" class="page">Error Handling in Streams</a></li>
    <li><a href="../stream/stream-io.html#working-with-streaming-io" class="active page">Working with streaming IO</a></li>
    <li><a href="../stream/stream-refs.html" class="page">StreamRefs - Reactive Streams over the network</a></li>
    <li><a href="../stream/stream-parallelism.html" class="page">Pipelining and Parallelism</a></li>
    <li><a href="../stream/stream-testkit.html" class="page">Testing streams</a></li>
    <li><a href="../stream/stream-substream.html" class="page">Substreams</a></li>
    <li><a href="../stream/stream-cookbook.html" class="page">Streams Cookbook</a></li>
    <li><a href="../general/stream/stream-configuration.html" class="page">Configuration</a></li>
    <li><a href="../stream/operators/index.html" class="page">Operators</a></li>
  </ul></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a>
  <ul>
    <li><a href="../discovery/index.html#module-info" class="header">Module info</a></li>
    <li><a href="../discovery/index.html#how-it-works" class="header">How it works</a></li>
    <li><a href="../discovery/index.html#discovery-method-dns" class="header">Discovery Method: DNS</a></li>
    <li><a href="../discovery/index.html#discovery-method-configuration" class="header">Discovery Method: Configuration</a></li>
    <li><a href="../discovery/index.html#discovery-method-aggregate-multiple-discovery-methods" class="header">Discovery Method: Aggregate multiple discovery methods</a></li>
    <li><a href="../discovery/index.html#migrating-from-pekko-management-discovery-before-1-0-0-" class="header">Migrating from Pekko Management Discovery (before 1.0.0)</a></li>
  </ul></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a>
  <ul>
    <li><a href="../typed/logging.html" class="page">Logging</a></li>
    <li><a href="../common/circuitbreaker.html" class="page">Circuit Breaker</a></li>
    <li><a href="../futures.html" class="page">Futures patterns</a></li>
    <li><a href="../typed/extending.html" class="page">Extending Apache Pekko</a></li>
  </ul></li>
  <li><a href="../common/other-modules.html" class="page">Other Apache Pekko modules</a>
  <ul>
    <li><a href="../common/other-modules.html#" class="header"><a href="https://pekko.apache.org/docs/pekko-http/current/">Pekko HTTP</a></a></li>
    <li><a href="../common/other-modules.html#" class="header"><a href="https://pekko.apache.org/docs/pekko-grpc/current/">Pekko gRPC</a></a></li>
    <li><a href="../common/other-modules.html#" class="header"><a href="https://pekko.apache.org/docs/pekko-connectors/current/">Pekko Connectors</a></a></li>
    <li><a href="../common/other-modules.html#" class="header"><a href="https://pekko.apache.org/docs/pekko-connectors-kafka/current/">Pekko Kafka Connector</a></a></li>
    <li><a href="../common/other-modules.html#" class="header"><a href="https://pekko.apache.org/docs/pekko-projection/current/">Pekko Projections</a></a></li>
    <li><a href="../common/other-modules.html#" class="header"><a href="https://pekko.apache.org/docs/pekko-persistence-cassandra/current/">Cassandra Plugin for Pekko Persistence</a></a></li>
    <li><a href="../common/other-modules.html#" class="header"><a href="https://pekko.apache.org/docs/pekko-persistence-jdbc/current/">JDBC Plugin for Pekko Persistence</a></a></li>
    <li><a href="../common/other-modules.html#" class="header"><a href="https://pekko.apache.org/docs/pekko-persistence-r2dbc/current/">R2DBC Plugin for Pekko Persistence</a></a></li>
    <li><a href="../common/other-modules.html#" class="header"><a href="https://pekko.apache.org/docs/pekko-persistence-spanner/current/">Google Cloud Spanner Plugin for Pekko Persistence</a></a></li>
    <li><a href="../common/other-modules.html#apache-pekko-management" class="header">Apache Pekko Management</a></li>
  </ul></li>
  <li><a href="../additional/deploy.html" class="page">Package, Deploy and Run</a>
  <ul>
    <li><a href="../additional/packaging.html" class="page">Packaging</a></li>
    <li><a href="../additional/operations.html" class="page">Operating a Cluster</a></li>
    <li><a href="../additional/deploying.html" class="page">Deploying</a></li>
    <li><a href="../additional/rolling-updates.html" class="page">Rolling Updates</a></li>
  </ul></li>
  <li><a href="../project/index.html" class="page">Project Information</a>
  <ul>
    <li><a href="../common/binary-compatibility-rules.html" class="page">Binary Compatibility Rules</a></li>
    <li><a href="../project/scala3.html" class="page">Scala 3 support</a></li>
    <li><a href="../project/downstream-upgrade-strategy.html" class="page">Downstream upgrade strategy</a></li>
    <li><a href="../common/may-change.html" class="page">Modules marked &ldquo;May Change&rdquo;</a></li>
    <li><a href="../additional/ide.html" class="page">IDE Tips</a></li>
    <li><a href="../project/immutable.html" class="page">Immutability using Lombok</a></li>
    <li><a href="../additional/osgi.html" class="page">Apache Pekko in OSGi</a></li>
    <li><a href="../project/migration-guides.html" class="page">Migration Guides</a></li>
    <li><a href="../project/rolling-update.html" class="page">Rolling Updates and Versions</a></li>
    <li><a href="../project/issue-tracking.html" class="page">Issue Tracking</a></li>
    <li><a href="../project/licenses.html" class="page">Licenses</a></li>
    <li><a href="../additional/faq.html" class="page">Frequently Asked Questions</a></li>
    <li><a href="../additional/books.html" class="page">Books and Videos</a></li>
    <li><a href="../project/examples.html" class="page">Example projects</a></li>
    <li><a href="../project/links.html" class="page">Project</a></li>
  </ul></li>
  <li><a href="../index-classic.html" class="page">Pekko Classic</a>
  <ul>
    <li><a href="../index-actors.html" class="page">Classic Actors</a></li>
    <li><a href="../index-cluster.html" class="page">Classic Clustering</a></li>
    <li><a href="../index-network.html" class="page">Classic Networking</a></li>
    <li><a href="../index-utilities-classic.html" class="page">Classic Utilities</a></li>
  </ul></li>
</ul>

<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../stream/stream-io.html#working-with-streaming-io" class="header">Working with streaming IO</a>
  <ul>
    <li><a href="../stream/stream-io.html#dependency" class="header">Dependency</a></li>
    <li><a href="../stream/stream-io.html#introduction" class="header">Introduction</a></li>
    <li><a href="../stream/stream-io.html#streaming-tcp" class="header">Streaming TCP</a></li>
    <li><a href="../stream/stream-io.html#streaming-file-io" class="header">Streaming File IO</a></li>
  </ul></li>
</ul>
</nav>


<ul class="md-nav__list md-nav__links">
<li class="md-nav__item"><a href="https://apache.org"><i class="md-icon">link</i> Apache Software Foundation</a></li>
<li class="md-nav__item"><a href="https://apache.org/licenses/"><i class="md-icon">link</i>&nbsp;License</a></li>
<li class="md-nav__item"><a href="https://apache.org/security/"><i class="md-icon">link</i>&nbsp;Security</a></li>
<li class="md-nav__item"><a href="https://www.apache.org/foundation/sponsorship.html"><i class="md-icon">link</i>&nbsp;Donate</a></li>
<li class="md-nav__item"><a href="https://www.apache.org/foundation/thanks.html"><i class="md-icon">link</i>&nbsp;Thanks</a></li>
</ul>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 0.0.0+26605-0f20b284+20230301-2309*
</label>
</li>
</ul>

</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../stream/stream-io.html#working-with-streaming-io" class="header">Working with streaming IO</a>
  <ul>
    <li><a href="../stream/stream-io.html#dependency" class="header">Dependency</a></li>
    <li><a href="../stream/stream-io.html#introduction" class="header">Introduction</a></li>
    <li><a href="../stream/stream-io.html#streaming-tcp" class="header">Streaming TCP</a></li>
    <li><a href="../stream/stream-io.html#streaming-file-io" class="header">Streaming File IO</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#working-with-streaming-io" name="working-with-streaming-io" class="anchor"><span class="anchor-link"></span></a>Working with streaming IO</h1>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>To use Pekko Streams, add the module to your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">val PekkoVersion = "0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT"
libraryDependencies += "org.apache.pekko" %% "pekko-stream" % PekkoVersion</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;properties&gt;
  &lt;scala.binary.version&gt;2.13&lt;/scala.binary.version&gt;
&lt;/properties&gt;
&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
      &lt;artifactId&gt;pekko-bom_${scala.binary.version}&lt;/artifactId&gt;
      &lt;version&gt;0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
    &lt;artifactId&gt;pekko-stream_${scala.binary.version}&lt;/artifactId&gt;
  &lt;/dependency&gt
&lt;/dependencies&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">def versions = [
  ScalaBinary: "2.13"
]
dependencies {
  implementation platform("org.apache.pekko:pekko-bom_${versions.ScalaBinary}:0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT")

  implementation "org.apache.pekko:pekko-stream_${versions.ScalaBinary}"
}</code></pre></dd></dl>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>Pekko Streams provides a way of handling File IO and TCP connections with Streams. While the general approach is very similar to the <a href="../io-tcp.html">Actor based TCP handling</a> using Pekko IO, by using Pekko Streams you are freed of having to manually react to back-pressure signals, as the library does it transparently for you.</p>
<h2><a href="#streaming-tcp" name="streaming-tcp" class="anchor"><span class="anchor-link"></span></a>Streaming TCP</h2>
<h3><a href="#accepting-connections-echo-server" name="accepting-connections-echo-server" class="anchor"><span class="anchor-link"></span></a>Accepting connections: Echo Server</h3>
<p>In order to implement a simple EchoServer we <code>bind</code> to a given address, which returns a <span class="group-scala"><span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/javadsl/Source.html" title="org.apache.pekko.stream.javadsl.Source"><code>Source</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/scaladsl/Source.html" title="org.apache.pekko.stream.scaladsl.Source"><code>Source</code></a></span>[<span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/javadsl/Tcp$$IncomingConnection.html" title="org.apache.pekko.stream.javadsl.Tcp.IncomingConnection"><code>IncomingConnection</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/scaladsl/Tcp$$IncomingConnection.html" title="org.apache.pekko.stream.scaladsl.Tcp.IncomingConnection"><code>IncomingConnection</code></a></span>, <a href="http://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html" title="scala.concurrent.Future"><code>Future</code></a>[<span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/javadsl/Tcp$$ServerBinding.html" title="org.apache.pekko.stream.javadsl.Tcp.ServerBinding"><code>ServerBinding</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/scaladsl/Tcp$$ServerBinding.html" title="org.apache.pekko.stream.scaladsl.Tcp.ServerBinding"><code>ServerBinding</code></a></span>]</span><span class="group-java"><span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/javadsl/Source.html" title="org.apache.pekko.stream.javadsl.Source"><code>Source</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/scaladsl/Source.html" title="org.apache.pekko.stream.scaladsl.Source"><code>Source</code></a></span>&lt;<span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/javadsl/Tcp$$IncomingConnection.html" title="org.apache.pekko.stream.javadsl.Tcp.IncomingConnection"><code>IncomingConnection</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/scaladsl/Tcp$$IncomingConnection.html" title="org.apache.pekko.stream.scaladsl.Tcp.IncomingConnection"><code>IncomingConnection</code></a></span>, <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html" title="java.util.concurrent.CompletionStage"><code>CompletionStage</code></a>&lt;<span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/javadsl/Tcp$$ServerBinding.html" title="org.apache.pekko.stream.javadsl.Tcp.ServerBinding"><code>ServerBinding</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/scaladsl/Tcp$$ServerBinding.html" title="org.apache.pekko.stream.scaladsl.Tcp.ServerBinding"><code>ServerBinding</code></a></span>&gt;&gt;</span>, which will emit an <code>IncomingConnection</code> element for each new connection that the Server should handle:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/io/StreamTcpDocSpec.scala#L38-L45" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val binding: Future[ServerBinding] =
  Tcp(system).bind(&quot;127.0.0.1&quot;, 8888).to(Sink.ignore).run()

binding.map { b =&gt;
  b.unbind().onComplete {
    case _ =&gt; // ...
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/io/StreamTcpDocTest.java#L71-L73" target="_blank" title="Go to snippet source">source</a><code class="language-java">// IncomingConnection and ServerBinding imported from Tcp
final Source&lt;IncomingConnection, CompletionStage&lt;ServerBinding&gt;&gt; connections =
    Tcp.get(system).bind(&quot;127.0.0.1&quot;, 8888);</code></pre></dd>
</dl>
<p><img src="../images/tcp-stream-bind.png" alt="tcp-stream-bind.png" /></p>
<p>Next, we handle <em>each</em> incoming connection using a <span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/javadsl/Flow.html" title="org.apache.pekko.stream.javadsl.Flow"><code>Flow</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/scaladsl/Flow.html" title="org.apache.pekko.stream.scaladsl.Flow"><code>Flow</code></a></span> which will be used as the operator to handle and emit <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/util/ByteString.html" title="org.apache.pekko.util.ByteString"><code>ByteString</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/util/ByteString.html" title="org.apache.pekko.util.ByteString"><code>ByteString</code></a></span> s from and to the TCP Socket. Since one <code>ByteString</code> does not have to necessarily correspond to exactly one line of text (the client might be sending the line in chunks) we use the <span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/javadsl/Framing$.html#delimiter(org.apache.pekko.util.ByteString,int,org.apache.pekko.stream.javadsl.FramingTruncation)" title="org.apache.pekko.stream.javadsl.Framing"><code>Framing.delimiter</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/scaladsl/Framing$.html#delimiter(delimiter:org.apache.pekko.util.ByteString,maximumFrameLength:Int,allowTruncation:Boolean):org.apache.pekko.stream.scaladsl.Flow[org.apache.pekko.util.ByteString,org.apache.pekko.util.ByteString,org.apache.pekko.NotUsed]" title="org.apache.pekko.stream.scaladsl.Framing"><code>Framing.delimiter</code></a></span> helper Flow to chunk the inputs up into actual lines of text. The last boolean argument indicates that we require an explicit line ending even for the last message before the connection is closed. In this example we add exclamation marks to each incoming text message and push it through the flow:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/io/StreamTcpDocSpec.scala#L51-L65" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko.stream.scaladsl.Framing

val connections: Source[IncomingConnection, Future[ServerBinding]] =
  Tcp(system).bind(host, port)
connections.runForeach { connection =&gt;
  println(s&quot;New connection from: ${connection.remoteAddress}&quot;)

  val echo = Flow[ByteString]
    .via(Framing.delimiter(ByteString(&quot;\n&quot;), maximumFrameLength = 256, allowTruncation = true))
    .map(_.utf8String)
    .map(_ + &quot;!!!\n&quot;)
    .map(ByteString(_))

  connection.handleWith(echo)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/io/StreamTcpDocTest.java#L82-L97" target="_blank" title="Go to snippet source">source</a><code class="language-java">connections.runForeach(
    connection -&gt; {
      System.out.println(&quot;New connection from: &quot; + connection.remoteAddress());

      final Flow&lt;ByteString, ByteString, NotUsed&gt; echo =
          Flow.of(ByteString.class)
              .via(
                  Framing.delimiter(
                      ByteString.fromString(&quot;\n&quot;), 256, FramingTruncation.DISALLOW))
              .map(ByteString::utf8String)
              .map(s -&gt; s + &quot;!!!\n&quot;)
              .map(ByteString::fromString);

      connection.handleWith(echo, system);
    },
    system);</code></pre></dd>
</dl>
<p><img src="../images/tcp-stream-run.png" alt="tcp-stream-run.png" /></p>
<p>Notice that while most building blocks in Pekko Streams are reusable and freely shareable, this is <em>not</em> the case for the incoming connection Flow, since it directly corresponds to an existing, already accepted connection its handling can only ever be materialized <em>once</em>.</p>
<p>Closing connections is possible by cancelling the <em>incoming connection</em> <span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/javadsl/Flow.html" title="org.apache.pekko.stream.javadsl.Flow"><code>Flow</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/scaladsl/Flow.html" title="org.apache.pekko.stream.scaladsl.Flow"><code>Flow</code></a></span> from your server logic (e.g. by connecting its downstream to a <span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/javadsl/Sink$.html#cancelled()" title="org.apache.pekko.stream.javadsl.Sink"><code>Sink.cancelled</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/scaladsl/Sink$.html#cancelled[T]:org.apache.pekko.stream.scaladsl.Sink[T,org.apache.pekko.NotUsed]" title="org.apache.pekko.stream.scaladsl.Sink"><code>Sink.cancelled</code></a></span> and its upstream to a <span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/javadsl/Source$.html#empty()" title="org.apache.pekko.stream.javadsl.Source"><code>Source.empty</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/scaladsl/Source$.html#empty[T]:org.apache.pekko.stream.scaladsl.Source[T,org.apache.pekko.NotUsed]" title="org.apache.pekko.stream.scaladsl.Source"><code>Source.empty</code></a></span>. It is also possible to shut down the server&rsquo;s socket by cancelling the <span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/javadsl/Tcp$$IncomingConnection.html" title="org.apache.pekko.stream.javadsl.Tcp.IncomingConnection"><code>IncomingConnection</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/scaladsl/Tcp$$IncomingConnection.html" title="org.apache.pekko.stream.scaladsl.Tcp.IncomingConnection"><code>IncomingConnection</code></a></span> source <code>connections</code>.</p>
<p>We can then test the TCP server by sending data to the TCP Socket using <code>netcat</code>:</p>
<pre><code>$ echo -n &quot;Hello World&quot; | netcat 127.0.0.1 8888
Hello World!!!
</code></pre>
<h3><a href="#connecting-repl-client" name="connecting-repl-client" class="anchor"><span class="anchor-link"></span></a>Connecting: REPL Client</h3>
<p>In this example we implement a rather naive Read Evaluate Print Loop client over TCP. Let&rsquo;s say we know a server has exposed a simple command line interface over TCP, and would like to interact with it using Pekko Streams over TCP. To open an outgoing connection socket we use the <code>outgoingConnection</code> method:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/io/StreamTcpDocSpec.scala#L123-L141" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val connection = Tcp(system).outgoingConnection(&quot;127.0.0.1&quot;, 8888)

val replParser =
  Flow[String].takeWhile(_ != &quot;q&quot;).concat(Source.single(&quot;BYE&quot;)).map(elem =&gt; ByteString(s&quot;$elem\n&quot;))

val repl = Flow[ByteString]
  .via(Framing.delimiter(ByteString(&quot;\n&quot;), maximumFrameLength = 256, allowTruncation = true))
  .map(_.utf8String)
  .map(text =&gt; println(&quot;Server: &quot; + text))
  .map(_ =&gt; readLine(&quot;&gt; &quot;))
  .via(replParser)

val connected = connection.join(repl).run()</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/io/StreamTcpDocTest.java#L159-L186" target="_blank" title="Go to snippet source">source</a><code class="language-java">final Flow&lt;ByteString, ByteString, CompletionStage&lt;OutgoingConnection&gt;&gt; connection =
    Tcp.get(system).outgoingConnection(&quot;127.0.0.1&quot;, 8888);
final Flow&lt;String, ByteString, NotUsed&gt; replParser =
    Flow.&lt;String&gt;create()
        .takeWhile(elem -&gt; !elem.equals(&quot;q&quot;))
        .concat(Source.single(&quot;BYE&quot;)) // will run after the original flow completes
        .map(elem -&gt; ByteString.fromString(elem + &quot;\n&quot;));

final Flow&lt;ByteString, ByteString, NotUsed&gt; repl =
    Flow.of(ByteString.class)
        .via(Framing.delimiter(ByteString.fromString(&quot;\n&quot;), 256, FramingTruncation.DISALLOW))
        .map(ByteString::utf8String)
        .map(
            text -&gt; {
              System.out.println(&quot;Server: &quot; + text);
              return &quot;next&quot;;
            })
        .map(elem -&gt; readLine(&quot;&gt; &quot;))
        .via(replParser);

CompletionStage&lt;OutgoingConnection&gt; connectionCS = connection.join(repl).run(system);</code></pre></dd>
</dl>
<p>The <code>repl</code> flow we use to handle the server interaction first prints the servers response, then awaits on input from the command line (this blocking call is used here for the sake of simplicity) and converts it to a <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/util/ByteString.html" title="org.apache.pekko.util.ByteString"><code>ByteString</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/util/ByteString.html" title="org.apache.pekko.util.ByteString"><code>ByteString</code></a></span> which is then sent over the wire to the server. Then we connect the TCP pipeline to this operatorâat this point it will be materialized and start processing data once the server responds with an <em>initial message</em>.</p>
<p>A resilient REPL client would be more sophisticated than this, for example it should split out the input reading into a separate mapAsync step and have a way to let the server write more data than one ByteString chunk at any given time, these improvements however are left as exercise for the reader.</p>
<h3><a href="#avoiding-deadlocks-and-liveness-issues-in-back-pressured-cycles" name="avoiding-deadlocks-and-liveness-issues-in-back-pressured-cycles" class="anchor"><span class="anchor-link"></span></a>Avoiding deadlocks and liveness issues in back-pressured cycles</h3>
<p>When writing such end-to-end back-pressured systems you may sometimes end up in a situation of a loop, in which <em>either side is waiting for the other one to start the conversation</em>. One does not need to look far to find examples of such back-pressure loops. In the two examples shown previously, we always assumed that the side we are connecting to would start the conversation, which effectively means both sides are back-pressured and can not get the conversation started. There are multiple ways of dealing with this which are explained in depth in <a href="stream-graphs.html#graph-cycles">Graph cycles, liveness and deadlocks</a>, however in client-server scenarios it is often the simplest to make either side send an initial message.</p><div class="callout note "><div class="callout-title">Note</div>
<p>In case of back-pressured cycles (which can occur even between different systems) sometimes you have to decide which of the sides has start the conversation in order to kick it off. This can be often done by injecting an initial message from one of the sidesâa conversation starter.</p></div>
<p>To break this back-pressure cycle we need to inject some initial message, a &ldquo;conversation starter&rdquo;. First, we need to decide which side of the connection should remain passive and which active. Thankfully in most situations finding the right spot to start the conversation is rather simple, as it often is inherent to the protocol we are trying to implement using Streams. In chat-like applications, which our examples resemble, it makes sense to make the Server initiate the conversation by emitting a &ldquo;hello&rdquo; message:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/io/StreamTcpDocSpec.scala#L79-L104" target="_blank" title="Go to snippet source">source</a><code class="language-scala">connections
  .to(Sink.foreach { connection =&gt;
    // server logic, parses incoming commands
    val commandParser = Flow[String].takeWhile(_ != &quot;BYE&quot;).map(_ + &quot;!&quot;)

    import connection._
    val welcomeMsg = s&quot;Welcome to: $localAddress, you are: $remoteAddress!&quot;
    val welcome = Source.single(welcomeMsg)

    val serverLogic = Flow[ByteString]
      .via(Framing.delimiter(ByteString(&quot;\n&quot;), maximumFrameLength = 256, allowTruncation = true))
      .map(_.utf8String)
      .via(commandParser)
      // merge in the initial banner after parser
      .merge(welcome)
      .map(_ + &quot;\n&quot;)
      .map(ByteString(_))

    connection.handleWith(serverLogic)
  })
  .run()</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/io/StreamTcpDocTest.java#L112-L150" target="_blank" title="Go to snippet source">source</a><code class="language-java">connections
    .to(
        Sink.foreach(
            (IncomingConnection connection) -&gt; {
              // server logic, parses incoming commands
              final Flow&lt;String, String, NotUsed&gt; commandParser =
                  Flow.&lt;String&gt;create()
                      .takeWhile(elem -&gt; !elem.equals(&quot;BYE&quot;))
                      .map(elem -&gt; elem + &quot;!&quot;);

              final String welcomeMsg =
                  &quot;Welcome to: &quot;
                      + connection.localAddress()
                      + &quot; you are: &quot;
                      + connection.remoteAddress()
                      + &quot;!&quot;;

              final Source&lt;String, NotUsed&gt; welcome = Source.single(welcomeMsg);
              final Flow&lt;ByteString, ByteString, NotUsed&gt; serverLogic =
                  Flow.of(ByteString.class)
                      .via(
                          Framing.delimiter(
                              ByteString.fromString(&quot;\n&quot;), 256, FramingTruncation.DISALLOW))
                      .map(ByteString::utf8String)
                      .via(commandParser)
                      .merge(welcome)
                      .map(s -&gt; s + &quot;\n&quot;)
                      .map(ByteString::fromString);

              connection.handleWith(serverLogic, system);
            }))
    .run(system);</code></pre></dd>
</dl>
<p>To emit the initial message we merge a <span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/javadsl/Source.html" title="org.apache.pekko.stream.javadsl.Source"><code>Source</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/scaladsl/Source.html" title="org.apache.pekko.stream.scaladsl.Source"><code>Source</code></a></span> with a single element, after the command processing but before the framing and transformation to <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/util/ByteString.html" title="org.apache.pekko.util.ByteString"><code>ByteString</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/util/ByteString.html" title="org.apache.pekko.util.ByteString"><code>ByteString</code></a></span> s this way we do not have to repeat such logic.</p>
<p>In this example both client and server may need to close the stream based on a parsed command - <code>BYE</code> in the case of the server, and <code>q</code> in the case of the client. This is implemented by <span class="group-scala">taking from the stream until <code>q</code> and and concatenating a <code>Source</code> with a single <code>BYE</code> element which will then be sent after the original source completed</span><span class="group-java">using a custom operator extending <a href="stream-customize.html"><code>GraphStage</code></a> which completes the stream once it encounters such command</span>.</p>
<h3><a href="#using-framing-in-your-protocol" name="using-framing-in-your-protocol" class="anchor"><span class="anchor-link"></span></a>Using framing in your protocol</h3>
<p>Streaming transport protocols like TCP only pass streams of bytes, and does not know what is a logical chunk of bytes from the application&rsquo;s point of view. Often when implementing network protocols you will want to introduce your own framing. This can be done in two ways: An end-of-frame marker, e.g. end line <code>\n</code>, can do framing via <span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/javadsl/Framing$.html#delimiter(org.apache.pekko.util.ByteString,int,org.apache.pekko.stream.javadsl.FramingTruncation)" title="org.apache.pekko.stream.javadsl.Framing"><code>Framing.delimiter</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/scaladsl/Framing$.html#delimiter(delimiter:org.apache.pekko.util.ByteString,maximumFrameLength:Int,allowTruncation:Boolean):org.apache.pekko.stream.scaladsl.Flow[org.apache.pekko.util.ByteString,org.apache.pekko.util.ByteString,org.apache.pekko.NotUsed]" title="org.apache.pekko.stream.scaladsl.Framing"><code>Framing.delimiter</code></a></span>. Or a length-field can be used to build a framing protocol. There is a bidi implementing this protocol provided by <span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/javadsl/Framing$.html#simpleFramingProtocol(int)" title="org.apache.pekko.stream.javadsl.Framing"><code>Framing.simpleFramingProtocol</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/stream/scaladsl/Framing$.html#simpleFramingProtocol(maximumMessageLength:Int):org.apache.pekko.stream.scaladsl.BidiFlow[org.apache.pekko.util.ByteString,org.apache.pekko.util.ByteString,org.apache.pekko.util.ByteString,org.apache.pekko.util.ByteString,org.apache.pekko.NotUsed]" title="org.apache.pekko.stream.scaladsl.Framing"><code>Framing.simpleFramingProtocol</code></a></span>.</p>
<p><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/current/org/apache/pekko/stream/scaladsl/JsonFraming$.html#objectScanner(maximumObjectLength:Int):org.apache.pekko.stream.scaladsl.Flow[org.apache.pekko.util.ByteString,org.apache.pekko.util.ByteString,org.apache.pekko.NotUsed]" title="pekko.stream.scaladsl.JsonFraming"><code>JsonFraming</code></a></span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/current/org/apache/pekko/stream/javadsl/JsonFraming.html#objectScanner(int)" title="pekko.stream.javadsl.JsonFraming"><code>JsonFraming</code></a></span> separates valid JSON objects from incoming <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/util/ByteString.html" title="org.apache.pekko.util.ByteString"><code>ByteString</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/util/ByteString.html" title="org.apache.pekko.util.ByteString"><code>ByteString</code></a></span> objects:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/stream-tests/src/test/scala/org/apache/pekko/stream/scaladsl/JsonFramingSpec.scala#L34-L46" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val input =
  &quot;&quot;&quot;
    |[
    | { &quot;name&quot; : &quot;john&quot; },
    | { &quot;name&quot; : &quot;Ãg get etiÃ° gler Ã¡n Ã¾ess aÃ° meiÃ°a mig&quot; },
    | { &quot;name&quot; : &quot;jack&quot; },
    |]
    |&quot;&quot;&quot;.stripMargin // also should complete once notices end of array

val result =
  Source.single(ByteString(input)).via(JsonFraming.objectScanner(Int.MaxValue)).runFold(Seq.empty[String]) {
    case (acc, entry) =&gt; acc ++ Seq(entry.utf8String)
  }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/stream-tests/src/test/java/org/apache/pekko/stream/javadsl/JsonFramingTest.java#L45-L56" target="_blank" title="Go to snippet source">source</a><code class="language-java">String input =
    &quot;[{ \&quot;name\&quot; : \&quot;john\&quot; }, { \&quot;name\&quot; : \&quot;Ãg get etiÃ° gler Ã¡n Ã¾ess aÃ° meiÃ°a mig\&quot; }, { \&quot;name\&quot; : \&quot;jack\&quot; }]&quot;;
CompletionStage&lt;ArrayList&lt;String&gt;&gt; result =
    Source.single(ByteString.fromString(input))
        .via(JsonFraming.objectScanner(Integer.MAX_VALUE))
        .runFold(
            new ArrayList&lt;String&gt;(),
            (acc, entry) -&gt; {
              acc.add(entry.utf8String());
              return acc;
            },
            system);</code></pre></dd>
</dl>
<h3><a href="#tls" name="tls" class="anchor"><span class="anchor-link"></span></a>TLS</h3>
<p>Similar factories as shown above for raw TCP but where the data is encrypted using TLS are available from <code>Tcp</code> through <code>outgoingConnectionWithTls</code>, <code>bindWithTls</code> and <code>bindAndHandleWithTls</code>, see the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/current/org/apache/pekko/stream/scaladsl/Tcp.html" title="pekko.stream.scaladsl.Tcp"><code>`Tcp Scaladoc`</code></a></span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/current/org/apache/pekko/stream/javadsl/Tcp.html" title="pekko.stream.javadsl.Tcp"><code>`Tcp Javadoc`</code></a></span> for details.</p>
<p>Using TLS requires a keystore and a truststore and then a somewhat involved dance of configuring the SSLEngine and the details for how the session should be negotiated:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/stream-tests/src/test/scala/org/apache/pekko/stream/io/TcpSpec.scala#L932-L970" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import java.security.KeyStore
import javax.net.ssl.KeyManagerFactory
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLEngine
import javax.net.ssl.TrustManagerFactory

import org.apache.pekko.stream.TLSRole

// initialize SSLContext once
lazy val sslContext: SSLContext = {
  // Don&#39;t hardcode your password in actual code
  val password = &quot;abcdef&quot;.toCharArray

  // trust store and keys in one keystore
  val keyStore = KeyStore.getInstance(&quot;PKCS12&quot;)
  keyStore.load(getClass.getResourceAsStream(&quot;/tcp-spec-keystore.p12&quot;), password)

  val trustManagerFactory = TrustManagerFactory.getInstance(&quot;SunX509&quot;)
  trustManagerFactory.init(keyStore)

  val keyManagerFactory = KeyManagerFactory.getInstance(&quot;SunX509&quot;)
  keyManagerFactory.init(keyStore, password)

  // init ssl context
  val context = SSLContext.getInstance(&quot;TLSv1.2&quot;)
  context.init(keyManagerFactory.getKeyManagers, trustManagerFactory.getTrustManagers, new SecureRandom)
  context
}

// create new SSLEngine from the SSLContext, which was initialized once
def createSSLEngine(role: TLSRole): SSLEngine = {
  val engine = sslContext.createSSLEngine()

  engine.setUseClientMode(role == pekko.stream.Client)
  engine.setEnabledCipherSuites(Array(&quot;TLS_RSA_WITH_AES_128_CBC_SHA&quot;))
  engine.setEnabledProtocols(Array(&quot;TLSv1.2&quot;))

  engine
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/stream-tests/src/test/java/org/apache/pekko/stream/javadsl/TcpTest.java#L55-L233" target="_blank" title="Go to snippet source">source</a><code class="language-java">// imports
import java.security.KeyStore;
import java.security.SecureRandom;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.TrustManagerFactory;
import org.apache.pekko.stream.TLSRole;

  // initialize SSLContext once
  private final SSLContext sslContext;

  {
    try {
      // Don&#39;t hardcode your password in actual code
      char[] password = &quot;abcdef&quot;.toCharArray();

      // trust store and keys in one keystore
      KeyStore keyStore = KeyStore.getInstance(&quot;PKCS12&quot;);
      keyStore.load(getClass().getResourceAsStream(&quot;/tcp-spec-keystore.p12&quot;), password);

      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(&quot;SunX509&quot;);
      trustManagerFactory.init(keyStore);

      KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(&quot;SunX509&quot;);
      keyManagerFactory.init(keyStore, password);

      // init ssl context
      SSLContext context = SSLContext.getInstance(&quot;TLSv1.2&quot;);
      context.init(
          keyManagerFactory.getKeyManagers(),
          trustManagerFactory.getTrustManagers(),
          new SecureRandom());

      sslContext = context;

    } catch (KeyStoreException
        | IOException
        | NoSuchAlgorithmException
        | CertificateException
        | UnrecoverableKeyException
        | KeyManagementException e) {
      throw new RuntimeException(e);
    }
  }

  // create new SSLEngine from the SSLContext, which was initialized once
  public SSLEngine createSSLEngine(TLSRole role) {
    SSLEngine engine = sslContext.createSSLEngine();

    engine.setUseClientMode(role.equals(org.apache.pekko.stream.TLSRole.client()));
    engine.setEnabledCipherSuites(new String[] {&quot;TLS_DHE_RSA_WITH_AES_256_GCM_SHA384&quot;});
    engine.setEnabledProtocols(new String[] {&quot;TLSv1.2&quot;});

    return engine;
  }</code></pre></dd>
</dl>
<p>The <code>SSLEngine</code> instance can then be used with the binding or outgoing connection factory methods.</p>
<h2><a href="#streaming-file-io" name="streaming-file-io" class="anchor"><span class="anchor-link"></span></a>Streaming File IO</h2>
<p>Pekko Streams provide simple Sources and Sinks that can work with <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/util/ByteString.html" title="org.apache.pekko.util.ByteString"><code>ByteString</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/util/ByteString.html" title="org.apache.pekko.util.ByteString"><code>ByteString</code></a></span> instances to perform IO operations on files.</p>
<p>Streaming data from a file is as easy as creating a <em>FileIO.fromPath</em> given a target path, and an optional <code>chunkSize</code> which determines the buffer size determined as one &ldquo;element&rdquo; in such stream:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/io/StreamFileDocSpec.scala#L40-L64" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko.stream.scaladsl._
val file = Paths.get(&quot;example.csv&quot;)

val foreach: Future[IOResult] = FileIO.fromPath(file).to(Sink.ignore).run()</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/io/StreamFileDocTest.java#L59-L78" target="_blank" title="Go to snippet source">source</a><code class="language-java">final Path file = Paths.get(&quot;example.csv&quot;);
  Sink&lt;ByteString, CompletionStage&lt;Done&gt;&gt; printlnSink =
      Sink.&lt;ByteString&gt;foreach(chunk -&gt; System.out.println(chunk.utf8String()));

  CompletionStage&lt;IOResult&gt; ioResult = FileIO.fromPath(file).to(printlnSink).run(system);</code></pre></dd>
</dl>
<p>Please note that these operators are backed by Actors and by default are configured to run on a pre-configured threadpool-backed dispatcher dedicated for File IO. This is very important as it isolates the blocking file IO operations from the rest of the ActorSystem allowing each dispatcher to be utilised in the most efficient way. If you want to configure a custom dispatcher for file IO operations globally, you can do so by changing the <code>pekko.stream.materializer.blocking-io-dispatcher</code>, or for a specific operator by specifying a custom Dispatcher in code, like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/scala/docs/stream/io/StreamFileDocSpec.scala#L70" target="_blank" title="Go to snippet source">source</a><code class="language-scala">FileIO.fromPath(file).withAttributes(ActorAttributes.dispatcher(&quot;custom-blocking-io-dispatcher&quot;))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/docs/src/test/java/jdocs/stream/io/StreamFileDocTest.java#L92-L93" target="_blank" title="Go to snippet source">source</a><code class="language-java">FileIO.toPath(file)
    .withAttributes(ActorAttributes.dispatcher(&quot;custom-blocking-io-dispatcher&quot;));</code></pre></dd>
</dl>
</div>
<div>
<a href="https://github.com/apache/incubator-pekko/tree/main/docs/src/main/paradox/stream/stream-io.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.0.0+26605-0f20b284+20230301-2309*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../stream/stream-error.html" title="Error Handling in Streams" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Error Handling in Streams
</span>
</div>
</a>
<a href="../stream/stream-refs.html" title="StreamRefs - Reactive Streams over the network" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
StreamRefs - Reactive Streams over the network
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
Copyright Â© 2022, 2023 <a href="https://apache.org">The Apache Software Foundation</a>, Licensed under the Apache License, Version 2.0.
 This product contains significant parts that were originally based on software from Lightbend (<a href="https://akka.io/">Akka</a>).
 Copyright (C) 2009-2022 Lightbend Inc. &lt;https://www.lightbend.com&gt; Apache Pekko is derived from Akka 2.6.x,
 the last version that was distributed under the Apache License, Version 2.0 License.
</div>
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../assets/javascripts/groups.js"></script>

<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
