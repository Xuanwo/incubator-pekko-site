<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="Apache Pekko is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala.">
<meta name="generator" content="Paradox, paradox-material-theme=0.6.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="Apache Pekko is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala.">
<link rel="shortcut icon" href="../assets/images/pekko_favicon.png">
<title>Replicated Event Sourcing Â· Apache Pekko Documentation</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../assets/stylesheets/application-palette.22915126.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
<link rel="stylesheet" href="../assets/stylesheets/pekko-theme.css">
</head>
<body
data-md-color-primary="white"
data-md-color-accent="orange"
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="Apache Pekko Documentation" class="md-header-nav__button md-logo">
<img src="../assets/images/pekko_logo.png" width="24" height="24">
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Apache Pekko Documentation
</span>
<span class="md-header-nav__topic">
Replicated Event Sourcing
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/apache/incubator-pekko"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="Apache Pekko Documentation" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<img src="../assets/images/pekko_logo.png" width="24" height="24">
</a>
<a href="../index.html" title="Apache Pekko Documentation">
Apache Pekko Documentation
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/apache/incubator-pekko"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko
</div>
</a>

</div>
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a>
  <ul>
    <li><a href="../security/index.html#receiving-security-advisories" class="header">Receiving Security Advisories</a></li>
    <li><a href="../security/index.html#reporting-vulnerabilities" class="header">Reporting Vulnerabilities</a></li>
    <li><a href="../security/index.html#security-related-documentation" class="header">Security Related Documentation</a></li>
  </ul></li>
  <li><a href="../typed/guide/index.html" class="page">Getting Started Guide</a>
  <ul>
    <li><a href="../typed/guide/introduction.html" class="page">Introduction to Apache Pekko</a></li>
    <li><a href="../typed/guide/actors-motivation.html" class="page">Why modern systems need a new programming model</a></li>
    <li><a href="../typed/guide/actors-intro.html" class="page">How the Actor Model Meets the Needs of Modern, Distributed Systems</a></li>
    <li><a href="../typed/guide/modules.html" class="page">Overview of Apache Pekko libraries and modules</a></li>
    <li><a href="../typed/guide/tutorial.html" class="page">Introduction to the Example</a></li>
    <li><a href="../typed/guide/tutorial_1.html" class="page">Part 1: Actor Architecture</a></li>
    <li><a href="../typed/guide/tutorial_2.html" class="page">Part 2: Creating the First Actor</a></li>
    <li><a href="../typed/guide/tutorial_3.html" class="page">Part 3: Working with Device Actors</a></li>
    <li><a href="../typed/guide/tutorial_4.html" class="page">Part 4: Working with Device Groups</a></li>
    <li><a href="../typed/guide/tutorial_5.html" class="page">Part 5: Querying Device Groups</a></li>
  </ul></li>
  <li><a href="../general/index.html" class="page">General Concepts</a>
  <ul>
    <li><a href="../general/terminology.html" class="page">Terminology, Concepts</a></li>
    <li><a href="../general/actor-systems.html" class="page">Actor Systems</a></li>
    <li><a href="../general/actors.html" class="page">What is an Actor?</a></li>
    <li><a href="../general/supervision.html" class="page">Supervision and Monitoring</a></li>
    <li><a href="../general/addressing.html" class="page">Actor References, Paths and Addresses</a></li>
    <li><a href="../general/remoting.html" class="page">Location Transparency</a></li>
    <li><a href="../general/jmm.html" class="page">Apache Pekko and the Java Memory Model</a></li>
    <li><a href="../general/message-delivery-reliability.html" class="page">Message Delivery Reliability</a></li>
    <li><a href="../general/configuration.html" class="page">Configuration</a></li>
    <li><a href="../general/configuration-reference.html" class="page">Default configuration</a></li>
  </ul></li>
  <li><a href="../typed/index.html" class="page">Actors</a>
  <ul>
    <li><a href="../typed/actors.html" class="page">Introduction to Actors</a></li>
    <li><a href="../typed/actor-lifecycle.html" class="page">Actor lifecycle</a></li>
    <li><a href="../typed/interaction-patterns.html" class="page">Interaction Patterns</a></li>
    <li><a href="../typed/fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="../typed/actor-discovery.html" class="page">Actor discovery</a></li>
    <li><a href="../typed/routers.html" class="page">Routers</a></li>
    <li><a href="../typed/stash.html" class="page">Stash</a></li>
    <li><a href="../typed/fsm.html" class="page">Behaviors as finite state machines</a></li>
    <li><a href="../coordinated-shutdown.html" class="page">Coordinated Shutdown</a></li>
    <li><a href="../typed/dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="../typed/mailboxes.html" class="page">Mailboxes</a></li>
    <li><a href="../typed/testing.html" class="page">Testing</a></li>
    <li><a href="../typed/coexisting.html" class="page">Coexistence</a></li>
    <li><a href="../typed/style-guide.html" class="page">Style guide</a></li>
    <li><a href="../typed/from-classic.html" class="page">Learning Pekko Typed from Classic</a></li>
  </ul></li>
  <li><a href="../typed/index-cluster.html" class="page">Cluster</a>
  <ul>
    <li><a href="../typed/cluster.html" class="page">Cluster Usage</a></li>
    <li><a href="../typed/cluster-concepts.html" class="page">Cluster Specification</a></li>
    <li><a href="../typed/cluster-membership.html" class="page">Cluster Membership Service</a></li>
    <li><a href="../typed/failure-detector.html" class="page">Phi Accrual Failure Detector</a></li>
    <li><a href="../typed/distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="../typed/cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="../typed/cluster-sharding.html" class="page">Cluster Sharding</a></li>
    <li><a href="../typed/cluster-sharding-concepts.html" class="page">Cluster Sharding concepts</a></li>
    <li><a href="../typed/cluster-sharded-daemon-process.html" class="page">Sharded Daemon Process</a></li>
    <li><a href="../typed/cluster-dc.html" class="page">Multi-DC Cluster</a></li>
    <li><a href="../typed/distributed-pub-sub.html" class="page">Distributed Publish Subscribe in Cluster</a></li>
    <li><a href="../typed/reliable-delivery.html" class="page">Reliable delivery</a></li>
    <li><a href="../serialization.html" class="page">Serialization</a></li>
    <li><a href="../serialization-jackson.html" class="page">Serialization with Jackson</a></li>
    <li><a href="../multi-jvm-testing.html" class="page">Multi JVM Testing</a></li>
    <li><a href="../multi-node-testing.html" class="page">Multi Node Testing</a></li>
    <li><a href="../remoting-artery.html" class="page">Artery Remoting</a></li>
    <li><a href="../remoting.html" class="page">Classic Remoting (Deprecated)</a></li>
    <li><a href="../split-brain-resolver.html" class="page">Split Brain Resolver</a></li>
    <li><a href="../coordination.html" class="page">Coordination</a></li>
    <li><a href="../typed/choosing-cluster.html" class="page">Choosing Pekko Cluster</a></li>
  </ul></li>
  <li><a href="../typed/index-persistence.html" class="page">Persistence (Event Sourcing)</a>
  <ul>
    <li><a href="../typed/persistence.html" class="page">Event Sourcing</a></li>
    <li><a href="../typed/replicated-eventsourcing.html#replicated-event-sourcing" class="active page">Replicated Event Sourcing</a></li>
    <li><a href="../typed/cqrs.html" class="page">CQRS</a></li>
    <li><a href="../typed/persistence-style.html" class="page">Style Guide</a></li>
    <li><a href="../typed/persistence-snapshot.html" class="page">Snapshotting</a></li>
    <li><a href="../typed/persistence-testing.html" class="page">Testing</a></li>
    <li><a href="../typed/persistence-fsm.html" class="page">EventSourced behaviors as finite state machines</a></li>
    <li><a href="../persistence-schema-evolution.html" class="page">Schema Evolution for Event Sourced Actors</a></li>
    <li><a href="../persistence-query.html" class="page">Apache Persistence Query</a></li>
    <li><a href="../persistence-query-leveldb.html" class="page">Persistence Query for LevelDB</a></li>
    <li><a href="../persistence-plugins.html" class="page">Persistence Plugins</a></li>
    <li><a href="../persistence-journals.html" class="page">Persistence - Building a storage backend</a></li>
    <li><a href="../typed/replicated-eventsourcing-examples.html" class="page">Replicated Event Sourcing Examples</a></li>
  </ul></li>
  <li><a href="../typed/index-persistence-durable-state.html" class="page">Persistence (Durable State)</a>
  <ul>
    <li><a href="../typed/durable-state/persistence.html" class="page">Durable State</a></li>
    <li><a href="../typed/durable-state/persistence-style.html" class="page">Style Guide</a></li>
    <li><a href="../typed/durable-state/cqrs.html" class="page">CQRS</a></li>
    <li><a href="../durable-state/persistence-query.html" class="page">Persistence Query</a></li>
  </ul></li>
  <li><a href="../stream/index.html" class="page">Streams</a>
  <ul>
    <li><a href="../stream/index.html#module-info" class="header">Module info</a></li>
    <li><a href="../stream/stream-introduction.html" class="page">Introduction</a></li>
    <li><a href="../stream/stream-quickstart.html" class="page">Streams Quickstart Guide</a></li>
    <li><a href="../general/stream/stream-design.html" class="page">Design Principles behind Apache Pekko Streams</a></li>
    <li><a href="../stream/stream-flows-and-basics.html" class="page">Basics and working with Flows</a></li>
    <li><a href="../stream/stream-graphs.html" class="page">Working with Graphs</a></li>
    <li><a href="../stream/stream-composition.html" class="page">Modularity, Composition and Hierarchy</a></li>
    <li><a href="../stream/stream-rate.html" class="page">Buffers and working with rate</a></li>
    <li><a href="../stream/stream-context.html" class="page">Context Propagation</a></li>
    <li><a href="../stream/stream-dynamic.html" class="page">Dynamic stream handling</a></li>
    <li><a href="../stream/stream-customize.html" class="page">Custom stream processing</a></li>
    <li><a href="../stream/futures-interop.html" class="page">Futures interop</a></li>
    <li><a href="../stream/actor-interop.html" class="page">Actors interop</a></li>
    <li><a href="../stream/reactive-streams-interop.html" class="page">Reactive Streams Interop</a></li>
    <li><a href="../stream/stream-error.html" class="page">Error Handling in Streams</a></li>
    <li><a href="../stream/stream-io.html" class="page">Working with streaming IO</a></li>
    <li><a href="../stream/stream-refs.html" class="page">StreamRefs - Reactive Streams over the network</a></li>
    <li><a href="../stream/stream-parallelism.html" class="page">Pipelining and Parallelism</a></li>
    <li><a href="../stream/stream-testkit.html" class="page">Testing streams</a></li>
    <li><a href="../stream/stream-substream.html" class="page">Substreams</a></li>
    <li><a href="../stream/stream-cookbook.html" class="page">Streams Cookbook</a></li>
    <li><a href="../general/stream/stream-configuration.html" class="page">Configuration</a></li>
    <li><a href="../stream/operators/index.html" class="page">Operators</a></li>
  </ul></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a>
  <ul>
    <li><a href="../discovery/index.html#module-info" class="header">Module info</a></li>
    <li><a href="../discovery/index.html#how-it-works" class="header">How it works</a></li>
    <li><a href="../discovery/index.html#discovery-method-dns" class="header">Discovery Method: DNS</a></li>
    <li><a href="../discovery/index.html#discovery-method-configuration" class="header">Discovery Method: Configuration</a></li>
    <li><a href="../discovery/index.html#discovery-method-aggregate-multiple-discovery-methods" class="header">Discovery Method: Aggregate multiple discovery methods</a></li>
    <li><a href="../discovery/index.html#migrating-from-pekko-management-discovery-before-1-0-0-" class="header">Migrating from Pekko Management Discovery (before 1.0.0)</a></li>
  </ul></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a>
  <ul>
    <li><a href="../typed/logging.html" class="page">Logging</a></li>
    <li><a href="../common/circuitbreaker.html" class="page">Circuit Breaker</a></li>
    <li><a href="../futures.html" class="page">Futures patterns</a></li>
    <li><a href="../typed/extending.html" class="page">Extending Apache Pekko</a></li>
  </ul></li>
  <li><a href="../common/other-modules.html" class="page">Other Apache Pekko modules</a>
  <ul>
    <li><a href="../common/other-modules.html#" class="header"><a href="https://pekko.apache.org/docs/pekko-http/current/">Pekko HTTP</a></a></li>
    <li><a href="../common/other-modules.html#" class="header"><a href="https://pekko.apache.org/docs/pekko-grpc/current/">Pekko gRPC</a></a></li>
    <li><a href="../common/other-modules.html#" class="header"><a href="https://pekko.apache.org/docs/pekko-connectors/current/">Pekko Connectors</a></a></li>
    <li><a href="../common/other-modules.html#" class="header"><a href="https://pekko.apache.org/docs/pekko-connectors-kafka/current/">Pekko Kafka Connector</a></a></li>
    <li><a href="../common/other-modules.html#" class="header"><a href="https://pekko.apache.org/docs/pekko-projection/current/">Pekko Projections</a></a></li>
    <li><a href="../common/other-modules.html#" class="header"><a href="https://pekko.apache.org/docs/pekko-persistence-cassandra/current/">Cassandra Plugin for Pekko Persistence</a></a></li>
    <li><a href="../common/other-modules.html#" class="header"><a href="https://pekko.apache.org/docs/pekko-persistence-jdbc/current/">JDBC Plugin for Pekko Persistence</a></a></li>
    <li><a href="../common/other-modules.html#" class="header"><a href="https://pekko.apache.org/docs/pekko-persistence-r2dbc/current/">R2DBC Plugin for Pekko Persistence</a></a></li>
    <li><a href="../common/other-modules.html#" class="header"><a href="https://pekko.apache.org/docs/pekko-persistence-spanner/current/">Google Cloud Spanner Plugin for Pekko Persistence</a></a></li>
    <li><a href="../common/other-modules.html#apache-pekko-management" class="header">Apache Pekko Management</a></li>
  </ul></li>
  <li><a href="../additional/deploy.html" class="page">Package, Deploy and Run</a>
  <ul>
    <li><a href="../additional/packaging.html" class="page">Packaging</a></li>
    <li><a href="../additional/operations.html" class="page">Operating a Cluster</a></li>
    <li><a href="../additional/deploying.html" class="page">Deploying</a></li>
    <li><a href="../additional/rolling-updates.html" class="page">Rolling Updates</a></li>
  </ul></li>
  <li><a href="../project/index.html" class="page">Project Information</a>
  <ul>
    <li><a href="../common/binary-compatibility-rules.html" class="page">Binary Compatibility Rules</a></li>
    <li><a href="../project/scala3.html" class="page">Scala 3 support</a></li>
    <li><a href="../project/downstream-upgrade-strategy.html" class="page">Downstream upgrade strategy</a></li>
    <li><a href="../common/may-change.html" class="page">Modules marked &ldquo;May Change&rdquo;</a></li>
    <li><a href="../additional/ide.html" class="page">IDE Tips</a></li>
    <li><a href="../project/immutable.html" class="page">Immutability using Lombok</a></li>
    <li><a href="../additional/osgi.html" class="page">Apache Pekko in OSGi</a></li>
    <li><a href="../project/migration-guides.html" class="page">Migration Guides</a></li>
    <li><a href="../project/rolling-update.html" class="page">Rolling Updates and Versions</a></li>
    <li><a href="../project/issue-tracking.html" class="page">Issue Tracking</a></li>
    <li><a href="../project/licenses.html" class="page">Licenses</a></li>
    <li><a href="../additional/faq.html" class="page">Frequently Asked Questions</a></li>
    <li><a href="../additional/books.html" class="page">Books and Videos</a></li>
    <li><a href="../project/examples.html" class="page">Example projects</a></li>
    <li><a href="../project/links.html" class="page">Project</a></li>
  </ul></li>
  <li><a href="../index-classic.html" class="page">Pekko Classic</a>
  <ul>
    <li><a href="../index-actors.html" class="page">Classic Actors</a></li>
    <li><a href="../index-cluster.html" class="page">Classic Clustering</a></li>
    <li><a href="../index-network.html" class="page">Classic Networking</a></li>
    <li><a href="../index-utilities-classic.html" class="page">Classic Utilities</a></li>
  </ul></li>
</ul>

<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../typed/replicated-eventsourcing.html#replicated-event-sourcing" class="header">Replicated Event Sourcing</a>
  <ul>
    <li><a href="../typed/replicated-eventsourcing.html#relaxing-the-single-writer-principle-for-availability" class="header">Relaxing the single-writer principle for availability</a></li>
    <li><a href="../typed/replicated-eventsourcing.html#api" class="header">API</a></li>
    <li><a href="../typed/replicated-eventsourcing.html#resolving-conflicting-updates" class="header">Resolving conflicting updates</a></li>
    <li><a href="../typed/replicated-eventsourcing.html#side-effects" class="header">Side effects</a></li>
    <li><a href="../typed/replicated-eventsourcing.html#how-it-works" class="header">How it works</a></li>
    <li><a href="../typed/replicated-eventsourcing.html#sharded-replicated-event-sourced-entities" class="header">Sharded Replicated Event Sourced entities</a></li>
    <li><a href="../typed/replicated-eventsourcing.html#tagging-events-and-running-projections" class="header">Tagging events and running projections</a></li>
    <li><a href="../typed/replicated-eventsourcing.html#direct-replication-of-events" class="header">Direct Replication of Events</a></li>
    <li><a href="../typed/replicated-eventsourcing.html#hot-standby" class="header">Hot Standby</a></li>
    <li><a href="../typed/replicated-eventsourcing.html#examples" class="header">Examples</a></li>
    <li><a href="../typed/replicated-eventsourcing.html#journal-support" class="header">Journal Support</a></li>
  </ul></li>
</ul>
</nav>


<ul class="md-nav__list md-nav__links">
<li class="md-nav__item"><a href="https://apache.org"><i class="md-icon">link</i> Apache Software Foundation</a></li>
<li class="md-nav__item"><a href="https://apache.org/licenses/"><i class="md-icon">link</i>&nbsp;License</a></li>
<li class="md-nav__item"><a href="https://apache.org/security/"><i class="md-icon">link</i>&nbsp;Security</a></li>
<li class="md-nav__item"><a href="https://www.apache.org/foundation/sponsorship.html"><i class="md-icon">link</i>&nbsp;Donate</a></li>
<li class="md-nav__item"><a href="https://www.apache.org/foundation/thanks.html"><i class="md-icon">link</i>&nbsp;Thanks</a></li>
</ul>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 0.0.0+26605-0f20b284+20230301-2309*
</label>
</li>
</ul>

</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../typed/replicated-eventsourcing.html#replicated-event-sourcing" class="header">Replicated Event Sourcing</a>
  <ul>
    <li><a href="../typed/replicated-eventsourcing.html#relaxing-the-single-writer-principle-for-availability" class="header">Relaxing the single-writer principle for availability</a></li>
    <li><a href="../typed/replicated-eventsourcing.html#api" class="header">API</a></li>
    <li><a href="../typed/replicated-eventsourcing.html#resolving-conflicting-updates" class="header">Resolving conflicting updates</a></li>
    <li><a href="../typed/replicated-eventsourcing.html#side-effects" class="header">Side effects</a></li>
    <li><a href="../typed/replicated-eventsourcing.html#how-it-works" class="header">How it works</a></li>
    <li><a href="../typed/replicated-eventsourcing.html#sharded-replicated-event-sourced-entities" class="header">Sharded Replicated Event Sourced entities</a></li>
    <li><a href="../typed/replicated-eventsourcing.html#tagging-events-and-running-projections" class="header">Tagging events and running projections</a></li>
    <li><a href="../typed/replicated-eventsourcing.html#direct-replication-of-events" class="header">Direct Replication of Events</a></li>
    <li><a href="../typed/replicated-eventsourcing.html#hot-standby" class="header">Hot Standby</a></li>
    <li><a href="../typed/replicated-eventsourcing.html#examples" class="header">Examples</a></li>
    <li><a href="../typed/replicated-eventsourcing.html#journal-support" class="header">Journal Support</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#replicated-event-sourcing" name="replicated-event-sourcing" class="anchor"><span class="anchor-link"></span></a>Replicated Event Sourcing</h1>
<p><a href="persistence.html">Event Sourcing</a> with <code>EventSourcedBehavior</code>s is based on the single writer principle, which means that there can only be one active instance of a <code>EventSourcedBehavior</code> with a given <code>persistenceId</code>. Otherwise, multiple instances would store interleaving events based on different states, and when these events would later be replayed it would not be possible to reconstruct the correct state.</p>
<p>This restriction means that in the event of network partitions, and for a short time during rolling re-deploys, some <code>EventSourcedBehavior</code> actors are unavailable.</p>
<p>Replicated Event Sourcing enables running multiple replicas of each entity. There is automatic replication of every event persisted to all replicas.</p>
<p>For instance, a replica can be run per:</p>
<ul>
  <li>Data Center</li>
  <li>Availability zone or rack</li>
</ul>
<p>The motivations are:</p>
<ul>
  <li>Redundancy to tolerate failures in one location and still be operational</li>
  <li>Serve requests from a location near the user to provide better responsiveness</li>
  <li>Balance the load over many servers</li>
</ul>
<p>However, the event handler must be able to <strong>handle concurrent events</strong> as when replication is enabled the single-writer guarantee is not maintained like it is with a normal <code>EventSourcedBehavior</code>.</p>
<p>The state of a replicated <code>EventSourcedBehavior</code> is <strong>eventually consistent</strong>. Event replication may be delayed due to network partitions and outages, which means that the event handler and those reading the state must be designed to handle this.</p>
<p>To be able to use Replicated Event Sourcing the journal and snapshot store used is required to have specific support for the metadata that the replication needs (see <a href="replicated-eventsourcing.html#journal-support">Journal Support</a>).</p>
<h2><a href="#relaxing-the-single-writer-principle-for-availability" name="relaxing-the-single-writer-principle-for-availability" class="anchor"><span class="anchor-link"></span></a>Relaxing the single-writer principle for availability</h2>
<p>Taking the example of using Replicated Event Sourcing to run a replica per data center.</p>
<p>When there is no network partitions and no concurrent writes the events stored by an <code>EventSourcedBehavior</code> at one replica can be replicated and consumed by another (corresponding) replica in another data center without any concerns. Such replicated events can simply be applied to the local state.</p>
<p><img src="images/replicated-events1.png" alt="images/replicated-events1.png" /></p>
<p>The interesting part begins when there are concurrent writes by <code>EventSourcedBehavior</code> replicas. That is more likely to happen when there is a network partition, but it can also happen when there are no network issues. They simply write at the &ldquo;same time&rdquo; before the events from the other side have been replicated and consumed.</p>
<p><img src="images/replicated-events2.png" alt="images/replicated-events2.png" /></p>
<p>The event handler logic for applying events to the state of the entity must be aware of that such concurrent updates can occur, and it must be modeled to handle such conflicts. This means that it should typically have the same characteristics as a Conflict Free Replicated Data Type (CRDT). With a CRDT there are by definition no conflicts, the events can always be applied. The library provides some general purpose CRDTs, but the logic of how to apply events can also be defined by an application specific function.</p>
<p>For example, sometimes it&rsquo;s enough to use application specific timestamps to decide which update should win.</p>
<p>To assist in implementing the event handler the Replicated Event Sourcing detects these conflicts.</p>
<h2><a href="#api" name="api" class="anchor"><span class="anchor-link"></span></a>API</h2>
<p><span class="group-scala">The same API as regular <code>EventSourcedBehavior</code>s</span><span class="group-java">A very similar API to the regular <code>EventSourcedBehavior</code></span> is used to define the logic. </p>
<p>To enable an entity for Replicated Event Sourcing <span class="group-java">let it extend <code>ReplicatedEventSourcedBehavior</code> instead of <code>EventSourcedBehavior</code> and</span> use the factory methods on <span class="group-scala"><code>org.apache.pekko.persistence.typed.scaladsl.ReplicatedEventSourcing</code></span><span class="group-java"><code>org.apache.pekko.persistence.typed.javadsl.ReplicatedEventSourcing</code></span>. </p>
<p>All replicas need to be known up front:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/scala/docs/org/apache/pekko/persistence/typed/ReplicatedEventSourcingCompileOnlySpec.scala#L29-L31" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val DCA = ReplicaId(&quot;DC-A&quot;)
val DCB = ReplicaId(&quot;DC-B&quot;)
val AllReplicas = Set(DCA, DCB)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/java/jdocs/org/apache/pekko/persistence/typed/MyReplicatedBehavior.java#L35-L39" target="_blank" title="Go to snippet source">source</a><code class="language-java">public static final ReplicaId DCA = new ReplicaId(&quot;DCA&quot;);
public static final ReplicaId DCB = new ReplicaId(&quot;DCB&quot;);

public static final Set&lt;ReplicaId&gt; ALL_REPLICAS =
    Collections.unmodifiableSet(new HashSet&lt;&gt;(Arrays.asList(DCA, DCB)));</code></pre></dd>
</dl>
<p>Then to enable replication create the event sourced behavior with the factory method:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/scala/docs/org/apache/pekko/persistence/typed/ReplicatedEventSourcingCompileOnlySpec.scala#L58-L68" target="_blank" title="Go to snippet source">source</a><code class="language-scala">def apply(
    system: ActorSystem[_],
    entityId: String,
    replicaId: ReplicaId): EventSourcedBehavior[Command, State, Event] = {
  ReplicatedEventSourcing.perReplicaJournalConfig(
    ReplicationId(&quot;MyReplicatedEntity&quot;, entityId, replicaId),
    Map(DCA -&gt; &quot;journalForDCA&quot;, DCB -&gt; &quot;journalForDCB&quot;)) { replicationContext =&gt;
    EventSourcedBehavior[Command, State, Event](???, ???, ???, ???)
  }
}
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/java/jdocs/org/apache/pekko/persistence/typed/MyReplicatedBehavior.java#L24-L67" target="_blank" title="Go to snippet source">source</a><code class="language-java">public class MyReplicatedBehavior
    extends ReplicatedEventSourcedBehavior&lt;
        MyReplicatedBehavior.Command, MyReplicatedBehavior.Event, MyReplicatedBehavior.State&gt; {
  public static Behavior&lt;Command&gt; create(String entityId, ReplicaId replicaId) {
    Map&lt;ReplicaId, String&gt; allReplicasAndQueryPlugins = new HashMap&lt;&gt;();
    allReplicasAndQueryPlugins.put(DCA, &quot;journalForDCA&quot;);
    allReplicasAndQueryPlugins.put(DCB, &quot;journalForDCB&quot;);

    return ReplicatedEventSourcing.perReplicaJournalConfig(
        new ReplicationId(&quot;MyReplicatedEntity&quot;, entityId, replicaId),
        allReplicasAndQueryPlugins,
        MyReplicatedBehavior::new);
  }

  private MyReplicatedBehavior(ReplicationContext replicationContext) {
    super(replicationContext);
  }</code></pre></dd>
</dl>
<p>The factory takes in:</p>
<ul>
  <li><code>entityId</code>: this will be used as part of the underlying persistenceId</li>
  <li><code>replicaId</code>: Which replica this instance is</li>
  <li><code>allReplicasAndQueryPlugins</code>: All Replicas and the query plugin used to read their events</li>
  <li>A factory function to create an instance of the <span class="group-scala"><code>EventSourcedBehavior</code></span><span class="group-java"><code>ReplicatedEventSourcedBehavior</code></span></li>
</ul>
<p>In this scenario each replica reads from each other&rsquo;s database effectively providing cross region replication for any database that has a Pekko Persistence plugin. Alternatively if all the replicas use the same journal, e.g. for testing or if it is a distributed database such as Cassandra, the <code>withSharedJournal</code> factory can be used. </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/scala/docs/org/apache/pekko/persistence/typed/ReplicatedEventSourcingCompileOnlySpec.scala#L42-L52" target="_blank" title="Go to snippet source">source</a><code class="language-scala">def apply(
    system: ActorSystem[_],
    entityId: String,
    replicaId: ReplicaId): EventSourcedBehavior[Command, State, Event] = {
  ReplicatedEventSourcing.commonJournalConfig(
    ReplicationId(&quot;MyReplicatedEntity&quot;, entityId, replicaId),
    AllReplicas,
    queryPluginId) { replicationContext =&gt;
    EventSourcedBehavior[Command, State, Event](???, ???, ???, ???)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/java/jdocs/org/apache/pekko/persistence/typed/MyReplicatedBehavior.java#L43-L50" target="_blank" title="Go to snippet source">source</a><code class="language-java">public static Behavior&lt;Command&gt; create(
    String entityId, ReplicaId replicaId, String queryPluginId) {
  return ReplicatedEventSourcing.commonJournalConfig(
      new ReplicationId(&quot;MyReplicatedEntity&quot;, entityId, replicaId),
      ALL_REPLICAS,
      queryPluginId,
      MyReplicatedBehavior::new);
}</code></pre></dd>
</dl><div class="group-scala">
<p>The function passed to both factory methods return an <code>EventSourcedBehavior</code> and provide access to the <span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/persistence/typed/javadsl/ReplicationContext.html" title="org.apache.pekko.persistence.typed.javadsl.ReplicationContext"><code>ReplicationContext</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/persistence/typed/scaladsl/ReplicationContext.html" title="org.apache.pekko.persistence.typed.scaladsl.ReplicationContext"><code>ReplicationContext</code></a></span> that has the following methods:</p>
<ul>
  <li><code>entityId</code></li>
  <li><code>replicaId</code></li>
  <li><code>allReplicas</code></li>
  <li><code>persistenceId</code> - to provide to the <code>EventSourcedBehavior</code> factory. This <strong>must be used</strong>.</li>
</ul>
<p>As well as methods that <strong>can only be</strong> used in the event handler. The values these methods return relate to the event that is being processed.</p></div><div class="group-java">
<p>The function passed to both factory methods is invoked with a special <span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/persistence/typed/javadsl/ReplicationContext.html" title="org.apache.pekko.persistence.typed.javadsl.ReplicationContext"><code>ReplicationContext</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/persistence/typed/scaladsl/ReplicationContext.html" title="org.apache.pekko.persistence.typed.scaladsl.ReplicationContext"><code>ReplicationContext</code></a></span> that needs to be passed to the concrete <code>ReplicatedEventSourcedBehavior</code> and on to the super constructor.</p>
<p>The context gives access to: </p>
<ul>
  <li><code>entityId</code></li>
  <li><code>replicaId</code></li>
  <li><code>allReplicas</code></li>
  <li><code>persistenceId</code></li>
</ul>
<p>As well as methods that <strong>can only be</strong> used in the event handler, accessed through <code>getReplicationContext</code>. The values these methods return relate to the event that is being processed.</p></div>
<ul>
  <li><code>origin</code>: The ReplicaId that originally created the event</li>
  <li><code>concurrent</code>: Whether the event was concurrent with another event as in the second diagram above</li>
  <li><code>recoveryRunning</code>: Whether a recovery is running. Can be used to send commands back to self for side effects that should only happen once.</li>
  <li><code>currentTimeMillis</code>: similar to <code>System.currentTimeMillis</code> but guaranteed never to go backwards</li>
</ul>
<p>The factory returns a <code>Behavior</code> that can be spawned like any other behavior.</p>
<h2><a href="#resolving-conflicting-updates" name="resolving-conflicting-updates" class="anchor"><span class="anchor-link"></span></a>Resolving conflicting updates</h2>
<h3><a href="#conflict-free-replicated-data-types" name="conflict-free-replicated-data-types" class="anchor"><span class="anchor-link"></span></a>Conflict free replicated data types</h3>
<p>Writing code to resolve conflicts can be complicated to get right. One well-understood technique to create eventually-consistent systems is to model your state as a Conflict Free Replicated Data Type, a CRDT. There are two types of CRDTs; operation-based and state-based. For Replicated Event Sourcing the operation-based is a good fit, since the events represent the operations. Note that this is distinct from the CRDT&rsquo;s implemented in <a href="distributed-data.html">Pekko Distributed Data</a>, which are state-based rather than operation-based.</p>
<p>The rule for operation-based CRDT&rsquo;s is that the operations must be commutative â in other words, applying the same events (which represent the operations) in any order should always produce the same final state. You may assume each event is applied only once, with <a href="replicated-eventsourcing.html#causal-delivery-order">causal delivery order</a>.</p>
<p>The following CRDTs are included that can you can use as the state or part of the state in the entity:</p>
<ul>
  <li><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/persistence/typed/crdt/LwwTime.html" title="org.apache.pekko.persistence.typed.crdt.LwwTime"><code>LwwTime</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/persistence/typed/crdt/LwwTime.html" title="org.apache.pekko.persistence.typed.crdt.LwwTime"><code>LwwTime</code></a></span></li>
  <li><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/persistence/typed/crdt/Counter.html" title="org.apache.pekko.persistence.typed.crdt.Counter"><code>Counter</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/persistence/typed/crdt/Counter.html" title="org.apache.pekko.persistence.typed.crdt.Counter"><code>Counter</code></a></span></li>
  <li><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/persistence/typed/crdt/ORSet.html" title="org.apache.pekko.persistence.typed.crdt.ORSet"><code>ORSet</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/persistence/typed/crdt/ORSet.html" title="org.apache.pekko.persistence.typed.crdt.ORSet"><code>ORSet</code></a></span></li>
</ul>
<p>Pekko serializers are included for all these types and can be used to serialize when <a href="../serialization-jackson.html#using-pekko-serialization-for-embedded-types">embedded in Jackson</a>.</p>
<p>An example would be a movies watch list that is represented by the general purpose <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/persistence/typed/crdt/ORSet.html" title="org.apache.pekko.persistence.typed.crdt.ORSet"><code>ORSet</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/persistence/typed/crdt/ORSet.html" title="org.apache.pekko.persistence.typed.crdt.ORSet"><code>ORSet</code></a></span> CRDT. <code>ORSet</code> is short for Observed Remove Set. Elements can be added and removed any number of times. Concurrent add wins over remove. It is an operation based CRDT where the delta of an operation (add/remove) can be represented as an event.</p>
<p>Such movies watch list example:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/scala/docs/org/apache/pekko/persistence/typed/ReplicatedMovieWatchListExampleSpec.scala#L33-L69" target="_blank" title="Go to snippet source">source</a><code class="language-scala">object MovieWatchList {
  sealed trait Command
  final case class AddMovie(movieId: String) extends Command
  final case class RemoveMovie(movieId: String) extends Command
  final case class GetMovieList(replyTo: ActorRef[MovieList]) extends Command
  final case class MovieList(movieIds: Set[String])

  def apply(entityId: String, replicaId: ReplicaId, allReplicaIds: Set[ReplicaId]): Behavior[Command] = {
    ReplicatedEventSourcing.commonJournalConfig(
      ReplicationId(&quot;movies&quot;, entityId, replicaId),
      allReplicaIds,
      PersistenceTestKitReadJournal.Identifier) { replicationContext =&gt;
      EventSourcedBehavior[Command, ORSet.DeltaOp, ORSet[String]](
        replicationContext.persistenceId,
        ORSet.empty(replicationContext.replicaId),
        (state, cmd) =&gt; commandHandler(state, cmd),
        (state, event) =&gt; eventHandler(state, event))
    }
  }

  private def commandHandler(state: ORSet[String], cmd: Command): Effect[ORSet.DeltaOp, ORSet[String]] = {
    cmd match {
      case AddMovie(movieId) =&gt;
        Effect.persist(state + movieId)
      case RemoveMovie(movieId) =&gt;
        Effect.persist(state - movieId)
      case GetMovieList(replyTo) =&gt;
        replyTo ! MovieList(state.elements)
        Effect.none
    }
  }

  private def eventHandler(state: ORSet[String], event: ORSet.DeltaOp): ORSet[String] = {
    state.applyOperation(event)
  }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/java/jdocs/org/apache/pekko/persistence/typed/ReplicatedMovieExample.java#L34-L111" target="_blank" title="Go to snippet source">source</a><code class="language-java">public final class MovieWatchList
    extends ReplicatedEventSourcedBehavior&lt;MovieWatchList.Command, ORSet.DeltaOp, ORSet&lt;String&gt;&gt; {

  interface Command {}

  public static class AddMovie implements Command {
    public final String movieId;

    public AddMovie(String movieId) {
      this.movieId = movieId;
    }
  }

  public static class RemoveMovie implements Command {
    public final String movieId;

    public RemoveMovie(String movieId) {
      this.movieId = movieId;
    }
  }

  public static class GetMovieList implements Command {
    public final ActorRef&lt;MovieList&gt; replyTo;

    public GetMovieList(ActorRef&lt;MovieList&gt; replyTo) {
      this.replyTo = replyTo;
    }
  }

  public static class MovieList {
    public final Set&lt;String&gt; movieIds;

    public MovieList(Set&lt;String&gt; movieIds) {
      this.movieIds = Collections.unmodifiableSet(movieIds);
    }
  }

  public static Behavior&lt;Command&gt; create(
      String entityId, ReplicaId replicaId, Set&lt;ReplicaId&gt; allReplicas) {
    return ReplicatedEventSourcing.commonJournalConfig(
        new ReplicationId(&quot;movies&quot;, entityId, replicaId),
        allReplicas,
        PersistenceTestKitReadJournal.Identifier(),
        MovieWatchList::new);
  }

  private MovieWatchList(ReplicationContext replicationContext) {
    super(replicationContext);
  }

  @Override
  public ORSet&lt;String&gt; emptyState() {
    return ORSet.empty(getReplicationContext().replicaId());
  }

  @Override
  public CommandHandler&lt;Command, ORSet.DeltaOp, ORSet&lt;String&gt;&gt; commandHandler() {
    return newCommandHandlerBuilder()
        .forAnyState()
        .onCommand(
            AddMovie.class, (state, command) -&gt; Effect().persist(state.add(command.movieId)))
        .onCommand(
            RemoveMovie.class,
            (state, command) -&gt; Effect().persist(state.remove(command.movieId)))
        .onCommand(
            GetMovieList.class,
            (state, command) -&gt; {
              command.replyTo.tell(new MovieList(state.getElements()));
              return Effect().none();
            })
        .build();
  }

  @Override
  public EventHandler&lt;ORSet&lt;String&gt;, ORSet.DeltaOp&gt; eventHandler() {
    return newEventHandlerBuilder().forAnyState().onAnyEvent(ORSet::applyOperation);
  }
}</code></pre></dd>
</dl>
<p>The <a href="replicated-eventsourcing-auction.html">Auction example</a> is a more comprehensive example that illustrates how application-specific rules can be used to implement an entity with CRDT semantics.</p>
<h3><a href="#last-writer-wins" name="last-writer-wins" class="anchor"><span class="anchor-link"></span></a>Last writer wins</h3>
<p>Sometimes, it is enough to use timestamps to decide which update should win. Such approach relies on synchronized clocks, and clocks of different machines will always be slightly out of sync. Timestamps should therefore only be used when the choice of value is not important for concurrent updates occurring within the clock skew.</p>
<p>In general, last writer wins means that the event is used if the timestamp of the event is later (higher) than the timestamp of previous local update, otherwise the event is discarded. There is no built-in support for last writer wins, because it must often be combined with more application specific aspects.</p>
<p><img src="images/lww.png" alt="images/lww.png" /></p>
<p>There is a small utility class <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/persistence/typed/crdt/LwwTime.html" title="org.apache.pekko.persistence.typed.crdt.LwwTime"><code>LwwTime</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/persistence/typed/crdt/LwwTime.html" title="org.apache.pekko.persistence.typed.crdt.LwwTime"><code>LwwTime</code></a></span> that can be useful for implementing last writer wins semantics. It contains a timestamp representing current time when the event was persisted and an identifier of the replica that persisted it. When comparing two <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/persistence/typed/crdt/LwwTime.html" title="org.apache.pekko.persistence.typed.crdt.LwwTime"><code>LwwTime</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/persistence/typed/crdt/LwwTime.html" title="org.apache.pekko.persistence.typed.crdt.LwwTime"><code>LwwTime</code></a></span> the greatest timestamp wins. The replica identifier is used if the two timestamps are equal, and then the one from the <code>replicaId</code> sorted first in alphanumeric order wins.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/scala/docs/org/apache/pekko/persistence/typed/ReplicatedBlogExampleSpec.scala#L116-L139" target="_blank" title="Go to snippet source">source</a><code class="language-scala">private def eventHandler(
    ctx: ActorContext[Command],
    replicationContext: ReplicationContext,
    state: BlogState,
    event: Event): BlogState = {
  ctx.log.info(s&quot;${replicationContext.entityId}:${replicationContext.replicaId} Received event $event&quot;)
  event match {
    case PostAdded(_, content, timestamp) =&gt;
      if (timestamp.isAfter(state.contentTimestamp)) {
        val s = state.withContent(content, timestamp)
        ctx.log.info(&quot;Updating content. New content is {}&quot;, s)
        s
      } else {
        ctx.log.info(&quot;Ignoring event as timestamp is older&quot;)
        state
      }
    case BodyChanged(_, newContent, timestamp) =&gt;
      if (timestamp.isAfter(state.contentTimestamp))
        state.withContent(newContent, timestamp)
      else state
    case Published(_) =&gt;
      state.copy(published = true)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/java/jdocs/org/apache/pekko/persistence/typed/ReplicatedBlogExample.java#L265-L296" target="_blank" title="Go to snippet source">source</a><code class="language-java">@Override
public EventHandler&lt;BlogState, Event&gt; eventHandler() {
  return newEventHandlerBuilder()
      .forAnyState()
      .onEvent(PostAdded.class, this::onPostAdded)
      .onEvent(BodyChanged.class, this::onBodyChanged)
      .onEvent(Published.class, this::onPublished)
      .build();
}

private BlogState onPostAdded(BlogState state, PostAdded event) {
  if (event.timestamp.isAfter(state.contentTimestamp)) {
    BlogState s = state.withContent(event.content, event.timestamp);
    context.getLog().info(&quot;Updating content. New content is {}&quot;, s);
    return s;
  } else {
    context.getLog().info(&quot;Ignoring event as timestamp is older&quot;);
    return state;
  }
}

private BlogState onBodyChanged(BlogState state, BodyChanged event) {
  if (event.timestamp.isAfter(state.contentTimestamp)) {
    return state.withContent(event.content, event.timestamp);
  } else {
    return state;
  }
}

private BlogState onPublished(BlogState state, Published event) {
  return state.publish();
}</code></pre></dd>
</dl>
<p>When creating the <code>LwwTime</code> it is good to have a monotonically increasing timestamp, and for that the <code>increase</code> method in <code>LwwTime</code> can be used:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/scala/docs/org/apache/pekko/persistence/typed/ReplicatedBlogExampleSpec.scala#L79-L112" target="_blank" title="Go to snippet source">source</a><code class="language-scala">private def commandHandler(
    ctx: ActorContext[Command],
    replicationContext: ReplicationContext,
    state: BlogState,
    cmd: Command): Effect[Event, BlogState] = {
  cmd match {
    case AddPost(_, content, replyTo) =&gt;
      val evt =
        PostAdded(
          replicationContext.entityId,
          content,
          state.contentTimestamp.increase(replicationContext.currentTimeMillis(), replicationContext.replicaId))
      Effect.persist(evt).thenRun { _ =&gt;
        replyTo ! AddPostDone(replicationContext.entityId)
      }
    case ChangeBody(_, newContent, replyTo) =&gt;
      val evt =
        BodyChanged(
          replicationContext.entityId,
          newContent,
          state.contentTimestamp.increase(replicationContext.currentTimeMillis(), replicationContext.replicaId))
      Effect.persist(evt).thenRun { _ =&gt;
        replyTo ! Done
      }
    case p: Publish =&gt;
      Effect.persist(Published(&quot;id&quot;)).thenRun { _ =&gt;
        p.replyTo ! Done
      }
    case gp: GetPost =&gt;
      ctx.log.info(&quot;GetPost {}&quot;, state.content)
      state.content.foreach(content =&gt; gp.replyTo ! content)
      Effect.none
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/java/jdocs/org/apache/pekko/persistence/typed/ReplicatedBlogExample.java#L217-L261" target="_blank" title="Go to snippet source">source</a><code class="language-java">@Override
public CommandHandler&lt;Command, Event, BlogState&gt; commandHandler() {
  return newCommandHandlerBuilder()
      .forAnyState()
      .onCommand(AddPost.class, this::onAddPost)
      .onCommand(ChangeBody.class, this::onChangeBody)
      .onCommand(Publish.class, this::onPublish)
      .onCommand(GetPost.class, this::onGetPost)
      .build();
}

private Effect&lt;Event, BlogState&gt; onAddPost(BlogState state, AddPost command) {
  PostAdded evt =
      new PostAdded(
          getReplicationContext().entityId(),
          command.content,
          state.contentTimestamp.increase(
              getReplicationContext().currentTimeMillis(),
              getReplicationContext().replicaId()));
  return Effect()
      .persist(evt)
      .thenRun(() -&gt; command.replyTo.tell(new AddPostDone(getReplicationContext().entityId())));
}

private Effect&lt;Event, BlogState&gt; onChangeBody(BlogState state, ChangeBody command) {
  BodyChanged evt =
      new BodyChanged(
          getReplicationContext().entityId(),
          command.newContent,
          state.contentTimestamp.increase(
              getReplicationContext().currentTimeMillis(),
              getReplicationContext().replicaId()));
  return Effect().persist(evt).thenRun(() -&gt; command.replyTo.tell(Done.getInstance()));
}

private Effect&lt;Event, BlogState&gt; onPublish(BlogState state, Publish command) {
  Published evt = new Published(getReplicationContext().entityId());
  return Effect().persist(evt).thenRun(() -&gt; command.replyTo.tell(Done.getInstance()));
}

private Effect&lt;Event, BlogState&gt; onGetPost(BlogState state, GetPost command) {
  context.getLog().info(&quot;GetPost {}&quot;, state.content);
  if (state.content.isPresent()) command.replyTo.tell(state.content.get());
  return Effect().none();
}</code></pre></dd>
</dl>
<p>The nature of last writer wins means that if you only have one timestamp for the state the events must represent an update of the full state. Otherwise, there is a risk that the state in different replicas will be different and not eventually converge.</p>
<p>An example of that would be an entity representing a blog post and the fields <code>author</code> and <code>title</code> could be updated separately with events <span class="group-scala"><code>AuthorChanged(newAuthor: String)</code></span><span class="group-java"><code>new AuthorChanged(newAuthor)</code></span> and <span class="group-scala"><code>TitleChanged(newTitle: String)</code></span><span class="group-java"><code>new TitleChanged(newTitle)</code></span>.</p>
<p>Let&rsquo;s say the blog post is created and the initial state of <code>title=Pekko, author=unknown</code> is in sync in both replicas <code>DC-A</code> and `DC-B.</p>
<p>In <code>DC-A</code> author is changed to &ldquo;Bob&rdquo; at time <code>100</code>. Before that event has been replicated over to <code>DC-B</code> the title is updated to &ldquo;Pekko News&rdquo; at time <code>101</code> in <code>DC-B</code>. When the events have been replicated the result will be:</p>
<p><code>DC-A</code>: The title update is later so the event is used and new state is <code>title=Pekko News, author=Bob</code></p>
<p><code>DC-B</code>: The author update is earlier so the event is discarded and state is <code>title=Pekko News, author=unknown</code></p>
<p>The problem here is that the partial update of the state is not applied on both sides, so the states have diverged and will not become the same.</p>
<p>To solve this with last writer wins the events must carry the full state, such as <span class="group-scala"><code>AuthorChanged(newContent: PostContent)</code></span><span class="group-java"><code>new AuthorChanged(newContent)</code></span> and <span class="group-scala"><code>TitleChanged(newContent: PostContent)</code></span><span class="group-java"><code>new TitleChanged(newContent)</code></span>. Then the result would eventually be <code>title=Pekko News, author=unknown</code> on both sides. The author update is lost but that is because the changes were performed concurrently. More important is that the state is eventually consistent.</p>
<p>Including the full state in each event is often not desired. An event typically represent a change, a delta. Then one can use several timestamps, one for each set of fields that can be updated together. In the above example one could use one timestamp for the title and another for the author. Then the events could represent changes to parts of the full state, such as <span class="group-scala"><code>AuthorChanged(newAuthor: String)</code></span><span class="group-java"><code>new AuthorChanged(newAuthor)</code></span> and <span class="group-scala"><code>TitleChanged(newTitle: String)</code></span><span class="group-java"><code>new TitleChanged(newTitle)</code></span>.</p>
<h2><a href="#side-effects" name="side-effects" class="anchor"><span class="anchor-link"></span></a>Side effects</h2>
<p>In most cases it is recommended to do side effects as <a href="persistence.html#effects-and-side-effects">described for <code>EventSourcedBehavior</code>s</a>.</p>
<p>Side effects from the event handler are generally discouraged because the event handlers are also used during replay and when consuming replicated events and that would result in undesired re-execution of the side effects.</p>
<p>Uses cases for doing side effects in the event handler:</p>
<ul>
  <li>Doing a side effect only in a single replica</li>
  <li>Doing a side effect once all replicas have seen an event</li>
  <li>A side effect for a replicated event</li>
  <li>A side effect when a conflict has occurred</li>
</ul>
<p>There is no built in support for knowing an event has been replicated to all replicas but it can be modelled in your state. For some use cases you may need to trigger side effects after consuming replicated events. For example when an auction has been closed in all data centers and all bids have been replicated. </p>
<p>The  contains the current replica, the origin replica for the event processes, and if a recovery is running. These can be used to implement side effects that take place once events are fully replicated. If the side effect should happen only once then a particular replica can be designated to do it. The <a href="replicated-eventsourcing-auction.html">Auction example</a> uses these techniques.</p>
<h2><a href="#how-it-works" name="how-it-works" class="anchor"><span class="anchor-link"></span></a>How it works</h2>
<p>You donât have to read this section to be able to use the feature, but to use the abstraction efficiently and for the right type of use cases it can be good to understand how itâs implemented. For example, it should give you the right expectations of the overhead that the solution introduces compared to using just <code>EventSourcedBehavior</code>s.</p>
<h3><a href="#causal-delivery-order" name="causal-delivery-order" class="anchor"><span class="anchor-link"></span></a>Causal delivery order</h3>
<p>Causal delivery order means that events persisted in one replica are read in the same order in other replicas. The order of concurrent events is undefined, which should be no problem when using <a href="replicated-eventsourcing.html#conflict-free-replicated-data-types">CRDT&rsquo;s</a> and otherwise will be detected via the <code>ReplicationContext</code> concurrent method.</p>
<p>For example:</p>
<pre><code>DC-1: write e1
DC-2: read e1, write e2
DC-1: read e2, write e3
</code></pre>
<p>In the above example the causality is <code>e1 -&gt; e2 -&gt; e3</code>. Also in a third replica DC-3 these events will be read in the same order e1, e2, e3.</p>
<p>Another example with concurrent events:</p>
<pre><code>DC1: write e1
DC2: read e1, write e2
DC1: write e3 (e2 and e3 are concurrent)
DC1: read e2
DC2: read e3
</code></pre>
<p>e2 and e3 are concurrent, i.e. they don&rsquo;t have a causal relation: DC1 sees them in the order &ldquo;e1, e3, e2&rdquo;, while DC2 sees them as &ldquo;e1, e2, e3&rdquo;.</p>
<p>A third replica may also see the events as either &ldquo;e1, e3, e2&rdquo; or as &ldquo;e1, e2, e3&rdquo;.</p>
<h3><a href="#concurrent-updates" name="concurrent-updates" class="anchor"><span class="anchor-link"></span></a>Concurrent updates</h3>
<p>Replicated Event Sourcing automatically tracks causality between events from different replicas using <a href="https://en.wikipedia.org/wiki/Version_vector">version vectors</a>.</p>
<p><img src="images/causality.png" alt="images/causality.png" /></p>
<p>Each replica &ldquo;owns&rdquo; a slot in the version vector and increases its counter when an event is persisted. The version vector is stored with the event, and when a replicated event is consumed the version vector of the event is merged with the local version vector.</p>
<p>When comparing two version vectors <code>v1</code> and <code>v2</code>: </p>
<ul>
  <li><code>v1</code> is SAME as <code>v2</code> iff for all i <code>v1(i) == v2(i)</code></li>
  <li><code>v1</code>is BEFORE <code>v2</code> iff for all i <code>v1(i) &lt;= v2(i)</code> and there exist a j such that <code>v1(j) &lt; v2(j)</code></li>
  <li><code>v1</code>is AFTER <code>v2</code> iff for all i <code>v1(i) &gt;= v2(i)</code> and there exist a j such that <code>v1(j) &gt; v2(j)</code></li>
  <li><code>v1</code>is CONCURRENT with <code>v2</code> otherwise</li>
</ul>
<h2><a href="#sharded-replicated-event-sourced-entities" name="sharded-replicated-event-sourced-entities" class="anchor"><span class="anchor-link"></span></a>Sharded Replicated Event Sourced entities</h2>
<p>There are three ways to integrate replicated event sourced entities with sharding:</p>
<ul>
  <li>Ensure that each replica has a unique entity id by using the replica id as part of the entity id</li>
  <li>Use <a href="cluster-dc.html">multi datacenter</a> to run a full copy of sharding per replica</li>
  <li>Use roles to run a full copy of sharding per replica</li>
</ul>
<p>To simplify all three cases the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/cluster/sharding/typed/ReplicatedShardingExtension.html" title="org.apache.pekko.cluster.sharding.typed.ReplicatedShardingExtension"><code>ReplicatedShardingExtension</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/cluster/sharding/typed/ReplicatedShardingExtension.html" title="org.apache.pekko.cluster.sharding.typed.ReplicatedShardingExtension"><code>ReplicatedShardingExtension</code></a></span> is available from the <code>pekko-cluster-sharding-typed</code> module.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/scala/docs/org/apache/pekko/cluster/sharding/typed/ReplicatedShardingCompileOnlySpec.scala#L41-L50" target="_blank" title="Go to snippet source">source</a><code class="language-scala">ReplicatedEntityProvider[Command](&quot;MyEntityType&quot;, Set(ReplicaId(&quot;DC-A&quot;), ReplicaId(&quot;DC-B&quot;))) {
  (entityTypeKey, replicaId) =&gt;
    ReplicatedEntity(replicaId,
      Entity(entityTypeKey) { entityContext =&gt;
        // the sharding entity id contains the business entityId, entityType, and replica id
        // which you&#39;ll need to create a ReplicatedEventSourcedBehavior
        val replicationId = ReplicationId.fromString(entityContext.entityId)
        MyEventSourcedBehavior(replicationId)
      })
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/java/jdocs/org/apache/pekko/cluster/sharding/typed/ReplicatedShardingCompileOnlySpec.java#L43-L55" target="_blank" title="Go to snippet source">source</a><code class="language-java">return ReplicatedEntityProvider.create(
    Command.class,
    &quot;MyReplicatedType&quot;,
    ALL_REPLICAS,
    (entityTypeKey, replicaId) -&gt;
        ReplicatedEntity.create(
            replicaId,
            Entity.of(
                entityTypeKey,
                entityContext -&gt;
                    myEventSourcedBehavior(
                        ReplicationId.fromString(entityContext.getEntityId())))));
</code></pre></dd>
</dl>
<p>This will run an instance of sharding and per replica and each entity id contains the replica id and the type name. Replicas could be on the same node if they end up in the same shard or if the shards get allocated to the same node.</p>
<p>To prevent this roles can be used. You could for instance add a cluster role per availability zone / rack and have a replica per rack.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/scala/docs/org/apache/pekko/cluster/sharding/typed/ReplicatedShardingCompileOnlySpec.scala#L60-L63" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val provider = ReplicatedEntityProvider.perRole(&quot;MyEntityType&quot;, Set(ReplicaId(&quot;DC-A&quot;), ReplicaId(&quot;DC-B&quot;))) {
  replicationId =&gt;
    MyEventSourcedBehavior(replicationId)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/java/jdocs/org/apache/pekko/cluster/sharding/typed/ReplicatedShardingCompileOnlySpec.java#L80-L93" target="_blank" title="Go to snippet source">source</a><code class="language-java">return ReplicatedEntityProvider.create(
    Command.class,
    &quot;MyReplicatedType&quot;,
    ALL_REPLICAS,
    (entityTypeKey, replicaId) -&gt;
        ReplicatedEntity.create(
            replicaId,
            Entity.of(
                    entityTypeKey,
                    entityContext -&gt;
                        myEventSourcedBehavior(
                            ReplicationId.fromString(entityContext.getEntityId())))
                .withRole(replicaId.id())));
</code></pre></dd>
</dl>
<p>Lastly if your Pekko Cluster is setup across DCs you can run a replica per DC.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/scala/docs/org/apache/pekko/cluster/sharding/typed/ReplicatedShardingCompileOnlySpec.scala#L54-L56" target="_blank" title="Go to snippet source">source</a><code class="language-scala">ReplicatedEntityProvider.perDataCenter(&quot;MyEntityType&quot;, Set(ReplicaId(&quot;DC-A&quot;), ReplicaId(&quot;DC-B&quot;))) { replicationId =&gt;
  MyEventSourcedBehavior(replicationId)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/java/jdocs/org/apache/pekko/cluster/sharding/typed/ReplicatedShardingCompileOnlySpec.java#L61-L74" target="_blank" title="Go to snippet source">source</a><code class="language-java">ReplicatedEntityProvider.create(
    Command.class,
    &quot;MyReplicatedType&quot;,
    ALL_REPLICAS,
    (entityTypeKey, replicaId) -&gt;
        ReplicatedEntity.create(
            replicaId,
            Entity.of(
                    entityTypeKey,
                    entityContext -&gt;
                        myEventSourcedBehavior(
                            ReplicationId.fromString(entityContext.getEntityId())))
                .withDataCenter(replicaId.id())));
</code></pre></dd>
</dl>
<p>Regardless of which replication strategy you use sending messages to the replicated entities is the same.</p>
<p><code>init</code> returns an <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/cluster/sharding/typed/ReplicatedSharding.html" title="org.apache.pekko.cluster.sharding.typed.ReplicatedSharding"><code>ReplicatedSharding</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/cluster/sharding/typed/ReplicatedSharding.html" title="org.apache.pekko.cluster.sharding.typed.ReplicatedSharding"><code>ReplicatedSharding</code></a></span> instance which gives access to <span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/cluster/sharding/typed/javadsl/EntityRef.html" title="org.apache.pekko.cluster.sharding.typed.javadsl.EntityRef"><code>EntityRef</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/cluster/sharding/typed/scaladsl/EntityRef.html" title="org.apache.pekko.cluster.sharding.typed.scaladsl.EntityRef"><code>EntityRef</code></a></span>s for each of the replicas for arbitrary routing logic:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/scala/docs/org/apache/pekko/cluster/sharding/typed/ReplicatedShardingCompileOnlySpec.scala#L67-L70" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val myReplicatedSharding: ReplicatedSharding[Command] =
  ReplicatedShardingExtension(system).init(provider)

val entityRefs: Map[ReplicaId, EntityRef[Command]] = myReplicatedSharding.entityRefsFor(&quot;myEntityId&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/cluster-sharding-typed/src/test/java/jdocs/org/apache/pekko/cluster/sharding/typed/ReplicatedShardingCompileOnlySpec.java#L99-L104" target="_blank" title="Go to snippet source">source</a><code class="language-java">ReplicatedShardingExtension extension = ReplicatedShardingExtension.get(system);

ReplicatedSharding&lt;Command&gt; replicatedSharding = extension.init(provider());

Map&lt;ReplicaId, EntityRef&lt;Command&gt;&gt; myEntityId =
    replicatedSharding.getEntityRefsFor(&quot;myEntityId&quot;);</code></pre></dd>
</dl>
<p>More advanced routing among the replicas is currently left as an exercise for the reader.</p>
<h2><a href="#tagging-events-and-running-projections" name="tagging-events-and-running-projections" class="anchor"><span class="anchor-link"></span></a>Tagging events and running projections</h2>
<p>Just like for regular <code>EventSourcedBehavior</code>s it is possible to tag events along with persisting them. This is useful for later retrival of events for a given tag. The same <a href="persistence.html#tagging">API for tagging provided for EventSourcedBehavior</a> can be used for replicated event sourced behaviors as well. Tagging is useful in practice to build queries that lead to other data representations or aggregations of these event streams that can more directly serve user queries â known as building the âread sideâ in <a href="cqrs.html">CQRS</a> based applications.</p>
<p>Creating read side projections is possible through <a href="https://pekko.apache.org/docs/pekko-projection/current/">Pekko Projection</a> or through direct usage of the <a href="../persistence-query.html#eventsbytag-and-currenteventsbytag">events by tag queries</a>. </p>
<p>The tagging is invoked in each replicas, which requires some special care in using tags, or else the same event will be tagged one time for each replica and show up in the event by tag stream one time for each replica. In addition to this the tags will be written in the respective journal of the replicas, which means that unless they all share a single journal the tag streams will be local to the replica even if the same tag is used on multiple replicas.</p>
<p>One strategy for dealing with this is to include the replica id in the tag name, this means there will be a tagged stream of events per replica that contains all replicated events, but since the events can arrive in different order, they can also come in different order per replica tag.</p>
<p>Another strategy would be to tag only the events that are local to the replica and not events that are replicated. Either using a tag that will be the same for all replicas, leading to a single stream of tagged events where the events from each replica is present only once, or with a tag including the replica id meaning that there will be a stream of tagged events with the events accepted locally for each replica.</p>
<p>Determining the replica id of the replicated actor itself and the origin replica id of an event is possible through the <span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/persistence/typed/javadsl/ReplicationContext.html" title="org.apache.pekko.persistence.typed.javadsl.ReplicationContext"><code>ReplicationContext</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/persistence/typed/scaladsl/ReplicationContext.html" title="org.apache.pekko.persistence.typed.scaladsl.ReplicationContext"><code>ReplicationContext</code></a></span> when the tagger callback is invoked like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/scala/org/apache/pekko/persistence/typed/ReplicatedEventSourcingTaggingSpec.scala#L55-L78" target="_blank" title="Go to snippet source">source</a><code class="language-scala">ReplicatedEventSourcing.commonJournalConfig(
  ReplicationId(&quot;TaggingSpec&quot;, entityId, replica),
  allReplicas,
  queryPluginId)(replicationContext =&gt;
  EventSourcedBehavior[Command, String, State](
    replicationContext.persistenceId,
    State(Set.empty),
    (state, command) =&gt;
      command match {
        case Add(string, ack) =&gt;
          if (state.strings.contains(string)) Effect.none.thenRun(_ =&gt; ack ! Done)
          else Effect.persist(string).thenRun(_ =&gt; ack ! Done)
        case GetStrings(replyTo) =&gt;
          replyTo ! state.strings
          Effect.none
      },
    (state, event) =&gt; state.copy(strings = state.strings + event))
    // use withTagger to define tagging logic
    .withTagger(event =&gt;
      // don&#39;t apply tags if event was replicated here, it already will appear in queries by tag
      // as the origin replica would have tagged it already
      if (replicationContext.origin != replicationContext.replicaId) Set.empty
      else if (event.length &gt; 10) Set(&quot;long-strings&quot;, &quot;strings&quot;)
      else Set(&quot;strings&quot;)))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko/tree/main/persistence-typed-tests/src/test/java/jdocs/org/apache/pekko/persistence/typed/ReplicatedStringSet.java#L81-L93" target="_blank" title="Go to snippet source">source</a><code class="language-java">@Override
public Set&lt;String&gt; tagsFor(String event) {
  // don&#39;t apply tags if event was replicated here, it already will appear in queries by tag
  // as the origin replica would have tagged it already
  if (getReplicationContext().replicaId() != getReplicationContext().origin()) {
    return new HashSet&lt;&gt;();
  } else {
    Set&lt;String&gt; tags = new HashSet&lt;&gt;();
    tags.add(&quot;strings&quot;);
    if (event.length() &gt; 10) tags.add(&quot;long-strings&quot;);
    return tags;
  }
}</code></pre></dd>
</dl>
<p>In this sample we are using a shared journal, and single tag but only tagging local events to it and therefore ending up with a single stream of tagged events from all replicas without duplicates. </p>
<h2><a href="#direct-replication-of-events" name="direct-replication-of-events" class="anchor"><span class="anchor-link"></span></a>Direct Replication of Events</h2>
<p>Each replica will read the events from all the other copies from the database. When used with Cluster Sharding, and to make the sharing of events with other replicas more efficient, each replica publishes the events across the Pekko cluster directly to other replicas. The delivery of events across the cluster is not guaranteed so the query to the journal is still needed but can be configured to poll the database less often since most events will arrive at the replicas through the cluster.</p>
<p>The direct replication of events feature is enabled by default when using Cluster Sharding. To disable this feature you first need to:</p>
<ol>
  <li>disable event publishing <span class="group-scala">on the <code>EventSourcedBehavior</code> with <code>withEventPublishing(false)</code></span><span class="group-java">overriding <code>withEventPublishing</code> from <code>ReplicatedEventSourcedBehavior</code> to return <code>false</code></span> , and then</li>
  <li>disable direct replication through <code>withDirectReplication(false)</code> on <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/cluster/sharding/typed/ReplicatedEntityProvider.html" title="org.apache.pekko.cluster.sharding.typed.ReplicatedEntityProvider"><code>ReplicatedEntityProvider</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/cluster/sharding/typed/ReplicatedEntityProvider.html" title="org.apache.pekko.cluster.sharding.typed.ReplicatedEntityProvider"><code>ReplicatedEntityProvider</code></a></span></li>
</ol>
<p>The &ldquo;event publishing&rdquo; feature publishes each event to the local system event bus as a side effect after it has been written. </p>
<h2><a href="#hot-standby" name="hot-standby" class="anchor"><span class="anchor-link"></span></a>Hot Standby</h2>
<p>If all writes occur to one replica and the other replicas are not started there might be many replicated events to catch up with when they are later started. Therefore it can be good to activate all replicas when there is some activity. </p>
<p>This can be achieved automatically when <code>ReplicatedSharding</code> is used and direct replication of events is enabled as described in <a href="replicated-eventsourcing.html#direct-replication-of-events">Direct Replication of Events</a>. When each written event is forwarded to the other replicas it will trigger them to start if they are not already started.</p>
<h2><a href="#examples" name="examples" class="anchor"><span class="anchor-link"></span></a>Examples</h2>
<p>More examples can be found in <a href="replicated-eventsourcing-examples.html">Replicated Event Sourcing Examples</a></p>
<h2><a href="#journal-support" name="journal-support" class="anchor"><span class="anchor-link"></span></a>Journal Support</h2>
<p>For a journal plugin to support replication it needs to store and read metadata for each event if it is defined in the   <code>metadata</code> field. To attach the metadata after writing it, <code>PersistentRepr.withMetadata</code> is used. The <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/persistence/journal/JournalSpec.html" title="org.apache.pekko.persistence.journal.JournalSpec"><code>JournalSpec</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/persistence/journal/JournalSpec.html" title="org.apache.pekko.persistence.journal.JournalSpec"><code>JournalSpec</code></a></span> in the Persistence TCK provides  a capability flag <code>supportsMetadata</code> to toggle verification that metadata is handled correctly.</p>
<p>For a snapshot plugin to support replication it needs to store and read metadata for the snapshot if it is defined in the  <code>metadata</code> field. To attach the metadata when reading the snapshot the <code>org.apache.pekko.persistence.SnapshotMetadata.apply</code> factory overload taking a <code>metadata</code> parameter is used. The <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/persistence/snapshot/SnapshotStoreSpec.html" title="org.apache.pekko.persistence.snapshot.SnapshotStoreSpec"><code>SnapshotStoreSpec</code></a></span><span class="group-java"><a href="https://pekko.apache.org/api/pekko/0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT/org/apache/pekko/persistence/snapshot/SnapshotStoreSpec.html" title="org.apache.pekko.persistence.snapshot.SnapshotStoreSpec"><code>SnapshotStoreSpec</code></a></span> in the Persistence TCK provides a capability flag <code>supportsMetadata</code> to toggle verification that metadata is handled correctly.</p>
<p>The following plugins support Replicated Event Sourcing:</p>
<ul>
  <li><a href="https://pekko.apache.org/docs/pekko-persistence-cassandra/current/index.html">Pekko Persistence Cassandra</a> versions 1.0.3+</li>
  <li><a href="https://pekko.apache.org/docs/pekko-persistence-spanner/current/overview.html">Pekko Persistence Spanner</a> versions 1.0.0-RC4+</li>
  <li><a href="https://pekko.apache.org/docs/pekko-persistence-jdbc/current">Pekko Persistence JDBC</a> versions 5.0.0+</li>
</ul>
</div>
<div>
<a href="https://github.com/apache/incubator-pekko/tree/main/docs/src/main/paradox/typed/replicated-eventsourcing.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.0.0+26605-0f20b284+20230301-2309*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../typed/persistence.html" title="Event Sourcing" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Event Sourcing
</span>
</div>
</a>
<a href="../typed/cqrs.html" title="CQRS" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
CQRS
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
Copyright Â© 2022, 2023 <a href="https://apache.org">The Apache Software Foundation</a>, Licensed under the Apache License, Version 2.0.
 This product contains significant parts that were originally based on software from Lightbend (<a href="https://akka.io/">Akka</a>).
 Copyright (C) 2009-2022 Lightbend Inc. &lt;https://www.lightbend.com&gt; Apache Pekko is derived from Akka 2.6.x,
 the last version that was distributed under the Apache License, Version 2.0 License.
</div>
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../assets/javascripts/groups.js"></script>

<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
