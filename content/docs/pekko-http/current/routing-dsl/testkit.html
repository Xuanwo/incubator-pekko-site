<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="Apache Pekko Http: Modern, fast, asynchronous, streaming-first HTTP server and client.">
<meta name="generator" content="Paradox, paradox-material-theme=0.6.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="Apache Pekko Http: Modern, fast, asynchronous, streaming-first HTTP server and client.">
<link rel="shortcut icon" href="../assets/images/pekko_favicon.png">
<title>Route TestKit Â· Apache Pekko HTTP</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../assets/stylesheets/application-palette.22915126.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
<link rel="stylesheet" href="../assets/stylesheets/pekko-theme.css">
</head>
<body
data-md-color-primary="white"
data-md-color-accent="orange"
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="Apache Pekko HTTP" class="md-header-nav__button md-logo">
<img src="../assets/images/pekko_logo.png" width="24" height="24">
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Apache Pekko HTTP
</span>
<span class="md-header-nav__topic">
Route TestKit
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/apache/incubator-pekko-http"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko-http
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="Apache Pekko HTTP" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<img src="../assets/images/pekko_logo.png" width="24" height="24">
</a>
<a href="../index.html" title="Apache Pekko HTTP">
Apache Pekko HTTP
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/apache/incubator-pekko-http"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko-http
</div>
</a>

</div>
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
<ul>
  <li><a href="../security.html" class="page">! Security Announcements !</a>
  <ul>
    <li><a href="../security.html#receiving-security-advisories" class="header">Receiving Security Advisories</a></li>
    <li><a href="../security.html#reporting-vulnerabilities" class="header">Reporting Vulnerabilities</a></li>
    <li><a href="../security.html#references" class="header">References</a></li>
  </ul></li>
  <li><a href="../release-notes/index.html" class="page">0. Release Notes</a></li>
  <li><a href="../introduction.html" class="page">1. Introduction</a>
  <ul>
    <li><a href="../introduction.html#philosophy" class="header">Philosophy</a></li>
    <li><a href="../introduction.html#using-apache-pekko-http" class="header">Using Apache Pekko HTTP</a></li>
    <li><a href="../introduction.html#routing-dsl-for-http-servers" class="header">Routing DSL for HTTP servers</a></li>
    <li><a href="../introduction.html#marshalling" class="header">Marshalling</a></li>
    <li><a href="../introduction.html#streaming" class="header">Streaming</a></li>
    <li><a href="../introduction.html#low-level-http-server-apis" class="header">Low-level HTTP server APIs</a></li>
    <li><a href="../introduction.html#http-client-api" class="header">HTTP Client API</a></li>
    <li><a href="../introduction.html#the-modules-that-make-up-apache-pekko-http" class="header">The modules that make up Apache Pekko HTTP</a></li>
  </ul></li>
  <li><a href="../usage.html" class="page">2. Usage</a>
  <ul>
    <li><a href="../configuration.html" class="page">Configuration</a></li>
    <li><a href="../migration-guide/index.html" class="page">Migration Guides</a></li>
    <li><a href="../compatibility-guidelines.html" class="page">Compatibility Guidelines</a></li>
  </ul></li>
  <li><a href="../common/index.html" class="page">3. Data Types &amp; Abstractions</a>
  <ul>
    <li><a href="../common/http-model.html" class="page">HTTP Model</a></li>
    <li><a href="../common/uri-model.html" class="page">The URI model</a></li>
    <li><a href="../common/marshalling.html" class="page">Marshalling</a></li>
    <li><a href="../common/unmarshalling.html" class="page">Unmarshalling</a></li>
    <li><a href="../common/encoding.html" class="page">Encoding / Decoding</a></li>
    <li><a href="../common/json-support.html" class="page">JSON Support</a></li>
    <li><a href="../common/xml-support.html" class="page">XML Support</a></li>
    <li><a href="../common/sse-support.html" class="page">Server-Sent Events Support</a></li>
    <li><a href="../common/timeouts.html" class="page">Timeouts</a></li>
    <li><a href="../common/caching.html" class="page">Caching</a></li>
  </ul></li>
  <li><a href="../server-side/index.html" class="page">4. Server API</a>
  <ul>
    <li><a href="../routing-dsl/index.html" class="page">Routing DSL</a></li>
    <li><a href="../server-side/low-level-api.html" class="page">Core Server API</a></li>
    <li><a href="../server-side/websocket-support.html" class="page">Server WebSocket Support</a></li>
    <li><a href="../server-side/server-https-support.html" class="page">Server HTTPS Support</a></li>
    <li><a href="../server-side/graceful-termination.html" class="page">Graceful termination</a></li>
    <li><a href="../server-side/http2.html" class="page">Server-Side HTTP/2 (Preview)</a></li>
  </ul></li>
  <li><a href="../client-side/index.html" class="page">5. Client API</a>
  <ul>
    <li><a href="../client-side/configuration.html" class="page">Configuration</a></li>
    <li><a href="../client-side/request-and-response.html" class="page">HttpRequest and HttpResponse</a></li>
    <li><a href="../client-side/request-level.html" class="page">Request-Level Client-Side API</a></li>
    <li><a href="../client-side/host-level.html" class="page">Host-Level Client-Side API</a></li>
    <li><a href="../client-side/connection-level.html" class="page">Connection-Level Client-Side API</a></li>
    <li><a href="../client-side/pool-overflow.html" class="page">Pool overflow and the max-open-requests setting</a></li>
    <li><a href="../client-side/client-https-support.html" class="page">Client-Side HTTPS Support</a></li>
    <li><a href="../client-side/client-transport.html" class="page">Pluggable Client Transports / HTTP(S) proxy Support</a></li>
    <li><a href="../client-side/websocket-support.html" class="page">Client-Side WebSocket Support</a></li>
    <li><a href="../client-side/http2.html" class="page">Client-Side HTTP/2 (Preview)</a></li>
  </ul></li>
  <li><a href="../extensions.html" class="page">6. Extensions</a></li>
  <li><a href="../technologies.html" class="page">7. Supported Technologies</a>
  <ul>
    <li><a href="../technologies.html#http" class="header">HTTP</a></li>
    <li><a href="../technologies.html#https" class="header">HTTPS</a></li>
    <li><a href="../technologies.html#websocket" class="header">WebSocket</a></li>
    <li><a href="../technologies.html#http-2" class="header">HTTP/2</a></li>
    <li><a href="../technologies.html#dns" class="header">DNS</a></li>
    <li><a href="../technologies.html#multipart" class="header">Multipart</a></li>
    <li><a href="../technologies.html#server-sent-events-sse-" class="header">Server-sent Events (SSE)</a></li>
    <li><a href="../technologies.html#json" class="header">JSON</a></li>
    <li><a href="../technologies.html#xml" class="header">XML</a></li>
    <li><a href="../technologies.html#gzip-and-deflate-content-encoding" class="header">Gzip and Deflate Content-Encoding</a></li>
  </ul></li>
  <li><a href="../tipsandtricks.html" class="page">8. Tips And Tricks</a>
  <ul>
    <li><a href="../troubleshooting/index.html" class="page">Troubleshooting</a></li>
    <li><a href="../handling-blocking-operations-in-pekko-http-routes.html" class="page">Handling blocking operations in Apache Pekko HTTP</a></li>
    <li><a href="../implications-of-streaming-http-entity.html" class="page">Implications of the streaming nature of Request/Response Entities</a></li>
  </ul></li>
  <li><a href="../contributing.html" class="page">9. Contributing</a>
  <ul>
    <li><a href="../contributing.html#welcome-" class="header">Welcome!</a></li>
    <li><a href="../contributing.html#snapshots" class="header">Snapshots</a></li>
  </ul></li>
  <li><a href="../reference.html" class="page">10. Reference</a>
  <ul>
    <li><a href="../reference.html#api-documentation" class="header">API Documentation</a></li>
    <li><a href="../reference.html#directives" class="header">Directives</a></li>
    <li><a href="../reference.html#books" class="header">Books</a></li>
  </ul></li>
</ul>

<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../routing-dsl/testkit.html#route-testkit" class="header">Route TestKit</a>
  <ul>
    <li><a href="../routing-dsl/testkit.html#dependency" class="header">Dependency</a></li>
    <li><a href="../routing-dsl/testkit.html#usage" class="header">Usage</a></li>
    <li><a href="../routing-dsl/testkit.html#example" class="header group-java">Example</a></li>
    <li><a href="../routing-dsl/testkit.html#writing-asserting-against-the-httpresponse" class="header group-java">Writing Asserting against the HttpResponse</a></li>
    <li><a href="../routing-dsl/testkit.html#supporting-custom-test-frameworks" class="header group-java">Supporting Custom Test Frameworks</a></li>
    <li><a href="../routing-dsl/testkit.html#testing-sealed-routes" class="header">Testing sealed Routes</a></li>
    <li><a href="../routing-dsl/testkit.html#testing-route-fragments" class="header">Testing Route fragments</a></li>
    <li><a href="../routing-dsl/testkit.html#accounting-for-slow-test-systems" class="header">Accounting for Slow Test Systems</a></li>
    <li><a href="../routing-dsl/testkit.html#increase-timeout" class="header">Increase Timeout</a></li>
    <li><a href="../routing-dsl/testkit.html#testing-actor-integration" class="header">Testing Actor integration</a></li>
    <li><a href="../routing-dsl/testkit.html#integration-testing-routes" class="header">Integration Testing Routes</a></li>
    <li><a href="../routing-dsl/testkit.html#examples" class="header">Examples</a></li>
  </ul></li>
</ul>
</nav>


<ul class="md-nav__list md-nav__links">
<li class="md-nav__item"><a href="https://apache.org"><i class="md-icon">link</i> Apache Software Foundation</a></li>
<li class="md-nav__item"><a href="https://apache.org/licenses/"><i class="md-icon">link</i>&nbsp;License</a></li>
<li class="md-nav__item"><a href="https://apache.org/security/"><i class="md-icon">link</i>&nbsp;Security</a></li>
<li class="md-nav__item"><a href="https://www.apache.org/foundation/sponsorship.html"><i class="md-icon">link</i>&nbsp;Donate</a></li>
<li class="md-nav__item"><a href="https://www.apache.org/foundation/thanks.html"><i class="md-icon">link</i>&nbsp;Thanks</a></li>
</ul>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 0.0.0+4308-98f0ff9c*
</label>
</li>
</ul>

</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../routing-dsl/testkit.html#route-testkit" class="header">Route TestKit</a>
  <ul>
    <li><a href="../routing-dsl/testkit.html#dependency" class="header">Dependency</a></li>
    <li><a href="../routing-dsl/testkit.html#usage" class="header">Usage</a></li>
    <li><a href="../routing-dsl/testkit.html#example" class="header group-java">Example</a></li>
    <li><a href="../routing-dsl/testkit.html#writing-asserting-against-the-httpresponse" class="header group-java">Writing Asserting against the HttpResponse</a></li>
    <li><a href="../routing-dsl/testkit.html#supporting-custom-test-frameworks" class="header group-java">Supporting Custom Test Frameworks</a></li>
    <li><a href="../routing-dsl/testkit.html#testing-sealed-routes" class="header">Testing sealed Routes</a></li>
    <li><a href="../routing-dsl/testkit.html#testing-route-fragments" class="header">Testing Route fragments</a></li>
    <li><a href="../routing-dsl/testkit.html#accounting-for-slow-test-systems" class="header">Accounting for Slow Test Systems</a></li>
    <li><a href="../routing-dsl/testkit.html#increase-timeout" class="header">Increase Timeout</a></li>
    <li><a href="../routing-dsl/testkit.html#testing-actor-integration" class="header">Testing Actor integration</a></li>
    <li><a href="../routing-dsl/testkit.html#integration-testing-routes" class="header">Integration Testing Routes</a></li>
    <li><a href="../routing-dsl/testkit.html#examples" class="header">Examples</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#route-testkit" name="route-testkit" class="anchor"><span class="anchor-link"></span></a>Route TestKit</h1>
<p>One of Apache Pekko HTTP&rsquo;s design goals is good testability of the created services. For services built with the Routing DSL Apache Pekko HTTP provides a dedicated testkit that makes efficient testing of route logic easy and convenient. This &ldquo;route test DSL&rdquo; is made available with the <em>pekko-http-testkit</em> module.</p>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>To use Apache Pekko HTTP TestKit, add the module to your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">val PekkoVersion = "0.0.0+26602-317cbb52-SNAPSHOT"
val PekkoHttpVersion = "0.0.0+4308-98f0ff9c-SNAPSHOT"
libraryDependencies ++= Seq(
  "org.apache.pekko" %% "pekko-stream-testkit" % PekkoVersion,
  "org.apache.pekko" %% "pekko-http-testkit" % PekkoHttpVersion
)</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">def versions = [
  PekkoVersion: "0.0.0+26602-317cbb52-SNAPSHOT",
  ScalaBinary: "2.13"
]
dependencies {
  implementation platform("org.apache.pekko:pekko-http-bom_${versions.ScalaBinary}:0.0.0+4308-98f0ff9c-SNAPSHOT")

  implementation "org.apache.pekko:pekko-stream-testkit_${versions.ScalaBinary}:${versions.PekkoVersion}"
  implementation "org.apache.pekko:pekko-http-testkit_${versions.ScalaBinary}"
}</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;properties&gt;
  &lt;pekko.version&gt;0.0.0+26602-317cbb52-SNAPSHOT&lt;/pekko.version&gt;
  &lt;scala.binary.version&gt;2.13&lt;/scala.binary.version&gt;
&lt;/properties&gt;
&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
      &lt;artifactId&gt;pekko-http-bom_${scala.binary.version}&lt;/artifactId&gt;
      &lt;version&gt;0.0.0+4308-98f0ff9c-SNAPSHOT&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
    &lt;artifactId&gt;pekko-stream-testkit_${scala.binary.version}&lt;/artifactId&gt;
    &lt;version&gt;${pekko.version}&lt;/version&gt;
  &lt;/dependency&gt
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
    &lt;artifactId&gt;pekko-http-testkit_${scala.binary.version}&lt;/artifactId&gt;
  &lt;/dependency&gt
&lt;/dependencies&gt;</code></pre></dd></dl>
<h2><a href="#usage" name="usage" class="anchor"><span class="anchor-link"></span></a>Usage</h2><div class="group-scala">
<p>Here is an example of what a simple test with the routing testkit might look like using the built-in support for <a href="http://www.scalatest.org">scalatest</a> and <a href="http://etorreborre.github.io/specs2/">specs2</a>:</p>
<dl>
  <dt>ScalaTest</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/server/FullTestKitExampleSpec.scala#L17-L71" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko
import pekko.http.scaladsl.model.StatusCodes
import pekko.http.scaladsl.testkit.ScalatestRouteTest
import pekko.http.scaladsl.server._
import Directives._
import org.scalatest.matchers.should.Matchers
import org.scalatest.wordspec.AnyWordSpec

class FullTestKitExampleSpec extends AnyWordSpec with Matchers with ScalatestRouteTest {

  val smallRoute =
    get {
      concat(
        pathSingleSlash {
          complete {
            &quot;Captain on the bridge!&quot;
          }
        },
        path(&quot;ping&quot;) {
          complete(&quot;PONG!&quot;)
        })
    }

  &quot;The service&quot; should {

    &quot;return a greeting for GET requests to the root path&quot; in {
      // tests:
      Get() ~&gt; smallRoute ~&gt; check {
        responseAs[String] shouldEqual &quot;Captain on the bridge!&quot;
      }
    }

    &quot;return a &#39;PONG!&#39; response for GET requests to /ping&quot; in {
      // tests:
      Get(&quot;/ping&quot;) ~&gt; smallRoute ~&gt; check {
        responseAs[String] shouldEqual &quot;PONG!&quot;
      }
    }

    &quot;leave GET requests to other paths unhandled&quot; in {
      // tests:
      Get(&quot;/kermit&quot;) ~&gt; smallRoute ~&gt; check {
        handled shouldBe false
      }
    }

    &quot;return a MethodNotAllowed error for PUT requests to the root path&quot; in {
      // tests:
      Put() ~&gt; Route.seal(smallRoute) ~&gt; check {
        status shouldEqual StatusCodes.MethodNotAllowed
        responseAs[String] shouldEqual &quot;HTTP method not allowed, supported methods: GET&quot;
      }
    }
  }
}</code></pre></dd>
  <dt>specs2</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/server/FullSpecs2TestKitExampleSpec.scala#L17-L70" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.specs2.mutable.Specification
import org.apache.pekko
import pekko.http.scaladsl.model.StatusCodes
import pekko.http.scaladsl.testkit.Specs2RouteTest
import pekko.http.scaladsl.server._
import Directives._

class FullSpecs2TestKitExampleSpec extends Specification with Specs2RouteTest {

  val smallRoute =
    get {
      concat(
        pathSingleSlash {
          complete {
            &quot;Captain on the bridge!&quot;
          }
        },
        path(&quot;ping&quot;) {
          complete(&quot;PONG!&quot;)
        })
    }

  &quot;The service&quot; should {

    &quot;return a greeting for GET requests to the root path&quot; in {
      // tests:
      Get() ~&gt; smallRoute ~&gt; check {
        responseAs[String] shouldEqual &quot;Captain on the bridge!&quot;
      }
    }

    &quot;return a &#39;PONG!&#39; response for GET requests to /ping&quot; in {
      // tests:
      Get(&quot;/ping&quot;) ~&gt; smallRoute ~&gt; check {
        responseAs[String] shouldEqual &quot;PONG!&quot;
      }
    }

    &quot;leave GET requests to other paths unhandled&quot; in {
      // tests:
      Get(&quot;/kermit&quot;) ~&gt; smallRoute ~&gt; check {
        handled should beFalse
      }
    }

    &quot;return a MethodNotAllowed error for PUT requests to the root path&quot; in {
      // tests:
      Put() ~&gt; Route.seal(smallRoute) ~&gt; check {
        status shouldEqual StatusCodes.MethodNotAllowed
        responseAs[String] shouldEqual &quot;HTTP method not allowed, supported methods: GET&quot;
      }
    }
  }
}</code></pre></dd>
</dl>
<p>The basic structure of a test built with the testkit is this (expression placeholder in all-caps):</p>
<pre><code>REQUEST ~&gt; ROUTE ~&gt; check {
  ASSERTIONS
}
</code></pre>
<p>In this template <em>REQUEST</em> is an expression evaluating to an <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/model/HttpRequest.html" title="org.apache.pekko.http.javadsl.model.HttpRequest"><code>HttpRequest</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/model/HttpRequest.html" title="org.apache.pekko.http.scaladsl.model.HttpRequest"><code>HttpRequest</code></a></span> instance. In most cases your test will, in one way or another, extend from <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/testkit/RouteTest.html" title="org.apache.pekko.http.javadsl.testkit.RouteTest"><code>RouteTest</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/testkit/RouteTest.html" title="org.apache.pekko.http.scaladsl.testkit.RouteTest"><code>RouteTest</code></a></span> which itself mixes in the <code>org.apache.pekko.http.scaladsl.client.RequestBuilding</code> trait, which gives you a concise and convenient way of constructing test requests. <a id="^1" href="#1">[1]</a></p>
<p><em>ROUTE</em> is an expression evaluating to a <a href="routes.html">Route</a>. You can specify one inline or simply refer to the route structure defined in your service.</p>
<p>The final element of the <code>~&gt;</code> chain is a <code>check</code> call, which takes a block of assertions as parameter. In this block you define your requirements onto the result produced by your route after having processed the given request. Typically you use one of the defined &ldquo;inspectors&rdquo; to retrieve a particular element of the routes response and express assertions against it using the test DSL provided by your test framework. For example, with <a href="http://www.scalatest.org">scalatest</a>, in order to verify that your route responds to the request with a status 200 response, you&rsquo;d use the <code>status</code> inspector and express an assertion like this:</p>
<pre class="prettyprint"><code class="language-scala">status shouldEqual 200
</code></pre>
<p>The following inspectors are defined:</p>
<h3><a href="#table-of-inspectors" name="table-of-inspectors" class="anchor"><span class="anchor-link"></span></a>Table of Inspectors</h3>
<table>
  <thead>
    <tr>
      <th>Inspector </th>
      <th>Description </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>charset: HttpCharset</code> </td>
      <td>Identical to <code>contentType.charset</code> </td>
    </tr>
    <tr>
      <td><code>chunks: Seq[HttpEntity.ChunkStreamPart]</code> </td>
      <td>Returns the entity chunks produced by the route. If the entity is not <code>chunked</code> returns <code>Nil</code>. </td>
    </tr>
    <tr>
      <td><code>closingExtension: String</code> </td>
      <td>Returns chunk extensions the route produced with its last response chunk. If the response entity is unchunked returns the empty string. </td>
    </tr>
    <tr>
      <td><code>contentType: ContentType</code> </td>
      <td>Identical to <code>responseEntity.contentType</code> </td>
    </tr>
    <tr>
      <td><code>definedCharset: Option[HttpCharset]</code> </td>
      <td>Identical to <code>contentType.definedCharset</code> </td>
    </tr>
    <tr>
      <td><code>entityAs[T :FromEntityUnmarshaller]: T</code> </td>
      <td>Unmarshals the response entity using the in-scope <code>FromEntityUnmarshaller</code> for the given type. Any errors in the process trigger a test failure. </td>
    </tr>
    <tr>
      <td><code>handled: Boolean</code> </td>
      <td>Indicates whether the route produced an <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/model/HttpResponse.html" title="org.apache.pekko.http.javadsl.model.HttpResponse"><code>HttpResponse</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/model/HttpResponse.html" title="org.apache.pekko.http.scaladsl.model.HttpResponse"><code>HttpResponse</code></a></span> for the request. If the route rejected the request <code>handled</code> evaluates to <code>false</code>. </td>
    </tr>
    <tr>
      <td><code>header(name: String): Option[HttpHeader]</code> </td>
      <td>Returns the response header with the given name or <code>None</code> if no such header is present in the response. </td>
    </tr>
    <tr>
      <td><code>header[T &lt;: HttpHeader]: Option[T]</code> </td>
      <td>Identical to <code>response.header[T]</code> </td>
    </tr>
    <tr>
      <td><code>headers: Seq[HttpHeader]</code> </td>
      <td>Identical to <code>response.headers</code> </td>
    </tr>
    <tr>
      <td><code>mediaType: MediaType</code> </td>
      <td>Identical to <code>contentType.mediaType</code> </td>
    </tr>
    <tr>
      <td><code>rejection: Rejection</code> </td>
      <td>The rejection produced by the route. If the route did not produce exactly one rejection a test failure is triggered. </td>
    </tr>
    <tr>
      <td><code>rejections: Seq[Rejection]</code> </td>
      <td>The rejections produced by the route. If the route did not reject the request a test failure is triggered. </td>
    </tr>
    <tr>
      <td><code>response: HttpResponse</code> </td>
      <td>The <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/model/HttpResponse.html" title="org.apache.pekko.http.javadsl.model.HttpResponse"><code>HttpResponse</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/model/HttpResponse.html" title="org.apache.pekko.http.scaladsl.model.HttpResponse"><code>HttpResponse</code></a></span> returned by the route. If the route did not return an <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/model/HttpResponse.html" title="org.apache.pekko.http.javadsl.model.HttpResponse"><code>HttpResponse</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/model/HttpResponse.html" title="org.apache.pekko.http.scaladsl.model.HttpResponse"><code>HttpResponse</code></a></span> instance (e.g. because it rejected the request) a test failure is triggered.</td>
    </tr>
    <tr>
      <td><code>responseAs[T: FromResponseUnmarshaller]: T</code> </td>
      <td>Unmarshals the response entity using the in-scope <code>FromResponseUnmarshaller</code> for the given type. Any errors in the process trigger a test failure. </td>
    </tr>
    <tr>
      <td><code>responseEntity: HttpEntity</code> </td>
      <td>Returns the response entity. </td>
    </tr>
    <tr>
      <td><code>status: StatusCode</code> </td>
      <td>Identical to <code>response.status</code> </td>
    </tr>
    <tr>
      <td><code>trailer: Seq[HttpHeader]</code> </td>
      <td>Returns the list of trailer headers the route produced with its last chunk. If the response entity is unchunked returns <code>Nil</code>. </td>
    </tr>
  </tbody>
</table>
<blockquote>
  <p><a id="1" href="#^1">[1]</a> If the request URI is relative it will be made absolute using an implicitly available instance of <code>DefaultHostInfo</code> whose value is &ldquo;<a href="http://example.com">http://example.com</a>&rdquo; by default. This mirrors the behavior of pekko-http-core which always produces absolute URIs for incoming request based on the request URI and the <code>Host</code>-header of the request. You can customize this behavior by bringing a custom instance of <code>DefaultHostInfo</code> into scope.</p>
</blockquote></div><div class="group-java">
<p>To use the testkit you need to take these steps:</p>
<ul>
  <li>add a dependency to the <code>pekko-http-testkit</code> module</li>
  <li>derive the test class from <code>JUnitRouteTest</code></li>
  <li>wrap the route under test with <code>RouteTest.testRoute</code> to create a <code>TestRoute</code></li>
  <li>run requests against the route using <code>TestRoute.run(request)</code> which will return a <code>TestResponse</code></li>
  <li>use the methods of <code>TestResponse</code> to assert on properties of the response</li>
</ul>
<h2><a href="#example" name="example" class="anchor"><span class="anchor-link"></span></a>Example</h2>
<p>To see the testkit in action consider the following simple calculator app service:</p>
<dl>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/server/testkit/MyAppService.java#L17-L58" target="_blank" title="Go to snippet source">source</a><code class="language-java"><br/>import org.apache.pekko.actor.ActorSystem;
import org.apache.pekko.http.javadsl.Http;
import org.apache.pekko.http.javadsl.server.AllDirectives;
import org.apache.pekko.http.javadsl.server.Route;
import org.apache.pekko.http.javadsl.server.examples.simple.SimpleServerApp;
import org.apache.pekko.http.javadsl.unmarshalling.StringUnmarshallers;

import java.io.IOException;

public class MyAppService extends AllDirectives {

  public String add(double x, double y) {
    return &quot;x + y = &quot; + (x + y);
  }

  public Route createRoute() {
    return
      get(() -&gt;
        pathPrefix(&quot;calculator&quot;, () -&gt;
          path(&quot;add&quot;, () -&gt;
            parameter(StringUnmarshallers.DOUBLE, &quot;x&quot;, x -&gt;
              parameter(StringUnmarshallers.DOUBLE, &quot;y&quot;, y -&gt;
                complete(add(x, y))
              )
            )
          )
        )
      );
  }

  public static void main(String[] args) throws IOException {
    final ActorSystem system = ActorSystem.create();

    final SimpleServerApp app = new SimpleServerApp();

    Http.get(system).newServerAt(&quot;127.0.0.1&quot;, 8080).bind(app.createRoute());

    System.console().readLine(&quot;Type RETURN to exit...&quot;);
    system.terminate();
  }
}</code></pre></dd>
</dl>
<p><code>MyAppService</code> extends from <code>AllDirectives</code> which brings all of the directives into scope. We define a method called <code>createRoute</code> that provides the routes to serve to <code>bind</code>.</p>
<p>Here&rsquo;s how you would test that service:</p>
<dl>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/server/testkit/TestkitExampleTest.java#L17-L44" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.http.javadsl.model.HttpRequest;
import org.apache.pekko.http.javadsl.model.StatusCodes;
import org.apache.pekko.http.javadsl.testkit.JUnitRouteTest;
import org.apache.pekko.http.javadsl.testkit.TestRoute;
import org.junit.Test;

public class TestkitExampleTest extends JUnitRouteTest {
    TestRoute appRoute = testRoute(new MyAppService().createRoute());

    @Test
    public void testCalculatorAdd() {
        // test happy path
        appRoute.run(HttpRequest.GET(&quot;/calculator/add?x=4.2&amp;y=2.3&quot;))
            .assertStatusCode(200)
            .assertEntity(&quot;x + y = 6.5&quot;);

        // test responses to potential errors
        appRoute.run(HttpRequest.GET(&quot;/calculator/add?x=3.2&quot;))
            .assertStatusCode(StatusCodes.NOT_FOUND) // 404
            .assertEntity(&quot;Request is missing required query parameter &#39;y&#39;&quot;);

        // test responses to potential errors
        appRoute.run(HttpRequest.GET(&quot;/calculator/add?x=3.2&amp;y=three&quot;))
            .assertStatusCode(StatusCodes.BAD_REQUEST)
            .assertEntity(&quot;The query parameter &#39;y&#39; was malformed:\n&quot; +
                    &quot;&#39;three&#39; is not a valid 64-bit floating point value&quot;);
    }
}</code></pre></dd>
</dl>
<h2><a href="#writing-asserting-against-the-httpresponse" name="writing-asserting-against-the-httpresponse" class="anchor"><span class="anchor-link"></span></a>Writing Asserting against the HttpResponse</h2>
<p>The testkit supports a fluent DSL to write compact assertions on the response by chaining assertions using &ldquo;dot-syntax&rdquo;. To simplify working with streamed responses the entity of the response is first &ldquo;strictified&rdquo;, i.e. entity data is collected into a single <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0/org/apache/pekko/util/ByteString.html" title="org.apache.pekko.util.ByteString"><code>ByteString</code></a></span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/0.0/org/apache/pekko/util/ByteString.html" title="org.apache.pekko.util.ByteString"><code>ByteString</code></a></span> and provided the entity is supplied as an <code>HttpEntityStrict</code>. This allows to write several assertions against the same entity data which wouldn&rsquo;t (necessarily) be possible for the streamed version.</p>
<p>All of the defined assertions provide HTTP specific error messages aiding in diagnosing problems.</p>
<p>Currently, these methods are defined on <code>TestResponse</code> to assert on the response:</p>
<table>
  <thead>
    <tr>
      <th>Inspector </th>
      <th>Description </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>assertStatusCode(int expectedCode)</code> </td>
      <td>Asserts that the numeric response status code equals the expected one </td>
    </tr>
    <tr>
      <td><code>assertStatusCode(StatusCode expectedCode)</code> </td>
      <td>Asserts that the response <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/model/StatusCode.html" title="org.apache.pekko.http.javadsl.model.StatusCode"><code>StatusCode</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/model/StatusCode.html" title="org.apache.pekko.http.scaladsl.model.StatusCode"><code>StatusCode</code></a></span> equals the expected one </td>
    </tr>
    <tr>
      <td><code>assertMediaType(String expectedType)</code> </td>
      <td>Asserts that the media type part of the response&rsquo;s content type matches the given String </td>
    </tr>
    <tr>
      <td><code>assertMediaType(MediaType expectedType)</code> </td>
      <td>Asserts that the media type part of the response&rsquo;s content type matches the given <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/model/MediaType.html" title="org.apache.pekko.http.javadsl.model.MediaType"><code>MediaType</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/model/MediaType.html" title="org.apache.pekko.http.scaladsl.model.MediaType"><code>MediaType</code></a></span> </td>
    </tr>
    <tr>
      <td><code>assertEntity(String expectedStringContent)</code> </td>
      <td>Asserts that the entity data interpreted as UTF8 equals the expected String </td>
    </tr>
    <tr>
      <td><code>assertEntityBytes(ByteString expectedBytes)</code> </td>
      <td>Asserts that the entity data bytes equal the expected ones </td>
    </tr>
    <tr>
      <td><code>assertEntityAs(Unmarshaller&lt;T&gt; unmarshaller, expectedValue: T)</code> </td>
      <td>Asserts that the entity data if unmarshalled with the given marshaller equals the given value </td>
    </tr>
    <tr>
      <td><code>assertHeaderExists(HttpHeader expectedHeader)</code> </td>
      <td>Asserts that the response contains an HttpHeader instance equal to the expected one </td>
    </tr>
    <tr>
      <td><code>assertHeaderKindExists(String expectedHeaderName)</code> </td>
      <td>Asserts that the response contains a header with the expected name </td>
    </tr>
    <tr>
      <td><code>assertHeader(String name, String expectedValue)</code> </td>
      <td>Asserts that the response contains a header with the given name and value. </td>
    </tr>
  </tbody>
</table>
<p>It&rsquo;s, of course, possible to use any other means of writing assertions by inspecting the properties the response manually. As written above, <code>TestResponse.entity</code> and <code>TestResponse.response</code> return strict versions of the entity data.</p>
<h2><a href="#supporting-custom-test-frameworks" name="supporting-custom-test-frameworks" class="anchor"><span class="anchor-link"></span></a>Supporting Custom Test Frameworks</h2>
<p>Adding support for a custom test framework is achieved by creating new superclass analogous to <code>JUnitRouteTest</code> for writing tests with the custom test framework deriving from <code>org.apache.pekko.http.javadsl.testkit.RouteTest</code> and implementing its abstract methods. This will allow users of the test framework to use <code>testRoute</code> and to write assertions using the assertion methods defined on <code>TestResponse</code>.</p></div>
<h2><a href="#testing-sealed-routes" name="testing-sealed-routes" class="anchor"><span class="anchor-link"></span></a>Testing sealed Routes</h2>
<p>The section above describes how to test a &ldquo;regular&rdquo; branch of your route structure, which reacts to incoming requests with HTTP response parts or rejections. Sometimes, however, you will want to verify that your service also translates <a href="rejections.html">Rejections</a> to HTTP responses in the way you expect.</p>
<p>You do this by calling the <code>Route.seal()</code> method. The <code>Route.seal()</code> method applies the logic of the <span class="group-scala">in-scope</span> <a href="exception-handling.html">ExceptionHandler</a> and <a href="rejections.html#the-rejectionhandler">RejectionHandler</a> <span class="group-java">passed as method arguments</span> to all exceptions and rejections coming back from the route, and translates them to the respective <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/model/HttpResponse.html" title="org.apache.pekko.http.javadsl.model.HttpResponse"><code>HttpResponse</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/model/HttpResponse.html" title="org.apache.pekko.http.scaladsl.model.HttpResponse"><code>HttpResponse</code></a></span>.</p>
<p>Note that explicit call on the <code>Route.seal</code> method is needed in test code, but in your application code it is not necessary. As described in <a href="routes.html#sealing-a-route">Sealing a Route</a>, your application code only needs to bring implicit rejection and exception handlers in scope.</p>
<h2><a href="#testing-route-fragments" name="testing-route-fragments" class="anchor"><span class="anchor-link"></span></a>Testing Route fragments</h2>
<p>Since the testkit is request-based, you cannot test requests that are illegal or impossible in HTTP. One such instance is testing a route that begins with the <code>pathEnd</code> directive, such as <code>routeFragment</code> here:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/server/TestKitFragmentSpec.scala#L31-L37" target="_blank" title="Go to snippet source">source</a><code class="language-scala">pathEnd {
  get {
    complete {
      &quot;Fragments of imagination&quot;
    }
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/server/testkit/MyAppFragment.java#L24-L28" target="_blank" title="Go to snippet source">source</a><code class="language-java">pathEnd(() -&gt;
        get(() -&gt;
                complete(&quot;Fragments of imagination&quot;)
        )
);</code></pre></dd>
</dl>
<p>You might create a route such as this to be able to compose it into another route such as:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/server/FragmentExample.scala#L17-L33" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko
import pekko.http.scaladsl.server.Directives._
import pekko.http.scaladsl.server.Route

object RouteFragment {
  val route: Route = pathEnd {
    get {
      complete(&quot;example&quot;)
    }
  }
}

object API {
  pathPrefix(&quot;version&quot;) {
    RouteFragment.route
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/server/testkit/MyAppFragment.java#L16-L32" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.http.javadsl.server.AllDirectives;
import org.apache.pekko.http.javadsl.server.Route;

public class MyAppFragment extends AllDirectives {

    public Route createRoute() {
        return
                pathEnd(() -&gt;
                        get(() -&gt;
                                complete(&quot;Fragments of imagination&quot;)
                        )
                );
    }

}</code></pre></dd>
</dl>
<p>However, it is impossible to unit test this Route directly using testkit, since it is impossible to create an empty HTTP request. To test this type of route, embed it in a synthetic route in your test, such as <code>testRoute</code> in the example above.</p>
<p>This is what the full working test looks like:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/server/TestKitFragmentSpec.scala#L19-L62" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko
import pekko.http.scaladsl.model.StatusCodes
import pekko.http.scaladsl.testkit.ScalatestRouteTest
import pekko.http.scaladsl.server._
import Directives._
import org.scalatest.matchers.should.Matchers
import org.scalatest.wordspec.AnyWordSpec

class TestKitFragmentSpec extends AnyWordSpec with Matchers with ScalatestRouteTest {

  val routeFragment =
      pathEnd {
        get {
          complete {
            &quot;Fragments of imagination&quot;
          }
        }
      }

  // Synthetic route to enable pathEnd testing
  val testRoute = {
    pathPrefix(&quot;test&quot;) {
      routeFragment
    }
  }

  &quot;The service&quot; should {
    &quot;return a greeting for GET requests&quot; in {
      // tests:
      Get(&quot;/test&quot;) ~&gt; testRoute ~&gt; check {
        responseAs[String] shouldEqual &quot;Fragments of imagination&quot;
      }
    }

    &quot;return a MethodNotAllowed error for PUT requests to the root path&quot; in {
      // tests:
      Put(&quot;/test&quot;) ~&gt; Route.seal(testRoute) ~&gt; check {
        status shouldEqual StatusCodes.MethodNotAllowed
      }
    }
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/server/testkit/TestKitFragmentTest.java#L17-L47" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.http.javadsl.model.HttpRequest;
import org.apache.pekko.http.javadsl.model.StatusCodes;
import org.apache.pekko.http.javadsl.server.AllDirectives;
import org.apache.pekko.http.javadsl.server.Route;
import org.apache.pekko.http.javadsl.testkit.JUnitRouteTest;
import org.apache.pekko.http.javadsl.testkit.TestRoute;
import org.junit.Test;

public class TestKitFragmentTest extends JUnitRouteTest {
    class FragmentTester extends AllDirectives {
        public Route createRoute(Route fragment) {
            return
                    pathPrefix(&quot;test&quot;, () -&gt;
                            fragment
                    );
        }
    }

    TestRoute fragment = testRoute(new MyAppFragment().createRoute());
    TestRoute testRoute = testRoute(new FragmentTester().createRoute(fragment.underlying()));

    @Test
    public void testFragment() {
        testRoute.run(HttpRequest.GET(&quot;/test&quot;))
                .assertStatusCode(200)
                .assertEntity(&quot;Fragments of imagination&quot;);

        testRoute.run(HttpRequest.PUT(&quot;/test&quot;))
                .assertStatusCode(StatusCodes.METHOD_NOT_ALLOWED);
    }
}</code></pre></dd>
</dl>
<h2><a href="#accounting-for-slow-test-systems" name="accounting-for-slow-test-systems" class="anchor"><span class="anchor-link"></span></a>Accounting for Slow Test Systems</h2>
<p>The timeouts you consciously defined on your lightning fast development environment might be too tight for your, most probably, high-loaded Continuous Integration server, invariably causing spurious failures. To account for such situations, timeout durations can be scaled by a given factor on such environments. Check the <a href="https://pekko.apache.org/docs/pekko/current/testing.html#accounting-for-slow-test-systems">Apache Pekko Docs</a> for further information.</p>
<h2><a href="#increase-timeout" name="increase-timeout" class="anchor"><span class="anchor-link"></span></a>Increase Timeout</h2>
<p>The default timeout when testing your routes using the testkit is <span class="group-scala">1 second</span><span class="group-java">3 seconds</span> second. Sometimes, though, this might not be enough. In order to extend this default timeout, to say 5 seconds, just add the following implicit in scope:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/server/TestKitFragmentSpec.scala#L67-L71" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import scala.concurrent.duration._
import pekko.http.scaladsl.testkit.RouteTestTimeout
import pekko.testkit.TestDuration

implicit val timeout = RouteTestTimeout(5.seconds.dilated)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/server/testkit/WithTimeoutTest.java#L24-L27" target="_blank" title="Go to snippet source">source</a><code class="language-java">@Override
public FiniteDuration awaitDuration() {
    return FiniteDuration.create(5, TimeUnit.SECONDS);
}</code></pre></dd>
</dl>
<p>Remember to configure the timeout using <code>dilated</code> if you want to account for slow test systems.</p>
<h2><a href="#testing-actor-integration" name="testing-actor-integration" class="anchor"><span class="anchor-link"></span></a>Testing Actor integration</h2>
<p>The <span class="group-scala"><code>ScalatestRouteTest</code></span><span class="group-java"><code>JUnitRouteTest</code></span> still provides a Classic <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0/org/apache/pekko/actor/ActorSystem.html" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem</code></a></span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/0.0/org/apache/pekko/actor/ActorSystem.html" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem</code></a></span>, so if you are not using the Classic API you will need to adapt it:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/server/TestKitWithActorSpec.scala#L17-L63" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import scala.concurrent.duration._
import scala.util.{ Failure, Success }

import org.apache.pekko
import pekko.actor.testkit.typed.scaladsl.TestProbe
import pekko.actor.typed.{ ActorRef, Scheduler }
import pekko.actor.typed.scaladsl.AskPattern._
import pekko.http.scaladsl.server.Directives._
import pekko.http.scaladsl.testkit.ScalatestRouteTest
import pekko.util.Timeout

import org.scalatest.matchers.should.Matchers
import org.scalatest.wordspec.AnyWordSpec

object RouteUnderTest {
  case class Ping(replyTo: ActorRef[String])

  // Your route under test, scheduler is only needed as ask is used
  def route(someActor: ActorRef[Ping])(implicit scheduler: Scheduler, timeout: Timeout) = get {
    path(&quot;ping&quot;) {
      complete(someActor ? Ping)
    }
  }
}

class TestKitWithActorSpec extends AnyWordSpec with Matchers with ScalatestRouteTest {
  import RouteUnderTest._

  // This test does not use the classic APIs,
  // so it needs to adapt the system:
  import pekko.actor.typed.scaladsl.adapter._
  implicit val typedSystem = system.toTyped
  implicit val timeout = Timeout(500.milliseconds)
  implicit val scheduler = system.scheduler

  &quot;The service&quot; should {
    &quot;return a &#39;PONG!&#39; response for GET requests to /ping&quot; in {
      val probe = TestProbe[Ping]()
      val test = Get(&quot;/ping&quot;) ~&gt; RouteUnderTest.route(probe.ref)
      val ping = probe.expectMessageType[Ping]
      ping.replyTo ! &quot;PONG!&quot;
      test ~&gt; check {
        responseAs[String] shouldEqual &quot;PONG!&quot;
      }
    }
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/server/testkit/TestKitWithActorTest.java#L17-L43" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.actor.testkit.typed.javadsl.TestProbe;
import org.apache.pekko.actor.typed.ActorSystem;
import org.apache.pekko.actor.typed.javadsl.Adapter;
import org.apache.pekko.http.javadsl.model.HttpRequest;
import org.apache.pekko.http.javadsl.testkit.JUnitRouteTest;

import org.apache.pekko.http.javadsl.testkit.TestRoute;
import org.apache.pekko.http.javadsl.testkit.TestRouteResult;
import org.junit.Test;

public class TestKitWithActorTest extends JUnitRouteTest {

    @Test
    public void returnPongForGetPing() {
        // This test does not use the classic APIs,
        // so it needs to adapt the system:
        ActorSystem&lt;Void&gt; system = Adapter.toTyped(system());

        TestProbe&lt;MyAppWithActor.Ping&gt; probe = TestProbe.create(system);
        TestRoute testRoute = testRoute(new MyAppWithActor().createRoute(probe.getRef(), system.scheduler()));

        TestRouteResult result = testRoute.run(HttpRequest.GET(&quot;/ping&quot;));
        MyAppWithActor.Ping ping = probe.expectMessageClass(MyAppWithActor.Ping.class);
        ping.replyTo.tell(&quot;PONG!&quot;);
        result.assertEntity(&quot;PONG!&quot;);
    }
}</code></pre></dd>
</dl>
<h2><a href="#integration-testing-routes" name="integration-testing-routes" class="anchor"><span class="anchor-link"></span></a>Integration Testing Routes</h2>
<p>Use <code>~!&gt;</code> to test a route running in full HTTP server mode:</p>
<pre><code>REQUEST ~!&gt; ROUTE ~&gt; check {
  ASSERTIONS
}
</code></pre>
<p>Certain routes can only be tested with <code>~!&gt;</code>, for example routes that use the <code>withRequestTimeout</code> directive.</p><div class="callout note "><div class="callout-title">Note</div>
<p>Using <code>~!&gt;</code> adds considerable extra overhead since each test will start a server and bind to a port so use it only when necessary.</p></div>
<h2><a href="#examples" name="examples" class="anchor"><span class="anchor-link"></span></a>Examples</h2>
<p>A great pool of examples are the tests for all the predefined directives in Apache Pekko HTTP. They can be found <span class="group-scala"><a href="https://github.com/apache/incubator-pekko-http/tree/main/http-tests/src/test/scala/akka/http/scaladsl/server/directives">here</a></span><span class="group-java"><a href="https://github.com/apache/incubator-pekko-http/tree/main/http-tests/src/test/java/akka/http/javadsl/server/directives">here</a></span>.</p>
</div>
<div>
<a href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/main/paradox/routing-dsl/testkit.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.0.0+4308-98f0ff9c*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../routing-dsl/style-guide.html" title="Routing DSL style guide" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Routing DSL style guide
</span>
</div>
</a>
<a href="../server-side/low-level-api.html" title="Core Server API" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Core Server API
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
Copyright Â© 2022, 2023 <a href="https://apache.org">The Apache Software Foundation</a>, Licensed under the Apache License, Version 2.0.
 This product contains significant parts that were originally based on software from Lightbend (<a href="https://akka.io/">Akka</a>).
 Copyright (C) 2009-2022 Lightbend Inc. &lt;https://www.lightbend.com&gt; Apache Pekko is derived from Akka 2.6.x,
 the last version that was distributed under the Apache License, Version 2.0 License.
</div>
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../assets/javascripts/groups.js"></script>

<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
