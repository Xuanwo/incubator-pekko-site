<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="Apache Pekko Http: Modern, fast, asynchronous, streaming-first HTTP server and client.">
<meta name="generator" content="Paradox, paradox-material-theme=0.6.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="Apache Pekko Http: Modern, fast, asynchronous, streaming-first HTTP server and client.">
<link rel="shortcut icon" href="../assets/images/pekko_favicon.png">
<title>Source Streaming Â· Apache Pekko HTTP</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../assets/stylesheets/application-palette.22915126.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
<link rel="stylesheet" href="../assets/stylesheets/pekko-theme.css">
</head>
<body
data-md-color-primary="white"
data-md-color-accent="orange"
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="Apache Pekko HTTP" class="md-header-nav__button md-logo">
<img src="../assets/images/pekko_logo.png" width="24" height="24">
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Apache Pekko HTTP
</span>
<span class="md-header-nav__topic">
Source Streaming
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/apache/incubator-pekko-http"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko-http
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="Apache Pekko HTTP" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<img src="../assets/images/pekko_logo.png" width="24" height="24">
</a>
<a href="../index.html" title="Apache Pekko HTTP">
Apache Pekko HTTP
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/apache/incubator-pekko-http"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko-http
</div>
</a>

</div>
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
<ul>
  <li><a href="../security.html" class="page">! Security Announcements !</a>
  <ul>
    <li><a href="../security.html#receiving-security-advisories" class="header">Receiving Security Advisories</a></li>
    <li><a href="../security.html#reporting-vulnerabilities" class="header">Reporting Vulnerabilities</a></li>
    <li><a href="../security.html#references" class="header">References</a></li>
  </ul></li>
  <li><a href="../release-notes/index.html" class="page">0. Release Notes</a></li>
  <li><a href="../introduction.html" class="page">1. Introduction</a>
  <ul>
    <li><a href="../introduction.html#philosophy" class="header">Philosophy</a></li>
    <li><a href="../introduction.html#using-apache-pekko-http" class="header">Using Apache Pekko HTTP</a></li>
    <li><a href="../introduction.html#routing-dsl-for-http-servers" class="header">Routing DSL for HTTP servers</a></li>
    <li><a href="../introduction.html#marshalling" class="header">Marshalling</a></li>
    <li><a href="../introduction.html#streaming" class="header">Streaming</a></li>
    <li><a href="../introduction.html#low-level-http-server-apis" class="header">Low-level HTTP server APIs</a></li>
    <li><a href="../introduction.html#http-client-api" class="header">HTTP Client API</a></li>
    <li><a href="../introduction.html#the-modules-that-make-up-apache-pekko-http" class="header">The modules that make up Apache Pekko HTTP</a></li>
  </ul></li>
  <li><a href="../usage.html" class="page">2. Usage</a>
  <ul>
    <li><a href="../configuration.html" class="page">Configuration</a></li>
    <li><a href="../migration-guide/index.html" class="page">Migration Guides</a></li>
    <li><a href="../compatibility-guidelines.html" class="page">Compatibility Guidelines</a></li>
  </ul></li>
  <li><a href="../common/index.html" class="page">3. Data Types &amp; Abstractions</a>
  <ul>
    <li><a href="../common/http-model.html" class="page">HTTP Model</a></li>
    <li><a href="../common/uri-model.html" class="page">The URI model</a></li>
    <li><a href="../common/marshalling.html" class="page">Marshalling</a></li>
    <li><a href="../common/unmarshalling.html" class="page">Unmarshalling</a></li>
    <li><a href="../common/encoding.html" class="page">Encoding / Decoding</a></li>
    <li><a href="../common/json-support.html" class="page">JSON Support</a></li>
    <li><a href="../common/xml-support.html" class="page">XML Support</a></li>
    <li><a href="../common/sse-support.html" class="page">Server-Sent Events Support</a></li>
    <li><a href="../common/timeouts.html" class="page">Timeouts</a></li>
    <li><a href="../common/caching.html" class="page">Caching</a></li>
  </ul></li>
  <li><a href="../server-side/index.html" class="page">4. Server API</a>
  <ul>
    <li><a href="../routing-dsl/index.html" class="page">Routing DSL</a></li>
    <li><a href="../server-side/low-level-api.html" class="page">Core Server API</a></li>
    <li><a href="../server-side/websocket-support.html" class="page">Server WebSocket Support</a></li>
    <li><a href="../server-side/server-https-support.html" class="page">Server HTTPS Support</a></li>
    <li><a href="../server-side/graceful-termination.html" class="page">Graceful termination</a></li>
    <li><a href="../server-side/http2.html" class="page">Server-Side HTTP/2 (Preview)</a></li>
  </ul></li>
  <li><a href="../client-side/index.html" class="page">5. Client API</a>
  <ul>
    <li><a href="../client-side/configuration.html" class="page">Configuration</a></li>
    <li><a href="../client-side/request-and-response.html" class="page">HttpRequest and HttpResponse</a></li>
    <li><a href="../client-side/request-level.html" class="page">Request-Level Client-Side API</a></li>
    <li><a href="../client-side/host-level.html" class="page">Host-Level Client-Side API</a></li>
    <li><a href="../client-side/connection-level.html" class="page">Connection-Level Client-Side API</a></li>
    <li><a href="../client-side/pool-overflow.html" class="page">Pool overflow and the max-open-requests setting</a></li>
    <li><a href="../client-side/client-https-support.html" class="page">Client-Side HTTPS Support</a></li>
    <li><a href="../client-side/client-transport.html" class="page">Pluggable Client Transports / HTTP(S) proxy Support</a></li>
    <li><a href="../client-side/websocket-support.html" class="page">Client-Side WebSocket Support</a></li>
    <li><a href="../client-side/http2.html" class="page">Client-Side HTTP/2 (Preview)</a></li>
  </ul></li>
  <li><a href="../extensions.html" class="page">6. Extensions</a></li>
  <li><a href="../technologies.html" class="page">7. Supported Technologies</a>
  <ul>
    <li><a href="../technologies.html#http" class="header">HTTP</a></li>
    <li><a href="../technologies.html#https" class="header">HTTPS</a></li>
    <li><a href="../technologies.html#websocket" class="header">WebSocket</a></li>
    <li><a href="../technologies.html#http-2" class="header">HTTP/2</a></li>
    <li><a href="../technologies.html#dns" class="header">DNS</a></li>
    <li><a href="../technologies.html#multipart" class="header">Multipart</a></li>
    <li><a href="../technologies.html#server-sent-events-sse-" class="header">Server-sent Events (SSE)</a></li>
    <li><a href="../technologies.html#json" class="header">JSON</a></li>
    <li><a href="../technologies.html#xml" class="header">XML</a></li>
    <li><a href="../technologies.html#gzip-and-deflate-content-encoding" class="header">Gzip and Deflate Content-Encoding</a></li>
  </ul></li>
  <li><a href="../tipsandtricks.html" class="page">8. Tips And Tricks</a>
  <ul>
    <li><a href="../troubleshooting/index.html" class="page">Troubleshooting</a></li>
    <li><a href="../handling-blocking-operations-in-pekko-http-routes.html" class="page">Handling blocking operations in Apache Pekko HTTP</a></li>
    <li><a href="../implications-of-streaming-http-entity.html" class="page">Implications of the streaming nature of Request/Response Entities</a></li>
  </ul></li>
  <li><a href="../contributing.html" class="page">9. Contributing</a>
  <ul>
    <li><a href="../contributing.html#welcome-" class="header">Welcome!</a></li>
    <li><a href="../contributing.html#snapshots" class="header">Snapshots</a></li>
  </ul></li>
  <li><a href="../reference.html" class="page">10. Reference</a>
  <ul>
    <li><a href="../reference.html#api-documentation" class="header">API Documentation</a></li>
    <li><a href="../reference.html#directives" class="header">Directives</a></li>
    <li><a href="../reference.html#books" class="header">Books</a></li>
  </ul></li>
</ul>

<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../routing-dsl/source-streaming-support.html#source-streaming" class="header">Source Streaming</a>
  <ul>
    <li><a href="../routing-dsl/source-streaming-support.html#json-streaming" class="header">JSON Streaming</a></li>
  </ul></li>
</ul>
</nav>


<ul class="md-nav__list md-nav__links">
<li class="md-nav__item"><a href="https://apache.org"><i class="md-icon">link</i> Apache Software Foundation</a></li>
<li class="md-nav__item"><a href="https://apache.org/licenses/"><i class="md-icon">link</i>&nbsp;License</a></li>
<li class="md-nav__item"><a href="https://apache.org/security/"><i class="md-icon">link</i>&nbsp;Security</a></li>
<li class="md-nav__item"><a href="https://www.apache.org/foundation/sponsorship.html"><i class="md-icon">link</i>&nbsp;Donate</a></li>
<li class="md-nav__item"><a href="https://www.apache.org/foundation/thanks.html"><i class="md-icon">link</i>&nbsp;Thanks</a></li>
</ul>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 0.0.0+4308-98f0ff9c*
</label>
</li>
</ul>

</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../routing-dsl/source-streaming-support.html#source-streaming" class="header">Source Streaming</a>
  <ul>
    <li><a href="../routing-dsl/source-streaming-support.html#json-streaming" class="header">JSON Streaming</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#source-streaming" name="source-streaming" class="anchor"><span class="anchor-link"></span></a>Source Streaming</h1>
<p>Apache Pekko HTTP supports completing a request with an Apache Pekko <span class="group-java"><a href="https://pekko.apache.org/japi/pekko/0.0/org/apache/pekko/stream/javadsl/Source.html" title="org.apache.pekko.stream.javadsl.Source"><code>Source&lt;T, ?&gt;</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0/org/apache/pekko/stream/scaladsl/Source.html" title="org.apache.pekko.stream.scaladsl.Source"><code>Source[T, _]</code></a></span>, which makes it possible to easily build and consume streaming end-to-end APIs which apply back pressure throughout the entire stack.</p>
<p>It is possible to complete requests with raw <span class="group-java"><a href="https://pekko.apache.org/japi/pekko/0.0/org/apache/pekko/stream/javadsl/Source.html" title="org.apache.pekko.stream.javadsl.Source"><code>Source&lt;ByteString, ?&gt;</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0/org/apache/pekko/stream/scaladsl/Source.html" title="org.apache.pekko.stream.scaladsl.Source"><code>Source[ByteString, _]</code></a></span>, however often it is more convenient to stream on an element-by-element basis, and allow Apache Pekko HTTP to handle the rendering internally - for example as a JSON array, or CSV stream (where each element is followed by a newline).</p>
<p>In the following sections we investigate how to make use of the JSON Streaming infrastructure, however the general hints apply to any kind of element-by-element streaming you could imagine.</p>
<h1><a href="#json-streaming" name="json-streaming" class="anchor"><span class="anchor-link"></span></a>JSON Streaming</h1>
<p><a href="https://en.wikipedia.org/wiki/JSON_Streaming">JSON Streaming</a> is a term referring to streaming a (possibly infinite) stream of element as independent JSON objects as a continuous HTTP request or response. The elements are most often separated using newlines, however do not have to be. Concatenating elements side-by-side or emitting &ldquo;very long&rdquo; JSON array is also another use case.</p>
<p>In the below examples, we&rsquo;ll be referring to the <code>Tweet</code> case class as our model, which is defined as:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/server/directives/JsonStreamingExamplesSpec.scala#L33" target="_blank" title="Go to snippet source">source</a><code class="language-scala">case class Tweet(uid: Int, txt: String)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/server/JsonStreamingExamplesTest.java#L207-L231" target="_blank" title="Go to snippet source">source</a><code class="language-java">private static final class JavaTweet {
  private int id;
  private String message;

  public JavaTweet(int id, String message) {
    this.id = id;
    this.message = message;
  }

  public int getId() {
    return id;
  }

  public void setId(int id) {
    this.id = id;
  }

  public void setMessage(String message) {
    this.message = message;
  }

  public String getMessage() {
    return message;
  }
}</code></pre></dd>
</dl><div class="group-scala">
<p>And as always with <code>spray-json</code>, we provide our marshaller and unmarshaller instances as implicit values using the <code>jsonFormat##</code> method to generate them statically:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/server/directives/JsonStreamingExamplesSpec.scala#L43-L48" target="_blank" title="Go to snippet source">source</a><code class="language-scala">object MyTweetJsonProtocol
    extends pekko.http.scaladsl.marshallers.sprayjson.SprayJsonSupport
    with spray.json.DefaultJsonProtocol {

  implicit val tweetFormat = jsonFormat2(Tweet.apply)
}</code></pre></dd>
</dl></div>
<h2><a href="#responding-with-json-streams" name="responding-with-json-streams" class="anchor"><span class="anchor-link"></span></a>Responding with JSON Streams</h2>
<p>In this example we implement an API representing an infinite stream of tweets, very much like Twitter&rsquo;s <a href="https://developer.twitter.com/en/docs">Streaming API</a>.</p><div class="group-scala">
<p>Firstly, we&rsquo;ll need to get some additional marshalling infrastructure set up, that is able to marshal to and from an Apache Pekko Streams <span class="group-java"><a href="https://pekko.apache.org/japi/pekko/0.0/org/apache/pekko/stream/javadsl/Source.html" title="org.apache.pekko.stream.javadsl.Source"><code>Source&lt;T, ?&gt;</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0/org/apache/pekko/stream/scaladsl/Source.html" title="org.apache.pekko.stream.scaladsl.Source"><code>Source[T, _]</code></a></span>. One such trait, containing the needed marshallers is <code>SprayJsonSupport</code>, which uses <code>spray-json</code> (a high performance JSON parser library), and is shipped as part of Apache Pekko HTTP in the <code>pekko-http-spray-json</code> module.</p>
<p>Once the general infrastructure is prepared, we import our model&rsquo;s marshallers, generated by <code>spray-json</code> (Step 1) and enable JSON Streaming by making an implicit <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/common/EntityStreamingSupport.html" title="org.apache.pekko.http.javadsl.common.EntityStreamingSupport"><code>EntityStreamingSupport</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/common/EntityStreamingSupport.html" title="org.apache.pekko.http.scaladsl.common.EntityStreamingSupport"><code>EntityStreamingSupport</code></a></span> instance available (Step 2). Apache Pekko HTTP pre-packages JSON and CSV entity streaming support, however it is simple to add your own, in case you&rsquo;d like to stream a different content type (for example plists or protobuf).</p></div><div class="group-java">
<p>Firstly, we&rsquo;ll need to get some additional marshalling infrastructure set up, that is able to marshal to and from an Apache Pekko Streams <span class="group-java"><a href="https://pekko.apache.org/japi/pekko/0.0/org/apache/pekko/stream/javadsl/Source.html" title="org.apache.pekko.stream.javadsl.Source"><code>Source&lt;T, ?&gt;</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0/org/apache/pekko/stream/scaladsl/Source.html" title="org.apache.pekko.stream.scaladsl.Source"><code>Source[T, ?]</code></a></span>. Here we&rsquo;ll use the <code>Jackson</code> helper class from <code>pekko-http-jackson</code> (a separate library that you should add as a dependency if you want to use Jackson with Apache Pekko HTTP).</p>
<p>First we enable JSON Streaming by making an implicit <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/common/EntityStreamingSupport.html" title="org.apache.pekko.http.javadsl.common.EntityStreamingSupport"><code>EntityStreamingSupport</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/common/EntityStreamingSupport.html" title="org.apache.pekko.http.scaladsl.common.EntityStreamingSupport"><code>EntityStreamingSupport</code></a></span> instance available (Step 1).</p>
<p>The default mode of rendering a <span class="group-java"><a href="https://pekko.apache.org/japi/pekko/0.0/org/apache/pekko/stream/javadsl/Source.html" title="org.apache.pekko.stream.javadsl.Source"><code>Source</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0/org/apache/pekko/stream/scaladsl/Source.html" title="org.apache.pekko.stream.scaladsl.Source"><code>Source</code></a></span> is to represent it as an JSON Array. If you want to change this representation for example to use Twitter style new-line separated JSON objects, you can do so by configuring the support trait accordingly.</p>
<p>In Step 1.1. we demonstrate how to configure the rendering to be new-line separated, and also how parallel marshalling can be applied. We configure the Support object to render the JSON as series of new-line separated JSON objects, simply by appending a ByteString consisting of a single new-line character to each ByteString in the stream. Although this format is <em>not</em> valid JSON, it is pretty popular since parsing it is relatively simple - clients need only to find the new-lines and apply JSON unmarshalling for an entire line of JSON.</p></div>
<p>The final step is simply completing a request using a Source of tweets, as simple as that:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/server/directives/JsonStreamingExamplesSpec.scala#L53-L84" target="_blank" title="Go to snippet source">source</a><code class="language-scala">// [1] import &quot;my protocol&quot;, for marshalling Tweet objects:
import MyTweetJsonProtocol._

// [2] pick a Source rendering support trait:
// Note that the default support renders the Source as JSON Array
implicit val jsonStreamingSupport: JsonEntityStreamingSupport = EntityStreamingSupport.json()

val route =
  path(&quot;tweets&quot;) {
    // [3] simply complete a request with a source of tweets:
    val tweets: Source[Tweet, NotUsed] = getTweets
    complete(tweets)
  }

// tests ------------------------------------------------------------
val AcceptJson = Accept(MediaRange(MediaTypes.`application/json`))
val AcceptXml = Accept(MediaRange(MediaTypes.`text/xml`))

Get(&quot;/tweets&quot;).withHeaders(AcceptJson) ~&gt; route ~&gt; check {
  responseAs[String] shouldEqual
  &quot;&quot;&quot;[&quot;&quot;&quot; +
  &quot;&quot;&quot;{&quot;txt&quot;:&quot;#Pekko rocks!&quot;,&quot;uid&quot;:1},&quot;&quot;&quot; +
  &quot;&quot;&quot;{&quot;txt&quot;:&quot;Streaming is so hot right now!&quot;,&quot;uid&quot;:2},&quot;&quot;&quot; +
  &quot;&quot;&quot;{&quot;txt&quot;:&quot;You cannot enter the same river twice.&quot;,&quot;uid&quot;:3}&quot;&quot;&quot; +
  &quot;&quot;&quot;]&quot;&quot;&quot;
}

// endpoint can only marshal Json, so it will *reject* requests for application/xml:
Get(&quot;/tweets&quot;).withHeaders(AcceptXml) ~&gt; route ~&gt; check {
  handled should ===(false)
  rejection should ===(UnacceptedResponseContentTypeRejection(Set(ContentTypes.`application/json`)))
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/server/JsonStreamingExamplesTest.java#L37-L202" target="_blank" title="Go to snippet source">source</a><code class="language-java">import static org.apache.pekko.http.javadsl.server.Directives.completeOKWithSource;
import static org.apache.pekko.http.javadsl.server.Directives.get;
import static org.apache.pekko.http.javadsl.server.Directives.parameter;
import static org.apache.pekko.http.javadsl.server.Directives.path;


// Step 1: Enable JSON streaming
// we&#39;re not using this in the example, but it&#39;s the simplest way to start:
// The default rendering is a JSON array: `[el, el, el , ...]`
final JsonEntityStreamingSupport jsonStreaming = EntityStreamingSupport.json();

// Step 1.1: Enable and customise how we&#39;ll render the JSON, as a compact array:
final ByteString start = ByteString.fromString(&quot;[&quot;);
final ByteString between = ByteString.fromString(&quot;,&quot;);
final ByteString end = ByteString.fromString(&quot;]&quot;);
final Flow&lt;ByteString, ByteString, NotUsed&gt; compactArrayRendering =
  Flow.of(ByteString.class).intersperse(start, between, end);

final JsonEntityStreamingSupport compactJsonSupport = EntityStreamingSupport.json()
  .withFramingRendererFlow(compactArrayRendering);


// Step 2: implement the route
final Route responseStreaming = path(&quot;tweets&quot;, () -&gt;
  get(() -&gt;
    parameter(StringUnmarshallers.INTEGER, &quot;n&quot;, n -&gt; {
      final Source&lt;JavaTweet, NotUsed&gt; tws =
        Source.repeat(new JavaTweet(12, &quot;Hello World!&quot;)).take(n);

      // Step 3: call complete* with your source, marshaller, and stream rendering mode
      return completeOKWithSource(tws, Jackson.marshaller(), compactJsonSupport);
    })
  )
);
// tests:
final TestRoute routes = testRoute(tweets());

// test happy path
final Accept acceptApplication = Accept.create(MediaRanges.create(MediaTypes.APPLICATION_JSON));
routes.run(HttpRequest.GET(&quot;/tweets?n=2&quot;).addHeader(acceptApplication))
  .assertStatusCode(200)
  .assertEntity(&quot;[{\&quot;id\&quot;:12,\&quot;message\&quot;:\&quot;Hello World!\&quot;},{\&quot;id\&quot;:12,\&quot;message\&quot;:\&quot;Hello World!\&quot;}]&quot;);

// test responses to potential errors
final Accept acceptText = Accept.create(MediaRanges.ALL_TEXT);
routes.run(HttpRequest.GET(&quot;/tweets?n=3&quot;).addHeader(acceptText))
  .assertStatusCode(StatusCodes.NOT_ACCEPTABLE) // 406
  .assertEntity(&quot;Resource representation is only available with these types:\napplication/json&quot;);
// tests --------------------------------------------
final TestRoute routes = testRoute(csvTweets());

// test happy path
final Accept acceptCsv = Accept.create(MediaRanges.create(MediaTypes.TEXT_CSV));
routes.run(HttpRequest.GET(&quot;/tweets?n=2&quot;).addHeader(acceptCsv))
  .assertStatusCode(200)
  .assertEntity(&quot;12,Hello World!\n&quot; +
    &quot;12,Hello World!\n&quot;);

// test responses to potential errors
final Accept acceptText = Accept.create(MediaRanges.ALL_APPLICATION);
routes.run(HttpRequest.GET(&quot;/tweets?n=3&quot;).addHeader(acceptText))
  .assertStatusCode(StatusCodes.NOT_ACCEPTABLE) // 406
  .assertEntity(&quot;Resource representation is only available with these types:\ntext/csv; charset=UTF-8&quot;);</code></pre></dd>
</dl>
<p>The reason the <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/common/EntityStreamingSupport.html" title="org.apache.pekko.http.javadsl.common.EntityStreamingSupport"><code>EntityStreamingSupport</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/common/EntityStreamingSupport.html" title="org.apache.pekko.http.scaladsl.common.EntityStreamingSupport"><code>EntityStreamingSupport</code></a></span> has to be enabled explicitly is that one might want to configure how the stream should be rendered. We&rsquo;ll discuss this in depth in the next section though.</p><div class="group-scala">
<h3><a href="#customising-response-rendering-mode" name="customising-response-rendering-mode" class="anchor"><span class="anchor-link"></span></a>Customising response rendering mode</h3>
<p>Since it is not always possible to directly and confidently answer the question of how a stream of <code>T</code> should look on the wire, the <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/common/EntityStreamingSupport.html" title="org.apache.pekko.http.javadsl.common.EntityStreamingSupport"><code>EntityStreamingSupport</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/common/EntityStreamingSupport.html" title="org.apache.pekko.http.scaladsl.common.EntityStreamingSupport"><code>EntityStreamingSupport</code></a></span> traits come into play and allow fine-tuning the stream&rsquo;s rendered representation.</p>
<p>For example, in case of JSON Streaming, there isn&rsquo;t really one standard about rendering the response. Some APIs prefer to render multiple JSON objects in a line-by-line fashion (Twitter&rsquo;s streaming APIs for example), while others simply return very large arrays, which could be streamed as well.</p>
<p>Apache Pekko defaults to the second one (streaming a JSON Array), as it is correct JSON and clients not expecting a streaming API would still be able to consume it in a naive way if they&rsquo;d want to.</p>
<p>The line-by-line approach however is also pretty popular even though it is not valid JSON. Its simplicity for client-side parsing is a strong point in case to pick this format for your Streaming APIs. Below we demonstrate how to reconfigure the support trait to render the JSON line-by-line.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/server/directives/JsonStreamingExamplesSpec.scala#L90-L117" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import MyTweetJsonProtocol._

// Configure the EntityStreamingSupport to render the elements as:
// {&quot;example&quot;:42}
// {&quot;example&quot;:43}
// ...
// {&quot;example&quot;:1000}
val newline = ByteString(&quot;\n&quot;)

implicit val jsonStreamingSupport = EntityStreamingSupport.json()
  .withFramingRenderer(Flow[ByteString].map(bs =&gt; bs ++ newline))

val route =
  path(&quot;tweets&quot;) {
    // [3] simply complete a request with a source of tweets:
    val tweets: Source[Tweet, NotUsed] = getTweets
    complete(tweets)
  }

// tests ------------------------------------------------------------
val AcceptJson = Accept(MediaRange(MediaTypes.`application/json`))

Get(&quot;/tweets&quot;).withHeaders(AcceptJson) ~&gt; route ~&gt; check {
  responseAs[String] shouldEqual
  &quot;&quot;&quot;{&quot;txt&quot;:&quot;#Pekko rocks!&quot;,&quot;uid&quot;:1}&quot;&quot;&quot; + &quot;\n&quot; +
  &quot;&quot;&quot;{&quot;txt&quot;:&quot;Streaming is so hot right now!&quot;,&quot;uid&quot;:2}&quot;&quot;&quot; + &quot;\n&quot; +
  &quot;&quot;&quot;{&quot;txt&quot;:&quot;You cannot enter the same river twice.&quot;,&quot;uid&quot;:3}&quot;&quot;&quot; + &quot;\n&quot;
}</code></pre></dd>
</dl>
<p>Another interesting feature is parallel marshalling. Since marshalling can potentially take much time, it is possible to marshal multiple elements of the stream in parallel. This is simply a configuration option on <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/common/EntityStreamingSupport.html" title="org.apache.pekko.http.javadsl.common.EntityStreamingSupport"><code>EntityStreamingSupport</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/common/EntityStreamingSupport.html" title="org.apache.pekko.http.scaladsl.common.EntityStreamingSupport"><code>EntityStreamingSupport</code></a></span> and is configurable like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/server/directives/JsonStreamingExamplesSpec.scala#L157-L165" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import MyTweetJsonProtocol._
implicit val jsonStreamingSupport: JsonEntityStreamingSupport =
  EntityStreamingSupport.json()
    .withParallelMarshalling(parallelism = 8, unordered = false)

path(&quot;tweets&quot;) {
  val tweets: Source[Tweet, NotUsed] = getTweets
  complete(tweets)
}</code></pre></dd>
</dl>
<p>The above shown mode preserves ordering of the Source&rsquo;s elements, which may sometimes be a required property, for example when streaming a strictly ordered dataset. Sometimes the concept of strict order does not apply to the data being streamed, though, which allows us to exploit this property and use an <code>unordered</code> rendering.</p>
<p>This <code>unordered</code> rendering can be enabled via a configuration option as shown below. Effectively, this allows Apache Pekko HTTP&rsquo;s marshalling infrastructure to concurrently marshall up to as many elements as defined in <code>parallelism</code> and emit the first one which is marshalled into the <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/model/HttpResponse.html" title="org.apache.pekko.http.javadsl.model.HttpResponse"><code>HttpResponse</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/model/HttpResponse.html" title="org.apache.pekko.http.scaladsl.model.HttpResponse"><code>HttpResponse</code></a></span>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/server/directives/JsonStreamingExamplesSpec.scala#L171-L179" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import MyTweetJsonProtocol._
implicit val jsonStreamingSupport: JsonEntityStreamingSupport =
  EntityStreamingSupport.json()
    .withParallelMarshalling(parallelism = 8, unordered = true)

path(&quot;tweets&quot; / &quot;unordered&quot;) {
  val tweets: Source[Tweet, NotUsed] = getTweets
  complete(tweets)
}</code></pre></dd>
</dl>
<p>This allows us to <em>potentially</em> render elements faster into the HttpResponse, since it can avoid &ldquo;head of line blocking&rdquo;, in case one element in front of the stream takes a long time to marshall, yet others after it are very quick to marshall.</p></div>
<h2><a href="#consuming-json-streaming-uploads" name="consuming-json-streaming-uploads" class="anchor"><span class="anchor-link"></span></a>Consuming JSON Streaming uploads</h2>
<p>Sometimes a client sends a streaming request. For example, an embedded device initiated a connection with the server and is feeding it with one line of measurement data.</p>
<p>In this example, we want to consume this data in a streaming fashion from the request entity and also apply back pressure to the underlying TCP connection should the server be unable to cope with the rate of incoming data. Back pressure is automatically applied thanks to <a href="https://pekko.apache.org/docs/pekko/current/stream/index.html">Apache Pekko Streams</a>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/server/directives/JsonStreamingExamplesSpec.scala#L185-L186" target="_blank" title="Go to snippet source">source</a><code class="language-scala">case class Measurement(id: String, value: Int)

object MyMeasurementJsonProtocol
    extends pekko.http.scaladsl.marshallers.sprayjson.SprayJsonSupport
    with spray.json.DefaultJsonProtocol {

  implicit val measurementFormat = jsonFormat2(Measurement.apply)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/server/JsonStreamingExamplesTest.java#L235-L260" target="_blank" title="Go to snippet source">source</a><code class="language-java">private static final class Measurement {
  private String id;
  private int value;

  public Measurement(String id, int value) {
    this.id = id;
    this.value = value;
  }

  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public void setValue(int value) {
    this.value = value;
  }

  public int getValue() {
    return value;
  }
}

final Unmarshaller&lt;ByteString, Measurement&gt; Measurements = Jackson.byteStringUnmarshaller(Measurement.class);</code></pre></dd>
</dl>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/server/directives/JsonStreamingExamplesSpec.scala#L200-L253" target="_blank" title="Go to snippet source">source</a><code class="language-scala">// [1] import &quot;my protocol&quot;, for unmarshalling Measurement objects:
import MyMeasurementJsonProtocol._

// [2] enable Json Streaming
implicit val jsonStreamingSupport = EntityStreamingSupport.json()

// prepare your persisting logic here
val persistMetrics = Flow[Measurement]

val route =
  path(&quot;metrics&quot;) {
    // [3] extract Source[Measurement, _]
    entity(asSourceOf[Measurement]) { measurements =&gt;
      // alternative syntax:
      // entity(as[Source[Measurement, NotUsed]]) { measurements =&gt;
      val measurementsSubmitted: Future[Int] =
        measurements
          .via(persistMetrics)
          .runFold(0) { (cnt, _) =&gt; cnt + 1 }

      complete {
        measurementsSubmitted.map(n =&gt; Map(&quot;msg&quot; -&gt; s&quot;&quot;&quot;Total metrics received: $n&quot;&quot;&quot;))
      }
    }
  }

// tests ------------------------------------------------------------
// uploading an array or newline separated values works out of the box
val data = HttpEntity(
  ContentTypes.`application/json`,
  &quot;&quot;&quot;
    |{&quot;id&quot;:&quot;temp&quot;,&quot;value&quot;:32}
    |{&quot;id&quot;:&quot;temp&quot;,&quot;value&quot;:31}
    |
  &quot;&quot;&quot;.stripMargin)

Post(&quot;/metrics&quot;, entity = data) ~&gt; route ~&gt; check {
  status should ===(StatusCodes.OK)
  responseAs[String] should ===(&quot;&quot;&quot;{&quot;msg&quot;:&quot;Total metrics received: 2&quot;}&quot;&quot;&quot;)
}

// the FramingWithContentType will reject any content type that it does not understand:
val xmlData = HttpEntity(
  ContentTypes.`text/xml(UTF-8)`,
  &quot;&quot;&quot;|&lt;data id=&quot;temp&quot; value=&quot;32&quot;/&gt;
     |&lt;data id=&quot;temp&quot; value=&quot;31&quot;/&gt;&quot;&quot;&quot;.stripMargin)

Post(&quot;/metrics&quot;, entity = xmlData) ~&gt; route ~&gt; check {
  handled should ===(false)
  rejection should ===(
    UnsupportedRequestContentTypeRejection(
      Set(ContentTypes.`application/json`),
      Some(ContentTypes.`text/xml(UTF-8)`)))
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/server/JsonStreamingExamplesTest.java#L44-L113" target="_blank" title="Go to snippet source">source</a><code class="language-java">import static org.apache.pekko.http.javadsl.server.Directives.complete;
import static org.apache.pekko.http.javadsl.server.Directives.entityAsSourceOf;
import static org.apache.pekko.http.javadsl.server.Directives.extractMaterializer;
import static org.apache.pekko.http.javadsl.server.Directives.onComplete;
import static org.apache.pekko.http.javadsl.server.Directives.post;

final Route incomingStreaming = path(&quot;metrics&quot;, () -&gt;
  post(() -&gt;
    extractMaterializer(mat -&gt; {
        final JsonEntityStreamingSupport jsonSupport = EntityStreamingSupport.json();

        return entityAsSourceOf(Measurements, jsonSupport, sourceOfMeasurements -&gt; {
          final CompletionStage&lt;Integer&gt; measurementCount = sourceOfMeasurements.runFold(0, (acc, measurement) -&gt; acc + 1, mat);
          return onComplete(measurementCount, c -&gt; complete(&quot;Total number of measurements: &quot; + c));
        });
      }
    )
  )
);</code></pre></dd>
</dl>
<h2><a href="#simple-csv-streaming-example" name="simple-csv-streaming-example" class="anchor"><span class="anchor-link"></span></a>Simple CSV streaming example</h2>
<p>Apache Pekko HTTP provides another <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/common/EntityStreamingSupport.html" title="org.apache.pekko.http.javadsl.common.EntityStreamingSupport"><code>EntityStreamingSupport</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/common/EntityStreamingSupport.html" title="org.apache.pekko.http.scaladsl.common.EntityStreamingSupport"><code>EntityStreamingSupport</code></a></span> out of the box, namely <code>csv</code> (comma-separated values). For completeness, we demonstrate its usage in the snippet below. As you&rsquo;ll notice, switching between streaming modes is fairly simple: You only have to make sure that an implicit <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/marshalling/Marshaller.html" title="org.apache.pekko.http.javadsl.marshalling.Marshaller"><code>Marshaller</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/marshalling/Marshaller.html" title="org.apache.pekko.http.scaladsl.marshalling.Marshaller"><code>Marshaller</code></a></span> of the requested type is available and that the streaming support operates on the same <code>Content-Type</code> as the rendered values. Otherwise, you&rsquo;ll see an error during runtime that the marshaller did not expose the expected content type and thus we can&rsquo;t render the streaming response).</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/server/directives/JsonStreamingExamplesSpec.scala#L123-L150" target="_blank" title="Go to snippet source">source</a><code class="language-scala">// [1] provide a marshaller to ByteString
implicit val tweetAsCsv = Marshaller.strict[Tweet, ByteString] { t =&gt;
  Marshalling.WithFixedContentType(ContentTypes.`text/csv(UTF-8)`,
    () =&gt; {
      val txt = t.txt.replaceAll(&quot;,&quot;, &quot;.&quot;)
      val uid = t.uid.toString
      ByteString(List(uid, txt).mkString(&quot;,&quot;))
    })
}

// [2] enable csv streaming:
implicit val csvStreaming = EntityStreamingSupport.csv()

val route =
  path(&quot;tweets&quot;) {
    val tweets: Source[Tweet, NotUsed] = getTweets
    complete(tweets)
  }

// tests ------------------------------------------------------------
val AcceptCsv = Accept(MediaRange(MediaTypes.`text/csv`))

Get(&quot;/tweets&quot;).withHeaders(AcceptCsv) ~&gt; route ~&gt; check {
  responseAs[String] shouldEqual
  &quot;1,#Pekko rocks!&quot; + &quot;\n&quot; +
  &quot;2,Streaming is so hot right now!&quot; + &quot;\n&quot; +
  &quot;3,You cannot enter the same river twice.&quot; + &quot;\n&quot;
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/server/JsonStreamingExamplesTest.java#L52-L136" target="_blank" title="Go to snippet source">source</a><code class="language-java">import static org.apache.pekko.http.javadsl.server.Directives.get;
import static org.apache.pekko.http.javadsl.server.Directives.path;
import static org.apache.pekko.http.javadsl.server.Directives.completeWithSource;

final Marshaller&lt;JavaTweet, ByteString&gt; renderAsCsv =
  Marshaller.withFixedContentType(ContentTypes.TEXT_CSV_UTF8, t -&gt;
    ByteString.fromString(t.getId() + &quot;,&quot; + t.getMessage())
  );

final CsvEntityStreamingSupport compactJsonSupport = EntityStreamingSupport.csv();

final Route responseStreaming = path(&quot;tweets&quot;, () -&gt;
  get(() -&gt;
    parameter(StringUnmarshallers.INTEGER, &quot;n&quot;, n -&gt; {
      final Source&lt;JavaTweet, NotUsed&gt; tws =
        Source.repeat(new JavaTweet(12, &quot;Hello World!&quot;)).take(n);
      return completeWithSource(tws, renderAsCsv, compactJsonSupport);
    })
  )
);</code></pre></dd>
</dl>
<h2><a href="#implementing-custom-entitystreamingsupport-traits" name="implementing-custom-entitystreamingsupport-traits" class="anchor"><span class="anchor-link"></span></a>Implementing custom EntityStreamingSupport traits</h2>
<p>The <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/common/EntityStreamingSupport.html" title="org.apache.pekko.http.javadsl.common.EntityStreamingSupport"><code>EntityStreamingSupport</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/common/EntityStreamingSupport.html" title="org.apache.pekko.http.scaladsl.common.EntityStreamingSupport"><code>EntityStreamingSupport</code></a></span> infrastructure is open for extension and not bound to any single format, content type, or marshalling library. The provided JSON support does not rely on <code>spray-json</code> directly, but uses <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/marshalling/Marshaller.html" title="org.apache.pekko.http.javadsl.marshalling.Marshaller"><code>Marshaller&lt;T, ByteString&gt;</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/marshalling/Marshaller.html" title="org.apache.pekko.http.scaladsl.marshalling.Marshaller"><code>Marshaller[T, ByteString]</code></a></span> instances, which can be provided using any JSON marshalling library (such as Circe, Jawn or Play JSON).</p>
<p>When implementing a custom support trait, one should simply extend the <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/common/EntityStreamingSupport.html" title="org.apache.pekko.http.javadsl.common.EntityStreamingSupport"><code>EntityStreamingSupport</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/common/EntityStreamingSupport.html" title="org.apache.pekko.http.scaladsl.common.EntityStreamingSupport"><code>EntityStreamingSupport</code></a></span> abstract class and implement all of its methods. It&rsquo;s best to use the existing implementations as a guideline.</p>
<h2><a href="#supporting-custom-content-types" name="supporting-custom-content-types" class="anchor"><span class="anchor-link"></span></a>Supporting custom content types</h2>
<p>In order to marshal into custom content types, both a <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/marshalling/Marshaller.html" title="org.apache.pekko.http.javadsl.marshalling.Marshaller"><code>Marshaller</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/marshalling/Marshaller.html" title="org.apache.pekko.http.scaladsl.marshalling.Marshaller"><code>Marshaller</code></a></span> that can handle that content type <strong>as well as an <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/common/EntityStreamingSupport.html" title="org.apache.pekko.http.javadsl.common.EntityStreamingSupport"><code>EntityStreamingSupport</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/common/EntityStreamingSupport.html" title="org.apache.pekko.http.scaladsl.common.EntityStreamingSupport"><code>EntityStreamingSupport</code></a></span> of matching content type</strong> is required.</p>
<p>Refer to the complete example below, showcasing how to configure a custom marshaller and change the entity streaming support&rsquo;s content type to be compatible. This is an area that would benefit from additional type safety, which we hope to add in a future release.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/server/directives/JsonStreamingFullExamples.scala#L23-L86" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko
import pekko.NotUsed
import pekko.actor.ActorSystem
import pekko.http.scaladsl.Http
import pekko.http.scaladsl.common.{ EntityStreamingSupport, JsonEntityStreamingSupport }
import pekko.http.scaladsl.model.{ HttpEntity, _ }
import pekko.http.scaladsl.server.Directives._
import pekko.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
import pekko.http.scaladsl.marshalling.{ Marshaller, ToEntityMarshaller }
import pekko.stream.scaladsl.Source
import spray.json.DefaultJsonProtocol

import scala.io.StdIn
import scala.util.Random

final case class User(name: String, id: String)

trait UserProtocol extends DefaultJsonProtocol {

  import spray.json._

  implicit val userFormat = jsonFormat2(User)

  val `vnd.example.api.v1+json` =
    MediaType.applicationWithFixedCharset(&quot;vnd.example.api.v1+json&quot;, HttpCharsets.`UTF-8`)
  val ct = ContentType.apply(`vnd.example.api.v1+json`)

  implicit def userMarshaller: ToEntityMarshaller[User] = Marshaller.oneOf(
    Marshaller.withFixedContentType(`vnd.example.api.v1+json`) { organisation =&gt;
      HttpEntity(`vnd.example.api.v1+json`, organisation.toJson.compactPrint)
    })
}

object ApiServer extends App with UserProtocol {
  implicit val system = ActorSystem(&quot;api&quot;)
  implicit val executionContext = system.dispatcher

  implicit val jsonStreamingSupport: JsonEntityStreamingSupport = EntityStreamingSupport.json()
    .withContentType(ct)
    .withParallelMarshalling(parallelism = 10, unordered = false)

  // (fake) async database query api
  def dummyUser(id: String) = User(s&quot;User $id&quot;, id.toString)

  def fetchUsers(): Source[User, NotUsed] = Source.fromIterator(() =&gt;
    Iterator.fill(10000) {
      val id = Random.nextInt()
      dummyUser(id.toString)
    })

  val route =
    pathPrefix(&quot;users&quot;) {
      get {
        complete(fetchUsers())
      }
    }

  val bindingFuture = Http().newServerAt(&quot;localhost&quot;, 8080).bind(route)

  println(s&quot;Server online at http://localhost:8080/\nPress RETURN to stop...&quot;)
  StdIn.readLine()
  bindingFuture.flatMap(_.unbind()).onComplete(_ =&gt; system.terminate())
}
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/server/directives/JsonStreamingFullExample.java#L17-L82" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.NotUsed;
import org.apache.pekko.actor.ActorSystem;
import org.apache.pekko.http.javadsl.Http;
import org.apache.pekko.http.javadsl.common.EntityStreamingSupport;
import org.apache.pekko.http.javadsl.marshalling.Marshaller;
import org.apache.pekko.http.javadsl.model.*;
import org.apache.pekko.http.javadsl.server.AllDirectives;
import org.apache.pekko.http.javadsl.server.Route;
import org.apache.pekko.stream.javadsl.Source;

import java.util.Random;
import java.util.stream.Stream;

public class JsonStreamingFullExample extends AllDirectives {

    public Route createRoute() {
        final MediaType.WithFixedCharset mediaType =
                MediaTypes.applicationWithFixedCharset(&quot;vnd.example.api.v1+json&quot;, HttpCharsets.UTF_8);

        final ContentType.WithFixedCharset contentType = ContentTypes.create(mediaType);

        final Marshaller&lt;User, RequestEntity&gt; userMarshaller =
                Marshaller.withFixedContentType(contentType, (User user) -&gt; HttpEntities.create(contentType, user.toJson()));

        final EntityStreamingSupport jsonStreamingSupport = EntityStreamingSupport.json()
                .withContentType(contentType)
                .withParallelMarshalling(10, false);

        return get(() -&gt;
                pathPrefix(&quot;users&quot;, () -&gt;
                        completeOKWithSource(fetchUsers(), userMarshaller, jsonStreamingSupport)
                )
        );
    }

    private Source&lt;User, NotUsed&gt; fetchUsers() {
        final Random rnd = new Random();
        return Source.fromIterator(() -&gt; Stream.generate(rnd::nextInt).map(this::dummyUser).limit(10000).iterator());
    }

    private User dummyUser(int id) {
        return new User(id, &quot;User &quot; + id);
    }

    static final class User {
        int id;
        String name;

        User(int id, String name) {
            this.id = id;
            this.name = name;
        }

        String toJson() {
            return &quot;{\&quot;id\&quot;:\&quot;&quot; + id + &quot;\&quot;, \&quot;name\&quot;:\&quot;&quot; + name + &quot;\&quot;}&quot;;
        }
    }

    public static void main(String[] args) {
        ActorSystem system = ActorSystem.create();
        final JsonStreamingFullExample app = new JsonStreamingFullExample();
        final Http http = Http.get(system);

        http.newServerAt(&quot;localhost&quot;, 8080).bind(app.createRoute());
    }
}</code></pre></dd>
</dl>
<h2><a href="#consuming-streaming-json-on-client-side" name="consuming-streaming-json-on-client-side" class="anchor"><span class="anchor-link"></span></a>Consuming streaming JSON on client-side</h2>
<p>For consuming such streaming APIs with, for example, JSON responses refer to <a href="../common/json-support.html#consuming-json-streaming-style-apis">Consuming JSON Streaming style APIs</a> documentation in the JSON support section.</p>
</div>
<div>
<a href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/main/paradox/routing-dsl/source-streaming-support.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.0.0+4308-98f0ff9c*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../routing-dsl/case-class-extraction.html" title="Case Class Extraction" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Case Class Extraction
</span>
</div>
</a>
<a href="../routing-dsl/style-guide.html" title="Routing DSL style guide" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Routing DSL style guide
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
Copyright Â© 2022, 2023 <a href="https://apache.org">The Apache Software Foundation</a>, Licensed under the Apache License, Version 2.0.
 This product contains significant parts that were originally based on software from Lightbend (<a href="https://akka.io/">Akka</a>).
 Copyright (C) 2009-2022 Lightbend Inc. &lt;https://www.lightbend.com&gt; Apache Pekko is derived from Akka 2.6.x,
 the last version that was distributed under the Apache License, Version 2.0 License.
</div>
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../assets/javascripts/groups.js"></script>

<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
