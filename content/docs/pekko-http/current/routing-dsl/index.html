<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="Apache Pekko Http: Modern, fast, asynchronous, streaming-first HTTP server and client.">
<meta name="generator" content="Paradox, paradox-material-theme=0.6.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="Apache Pekko Http: Modern, fast, asynchronous, streaming-first HTTP server and client.">
<link rel="shortcut icon" href="../assets/images/pekko_favicon.png">
<title>Routing DSL Â· Apache Pekko HTTP</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../assets/stylesheets/application-palette.22915126.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
<link rel="stylesheet" href="../assets/stylesheets/pekko-theme.css">
</head>
<body
data-md-color-primary="white"
data-md-color-accent="orange"
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="Apache Pekko HTTP" class="md-header-nav__button md-logo">
<img src="../assets/images/pekko_logo.png" width="24" height="24">
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Apache Pekko HTTP
</span>
<span class="md-header-nav__topic">
Routing DSL
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/apache/incubator-pekko-http"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko-http
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="Apache Pekko HTTP" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<img src="../assets/images/pekko_logo.png" width="24" height="24">
</a>
<a href="../index.html" title="Apache Pekko HTTP">
Apache Pekko HTTP
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/apache/incubator-pekko-http"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko-http
</div>
</a>

</div>
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
<ul>
  <li><a href="../security.html" class="page">! Security Announcements !</a>
  <ul>
    <li><a href="../security.html#receiving-security-advisories" class="header">Receiving Security Advisories</a></li>
    <li><a href="../security.html#reporting-vulnerabilities" class="header">Reporting Vulnerabilities</a></li>
    <li><a href="../security.html#references" class="header">References</a></li>
  </ul></li>
  <li><a href="../release-notes/index.html" class="page">0. Release Notes</a></li>
  <li><a href="../introduction.html" class="page">1. Introduction</a>
  <ul>
    <li><a href="../introduction.html#philosophy" class="header">Philosophy</a></li>
    <li><a href="../introduction.html#using-apache-pekko-http" class="header">Using Apache Pekko HTTP</a></li>
    <li><a href="../introduction.html#routing-dsl-for-http-servers" class="header">Routing DSL for HTTP servers</a></li>
    <li><a href="../introduction.html#marshalling" class="header">Marshalling</a></li>
    <li><a href="../introduction.html#streaming" class="header">Streaming</a></li>
    <li><a href="../introduction.html#low-level-http-server-apis" class="header">Low-level HTTP server APIs</a></li>
    <li><a href="../introduction.html#http-client-api" class="header">HTTP Client API</a></li>
    <li><a href="../introduction.html#the-modules-that-make-up-apache-pekko-http" class="header">The modules that make up Apache Pekko HTTP</a></li>
  </ul></li>
  <li><a href="../usage.html" class="page">2. Usage</a>
  <ul>
    <li><a href="../configuration.html" class="page">Configuration</a></li>
    <li><a href="../migration-guide/index.html" class="page">Migration Guides</a></li>
    <li><a href="../compatibility-guidelines.html" class="page">Compatibility Guidelines</a></li>
  </ul></li>
  <li><a href="../common/index.html" class="page">3. Data Types &amp; Abstractions</a>
  <ul>
    <li><a href="../common/http-model.html" class="page">HTTP Model</a></li>
    <li><a href="../common/uri-model.html" class="page">The URI model</a></li>
    <li><a href="../common/marshalling.html" class="page">Marshalling</a></li>
    <li><a href="../common/unmarshalling.html" class="page">Unmarshalling</a></li>
    <li><a href="../common/encoding.html" class="page">Encoding / Decoding</a></li>
    <li><a href="../common/json-support.html" class="page">JSON Support</a></li>
    <li><a href="../common/xml-support.html" class="page">XML Support</a></li>
    <li><a href="../common/sse-support.html" class="page">Server-Sent Events Support</a></li>
    <li><a href="../common/timeouts.html" class="page">Timeouts</a></li>
    <li><a href="../common/caching.html" class="page">Caching</a></li>
  </ul></li>
  <li><a href="../server-side/index.html" class="page">4. Server API</a>
  <ul>
    <li><a href="../routing-dsl/index.html#routing-dsl" class="active page">Routing DSL</a></li>
    <li><a href="../server-side/low-level-api.html" class="page">Core Server API</a></li>
    <li><a href="../server-side/websocket-support.html" class="page">Server WebSocket Support</a></li>
    <li><a href="../server-side/server-https-support.html" class="page">Server HTTPS Support</a></li>
    <li><a href="../server-side/graceful-termination.html" class="page">Graceful termination</a></li>
    <li><a href="../server-side/http2.html" class="page">Server-Side HTTP/2 (Preview)</a></li>
  </ul></li>
  <li><a href="../client-side/index.html" class="page">5. Client API</a>
  <ul>
    <li><a href="../client-side/configuration.html" class="page">Configuration</a></li>
    <li><a href="../client-side/request-and-response.html" class="page">HttpRequest and HttpResponse</a></li>
    <li><a href="../client-side/request-level.html" class="page">Request-Level Client-Side API</a></li>
    <li><a href="../client-side/host-level.html" class="page">Host-Level Client-Side API</a></li>
    <li><a href="../client-side/connection-level.html" class="page">Connection-Level Client-Side API</a></li>
    <li><a href="../client-side/pool-overflow.html" class="page">Pool overflow and the max-open-requests setting</a></li>
    <li><a href="../client-side/client-https-support.html" class="page">Client-Side HTTPS Support</a></li>
    <li><a href="../client-side/client-transport.html" class="page">Pluggable Client Transports / HTTP(S) proxy Support</a></li>
    <li><a href="../client-side/websocket-support.html" class="page">Client-Side WebSocket Support</a></li>
    <li><a href="../client-side/http2.html" class="page">Client-Side HTTP/2 (Preview)</a></li>
  </ul></li>
  <li><a href="../extensions.html" class="page">6. Extensions</a></li>
  <li><a href="../technologies.html" class="page">7. Supported Technologies</a>
  <ul>
    <li><a href="../technologies.html#http" class="header">HTTP</a></li>
    <li><a href="../technologies.html#https" class="header">HTTPS</a></li>
    <li><a href="../technologies.html#websocket" class="header">WebSocket</a></li>
    <li><a href="../technologies.html#http-2" class="header">HTTP/2</a></li>
    <li><a href="../technologies.html#dns" class="header">DNS</a></li>
    <li><a href="../technologies.html#multipart" class="header">Multipart</a></li>
    <li><a href="../technologies.html#server-sent-events-sse-" class="header">Server-sent Events (SSE)</a></li>
    <li><a href="../technologies.html#json" class="header">JSON</a></li>
    <li><a href="../technologies.html#xml" class="header">XML</a></li>
    <li><a href="../technologies.html#gzip-and-deflate-content-encoding" class="header">Gzip and Deflate Content-Encoding</a></li>
  </ul></li>
  <li><a href="../tipsandtricks.html" class="page">8. Tips And Tricks</a>
  <ul>
    <li><a href="../troubleshooting/index.html" class="page">Troubleshooting</a></li>
    <li><a href="../handling-blocking-operations-in-pekko-http-routes.html" class="page">Handling blocking operations in Apache Pekko HTTP</a></li>
    <li><a href="../implications-of-streaming-http-entity.html" class="page">Implications of the streaming nature of Request/Response Entities</a></li>
  </ul></li>
  <li><a href="../contributing.html" class="page">9. Contributing</a>
  <ul>
    <li><a href="../contributing.html#welcome-" class="header">Welcome!</a></li>
    <li><a href="../contributing.html#snapshots" class="header">Snapshots</a></li>
  </ul></li>
  <li><a href="../reference.html" class="page">10. Reference</a>
  <ul>
    <li><a href="../reference.html#api-documentation" class="header">API Documentation</a></li>
    <li><a href="../reference.html#directives" class="header">Directives</a></li>
    <li><a href="../reference.html#books" class="header">Books</a></li>
  </ul></li>
</ul>

<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../routing-dsl/index.html#routing-dsl" class="header">Routing DSL</a>
  <ul>
    <li><a href="../routing-dsl/index.html#minimal-example" class="header">Minimal Example</a></li>
    <li><a href="../routing-dsl/index.html#longer-example" class="header group-scala">Longer Example</a></li>
    <li><a href="../routing-dsl/index.html#getting-started" class="header">Getting started</a></li>
    <li><a href="../routing-dsl/index.html#compared-with-play-framework-routes" class="header">Compared with Play framework routes</a></li>
    <li><a href="../routing-dsl/index.html#interaction-with-actors" class="header">Interaction with Actors</a></li>
    <li><a href="../routing-dsl/index.html#dynamic-routing-example" class="header">Dynamic Routing Example</a></li>
    <li><a href="../routing-dsl/index.html#handling-http-server-failures-in-the-high-level-api" class="header">Handling HTTP Server failures in the High-Level API</a></li>
    <li><a href="../routing-dsl/index.html#file-uploads" class="header">File uploads</a></li>
    <li><a href="../routing-dsl/index.html#configuring-server-side-https" class="header">Configuring Server-side HTTPS</a></li>
  </ul></li>
</ul>
</nav>


<ul class="md-nav__list md-nav__links">
<li class="md-nav__item"><a href="https://apache.org"><i class="md-icon">link</i> Apache Software Foundation</a></li>
<li class="md-nav__item"><a href="https://apache.org/licenses/"><i class="md-icon">link</i>&nbsp;License</a></li>
<li class="md-nav__item"><a href="https://apache.org/security/"><i class="md-icon">link</i>&nbsp;Security</a></li>
<li class="md-nav__item"><a href="https://www.apache.org/foundation/sponsorship.html"><i class="md-icon">link</i>&nbsp;Donate</a></li>
<li class="md-nav__item"><a href="https://www.apache.org/foundation/thanks.html"><i class="md-icon">link</i>&nbsp;Thanks</a></li>
</ul>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 0.0.0+4308-98f0ff9c*
</label>
</li>
</ul>

</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../routing-dsl/index.html#routing-dsl" class="header">Routing DSL</a>
  <ul>
    <li><a href="../routing-dsl/index.html#minimal-example" class="header">Minimal Example</a></li>
    <li><a href="../routing-dsl/index.html#longer-example" class="header group-scala">Longer Example</a></li>
    <li><a href="../routing-dsl/index.html#getting-started" class="header">Getting started</a></li>
    <li><a href="../routing-dsl/index.html#compared-with-play-framework-routes" class="header">Compared with Play framework routes</a></li>
    <li><a href="../routing-dsl/index.html#interaction-with-actors" class="header">Interaction with Actors</a></li>
    <li><a href="../routing-dsl/index.html#dynamic-routing-example" class="header">Dynamic Routing Example</a></li>
    <li><a href="../routing-dsl/index.html#handling-http-server-failures-in-the-high-level-api" class="header">Handling HTTP Server failures in the High-Level API</a></li>
    <li><a href="../routing-dsl/index.html#file-uploads" class="header">File uploads</a></li>
    <li><a href="../routing-dsl/index.html#configuring-server-side-https" class="header">Configuring Server-side HTTPS</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#routing-dsl" name="routing-dsl" class="anchor"><span class="anchor-link"></span></a>Routing DSL</h1>
<p>Apache Pekko HTTP provides a flexible routing DSL for elegantly defining RESTful web services. It picks up where the <a href="../server-side/low-level-api.html">low-level API</a> leaves off and offers much of the higher-level functionality of typical web servers or frameworks, like deconstruction of URIs, content negotiation or static content serving.</p><div class="callout note "><div class="callout-title">Note</div>
<p>It is recommended to read the <a href="../implications-of-streaming-http-entity.html">Implications of the streaming nature of Request/Response Entities</a> section, as it explains the underlying full-stack streaming concepts, which may be unexpected when coming from a background with non-&ldquo;streaming first&rdquo; HTTP Servers.</p></div>
<div class="toc ">
<ul>
  <li><a href="../routing-dsl/index.html#minimal-example" class="header">Minimal Example</a></li>
  <li><a href="../routing-dsl/index.html#longer-example" class="header group-scala">Longer Example</a></li>
  <li><a href="../routing-dsl/index.html#getting-started" class="header">Getting started</a></li>
  <li><a href="../routing-dsl/index.html#compared-with-play-framework-routes" class="header">Compared with Play framework routes</a></li>
  <li><a href="../routing-dsl/index.html#interaction-with-actors" class="header">Interaction with Actors</a></li>
  <li><a href="../routing-dsl/index.html#dynamic-routing-example" class="header">Dynamic Routing Example</a></li>
  <li><a href="../routing-dsl/index.html#handling-http-server-failures-in-the-high-level-api" class="header">Handling HTTP Server failures in the High-Level API</a></li>
  <li><a href="../routing-dsl/index.html#file-uploads" class="header">File uploads</a></li>
  <li><a href="../routing-dsl/index.html#configuring-server-side-https" class="header">Configuring Server-side HTTPS</a></li>
  <li><a href="../routing-dsl/overview.html" class="page">Routing DSL Overview</a></li>
  <li><a href="../routing-dsl/play-comparison.html" class="page">Compared with Play routes</a></li>
  <li><a href="../routing-dsl/routes.html" class="page">Routes</a></li>
  <li><a href="../routing-dsl/directives/index.html" class="page">Directives</a></li>
  <li><a href="../routing-dsl/rejections.html" class="page">Rejections</a></li>
  <li><a href="../routing-dsl/exception-handling.html" class="page">Exception Handling</a></li>
  <li><a href="../routing-dsl/case-class-extraction.html" class="page group-scala">Case Class Extraction</a></li>
  <li><a href="../routing-dsl/source-streaming-support.html" class="page">Source Streaming</a></li>
  <li><a href="../routing-dsl/style-guide.html" class="page">Routing DSL style guide</a></li>
  <li><a href="../routing-dsl/testkit.html" class="page">Route TestKit</a></li>
</ul>
</div>
<h2><a href="#minimal-example" name="minimal-example" class="anchor"><span class="anchor-link"></span></a>Minimal Example</h2>
<p>This is a complete, very basic Apache Pekko HTTP application relying on the Routing DSL:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/HttpServerRoutingMinimal.scala" target="_blank" title="Go to snippet source">source</a><code class="language-scala">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * license agreements; and to You under the Apache License, version 2.0:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * This file is part of the Apache Pekko project, derived from Akka.
 */

/*
 * Copyright (C) 2020-2022 Lightbend Inc. &lt;https://www.lightbend.com&gt;
 */

package docs.http.scaladsl

import org.apache.pekko
import pekko.actor.typed.ActorSystem
import pekko.actor.typed.scaladsl.Behaviors
import pekko.http.scaladsl.Http
import pekko.http.scaladsl.model._
import pekko.http.scaladsl.server.Directives._
import scala.io.StdIn

object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    implicit val system = ActorSystem(Behaviors.empty, &quot;my-system&quot;)
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path(&quot;hello&quot;) {
        get {
          complete(HttpEntity(ContentTypes.`text/html(UTF-8)`, &quot;&lt;h1&gt;Say hello to akka-http&lt;/h1&gt;&quot;))
        }
      }

    val bindingFuture = Http().newServerAt(&quot;localhost&quot;, 8080).bind(route)

    println(s&quot;Server now online. Please navigate to http://localhost:8080/hello\nPress RETURN to stop...&quot;)
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ =&gt; system.terminate()) // and shutdown when done
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/HttpServerMinimalExampleTest.java#L16-L54" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.actor.typed.ActorSystem;
import org.apache.pekko.actor.typed.javadsl.Behaviors;
import org.apache.pekko.http.javadsl.Http;
import org.apache.pekko.http.javadsl.ServerBinding;
import org.apache.pekko.http.javadsl.server.AllDirectives;
import org.apache.pekko.http.javadsl.server.Route;

import java.util.concurrent.CompletionStage;

public class HttpServerMinimalExampleTest extends AllDirectives {

  public static void main(String[] args) throws Exception {
    // boot up server using the route as defined below
    ActorSystem&lt;Void&gt; system = ActorSystem.create(Behaviors.empty(), &quot;routes&quot;);

    final Http http = Http.get(system);

    //In order to access all directives we need an instance where the routes are define.
    HttpServerMinimalExampleTest app = new HttpServerMinimalExampleTest();

    final CompletionStage&lt;ServerBinding&gt; binding =
      http.newServerAt(&quot;localhost&quot;, 8080)
          .bind(app.createRoute());

    System.out.println(&quot;Server online at http://localhost:8080/\nPress RETURN to stop...&quot;);
    System.in.read(); // let it run until user presses return

    binding
        .thenCompose(ServerBinding::unbind) // trigger unbinding from the port
        .thenAccept(unbound -&gt; system.terminate()); // and shutdown when done
  }

  private Route createRoute() {
    return concat(
        path(&quot;hello&quot;, () -&gt;
            get(() -&gt;
                complete(&quot;&lt;h1&gt;Say hello to pekko-http&lt;/h1&gt;&quot;))));
  }
}</code></pre></dd>
</dl>
<p>It starts an HTTP Server on localhost and replies to GET requests to <code>/hello</code> with a simple response.</p><div class="group-scala">
<h2><a href="#longer-example" name="longer-example" class="anchor"><span class="anchor-link"></span></a>Longer Example</h2>
<p>The following is an Apache Pekko HTTP route definition that tries to show off a few features. The resulting service does not really do anything useful but its definition should give you a feel for what an actual API definition with the Routing DSL will look like:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/HttpServerExampleSpec.scala#L203-L317" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko
import pekko.actor.{ ActorRef, ActorSystem }
import pekko.http.scaladsl.coding.Coders
import pekko.http.scaladsl.marshalling.ToResponseMarshaller
import pekko.http.scaladsl.model.StatusCodes.MovedPermanently
import pekko.http.scaladsl.server.Directives._
import pekko.http.scaladsl.unmarshalling.FromRequestUnmarshaller
import pekko.pattern.ask
import pekko.util.Timeout

// types used by the API routes
type Money = Double // only for demo purposes, don&#39;t try this at home!
type TransactionResult = String
case class User(name: String)
case class Order(email: String, amount: Money)
case class Update(order: Order)
case class OrderItem(i: Int, os: Option[String], s: String)

// marshalling would usually be derived automatically using libraries
implicit val orderUM: FromRequestUnmarshaller[Order] = ???
implicit val orderM: ToResponseMarshaller[Order] = ???
implicit val orderSeqM: ToResponseMarshaller[Seq[Order]] = ???
implicit val timeout: Timeout = ??? // for actor asks
implicit val ec: ExecutionContext = ???
implicit val sys: ActorSystem = ???

// backend entry points
def myAuthenticator: Authenticator[User] = ???
def retrieveOrdersFromDB: Future[Seq[Order]] = ???
def myDbActor: ActorRef = ???
def processOrderRequest(id: Int, complete: Order =&gt; Unit): Unit = ???

lazy val binding = Http().newServerAt(&quot;localhost&quot;, 8080).bind(topLevelRoute)
// ...

lazy val topLevelRoute: Route =
  // provide top-level path structure here but delegate functionality to subroutes for readability
  concat(
    path(&quot;orders&quot;)(ordersRoute),
    // extract URI path element as Int
    pathPrefix(&quot;order&quot; / IntNumber)(orderRoute),
    pathPrefix(&quot;documentation&quot;)(documentationRoute),
    path(&quot;oldApi&quot; / Remaining) { pathRest =&gt;
      redirect(&quot;http://oldapi.example.com/&quot; + pathRest, MovedPermanently)
    })

// For bigger routes, these sub-routes can be moved to separate files
lazy val ordersRoute: Route =
  authenticateBasic(realm = &quot;admin area&quot;, myAuthenticator) { user =&gt;
    concat(
      get {
        encodeResponseWith(Coders.Deflate) {
          complete {
            // unpack future and marshal custom object with in-scope marshaller
            retrieveOrdersFromDB
          }
        }
      },
      post {
        // decompress gzipped or deflated requests if required
        decodeRequest {
          // unmarshal with in-scope unmarshaller
          entity(as[Order]) { order =&gt;
            complete {
              // ... write order to DB
              &quot;Order received&quot;
            }
          }
        }
      })
  }

def orderRoute(orderId: Int): Route =
  concat(
    pathEnd {
      concat(
        put {
          // form extraction from multipart or www-url-encoded forms
          formFields(&quot;email&quot;, &quot;total&quot;.as[Money]).as(Order) { order =&gt;
            complete {
              // complete with serialized Future result
              (myDbActor ? Update(order)).mapTo[TransactionResult]
            }
          }
        },
        get {
          // debugging helper
          logRequest(&quot;GET-ORDER&quot;) {
            // use in-scope marshaller to create completer function
            completeWith(instanceOf[Order]) { completer =&gt;
              // custom
              processOrderRequest(orderId, completer)
            }
          }
        })
    },
    path(&quot;items&quot;) {
      get {
        // parameters to case class extraction
        parameters(&quot;size&quot;.as[Int], &quot;color&quot;.optional, &quot;dangerous&quot;.withDefault(&quot;no&quot;))
          .as(OrderItem) { orderItem =&gt;
            // ... route using case class instance created from
            // required and optional query parameters
          }
      }
    })

lazy val documentationRoute: Route =
  // optionally compresses the response with Gzip or Deflate
  // if the client accepts compressed responses
  encodeResponse {
    // serve up static content from a JAR resource
    getFromResourceDirectory(&quot;docs&quot;)
  }</code></pre></div>
<h2><a href="#getting-started" name="getting-started" class="anchor"><span class="anchor-link"></span></a>Getting started</h2>
<p>The project template in <span class="group-scala"><a href="https://developer.lightbend.com/guides/akka-http-quickstart-scala/">Apache Pekko HTTP Quickstart for Scala</a></span><span class="group-java"><a href="https://developer.lightbend.com/guides/akka-http-quickstart-java/">Apache Pekko HTTP Quickstart for Java</a></span> will help you to get a working Apache Pekko HTTP server running.</p>
<h2><a href="#compared-with-play-framework-routes" name="compared-with-play-framework-routes" class="anchor"><span class="anchor-link"></span></a>Compared with Play framework routes</h2>
<p>If you have been using Play framework&rsquo;s routes file notation before this <a href="play-comparison.html">Play comparison</a> may help you to get started with Apache Pekko HTTP routing.</p>
<a name="interaction-with-akka-typed">
<h2><a href="#interaction-with-actors" name="interaction-with-actors" class="anchor"><span class="anchor-link"></span></a>Interaction with Actors</h2>
<p>The following example shows how to use Apache Pekko HTTP with Apache Pekko Actors.</p>
<p>We will create a small web server responsible to record build jobs with its state and duration, query jobs by id and status, and clear the job history.</p>
<p>First let&rsquo;s start by defining the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0/org/apache/pekko/actor/typed/Behavior.html" title="org.apache.pekko.actor.typed.Behavior"><code>Behavior</code></a></span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/0.0/org/apache/pekko/actor/typed/Behavior.html" title="org.apache.pekko.actor.typed.Behavior"><code>Behavior</code></a></span> that will act as a repository for the build job information. This isn&rsquo;t strictly needed for our sample, but just to have an actual actor to interact with:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/HttpServerWithActorsSample.scala#L19-L59" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko
import pekko.actor.typed.{ ActorRef, Behavior }
import pekko.actor.typed.scaladsl.Behaviors

object JobRepository {

  // Definition of the a build job and its possible status values
  sealed trait Status
  object Successful extends Status
  object Failed extends Status

  final case class Job(id: Long, projectName: String, status: Status, duration: Long)

  // Trait defining successful and failure responses
  sealed trait Response
  case object OK extends Response
  final case class KO(reason: String) extends Response

  // Trait and its implementations representing all possible messages that can be sent to this Behavior
  sealed trait Command
  final case class AddJob(job: Job, replyTo: ActorRef[Response]) extends Command
  final case class GetJobById(id: Long, replyTo: ActorRef[Option[Job]]) extends Command
  final case class ClearJobs(replyTo: ActorRef[Response]) extends Command

  // This behavior handles all possible incoming messages and keeps the state in the function parameter
  def apply(jobs: Map[Long, Job] = Map.empty): Behavior[Command] = Behaviors.receiveMessage {
    case AddJob(job, replyTo) if jobs.contains(job.id) =&gt;
      replyTo ! KO(&quot;Job already exists&quot;)
      Behaviors.same
    case AddJob(job, replyTo) =&gt;
      replyTo ! OK
      JobRepository(jobs.+(job.id -&gt; job))
    case GetJobById(id, replyTo) =&gt;
      replyTo ! jobs.get(id)
      Behaviors.same
    case ClearJobs(replyTo) =&gt;
      replyTo ! OK
      JobRepository(Map.empty)
  }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/JobRepository.java#L17-L155" target="_blank" title="Go to snippet source">source</a><code class="language-java">import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

import org.apache.pekko.actor.typed.ActorRef;
import org.apache.pekko.actor.typed.Behavior;
import org.apache.pekko.actor.typed.javadsl.*;
import com.fasterxml.jackson.annotation.*;

/**
 * Actor for use with the HttpServerWithActorsSample
 */
public class JobRepository extends AbstractBehavior&lt;JobRepository.Command&gt; {

  @JsonFormat
  public static final class Job {
    @JsonProperty(&quot;id&quot;)
    final Long id;
    @JsonProperty(&quot;project-name&quot;)
    final String projectName;
    @JsonProperty(&quot;status&quot;)
    final String status;
    @JsonProperty(&quot;duration&quot;)
    final Long duration;

    @JsonCreator(mode = JsonCreator.Mode.PROPERTIES)
    public Job(@JsonProperty(&quot;id&quot;) Long id, @JsonProperty(&quot;project-name&quot;) String projectName, @JsonProperty(&quot;duration&quot;) Long duration) {
      this(id, projectName, &quot;Success&quot;, duration);
    }
    public Job(Long id, String projectName, String status, Long duration) {
      this.id = id;
      this.projectName = projectName;
      this.status = status;
      this.duration = duration;
    }
  }

  // Successful and failure responses
  interface Response {}

  public static final class OK implements Response {
    private static OK INSTANCE = new OK();

    private OK() {}

    public static OK getInstance() {
      return INSTANCE;
    }
  }

  public static final class KO implements Response {
    final String reason;

    public KO(String reason) {
      this.reason = reason;
    }
  }

  // All possible messages that can be sent to this Behavior
  interface Command {}

  public static final class AddJob implements Command {
    final Job job;
    final ActorRef&lt;Response&gt; replyTo;

    public AddJob(Job job, ActorRef&lt;Response&gt; replyTo) {
      this.job = job;
      this.replyTo = replyTo;
    }
  }

  public static final class GetJobById implements Command {
    final Long id;
    final ActorRef&lt;Optional&lt;Job&gt;&gt; replyTo;

    public GetJobById(Long id, ActorRef&lt;Optional&lt;Job&gt;&gt; replyTo) {
      this.id = id;
      this.replyTo = replyTo;
    }
  }

  public static final class ClearJobs implements Command {
    final ActorRef&lt;Response&gt; replyTo;

    public ClearJobs(ActorRef&lt;Response&gt; replyTo) {
      this.replyTo = replyTo;
    }
  }

  public static Behavior&lt;Command&gt; create() {
    return create(new HashMap&lt;Long, Job&gt;());
  }

  public static Behavior&lt;Command&gt; create(Map&lt;Long, Job&gt; jobs) {
    return Behaviors.setup(ctx -&gt; new JobRepository(ctx, jobs));
  }

  private Map&lt;Long, Job&gt; jobs;

  private JobRepository(ActorContext&lt;Command&gt; context, Map&lt;Long, Job&gt; jobs) {
    super(context);
    this.jobs = jobs;
  }

  // This receive handles all possible incoming messages and keeps the state in the actor
  @Override
  public Receive&lt;Command&gt; createReceive() {
    return newReceiveBuilder()
            .onMessage(AddJob.class, this::addJob)
            .onMessage(GetJobById.class, this::getJobById)
            .onMessage(ClearJobs.class, this::clearJobs)
            .build();
  }

  private Behavior&lt;Command&gt; addJob(AddJob msg) {
    if (jobs.containsKey(msg.job.id))
      msg.replyTo.tell(new KO(&quot;Job already exists&quot;));
    else {
      jobs.put(msg.job.id, msg.job);
      msg.replyTo.tell(OK.getInstance());
    }
    return Behaviors.same();
  }

  private Behavior&lt;Command&gt; getJobById(GetJobById msg) {
    if (jobs.containsKey(msg.id)) {
      msg.replyTo.tell(Optional.of(jobs.get(msg.id)));
    } else {
      msg.replyTo.tell(Optional.empty());
    }
    return Behaviors.same();
  }

  private Behavior&lt;Command&gt; clearJobs(ClearJobs msg) {
    msg.replyTo.tell(OK.getInstance());
    jobs.clear();
    return Behaviors.same();
  }
}</code></pre></dd>
</dl><div class="group-scala">
<p>Then, let&rsquo;s define the JSON marshaller and unmarshallers for the HTTP routes:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/HttpServerWithActorsSample.scala#L63-L89" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko.http.scaladsl.marshallers.sprayjson.SprayJsonSupport
import spray.json.DefaultJsonProtocol
import spray.json.DeserializationException
import spray.json.JsString
import spray.json.JsValue
import spray.json.RootJsonFormat

trait JsonSupport extends SprayJsonSupport {
  // import the default encoders for primitive types (Int, String, Lists etc)
  import DefaultJsonProtocol._
  import JobRepository._

  implicit object StatusFormat extends RootJsonFormat[Status] {
    def write(status: Status): JsValue = status match {
      case Failed     =&gt; JsString(&quot;Failed&quot;)
      case Successful =&gt; JsString(&quot;Successful&quot;)
    }

    def read(json: JsValue): Status = json match {
      case JsString(&quot;Failed&quot;)     =&gt; Failed
      case JsString(&quot;Successful&quot;) =&gt; Successful
      case _                      =&gt; throw new DeserializationException(&quot;Status unexpected&quot;)
    }
  }

  implicit val jobFormat = jsonFormat4(Job)
}</code></pre></dd>
</dl></div>
<p>Next step is to define the <span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/server/index.html#Route=org.apache.pekko.http.scaladsl.server.RequestContext=%3Escala.concurrent.Future[org.apache.pekko.http.scaladsl.server.RouteResult]" title="org.apache.pekko.http.scaladsl.server"><code>Route</code></a></span> <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/server/Route.html" title="org.apache.pekko.http.javadsl.server.Route"><code>Route</code></a></span> that will communicate with the previously defined behavior and handle all its possible responses:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/HttpServerWithActorsSample.scala#L93-L146" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko
import pekko.actor.typed.ActorSystem
import pekko.util.Timeout

import pekko.http.scaladsl.server.Directives._
import pekko.http.scaladsl.model.StatusCodes
import pekko.http.scaladsl.server.Route

import scala.concurrent.duration._
import scala.concurrent.Future

class JobRoutes(buildJobRepository: ActorRef[JobRepository.Command])(
    implicit system: ActorSystem[_]) extends JsonSupport {

  import pekko.actor.typed.scaladsl.AskPattern.schedulerFromActorSystem
  import pekko.actor.typed.scaladsl.AskPattern.Askable

  // asking someone requires a timeout and a scheduler, if the timeout hits without response
  // the ask is failed with a TimeoutException
  implicit val timeout: Timeout = 3.seconds

  lazy val theJobRoutes: Route =
    pathPrefix(&quot;jobs&quot;) {
      concat(
        pathEnd {
          concat(
            post {
              entity(as[JobRepository.Job]) { job =&gt;
                val operationPerformed: Future[JobRepository.Response] =
                  buildJobRepository.ask(JobRepository.AddJob(job, _))
                onSuccess(operationPerformed) {
                  case JobRepository.OK         =&gt; complete(&quot;Job added&quot;)
                  case JobRepository.KO(reason) =&gt; complete(StatusCodes.InternalServerError -&gt; reason)
                }
              }
            },
            delete {
              val operationPerformed: Future[JobRepository.Response] =
                buildJobRepository.ask(JobRepository.ClearJobs(_))
              onSuccess(operationPerformed) {
                case JobRepository.OK         =&gt; complete(&quot;Jobs cleared&quot;)
                case JobRepository.KO(reason) =&gt; complete(StatusCodes.InternalServerError -&gt; reason)
              }
            })
        },
        (get &amp; path(LongNumber)) { id =&gt;
          val maybeJob: Future[Option[JobRepository.Job]] =
            buildJobRepository.ask(JobRepository.GetJobById(id, _))
          rejectEmptyResponse {
            complete(maybeJob)
          }
        })
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/JobRoutes.java#L17-L108" target="_blank" title="Go to snippet source">source</a><code class="language-java">import java.time.Duration;
import java.util.Optional;
import java.util.concurrent.CompletionStage;

import org.apache.pekko.actor.typed.ActorRef;
import org.apache.pekko.actor.typed.ActorSystem;
import org.apache.pekko.actor.typed.javadsl.AskPattern;

import org.apache.pekko.http.javadsl.marshallers.jackson.Jackson;
import org.apache.pekko.http.javadsl.model.StatusCodes;
import org.apache.pekko.http.javadsl.server.Route;

import static org.apache.pekko.http.javadsl.server.Directives.*;
import static org.apache.pekko.http.javadsl.unmarshalling.StringUnmarshallers.LONG;

/**
 * Routes for use with the HttpServerWithActorsSample
 */
public class JobRoutes {
  private final ActorSystem&lt;?&gt; system;
  private final ActorRef&lt;JobRepository.Command&gt; buildJobRepository;

  public JobRoutes(ActorRef&lt;JobRepository.Command&gt; buildJobRepository, ActorSystem&lt;?&gt; system) {
    this.system = system;
    this.buildJobRepository = buildJobRepository;
  }

  private Route addOrDelete() {
    return concat(
            post(() -&gt;
                    entity(Jackson.unmarshaller(JobRepository.Job.class), job -&gt;
                      onSuccess(add(job), r -&gt; complete(&quot;Job added&quot;))
                    )),
            delete(() -&gt; onSuccess(deleteAll(), r -&gt; complete(&quot;Jobs cleared&quot;)))
    );
  }

  private CompletionStage&lt;JobRepository.OK&gt; add(JobRepository.Job job) {
    return handleKO(AskPattern.ask(
            buildJobRepository,
            replyTo -&gt; new JobRepository.AddJob(job, replyTo),
            Duration.ofSeconds(3),
            system.scheduler()));
  }

  private CompletionStage&lt;JobRepository.OK&gt; deleteAll() {
    return handleKO(AskPattern.ask(
            buildJobRepository,
            JobRepository.ClearJobs::new,
            Duration.ofSeconds(3),
            system.scheduler()));
  }

  public Route jobRoutes() {
    return pathPrefix(&quot;jobs&quot;, () -&gt;
            concat(
                    pathEnd(this::addOrDelete),
                    get(() -&gt;
                            path(LONG, jobId -&gt;
                              onSuccess(getJob(jobId), jobOption -&gt; {
                                if (jobOption.isPresent()) {
                                  return complete(StatusCodes.OK, jobOption.get(), Jackson.&lt;JobRepository.Job&gt;marshaller());
                                } else {
                                  return complete(StatusCodes.NOT_FOUND);
                                }
                              })
                            )
                    )
            )
    );
  }

  private CompletionStage&lt;Optional&lt;JobRepository.Job&gt;&gt; getJob(Long jobId) {
    return AskPattern.ask(
            buildJobRepository,
            replyTo -&gt; new JobRepository.GetJobById(jobId, replyTo),
            Duration.ofSeconds(3),
            system.scheduler());
  }

  private CompletionStage&lt;JobRepository.OK&gt; handleKO(CompletionStage&lt;JobRepository.Response&gt; stage) {
    return stage.thenApply(response -&gt; {
      if (response instanceof JobRepository.OK) {
        return (JobRepository.OK)response;
      } else if (response instanceof JobRepository.KO) {
        throw new IllegalStateException(((JobRepository.KO) response).reason);
      } else {
        throw new IllegalStateException(&quot;Invalid response&quot;);
      }
    });
  }
}</code></pre></dd>
</dl>
<p>Finally, we create a <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0/org/apache/pekko/actor/typed/Behavior.html" title="org.apache.pekko.actor.typed.Behavior"><code>Behavior</code></a></span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/0.0/org/apache/pekko/actor/typed/Behavior.html" title="org.apache.pekko.actor.typed.Behavior"><code>Behavior</code></a></span> that bootstraps the web server and use it as the root behavior of our actor system:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/HttpServerWithActorsSample.scala#L150-L215" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko
import pekko.actor.typed.PostStop
import pekko.http.scaladsl.Http.ServerBinding
import pekko.http.scaladsl.Http

import scala.util.{ Failure, Success }

object Server {

  sealed trait Message
  private final case class StartFailed(cause: Throwable) extends Message
  private final case class Started(binding: ServerBinding) extends Message
  case object Stop extends Message

  def apply(host: String, port: Int): Behavior[Message] = Behaviors.setup { ctx =&gt;
    implicit val system = ctx.system

    val buildJobRepository = ctx.spawn(JobRepository(), &quot;JobRepository&quot;)
    val routes = new JobRoutes(buildJobRepository)

    val serverBinding: Future[Http.ServerBinding] =
      Http().newServerAt(host, port).bind(routes.theJobRoutes)
    ctx.pipeToSelf(serverBinding) {
      case Success(binding) =&gt; Started(binding)
      case Failure(ex)      =&gt; StartFailed(ex)
    }

    def running(binding: ServerBinding): Behavior[Message] =
      Behaviors.receiveMessagePartial[Message] {
        case Stop =&gt;
          ctx.log.info(
            &quot;Stopping server http://{}:{}/&quot;,
            binding.localAddress.getHostString,
            binding.localAddress.getPort)
          Behaviors.stopped
      }.receiveSignal {
        case (_, PostStop) =&gt;
          binding.unbind()
          Behaviors.same
      }

    def starting(wasStopped: Boolean): Behaviors.Receive[Message] =
      Behaviors.receiveMessage[Message] {
        case StartFailed(cause) =&gt;
          throw new RuntimeException(&quot;Server failed to start&quot;, cause)
        case Started(binding) =&gt;
          ctx.log.info(
            &quot;Server online at http://{}:{}/&quot;,
            binding.localAddress.getHostString,
            binding.localAddress.getPort)
          if (wasStopped) ctx.self ! Stop
          running(binding)
        case Stop =&gt;
          // we got a stop message but haven&#39;t completed starting yet,
          // we cannot stop until starting has completed
          starting(wasStopped = true)
      }

    starting(wasStopped = false)
  }
}

def main(args: Array[String]): Unit = {
  val system: ActorSystem[Server.Message] =
    ActorSystem(Server(&quot;localhost&quot;, 8080), &quot;BuildJobsServer&quot;)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/HttpServerWithActorsSample.java#L24-L117" target="_blank" title="Go to snippet source">source</a><code class="language-java"><br/>import org.apache.pekko.actor.typed.ActorRef;
import org.apache.pekko.actor.typed.ActorSystem;
import org.apache.pekko.actor.typed.Behavior;
import org.apache.pekko.actor.typed.PostStop;
import org.apache.pekko.actor.typed.javadsl.BehaviorBuilder;
import org.apache.pekko.actor.typed.javadsl.Behaviors;
import org.apache.pekko.http.javadsl.Http;
import org.apache.pekko.http.javadsl.ServerBinding;
import org.apache.pekko.http.javadsl.server.Route;

import java.util.concurrent.CompletionStage;

public class HttpServerWithActorsSample {

  interface Message {}

  private static final class StartFailed implements Message {
    final Throwable ex;

    public StartFailed(Throwable ex) {
      this.ex = ex;
    }
  }

  private static final class Started implements Message {
    final ServerBinding binding;

    public Started(ServerBinding binding) {
      this.binding = binding;
    }
  }

  private static final class Stop implements Message {}

  public static Behavior&lt;Message&gt; create(String host, Integer port) {
    return Behaviors.setup(ctx -&gt; {
      ActorSystem&lt;Void&gt; system = ctx.getSystem();
      ActorRef&lt;JobRepository.Command&gt; buildJobRepository = ctx.spawn(JobRepository.create(), &quot;JobRepository&quot;);
      Route routes = new JobRoutes(buildJobRepository, ctx.getSystem()).jobRoutes();

      CompletionStage&lt;ServerBinding&gt; serverBinding =
              Http.get(system)
                .newServerAt(host, port)
                .bind(routes);

      ctx.pipeToSelf(serverBinding, (binding, failure) -&gt; {
        if (binding != null) return new Started(binding);
        else return new StartFailed(failure);
      });

      return starting(false);
    });
  }

  private static Behavior&lt;Message&gt; starting(boolean wasStopped) {
    return Behaviors.setup(ctx -&gt;
            BehaviorBuilder.&lt;Message&gt;create()
                    .onMessage(StartFailed.class, failed -&gt; {
                      throw new RuntimeException(&quot;Server failed to start&quot;, failed.ex);
                    })
                    .onMessage(Started.class, msg -&gt; {
                      ctx.getLog().info(
                              &quot;Server online at http://{}:{}&quot;,
                              msg.binding.localAddress().getAddress(),
                              msg.binding.localAddress().getPort());

                      if (wasStopped) ctx.getSelf().tell(new Stop());

                      return running(msg.binding);
                    })
                    .onMessage(Stop.class, s -&gt; {
                      // we got a stop message but haven&#39;t completed starting yet,
                      // we cannot stop until starting has completed
                      return starting(true);
                    })
                    .build());
  }

  private static Behavior&lt;Message&gt; running(ServerBinding binding) {
    return BehaviorBuilder.&lt;Message&gt;create()
            .onMessage(Stop.class, msg -&gt; Behaviors.stopped())
            .onSignal(PostStop.class, msg -&gt; {
              binding.unbind();
              return Behaviors.same();
            })
            .build();
  }

  public static void main(String[] args) {
    ActorSystem&lt;Message&gt; system = ActorSystem.create(
            HttpServerWithActorsSample.create(&quot;localhost&quot;, 8080), &quot;BuildJobsServer&quot;);
  }
}</code></pre></dd>
</dl>
<h2><a href="#dynamic-routing-example" name="dynamic-routing-example" class="anchor"><span class="anchor-link"></span></a>Dynamic Routing Example</h2>
<p>As the routes are evaluated for each request, it is possible to make changes at runtime. Please note that every access may happen on a separated thread, so any shared mutable state must be thread safe.</p>
<p>The following is an Apache Pekko HTTP route definition that allows dynamically adding new or updating mock endpoints with associated request-response pairs at runtime.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/HttpServerExampleSpec.scala#L447-L478" target="_blank" title="Go to snippet source">source</a><code class="language-scala">case class MockDefinition(path: String, requests: Seq[JsValue], responses: Seq[JsValue])
implicit val format = jsonFormat3(MockDefinition)

@volatile var state = Map.empty[String, Map[JsValue, JsValue]]

// fixed route to update state
val fixedRoute: Route = post {
  pathSingleSlash {
    entity(as[MockDefinition]) { mock =&gt;
      val mapping = mock.requests.zip(mock.responses).toMap
      state = state + (mock.path -&gt; mapping)
      complete(&quot;ok&quot;)
    }
  }
}

// dynamic routing based on current state
val dynamicRoute: Route = ctx =&gt; {
  val routes = state.map {
    case (segment, responses) =&gt;
      post {
        path(segment) {
          entity(as[JsValue]) { input =&gt;
            complete(responses.get(input))
          }
        }
      }
  }
  concat(routes.toList: _*)(ctx)
}

val route = fixedRoute ~ dynamicRoute</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/HttpServerDynamicRoutingExampleTest.java#L47-L103" target="_blank" title="Go to snippet source">source</a><code class="language-java">final private Map&lt;String, Map&lt;JsonNode, JsonNode&gt;&gt; state = new ConcurrentHashMap&lt;&gt;();

private Route createRoute() {
  // fixed route to update state
  Route fixedRoute = post(() -&gt;
    pathSingleSlash(() -&gt;
      entity(Jackson.unmarshaller(MockDefinition.class), mock -&gt; {
        Map&lt;JsonNode, JsonNode&gt; mappings = new HashMap&lt;&gt;();
        int size = Math.min(mock.getRequests().size(), mock.getResponses().size());
        for (int i = 0; i &lt; size; i++) {
          mappings.put(mock.getRequests().get(i), mock.getResponses().get(i));
        }
        state.put(mock.getPath(), mappings);
        return complete(&quot;ok&quot;);
      })
    )
  );

  // dynamic routing based on current state
  Route dynamicRoute = post(() -&gt;
    state.entrySet().stream().map(mock -&gt;
      path(mock.getKey(), () -&gt;
        entity(Jackson.unmarshaller(JsonNode.class), input -&gt;
          complete(StatusCodes.OK, mock.getValue().get(input), Jackson.marshaller())
        )
      )
    ).reduce(reject(), Route::orElse)
  );

  return concat(fixedRoute, dynamicRoute);
}

private static class MockDefinition {
  private final String path;
  private final List&lt;JsonNode&gt; requests;
  private final List&lt;JsonNode&gt; responses;

  public MockDefinition(@JsonProperty(&quot;path&quot;) String path,
                        @JsonProperty(&quot;requests&quot;) List&lt;JsonNode&gt; requests,
                        @JsonProperty(&quot;responses&quot;) List&lt;JsonNode&gt; responses) {
    this.path = path;
    this.requests = requests;
    this.responses = responses;
  }

  public String getPath() {
    return path;
  }

  public List&lt;JsonNode&gt; getRequests() {
    return requests;
  }

  public List&lt;JsonNode&gt; getResponses() {
    return responses;
  }
}</code></pre></dd>
</dl>
<p>For example, let&rsquo;s say we do a POST request with body:</p>
<pre class="prettyprint"><code class="language-json">{
  &quot;path&quot;: &quot;test&quot;,
  &quot;requests&quot;: [
    {&quot;id&quot;: 1},
    {&quot;id&quot;: 2}
  ],
  &quot;responses&quot;: [
    {&quot;amount&quot;: 1000},
    {&quot;amount&quot;: 2000}
  ]
}
</code></pre>
<p>Subsequent POST request to <code>/test</code> with body <code>{&quot;id&quot;: 1}</code> will be responded with <code>{&quot;amount&quot;: 1000}</code>.</p>
<h2><a href="#handling-http-server-failures-in-the-high-level-api" name="handling-http-server-failures-in-the-high-level-api" class="anchor"><span class="anchor-link"></span></a>Handling HTTP Server failures in the High-Level API</h2>
<p>There are various situations when failure may occur while initialising or running an Apache Pekko HTTP server. Apache Pekko by default will log all these failures, however sometimes one may want to react to failures in addition to them just being logged, for example by shutting down the actor system, or notifying some external monitoring end-point explicitly.</p>
<h3><a href="#bind-failures" name="bind-failures" class="anchor"><span class="anchor-link"></span></a>Bind failures</h3>
<p>For example the server might be unable to bind to the given port. For example when the port is already taken by another application, or if the port is privileged (i.e. only usable by <code>root</code>). In this case the &ldquo;binding future&rdquo; will fail immediately, and we can react to it by listening on the <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span>&rsquo;s completion:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/HttpServerBindingFailure.scala" target="_blank" title="Go to snippet source">source</a><code class="language-scala">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * license agreements; and to You under the Apache License, version 2.0:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * This file is part of the Apache Pekko project, derived from Akka.
 */

/*
 * Copyright (C) 2020-2022 Lightbend Inc. &lt;https://www.lightbend.com&gt;
 */

package docs.http.scaladsl

import org.apache.pekko
import pekko.actor.ActorSystem
import pekko.http.scaladsl.Http
import pekko.http.scaladsl.Http.ServerBinding
import pekko.http.scaladsl.server.Directives._

import scala.concurrent.Future

object HttpServerBindingFailure {
  def main(args: Array[String]): Unit = {
    implicit val system = ActorSystem()
    // needed for the future foreach in the end
    implicit val executionContext = system.dispatcher

    val handler = get {
      complete(&quot;Hello world!&quot;)
    }

    // let&#39;s say the OS won&#39;t allow us to bind to 80.
    val (host, port) = (&quot;localhost&quot;, 80)
    val bindingFuture: Future[ServerBinding] =
      Http().newServerAt(host, port).bindFlow(handler)

    bindingFuture.failed.foreach { ex =&gt;
      system.log.error(ex, &quot;Failed to bind to {}:{}!&quot;, host, port)
    }
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/server/HighLevelServerBindFailureExample.java#L17-L45" target="_blank" title="Go to snippet source">source</a><code class="language-java"><br/>import org.apache.pekko.actor.ActorSystem;
import org.apache.pekko.http.javadsl.Http;
import org.apache.pekko.http.javadsl.ServerBinding;
import org.apache.pekko.http.javadsl.server.Route;

import java.io.IOException;
import java.util.concurrent.CompletionStage;

public class HighLevelServerBindFailureExample {
  public static void main(String[] args) throws IOException {
    // boot up server using the route as defined below
    final ActorSystem system = ActorSystem.create();

    final HighLevelServerExample app = new HighLevelServerExample();
    final Route route = app.createRoute();

    final CompletionStage&lt;ServerBinding&gt; binding =
        Http.get(system).newServerAt(&quot;127.0.0.1&quot;, 8080).bind(route);

    binding.exceptionally(failure -&gt; {
      System.err.println(&quot;Something very bad happened! &quot; + failure.getMessage());
      system.terminate();
      return null;
    });

    system.terminate();
  }
}</code></pre></dd>
</dl><div class="callout note "><div class="callout-title">Note</div>
<p>For a more low-level overview of the kinds of failures that can happen and also more fine-grained control over them refer to the <a href="../server-side/low-level-api.html#handling-http-server-failures-low-level">Handling HTTP Server failures in the Low-Level API</a> documentation.</p></div>
<h3><a href="#failures-and-exceptions-inside-the-routing-dsl" name="failures-and-exceptions-inside-the-routing-dsl" class="anchor"><span class="anchor-link"></span></a>Failures and exceptions inside the Routing DSL</h3>
<p>Exception handling within the Routing DSL is done by providing <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/server/ExceptionHandler.html" title="org.apache.pekko.http.javadsl.server.ExceptionHandler"><code>ExceptionHandler</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/server/ExceptionHandler.html" title="org.apache.pekko.http.scaladsl.server.ExceptionHandler"><code>ExceptionHandler</code></a></span> s which are documented in-depth in the <a href="exception-handling.html">Exception Handling</a> section of the documentation. You can use them to transform exceptions into <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/model/HttpResponse.html" title="org.apache.pekko.http.javadsl.model.HttpResponse"><code>HttpResponse</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/model/HttpResponse.html" title="org.apache.pekko.http.scaladsl.model.HttpResponse"><code>HttpResponse</code></a></span> s with appropriate error codes and human-readable failure descriptions.</p>
<h2><a href="#file-uploads" name="file-uploads" class="anchor"><span class="anchor-link"></span></a>File uploads</h2>
<p>For high level directives to handle uploads see the <a href="directives/file-upload-directives/index.html">FileUploadDirectives</a>.</p>
<p>Handling a simple file upload from for example a browser form with a <em>file</em> input can be done by accepting a <em>Multipart.FormData</em> entity, note that the body parts are <em>Source</em> rather than all available right away, and so is the individual body part payload so you will need to consume those streams both for the file and for the form fields.</p>
<p>Here is a simple example which just dumps the uploaded file into a temporary file on disk, collects some form fields and saves an entry to a fictive database:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/server/FileUploadExamplesSpec.scala#L41-L76" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val uploadVideo =
  path(&quot;video&quot;) {
    entity(as[Multipart.FormData]) { formData =&gt;
      // collect all parts of the multipart as it arrives into a map
      val allPartsF: Future[Map[String, Any]] = formData.parts.mapAsync[(String, Any)](1) {

        case b: BodyPart if b.name == &quot;file&quot; =&gt;
          // stream into a file as the chunks of it arrives and return a future
          // file to where it got stored
          val file = File.createTempFile(&quot;upload&quot;, &quot;tmp&quot;)
          b.entity.dataBytes.runWith(FileIO.toPath(file.toPath)).map(_ =&gt;
            b.name -&gt; file)

        case b: BodyPart =&gt;
          // collect form field values
          b.toStrict(2.seconds).map(strict =&gt;
            b.name -&gt; strict.entity.data.utf8String)

      }.runFold(Map.empty[String, Any])((map, tuple) =&gt; map + tuple)

      val done = allPartsF.map { allParts =&gt;
        // You would have some better validation/unmarshalling here
        db.create(Video(
          file = allParts(&quot;file&quot;).asInstanceOf[File],
          title = allParts(&quot;title&quot;).asInstanceOf[String],
          author = allParts(&quot;author&quot;).asInstanceOf[String]))
      }

      // when processing have finished create a response for the user
      onSuccess(allPartsF) { allParts =&gt;
        complete {
          &quot;ok!&quot;
        }
      }
    }
  }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/server/FileUploadExamplesTest.java#L43-L107" target="_blank" title="Go to snippet source">source</a><code class="language-java">import static org.apache.pekko.http.javadsl.server.Directives.complete;
import static org.apache.pekko.http.javadsl.server.Directives.entity;
import static org.apache.pekko.http.javadsl.server.Directives.onSuccess;
import static org.apache.pekko.http.javadsl.server.Directives.path;

  path(&quot;video&quot;, () -&gt;
  entity(Unmarshaller.entityToMultipartFormData(), formData -&gt; {
    // collect all parts of the multipart as it arrives into a map
    final CompletionStage&lt;Map&lt;String, Object&gt;&gt; allParts =
      formData.getParts().mapAsync(1, bodyPart -&gt; {
        if (&quot;file&quot;.equals(bodyPart.getName())) {
          // stream into a file as the chunks of it arrives and return a CompletionStage
          // file to where it got stored
          final File file = File.createTempFile(&quot;upload&quot;, &quot;tmp&quot;);
          return bodyPart.getEntity().getDataBytes()
            .runWith(FileIO.toPath(file.toPath()), materializer)
            .thenApply(ignore -&gt;
              new Pair&lt;String, Object&gt;(bodyPart.getName(), file)
            );
        } else {
          // collect form field values
          return bodyPart.toStrict(2 * 1000, materializer)
            .thenApply(strict -&gt;
              new Pair&lt;String, Object&gt;(bodyPart.getName(),
                strict.getEntity().getData().utf8String())
            );
        }
      }).runFold(new HashMap&lt;String, Object&gt;(), (acc, pair) -&gt; {
        acc.put(pair.first(), pair.second());
        return acc;
      }, materializer);

    // simulate a DB call
    final CompletionStage&lt;Void&gt; done = allParts.thenCompose(map -&gt;
      // You would have some better validation/unmarshalling here
      DB.create((File) map.get(&quot;file&quot;),
        (String) map.get(&quot;title&quot;),
        (String) map.get(&quot;author&quot;)
      ));

    // when processing have finished create a response for the user
    return onSuccess(allParts, x -&gt; complete(&quot;ok!&quot;));
  })
);</code></pre></dd>
</dl>
<p>You can transform the uploaded files as they arrive rather than storing them in a temporary file as in the previous example. In this example we accept any number of <code>.csv</code> files, parse those into lines and split each line before we send it to an actor for further processing:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/server/FileUploadExamplesSpec.scala#L87-L109" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val splitLines = Framing.delimiter(ByteString(&quot;\n&quot;), 256)

val csvUploads =
  path(&quot;metadata&quot; / LongNumber) { id =&gt;
    entity(as[Multipart.FormData]) { formData =&gt;
      val done: Future[Done] = formData.parts.mapAsync(1) {
        case b: BodyPart if b.filename.exists(_.endsWith(&quot;.csv&quot;)) =&gt;
          b.entity.dataBytes
            .via(splitLines)
            .map(_.utf8String.split(&quot;,&quot;).toVector)
            .runForeach(csv =&gt;
              metadataActor ! MetadataActor.Entry(id, csv))
        case _ =&gt; Future.successful(Done)
      }.runWith(Sink.ignore)

      // when processing have finished create a response for the user
      onSuccess(done) { _ =&gt;
        complete {
          &quot;ok!&quot;
        }
      }
    }
  }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/server/FileUploadExamplesTest.java#L51-L147" target="_blank" title="Go to snippet source">source</a><code class="language-java">import static org.apache.pekko.http.javadsl.server.Directives.complete;
import static org.apache.pekko.http.javadsl.server.Directives.entity;
import static org.apache.pekko.http.javadsl.server.Directives.onComplete;
import static org.apache.pekko.http.javadsl.server.Directives.path;

Route csvUploads() {
  final Flow&lt;ByteString, ByteString, NotUsed&gt; splitLines =
    Framing.delimiter(ByteString.fromString(&quot;\n&quot;), 256);

  return path(segment(&quot;metadata&quot;).slash(longSegment()), id -&gt;
    entity(Unmarshaller.entityToMultipartFormData(), formData -&gt; {

      final CompletionStage&lt;Done&gt; done = formData.getParts().mapAsync(1, bodyPart -&gt;
        bodyPart.getFilename().filter(name -&gt; name.endsWith(&quot;.csv&quot;)).map(ignored -&gt;
          bodyPart.getEntity().getDataBytes()
            .via(splitLines)
            .map(bs -&gt; bs.utf8String().split(&quot;,&quot;))
            .runForeach(csv -&gt;
                metadataActor.tell(new Entry(id, csv), ActorRef.noSender()),
              materializer)
        ).orElseGet(() -&gt;
          // in case the uploaded file is not a CSV
          CompletableFuture.completedFuture(Done.getInstance()))
      ).runWith(Sink.ignore(), materializer);

      // when processing have finished create a response for the user
      return onComplete(() -&gt; done, ignored -&gt; complete(&quot;ok!&quot;));
    })
  );
}</code></pre></dd>
</dl>
<h2><a href="#configuring-server-side-https" name="configuring-server-side-https" class="anchor"><span class="anchor-link"></span></a>Configuring Server-side HTTPS</h2>
<p>For detailed documentation about configuring and using HTTPS on the server-side refer to <a href="../server-side/server-https-support.html">Server-Side HTTPS Support</a>.</p>
</div>
<div>
<a href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/main/paradox/routing-dsl/index.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.0.0+4308-98f0ff9c*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../server-side/index.html" title="4. Server API" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
4. Server API
</span>
</div>
</a>
<a href="../routing-dsl/overview.html" title="Routing DSL Overview" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Routing DSL Overview
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
Copyright Â© 2022, 2023 <a href="https://apache.org">The Apache Software Foundation</a>, Licensed under the Apache License, Version 2.0.
 This product contains significant parts that were originally based on software from Lightbend (<a href="https://akka.io/">Akka</a>).
 Copyright (C) 2009-2022 Lightbend Inc. &lt;https://www.lightbend.com&gt; Apache Pekko is derived from Akka 2.6.x,
 the last version that was distributed under the Apache License, Version 2.0 License.
</div>
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../assets/javascripts/groups.js"></script>

<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
