<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="Apache Pekko Http: Modern, fast, asynchronous, streaming-first HTTP server and client.">
<meta name="generator" content="Paradox, paradox-material-theme=0.6.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="Apache Pekko Http: Modern, fast, asynchronous, streaming-first HTTP server and client.">
<link rel="shortcut icon" href="../assets/images/pekko_favicon.png">
<title>Host-Level Client-Side API Â· Apache Pekko HTTP</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../assets/stylesheets/application-palette.22915126.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
<link rel="stylesheet" href="../assets/stylesheets/pekko-theme.css">
</head>
<body
data-md-color-primary="white"
data-md-color-accent="orange"
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="Apache Pekko HTTP" class="md-header-nav__button md-logo">
<img src="../assets/images/pekko_logo.png" width="24" height="24">
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Apache Pekko HTTP
</span>
<span class="md-header-nav__topic">
Host-Level Client-Side API
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/apache/incubator-pekko-http"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko-http
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="Apache Pekko HTTP" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<img src="../assets/images/pekko_logo.png" width="24" height="24">
</a>
<a href="../index.html" title="Apache Pekko HTTP">
Apache Pekko HTTP
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/apache/incubator-pekko-http"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko-http
</div>
</a>

</div>
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
<ul>
  <li><a href="../security.html" class="page">! Security Announcements !</a>
  <ul>
    <li><a href="../security.html#receiving-security-advisories" class="header">Receiving Security Advisories</a></li>
    <li><a href="../security.html#reporting-vulnerabilities" class="header">Reporting Vulnerabilities</a></li>
    <li><a href="../security.html#references" class="header">References</a></li>
  </ul></li>
  <li><a href="../release-notes/index.html" class="page">0. Release Notes</a></li>
  <li><a href="../introduction.html" class="page">1. Introduction</a>
  <ul>
    <li><a href="../introduction.html#philosophy" class="header">Philosophy</a></li>
    <li><a href="../introduction.html#using-apache-pekko-http" class="header">Using Apache Pekko HTTP</a></li>
    <li><a href="../introduction.html#routing-dsl-for-http-servers" class="header">Routing DSL for HTTP servers</a></li>
    <li><a href="../introduction.html#marshalling" class="header">Marshalling</a></li>
    <li><a href="../introduction.html#streaming" class="header">Streaming</a></li>
    <li><a href="../introduction.html#low-level-http-server-apis" class="header">Low-level HTTP server APIs</a></li>
    <li><a href="../introduction.html#http-client-api" class="header">HTTP Client API</a></li>
    <li><a href="../introduction.html#the-modules-that-make-up-apache-pekko-http" class="header">The modules that make up Apache Pekko HTTP</a></li>
  </ul></li>
  <li><a href="../usage.html" class="page">2. Usage</a>
  <ul>
    <li><a href="../configuration.html" class="page">Configuration</a></li>
    <li><a href="../migration-guide/index.html" class="page">Migration Guides</a></li>
    <li><a href="../compatibility-guidelines.html" class="page">Compatibility Guidelines</a></li>
  </ul></li>
  <li><a href="../common/index.html" class="page">3. Data Types &amp; Abstractions</a>
  <ul>
    <li><a href="../common/http-model.html" class="page">HTTP Model</a></li>
    <li><a href="../common/uri-model.html" class="page">The URI model</a></li>
    <li><a href="../common/marshalling.html" class="page">Marshalling</a></li>
    <li><a href="../common/unmarshalling.html" class="page">Unmarshalling</a></li>
    <li><a href="../common/encoding.html" class="page">Encoding / Decoding</a></li>
    <li><a href="../common/json-support.html" class="page">JSON Support</a></li>
    <li><a href="../common/xml-support.html" class="page">XML Support</a></li>
    <li><a href="../common/sse-support.html" class="page">Server-Sent Events Support</a></li>
    <li><a href="../common/timeouts.html" class="page">Timeouts</a></li>
    <li><a href="../common/caching.html" class="page">Caching</a></li>
  </ul></li>
  <li><a href="../server-side/index.html" class="page">4. Server API</a>
  <ul>
    <li><a href="../routing-dsl/index.html" class="page">Routing DSL</a></li>
    <li><a href="../server-side/low-level-api.html" class="page">Core Server API</a></li>
    <li><a href="../server-side/websocket-support.html" class="page">Server WebSocket Support</a></li>
    <li><a href="../server-side/server-https-support.html" class="page">Server HTTPS Support</a></li>
    <li><a href="../server-side/graceful-termination.html" class="page">Graceful termination</a></li>
    <li><a href="../server-side/http2.html" class="page">Server-Side HTTP/2 (Preview)</a></li>
  </ul></li>
  <li><a href="../client-side/index.html" class="page">5. Client API</a>
  <ul>
    <li><a href="../client-side/configuration.html" class="page">Configuration</a></li>
    <li><a href="../client-side/request-and-response.html" class="page">HttpRequest and HttpResponse</a></li>
    <li><a href="../client-side/request-level.html" class="page">Request-Level Client-Side API</a></li>
    <li><a href="../client-side/host-level.html#host-level-client-side-api" class="active page">Host-Level Client-Side API</a></li>
    <li><a href="../client-side/connection-level.html" class="page">Connection-Level Client-Side API</a></li>
    <li><a href="../client-side/pool-overflow.html" class="page">Pool overflow and the max-open-requests setting</a></li>
    <li><a href="../client-side/client-https-support.html" class="page">Client-Side HTTPS Support</a></li>
    <li><a href="../client-side/client-transport.html" class="page">Pluggable Client Transports / HTTP(S) proxy Support</a></li>
    <li><a href="../client-side/websocket-support.html" class="page">Client-Side WebSocket Support</a></li>
    <li><a href="../client-side/http2.html" class="page">Client-Side HTTP/2 (Preview)</a></li>
  </ul></li>
  <li><a href="../extensions.html" class="page">6. Extensions</a></li>
  <li><a href="../technologies.html" class="page">7. Supported Technologies</a>
  <ul>
    <li><a href="../technologies.html#http" class="header">HTTP</a></li>
    <li><a href="../technologies.html#https" class="header">HTTPS</a></li>
    <li><a href="../technologies.html#websocket" class="header">WebSocket</a></li>
    <li><a href="../technologies.html#http-2" class="header">HTTP/2</a></li>
    <li><a href="../technologies.html#dns" class="header">DNS</a></li>
    <li><a href="../technologies.html#multipart" class="header">Multipart</a></li>
    <li><a href="../technologies.html#server-sent-events-sse-" class="header">Server-sent Events (SSE)</a></li>
    <li><a href="../technologies.html#json" class="header">JSON</a></li>
    <li><a href="../technologies.html#xml" class="header">XML</a></li>
    <li><a href="../technologies.html#gzip-and-deflate-content-encoding" class="header">Gzip and Deflate Content-Encoding</a></li>
  </ul></li>
  <li><a href="../tipsandtricks.html" class="page">8. Tips And Tricks</a>
  <ul>
    <li><a href="../troubleshooting/index.html" class="page">Troubleshooting</a></li>
    <li><a href="../handling-blocking-operations-in-pekko-http-routes.html" class="page">Handling blocking operations in Apache Pekko HTTP</a></li>
    <li><a href="../implications-of-streaming-http-entity.html" class="page">Implications of the streaming nature of Request/Response Entities</a></li>
  </ul></li>
  <li><a href="../contributing.html" class="page">9. Contributing</a>
  <ul>
    <li><a href="../contributing.html#welcome-" class="header">Welcome!</a></li>
    <li><a href="../contributing.html#snapshots" class="header">Snapshots</a></li>
  </ul></li>
  <li><a href="../reference.html" class="page">10. Reference</a>
  <ul>
    <li><a href="../reference.html#api-documentation" class="header">API Documentation</a></li>
    <li><a href="../reference.html#directives" class="header">Directives</a></li>
    <li><a href="../reference.html#books" class="header">Books</a></li>
  </ul></li>
</ul>

<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../client-side/host-level.html#host-level-client-side-api" class="header">Host-Level Client-Side API</a>
  <ul>
    <li><a href="../client-side/host-level.html#requesting-a-host-connection-pool" class="header">Requesting a Host Connection Pool</a></li>
    <li><a href="../client-side/host-level.html#configuring-a-host-connection-pool" class="header">Configuring a Host Connection Pool</a></li>
    <li><a href="../client-side/host-level.html#using-a-host-connection-pool" class="header">Using a Host Connection Pool</a></li>
    <li><a href="../client-side/host-level.html#connection-allocation-logic" class="header">Connection Allocation Logic</a></li>
    <li><a href="../client-side/host-level.html#retrying-a-request" class="header">Retrying a Request</a></li>
    <li><a href="../client-side/host-level.html#pool-shutdown" class="header">Pool Shutdown</a></li>
    <li><a href="../client-side/host-level.html#examples" class="header">Examples</a></li>
  </ul></li>
</ul>
</nav>


<ul class="md-nav__list md-nav__links">
<li class="md-nav__item"><a href="https://apache.org"><i class="md-icon">link</i> Apache Software Foundation</a></li>
<li class="md-nav__item"><a href="https://apache.org/licenses/"><i class="md-icon">link</i>&nbsp;License</a></li>
<li class="md-nav__item"><a href="https://apache.org/security/"><i class="md-icon">link</i>&nbsp;Security</a></li>
<li class="md-nav__item"><a href="https://www.apache.org/foundation/sponsorship.html"><i class="md-icon">link</i>&nbsp;Donate</a></li>
<li class="md-nav__item"><a href="https://www.apache.org/foundation/thanks.html"><i class="md-icon">link</i>&nbsp;Thanks</a></li>
</ul>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 0.0.0+4308-98f0ff9c*
</label>
</li>
</ul>

</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../client-side/host-level.html#host-level-client-side-api" class="header">Host-Level Client-Side API</a>
  <ul>
    <li><a href="../client-side/host-level.html#requesting-a-host-connection-pool" class="header">Requesting a Host Connection Pool</a></li>
    <li><a href="../client-side/host-level.html#configuring-a-host-connection-pool" class="header">Configuring a Host Connection Pool</a></li>
    <li><a href="../client-side/host-level.html#using-a-host-connection-pool" class="header">Using a Host Connection Pool</a></li>
    <li><a href="../client-side/host-level.html#connection-allocation-logic" class="header">Connection Allocation Logic</a></li>
    <li><a href="../client-side/host-level.html#retrying-a-request" class="header">Retrying a Request</a></li>
    <li><a href="../client-side/host-level.html#pool-shutdown" class="header">Pool Shutdown</a></li>
    <li><a href="../client-side/host-level.html#examples" class="header">Examples</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#host-level-client-side-api" name="host-level-client-side-api" class="anchor"><span class="anchor-link"></span></a>Host-Level Client-Side API</h1>
<p>As opposed to the <a href="connection-level.html">Connection-Level Client-Side API</a> the host-level API relieves you from manually managing individual HTTP connections. It autonomously manages a configurable pool of connections to <em>one particular target endpoint</em> (i.e. host/port combination).</p><div class="callout note "><div class="callout-title">Note</div>
<p>It is recommended to first read the <a href="../implications-of-streaming-http-entity.html">Implications of the streaming nature of Request/Response Entities</a> section, as it explains the underlying full-stack streaming concepts, which may be unexpected when coming from a background with non-&ldquo;streaming first&rdquo; HTTP Clients.</p></div>
<h2><a href="#requesting-a-host-connection-pool" name="requesting-a-host-connection-pool" class="anchor"><span class="anchor-link"></span></a>Requesting a Host Connection Pool</h2>
<p>The best way to get a hold of a connection pool to a given target endpoint is the <span class="group-scala"><code>Http().cachedHostConnectionPool(...)</code></span><span class="group-java"><code>Http.get(system).cachedHostConnectionPool(...)</code></span> method, which returns a <span class="group-java"><a href="https://pekko.apache.org/japi/pekko/0.0/org/apache/pekko/stream/javadsl/Flow.html" title="org.apache.pekko.stream.javadsl.Flow"><code>Flow</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0/org/apache/pekko/stream/scaladsl/Flow.html" title="org.apache.pekko.stream.scaladsl.Flow"><code>Flow</code></a></span> that can be &ldquo;baked&rdquo; into an application-level stream setup. This flow is also called a &ldquo;pool client flow&rdquo;.</p>
<p>The connection pool underlying a pool client flow is cached. For every <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0/org/apache/pekko/actor/ActorSystem.html" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem</code></a></span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/0.0/org/apache/pekko/actor/ActorSystem.html" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem</code></a></span>, target endpoint and pool configuration there will never be more than a single pool live at any time.</p>
<p>Also, the HTTP layer transparently manages idle shutdown and restarting of connection pools as configured. The client flow instances therefore remain valid throughout the lifetime of the application, i.e. they can be materialized as often as required and the time between individual materialization is of no importance.</p>
<p>When you request a pool client flow with <span class="group-scala"><code>Http().cachedHostConnectionPool(...)</code></span><span class="group-java"><code>Http.get(system).cachedHostConnectionPool(...)</code></span>, Apache Pekko HTTP will immediately start the pool, even before the first client flow materialization. However, this running pool will not actually open the first connection to the target endpoint until the first request has arrived.</p>
<h2><a href="#configuring-a-host-connection-pool" name="configuring-a-host-connection-pool" class="anchor"><span class="anchor-link"></span></a>Configuring a Host Connection Pool</h2>
<p>Apart from the connection-level config settings and socket options there are a number of settings that allow you to influence the behavior of the connection pool logic itself. Check out the <code>pekko.http.host-connection-pool</code> section of the Apache Pekko HTTP <a href="../configuration.html">Configuration</a> for more information about which settings are available and what they mean.</p>
<p>Note that, if you request pools with different configurations for the same target host you will get <em>independent</em> pools. This means that, in total, your application might open more concurrent HTTP connections to the target endpoint than any of the individual pool&rsquo;s <code>max-connections</code> settings allow!</p>
<p>There is one setting that likely deserves a bit deeper explanation: <code>max-open-requests</code>. This setting limits the maximum number of requests that can be in-flight at any time for a single connection pool. If an application calls <span class="group-scala"><code>Http().cachedHostConnectionPool(...)</code></span><span class="group-java"><code>Http.get(system).cachedHostConnectionPool(...)</code></span> 3 times (with the same endpoint and settings) it will get back <code>3</code> different client flow instances for the same pool. If each of these client flows is then materialized <code>4</code> times (concurrently) the application will have 12 concurrently running client flow materializations. All of these share the resources of the single pool.</p>
<p>This means that no more than 12 requests can be open at any time.</p>
<p>The <code>max-open-requests</code> config setting allows for applying a hard limit which serves mainly as a protection against erroneous connection pool use, e.g. because the application is materializing too many client flows that all compete for the same pooled connections.</p>
<a id="using-a-host-connection-pool"></a>
<h2><a href="#using-a-host-connection-pool" name="using-a-host-connection-pool" class="anchor"><span class="anchor-link"></span></a>Using a Host Connection Pool</h2>
<p>The &ldquo;pool client flow&rdquo; returned by <span class="group-scala"><code>Http().cachedHostConnectionPool(...)</code></span><span class="group-java"><code>Http.get(system).cachedHostConnectionPool(...)</code></span> has the following type:</p><div class="group-scala">
<pre class="prettyprint"><code class="language-scala">Flow[(HttpRequest, T), (Try[HttpResponse], T), HostConnectionPool]
</code></pre></div><div class="group-java">
<pre class="prettyprint"><code class="language-java">Flow&lt;Pair&lt;HttpRequest, T&gt;, Pair&lt;Try&lt;HttpResponse&gt;, T&gt;, HostConnectionPool&gt;
</code></pre></div>
<p>This means it consumes pairs of type <span class="group-scala"><code>(HttpRequest, T)</code></span><span class="group-java"><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0/org/apache/pekko/japi/Pair.html" title="org.apache.pekko.japi.Pair"><code>Pair[HttpRequest, T]</code></a></span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/0.0/org/apache/pekko/japi/Pair.html" title="org.apache.pekko.japi.Pair"><code>Pair&lt;HttpRequest, T&gt;</code></a></span></span> and produces pairs of type <span class="group-scala"><code>(Try[HttpResponse], T)</code></span><span class="group-java"><code>Pair&lt;Try&lt;HttpResponse&gt;, T&gt;</code></span> which might appear more complicated than necessary on first sight. The reason why the pool API includes objects of custom type <code>T</code> on both ends lies in the fact that the underlying transport usually comprises more than a single connection and as such the pool client flow often generates responses in an order that doesn&rsquo;t directly match the consumed requests. We could have built the pool logic in a way that reorders responses according to their requests before dispatching them to the application, but this would have meant that a single slow response could block the delivery of potentially many responses that would otherwise be ready for consumption by the application.</p>
<p>In order to prevent unnecessary head-of-line blocking the pool client-flow is allowed to dispatch responses as soon as they arrive, independently of the request order. Of course this means that there needs to be another way to associate a response with its respective request. The way that this is done is by allowing the application to pass along a custom &ldquo;context&rdquo; object with the request, which is then passed back to the application with the respective response. This context object of type <code>T</code> is completely opaque to Apache Pekko HTTP, i.e. you can pick whatever works best for your particular application scenario.</p><div class="callout note "><div class="callout-title">Note</div>
<p>A consequence of using a pool is that long-running requests block a connection while running and may starve other requests. Make sure not to use a connection pool for long-running requests like long-polling GET requests. Use the <a href="connection-level.html">Connection-Level Client-Side API</a> instead.</p></div>
<h2><a href="#connection-allocation-logic" name="connection-allocation-logic" class="anchor"><span class="anchor-link"></span></a>Connection Allocation Logic</h2>
<p>This is how Apache Pekko HTTP allocates incoming requests to the available connection &ldquo;slots&rdquo;:</p>
<ol>
  <li>If there is a connection alive and currently idle then schedule the request across this connection.</li>
  <li>If no connection is idle and there is still an unconnected slot then establish a new connection.</li>
  <li>If all connections are already established and &ldquo;loaded&rdquo; with other requests then pick the connection with the least open requests that only has requests with idempotent methods scheduled to it, if there is one.</li>
  <li>Otherwise apply back-pressure to the request source, i.e. stop accepting new requests.</li>
</ol>
<h2><a href="#retrying-a-request" name="retrying-a-request" class="anchor"><span class="anchor-link"></span></a>Retrying a Request</h2>
<p>If the <code>max-retries</code> pool config setting is greater than zero the pool retries idempotent requests for which a response could not be successfully retrieved. Idempotent requests are those whose HTTP method is defined to be idempotent by the HTTP spec, which are all the ones currently modelled by Apache Pekko HTTP except for the <code>POST</code>, <code>PATCH</code> and <code>CONNECT</code> methods.</p>
<p>When a response could not be received for a certain request there are essentially three possible error scenarios:</p>
<ol>
  <li>The request got lost on the way to the server.</li>
  <li>The server experiences a problem while processing the request.</li>
  <li>The response from the server got lost on the way back.</li>
</ol>
<p>Since the host connector cannot know which one of these possible reasons caused the problem and therefore <code>PATCH</code> and <code>POST</code> requests could have already triggered a non-idempotent action on the server these requests cannot be retried.</p>
<p>In these cases, as well as when all retries have not yielded a proper response, the pool produces a failed <code>Try</code> (i.e. a <code>scala.util.Failure</code>) together with the custom request context.</p>
<p>If a request fails during connecting to the server, for example, because the DNS name cannot be resolved or the server is currently unavailable, retries are attempted with exponential backoff delay. See the documentation of the <code>pekko.http.host-connection-pool.base-connection-backoff</code> setting in the <a href="../configuration.html">configuration</a>.</p>
<h2><a href="#pool-shutdown" name="pool-shutdown" class="anchor"><span class="anchor-link"></span></a>Pool Shutdown</h2>
<p>Completing a pool client flow will simply detach the flow from the pool. The connection pool itself will continue to run as it may be serving other client flows concurrently or in the future. Only after the configured <code>idle-timeout</code> for the pool has expired will Apache Pekko HTTP automatically terminate the pool and free all its resources.</p>
<p>If a new client flow is requested with <span class="group-scala"><code>Http().cachedHostConnectionPool(...)</code></span><span class="group-java"><code>Http.get(system).cachedHostConnectionPool(...)</code></span> or if an already existing client flow is re-materialized the respective pool is automatically and transparently restarted.</p>
<p>In addition to the automatic shutdown via the configured idle timeouts it&rsquo;s also possible to trigger the immediate shutdown of a specific pool by calling <code>shutdown()</code> on the <code>HostConnectionPool</code> instance that the pool client flow materializes into. This <code>shutdown()</code> call produces a <span class="group-scala"><code>Future[Unit]</code></span><span class="group-java"><code>CompletionStage&lt;Done&gt;</code></span> which is fulfilled when the pool termination has been completed.</p>
<p>It&rsquo;s also possible to trigger the immediate termination of <em>all</em> connection pools in the <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0/org/apache/pekko/actor/ActorSystem.html" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem</code></a></span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/0.0/org/apache/pekko/actor/ActorSystem.html" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem</code></a></span> at the same time by calling <span class="group-scala"><code>Http().shutdownAllConnectionPools()</code></span><span class="group-java"><code>Http.get(system).shutdownAllConnectionPools()</code></span>. This call too produces a <span class="group-scala"><code>Future[Unit]</code></span><span class="group-java"><code>CompletionStage&lt;Done&gt;</code></span> which is fulfilled when all pools have terminated.</p>
<p><span class="group-scala"><code>Http().addClientPoolsToCoordinatedShutdown()</code></span><span class="group-java"><code>Http.get(system).addClientPoolsToCoordinatedShutdown()</code></span> will add the client connection pool shutdown to Apache Pekko&rsquo;s <a href="https://pekko.apache.org/docs/pekko/current/coordinated-shutdown.html">coordinated shutdown</a> so it will be called before the actor system disappears.</p><div class="callout note "><div class="callout-title">Note</div>
<p>When encountering unexpected <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0/org/apache/pekko/stream/AbruptTerminationException.html" title="org.apache.pekko.stream.AbruptTerminationException"><code>AbruptTerminationException</code></a></span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/0.0/org/apache/pekko/stream/AbruptTerminationException.html" title="org.apache.pekko.stream.AbruptTerminationException"><code>AbruptTerminationException</code></a></span> exceptions during <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0/org/apache/pekko/actor/ActorSystem.html" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem</code></a></span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/0.0/org/apache/pekko/actor/ActorSystem.html" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem</code></a></span> <strong>shutdown</strong> please make sure that active connections are shut down before shutting down the entire system, this can be done by calling the <span class="group-scala"><code>Http().shutdownAllConnectionPools()</code></span><span class="group-java"><code>Http.get(system).shutdownAllConnectionPools()</code></span> method, and only once its <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> completes, shutting down the actor system.</p></div>
<h2><a href="#examples" name="examples" class="anchor"><span class="anchor-link"></span></a>Examples</h2><div class="callout note group-scala"><div class="callout-title">Note</div>
<p>At this place we previously showed an example that used the <code>Source.single(request).via(pool).runWith(Sink.head)</code>. In fact, this is an anti-pattern that doesn&rsquo;t perform well. Please either supply requests using a queue or in a streamed fashion as shown below.</p></div><div class="group-scala">
<h3><a href="#using-the-host-level-api-with-a-queue" name="using-the-host-level-api-with-a-queue" class="anchor"><span class="anchor-link"></span></a>Using the host-level API with a queue</h3>
<p>In many cases, you just want to issue requests to a pool and receive responses when they are available. In most cases, you should use the <a href="request-level.html">Request-Level Client-Side API</a> for this purpose. If you want to use a similar Future-based API with the host-level API, here&rsquo;s how to do it.</p>
<p>As explained above, Apache Pekko HTTP prevents to build up an unbounded buffer of requests and an unlimited number of connections. Therefore, it guards itself a) by applying backpressure to all request streams connected to the cached pool and b) by failing requests with a <span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0/org/apache/pekko/stream/BufferOverflowException.html" title="org.apache.pekko.stream.BufferOverflowException"><code>BufferOverflowException</code></a></span><span class="group-java"><a href="https://pekko.apache.org/japi/pekko/0.0/org/apache/pekko/stream/BufferOverflowException.html" title="org.apache.pekko.stream.BufferOverflowException"><code>BufferOverflowException</code></a></span> when the internal buffer overflows when too many materializations exist or too many requests have been issued to the pool.</p>
<p>To mimic the request-level API we can put an explicit queue in front of the pool and decide ourselves what to do when this explicit queue overflows. This example shows how to do this. (Thanks go to <a href="https://kazuhiro.github.io/scala/akka/akka-http/akka-streams/2016/01/31/connection-pooling-with-akka-http-and-source-queue.html">kazuhiro&rsquo;s blog for the initial idea</a>.)</p>
<p>You can tweak the <code>QueueSize</code> setting according to your memory constraints. In any case, you need to think about a strategy about what to do when requests fail because the queue overflowed (e.g. try again later or just fail).</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/HttpClientExampleSpec.scala#L177-L216" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import scala.util.{ Failure, Success }
import scala.concurrent.{ Future, Promise }

import org.apache.pekko
import pekko.actor.ActorSystem
import pekko.http.scaladsl.Http
import pekko.http.scaladsl.model._
import pekko.stream.scaladsl._

import pekko.stream.{ OverflowStrategy, QueueOfferResult }

implicit val system = ActorSystem()
import system.dispatcher // to get an implicit ExecutionContext into scope

val QueueSize = 10

// This idea came initially from this blog post:
// http://kazuhiro.github.io/scala/akka/akka-http/akka-streams/2016/01/31/connection-pooling-with-akka-http-and-source-queue.html
val poolClientFlow = Http().cachedHostConnectionPool[Promise[HttpResponse]](&quot;pekko.apache.org&quot;)
val queue =
  Source.queue[(HttpRequest, Promise[HttpResponse])](QueueSize, OverflowStrategy.dropNew)
    .via(poolClientFlow)
    .to(Sink.foreach {
      case ((Success(resp), p)) =&gt; p.success(resp)
      case ((Failure(e), p))    =&gt; p.failure(e)
    })
    .run()

def queueRequest(request: HttpRequest): Future[HttpResponse] = {
  val responsePromise = Promise[HttpResponse]()
  queue.offer(request -&gt; responsePromise).flatMap {
    case QueueOfferResult.Enqueued    =&gt; responsePromise.future
    case QueueOfferResult.Dropped     =&gt; Future.failed(new RuntimeException(&quot;Queue overflowed. Try again later.&quot;))
    case QueueOfferResult.Failure(ex) =&gt; Future.failed(ex)
    case QueueOfferResult.QueueClosed =&gt; Future.failed(
        new RuntimeException(&quot;Queue was closed (pool shut down) while running the request. Try again later.&quot;))
  }
}

val responseFuture: Future[HttpResponse] = queueRequest(HttpRequest(uri = &quot;/&quot;))</code></pre>
<h3><a href="#using-the-host-level-api-in-a-streaming-fashion" name="using-the-host-level-api-in-a-streaming-fashion" class="anchor"><span class="anchor-link"></span></a>Using the host-level API in a streaming fashion</h3>
<p>It is even better to use the streaming API directly. This will mostly prevent intermediate buffers as data can be generated &ldquo;on-the-fly&rdquo; while streaming the requests. You supply the requests as a stream, i.e. as a <span class="group-java"><a href="https://pekko.apache.org/japi/pekko/0.0/org/apache/pekko/stream/javadsl/Source.html" title="org.apache.pekko.stream.javadsl.Source"><code>Source&lt;(HttpRequest, ...)&gt;</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0/org/apache/pekko/stream/scaladsl/Source.html" title="org.apache.pekko.stream.scaladsl.Source"><code>Source[(HttpRequest, ...)]</code></a></span>, and the pool will &ldquo;pull out&rdquo; single requests when capacity is available on one of the connections to the host.</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/HttpClientExampleSpec.scala#L222-L282" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import java.nio.file.{ Path, Paths }

import scala.util.{ Failure, Success }
import scala.concurrent.Future

import org.apache.pekko
import pekko.NotUsed
import pekko.actor.ActorSystem
import pekko.http.scaladsl.Http
import pekko.http.scaladsl.model._
import pekko.stream.scaladsl._

import pekko.http.scaladsl.model.Multipart.FormData
import pekko.http.scaladsl.marshalling.Marshal

implicit val system = ActorSystem()
import system.dispatcher // to get an implicit ExecutionContext into scope

case class FileToUpload(name: String, location: Path)

def filesToUpload(): Source[FileToUpload, NotUsed] =
  // This could even be a lazy/infinite stream. For this example we have a finite one:
  Source(List(
    FileToUpload(&quot;foo.txt&quot;, Paths.get(&quot;./foo.txt&quot;)),
    FileToUpload(&quot;bar.txt&quot;, Paths.get(&quot;./bar.txt&quot;)),
    FileToUpload(&quot;baz.txt&quot;, Paths.get(&quot;./baz.txt&quot;))))

val poolClientFlow =
  Http().cachedHostConnectionPool[FileToUpload](&quot;pekko.apache.org&quot;)

def createUploadRequest(fileToUpload: FileToUpload): Future[(HttpRequest, FileToUpload)] = {
  val bodyPart =
    // fromPath will use FileIO.fromPath to stream the data from the file directly
    FormData.BodyPart.fromPath(fileToUpload.name, ContentTypes.`application/octet-stream`, fileToUpload.location)

  val body = FormData(bodyPart) // only one file per upload
  Marshal(body).to[RequestEntity].map { entity =&gt; // use marshalling to create multipart/formdata entity
    // build the request and annotate it with the original metadata
    HttpRequest(method = HttpMethods.POST, uri = &quot;http://example.com/uploader&quot;, entity = entity) -&gt; fileToUpload
  }
}

// you need to supply the list of files to upload as a Source[...]
filesToUpload()
  // The stream will &quot;pull out&quot; these requests when capacity is available.
  // When that is the case we create one request concurrently
  // (the pipeline will still allow multiple requests running at the same time)
  .mapAsync(1)(createUploadRequest)
  // then dispatch the request to the connection pool
  .via(poolClientFlow)
  // report each response
  // Note: responses will not come in in the same order as requests. The requests will be run on one of the
  // multiple pooled connections and may thus &quot;overtake&quot; each other.
  .runForeach {
    case (Success(response), fileToUpload) =&gt;
      // TODO: also check for response status code
      println(s&quot;Result for file: $fileToUpload was successful: $response&quot;)
      response.discardEntityBytes() // don&#39;t forget this
    case (Failure(ex), fileToUpload) =&gt;
      println(s&quot;Uploading file $fileToUpload failed with $ex&quot;)
  }</code></pre></div><div class="group-java">
<p>For now, please see the Scala examples in <a href="../client-side/host-level.html#examples?language=scala">Scala Host-Level Client API</a>. If you want to help with converting the examples see issue <a href="https://github.com/akka/akka-http/issues/836">#836</a>.</p></div>
</div>
<div>
<a href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/main/paradox/client-side/host-level.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.0.0+4308-98f0ff9c*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../client-side/request-level.html" title="Request-Level Client-Side API" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Request-Level Client-Side API
</span>
</div>
</a>
<a href="../client-side/connection-level.html" title="Connection-Level Client-Side API" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Connection-Level Client-Side API
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
Copyright Â© 2022, 2023 <a href="https://apache.org">The Apache Software Foundation</a>, Licensed under the Apache License, Version 2.0.
 This product contains significant parts that were originally based on software from Lightbend (<a href="https://akka.io/">Akka</a>).
 Copyright (C) 2009-2022 Lightbend Inc. &lt;https://www.lightbend.com&gt; Apache Pekko is derived from Akka 2.6.x,
 the last version that was distributed under the Apache License, Version 2.0 License.
</div>
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../assets/javascripts/groups.js"></script>

<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
