{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Apache Pekko HTTP"},{"location":"/index.html#apache-pekko-http","text":"! Security Announcements ! Receiving Security Advisories Reporting Vulnerabilities References 0. Release Notes 1. Introduction Philosophy Using Apache Pekko HTTP Routing DSL for HTTP servers Marshalling Streaming Low-level HTTP server APIs HTTP Client API The modules that make up Apache Pekko HTTP 2. Usage Configuration Migration Guides Compatibility Guidelines 3. Data Types & Abstractions HTTP Model The URI model Marshalling Unmarshalling Encoding / Decoding JSON Support XML Support Server-Sent Events Support Timeouts Caching 4. Server API Routing DSL Core Server API Server WebSocket Support Server HTTPS Support Graceful termination Server-Side HTTP/2 (Preview) 5. Client API Configuration HttpRequest and HttpResponse Request-Level Client-Side API Host-Level Client-Side API Connection-Level Client-Side API Pool overflow and the max-open-requests setting Client-Side HTTPS Support Pluggable Client Transports / HTTP(S) proxy Support Client-Side WebSocket Support Client-Side HTTP/2 (Preview) 6. Extensions 7. Supported Technologies HTTP HTTPS WebSocket HTTP/2 DNS Multipart Server-sent Events (SSE) JSON XML Gzip and Deflate Content-Encoding 8. Tips And Tricks Troubleshooting Handling blocking operations in Apache Pekko HTTP Implications of the streaming nature of Request/Response Entities 9. Contributing Welcome! Snapshots 10. Reference API Documentation Directives Books","title":"Apache Pekko HTTP"},{"location":"/security.html","text":"","title":"! Security Announcements !"},{"location":"/security.html#security-announcements-","text":"","title":"! Security Announcements !"},{"location":"/security.html#receiving-security-advisories","text":"The best way to receive any and all security announcements is to subscribe to the Apache Announce Mailing List.\nThis mailing list has a reasonable level of traffic, and receives notifications only after security reports have been managed by the core Apache teams and fixes are publicly available.\nThis mailing list also has announcements of releases for Apache projects.","title":"Receiving Security Advisories"},{"location":"/security.html#reporting-vulnerabilities","text":"We strongly encourage people to report such problems to our private security mailing list first, before disclosing them in a public forum.\nPlease follow the guidelines laid down by the Apache Security team.\nIdeally, any issues affecting Apache Pekko and Pekko should be reported to Apache team first. We will share the report with the Lightbend Akka team.","title":"Reporting Vulnerabilities"},{"location":"/security.html#references","text":"Akka HTTP security fixes","title":"References"},{"location":"/release-notes/index.html","text":"","title":"0. Release Notes"},{"location":"/release-notes/index.html#0-release-notes","text":"Akka HTTP releases","title":"0. Release Notes"},{"location":"/introduction.html","text":"","title":"1. Introduction"},{"location":"/introduction.html#1-introduction","text":"Project Info: Pekko Http Artifact org.apache.pekko pekko-http 0.0.0+4308-98f0ff9c-SNAPSHOT Snapshots are available JDK versions Adopt OpenJDK 8 Adopt OpenJDK 11 Scala versions 2.13.10, 2.12.15 JPMS module name pekko.http License Apache-2.0 API documentation API (Scaladoc) API (Javadoc) Forums Lightbend Discuss akka/akka Gitter channel Release notes akka.io blog Issues Github issues Sources https://github.com/apache/incubator-pekko-http\nThe Apache Pekko HTTP modules implement a full server- and client-side HTTP stack on top of pekko-actor and pekko-stream. It’s not a web-framework but rather a more general toolkit for providing and consuming HTTP-based services. While interaction with a browser is of course also in scope it is not the primary focus of Apache Pekko HTTP.\nApache Pekko HTTP follows a rather open design and many times offers several different API levels for “doing the same thing”. You get to pick the API level of abstraction that is most suitable for your application. This means that, if you have trouble achieving something using a high-level API, there’s a good chance that you can get it done with a low-level API, which offers more flexibility but might require you to write more application code.","title":"1. Introduction"},{"location":"/introduction.html#philosophy","text":"Apache Pekko HTTP has been driven with a clear focus on providing tools for building integration layers rather than application cores. As such it regards itself as a suite of libraries rather than a framework.\nA framework, as we’d like to think of the term, gives you a “frame”, in which you build your application. It comes with a lot of decisions already pre-made and provides a foundation including support structures that lets you get started and deliver results quickly. In a way a framework is like a skeleton onto which you put the “flesh” of your application in order to have it come alive. As such frameworks work best if you choose them before you start application development and try to stick to the framework’s “way of doing things” as you go along.\nFor example, if you are building a browser-facing web application it makes sense to choose a web framework and build your application on top of it because the “core” of the application is the interaction of a browser with your code on the web-server. The framework makers have chosen one “proven” way of designing such applications and let you “fill in the blanks” of a more or less flexible “application-template”. Being able to rely on best-practice architecture like this can be a great asset for getting things done quickly.\nHowever, if your application is not primarily a web application because its core is not browser-interaction but some specialized maybe complex business service and you are merely trying to connect it to the world via a REST/HTTP interface a web-framework might not be what you need. In this case the application architecture should be dictated by what makes sense for the core not the interface layer. Also, you probably won’t benefit from the possibly existing browser-specific framework components like view templating, asset management, JavaScript- and CSS generation/manipulation/minification, localization support, AJAX support, etc.\nApache Pekko HTTP was designed specifically as “not-a-framework”, not because we don’t like frameworks, but for use cases where a framework is not the right choice. Apache Pekko HTTP is made for building integration layers based on HTTP and as such tries to “stay on the sidelines”. Therefore you normally don’t build your application “on top of” Apache Pekko HTTP, but you build your application on top of whatever makes sense and use Apache Pekko HTTP merely for the HTTP integration needs.\nOn the other hand, if you prefer to build your applications with the guidance of a framework, you should give Play Framework a try, which is planning to use Apache Pekko internally. If you come from Play and want to try Apache Pekko HTTP, we collected a side-by-side comparison to show how some Play routing features map to the Apache Pekko HTTP routing DSL.","title":"Philosophy"},{"location":"/introduction.html#using-apache-pekko-http","text":"Apache Pekko HTTP is provided as independent modules from Apache Pekko itself under its own release cycle. The modules, however, do not depend on pekko-actor or pekko-stream, so the user is required to choose an Apache Pekko version to run against and add a manual dependency to pekko-stream of the chosen version.\nsbt val PekkoVersion = \"0.0.0+26602-317cbb52-SNAPSHOT\"\nval PekkoHttpVersion = \"0.0.0+4308-98f0ff9c-SNAPSHOT\"\nlibraryDependencies ++= Seq(\n  \"org.apache.pekko\" %% \"pekko-actor-typed\" % PekkoVersion,\n  \"org.apache.pekko\" %% \"pekko-stream\" % PekkoVersion,\n  \"org.apache.pekko\" %% \"pekko-http\" % PekkoHttpVersion\n) Gradle def versions = [\n  PekkoVersion: \"0.0.0+26602-317cbb52-SNAPSHOT\",\n  ScalaBinary: \"2.13\"\n]\ndependencies {\n  implementation platform(\"org.apache.pekko:pekko-http-bom_${versions.ScalaBinary}:0.0.0+4308-98f0ff9c-SNAPSHOT\")\n\n  implementation \"org.apache.pekko:pekko-actor-typed_${versions.ScalaBinary}:${versions.PekkoVersion}\"\n  implementation \"org.apache.pekko:pekko-stream_${versions.ScalaBinary}:${versions.PekkoVersion}\"\n  implementation \"org.apache.pekko:pekko-http_${versions.ScalaBinary}\"\n} Maven <properties>\n  <pekko.version>0.0.0+26602-317cbb52-SNAPSHOT</pekko.version>\n  <scala.binary.version>2.13</scala.binary.version>\n</properties>\n<dependencyManagement>\n  <dependencies>\n    <dependency>\n      <groupId>org.apache.pekko</groupId>\n      <artifactId>pekko-http-bom_${scala.binary.version}</artifactId>\n      <version>0.0.0+4308-98f0ff9c-SNAPSHOT</version>\n      <type>pom</type>\n      <scope>import</scope>\n    </dependency>\n  </dependencies>\n</dependencyManagement>\n<dependencies>\n  <dependency>\n    <groupId>org.apache.pekko</groupId>\n    <artifactId>pekko-actor-typed_${scala.binary.version}</artifactId>\n    <version>${pekko.version}</version>\n  </dependency>\n  <dependency>\n    <groupId>org.apache.pekko</groupId>\n    <artifactId>pekko-stream_${scala.binary.version}</artifactId>\n    <version>${pekko.version}</version>\n  </dependency>\n  <dependency>\n    <groupId>org.apache.pekko</groupId>\n    <artifactId>pekko-http_${scala.binary.version}</artifactId>\n  </dependency>\n</dependencies>\nYou may download a packaged version of this project by clicking “Create a project for me!” on the Lightbend Getting Started page Lightbend Getting Started page.\nAlternatively, you can bootstrap a new project with Apache Pekko HTTP already configured using the Giter8 template directly via sbt:\nFor Scala (sbt) sbt new akka/akka-http-quickstart-scala.g8\nFor Java (Maven or Gradle) sbt new akka/akka-http-quickstart-java.g8\n From there on the prepared project can be built using Gradle or Maven.\nMore instructions can be found on the template projecttemplate project.","title":"Using Apache Pekko HTTP"},{"location":"/introduction.html#routing-dsl-for-http-servers","text":"The high-level, routing API of Apache Pekko HTTP provides a DSL to describe HTTP “routes” and how they should be handled. Each route is composed of one or more level of DirectivesDirectives that narrows down to handling one specific type of request.\nFor example one route might start with matching the path of the request, only matching if it is “/hello”, then narrowing it down to only handle HTTP get requests and then complete those with a string literal, which will be sent back as an HTTP OK with the string as response body.\nThe Route Route created using the Route DSL is then “bound” to a port to start serving HTTP requests:\nScala copysource/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * license agreements; and to You under the Apache License, version 2.0:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * This file is part of the Apache Pekko project, derived from Akka.\n */\n\n/*\n * Copyright (C) 2020-2022 Lightbend Inc. <https://www.lightbend.com>\n */\n\npackage docs.http.scaladsl\n\nimport org.apache.pekko\nimport pekko.actor.typed.ActorSystem\nimport pekko.actor.typed.scaladsl.Behaviors\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.model._\nimport pekko.http.scaladsl.server.Directives._\nimport scala.io.StdIn\n\nobject HttpServerRoutingMinimal {\n\n  def main(args: Array[String]): Unit = {\n\n    implicit val system = ActorSystem(Behaviors.empty, \"my-system\")\n    // needed for the future flatMap/onComplete in the end\n    implicit val executionContext = system.executionContext\n\n    val route =\n      path(\"hello\") {\n        get {\n          complete(HttpEntity(ContentTypes.`text/html(UTF-8)`, \"<h1>Say hello to akka-http</h1>\"))\n        }\n      }\n\n    val bindingFuture = Http().newServerAt(\"localhost\", 8080).bind(route)\n\n    println(s\"Server now online. Please navigate to http://localhost:8080/hello\\nPress RETURN to stop...\")\n    StdIn.readLine() // let it run until user presses return\n    bindingFuture\n      .flatMap(_.unbind()) // trigger unbinding from the port\n      .onComplete(_ => system.terminate()) // and shutdown when done\n  }\n} Java copysourceimport org.apache.pekko.actor.typed.ActorSystem;\nimport org.apache.pekko.actor.typed.javadsl.Behaviors;\nimport org.apache.pekko.http.javadsl.Http;\nimport org.apache.pekko.http.javadsl.ServerBinding;\nimport org.apache.pekko.http.javadsl.server.AllDirectives;\nimport org.apache.pekko.http.javadsl.server.Route;\n\nimport java.util.concurrent.CompletionStage;\n\npublic class HttpServerMinimalExampleTest extends AllDirectives {\n\n  public static void main(String[] args) throws Exception {\n    // boot up server using the route as defined below\n    ActorSystem<Void> system = ActorSystem.create(Behaviors.empty(), \"routes\");\n\n    final Http http = Http.get(system);\n\n    //In order to access all directives we need an instance where the routes are define.\n    HttpServerMinimalExampleTest app = new HttpServerMinimalExampleTest();\n\n    final CompletionStage<ServerBinding> binding =\n      http.newServerAt(\"localhost\", 8080)\n          .bind(app.createRoute());\n\n    System.out.println(\"Server online at http://localhost:8080/\\nPress RETURN to stop...\");\n    System.in.read(); // let it run until user presses return\n\n    binding\n        .thenCompose(ServerBinding::unbind) // trigger unbinding from the port\n        .thenAccept(unbound -> system.terminate()); // and shutdown when done\n  }\n\n  private Route createRoute() {\n    return concat(\n        path(\"hello\", () ->\n            get(() ->\n                complete(\"<h1>Say hello to pekko-http</h1>\"))));\n  }\n}\nWhen you run this server, you can either open the page in a browser, at the following url: http://localhost:8080/hello, or call it in your terminal, via curl http://localhost:8080/hello.","title":"Routing DSL for HTTP servers"},{"location":"/introduction.html#marshalling","text":"Transforming request and response bodies between over-the-wire formats and objects to be used in your application is done separately from the route declarations, in marshallers, which are pulled in implicitly using the “magnet” pattern. This means that you can complete a request with any kind of object as long as there is an implicit marshaller available in scope.\nDefault marshallers are provided for simple objects like String or ByteString, and you can define your own for example for JSON. An additional module provides JSON serialization using the spray-json library (see JSON Support for details): sbt val PekkoHttpVersion = \"0.0.0+4308-98f0ff9c-SNAPSHOT\"\nlibraryDependencies += \"org.apache.pekko\" %% \"pekko-http-spray-json\" % PekkoHttpVersion Gradle def versions = [\n  ScalaBinary: \"2.13\"\n]\ndependencies {\n  implementation platform(\"org.apache.pekko:pekko-http-bom_${versions.ScalaBinary}:0.0.0+4308-98f0ff9c-SNAPSHOT\")\n\n  implementation \"org.apache.pekko:pekko-http-spray-json_${versions.ScalaBinary}\"\n} Maven <properties>\n  <scala.binary.version>2.13</scala.binary.version>\n</properties>\n<dependencyManagement>\n  <dependencies>\n    <dependency>\n      <groupId>org.apache.pekko</groupId>\n      <artifactId>pekko-http-bom_${scala.binary.version}</artifactId>\n      <version>0.0.0+4308-98f0ff9c-SNAPSHOT</version>\n      <type>pom</type>\n      <scope>import</scope>\n    </dependency>\n  </dependencies>\n</dependencyManagement>\n<dependencies>\n  <dependency>\n    <groupId>org.apache.pekko</groupId>\n    <artifactId>pekko-http-spray-json_${scala.binary.version}</artifactId>\n  </dependency>\n</dependencies>\nJSON support is possible in pekko-http by the use of Jackson, an external artifact (see JSON Support for details): sbt val PekkoHttpVersion = \"0.0.0+4308-98f0ff9c-SNAPSHOT\"\nlibraryDependencies += \"org.apache.pekko\" %% \"pekko-http-jackson\" % PekkoHttpVersion Gradle def versions = [\n  ScalaBinary: \"2.13\"\n]\ndependencies {\n  implementation platform(\"org.apache.pekko:pekko-http-bom_${versions.ScalaBinary}:0.0.0+4308-98f0ff9c-SNAPSHOT\")\n\n  implementation \"org.apache.pekko:pekko-http-jackson_${versions.ScalaBinary}\"\n} Maven <properties>\n  <scala.binary.version>2.13</scala.binary.version>\n</properties>\n<dependencyManagement>\n  <dependencies>\n    <dependency>\n      <groupId>org.apache.pekko</groupId>\n      <artifactId>pekko-http-bom_${scala.binary.version}</artifactId>\n      <version>0.0.0+4308-98f0ff9c-SNAPSHOT</version>\n      <type>pom</type>\n      <scope>import</scope>\n    </dependency>\n  </dependencies>\n</dependencyManagement>\n<dependencies>\n  <dependency>\n    <groupId>org.apache.pekko</groupId>\n    <artifactId>pekko-http-jackson_${scala.binary.version}</artifactId>\n  </dependency>\n</dependencies>\nA common use case is to reply to a request using a model object having the marshaller transform it into JSON. In this case shown by two separate routes. The first route queries an asynchronous database and marshals the Future[Option[Item]]CompletionStage<Optional<Item>> result into a JSON response. The second unmarshals an Order from the incoming request, saves it to the database and replies with an OK when done.\nScala copysource/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * license agreements; and to You under the Apache License, version 2.0:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * This file is part of the Apache Pekko project, derived from Akka.\n */\n\n/*\n * Copyright (C) 2020-2022 Lightbend Inc. <https://www.lightbend.com>\n */\n\npackage docs.http.scaladsl\n\nimport org.apache.pekko\nimport pekko.actor.typed.ActorSystem\nimport pekko.actor.typed.scaladsl.Behaviors\nimport pekko.http.scaladsl.Http\nimport pekko.Done\nimport pekko.http.scaladsl.server.Route\nimport pekko.http.scaladsl.server.Directives._\nimport pekko.http.scaladsl.model.StatusCodes\n// for JSON serialization/deserialization following dependency is required:\n// \"com.typesafe.akka\" %% \"akka-http-spray-json\" % \"10.1.7\"\nimport pekko.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._\nimport spray.json.DefaultJsonProtocol._\n\nimport scala.io.StdIn\n\nimport scala.concurrent.Future\n\nobject SprayJsonExample {\n\n  // needed to run the route\n  implicit val system = ActorSystem(Behaviors.empty, \"SprayExample\")\n  // needed for the future map/flatmap in the end and future in fetchItem and saveOrder\n  implicit val executionContext = system.executionContext\n\n  var orders: List[Item] = Nil\n\n  // domain model\n  final case class Item(name: String, id: Long)\n  final case class Order(items: List[Item])\n\n  // formats for unmarshalling and marshalling\n  implicit val itemFormat = jsonFormat2(Item)\n  implicit val orderFormat = jsonFormat1(Order)\n\n  // (fake) async database query api\n  def fetchItem(itemId: Long): Future[Option[Item]] = Future {\n    orders.find(o => o.id == itemId)\n  }\n  def saveOrder(order: Order): Future[Done] = {\n    orders = order match {\n      case Order(items) => items ::: orders\n      case _            => orders\n    }\n    Future { Done }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val route: Route =\n      concat(\n        get {\n          pathPrefix(\"item\" / LongNumber) { id =>\n            // there might be no item for a given id\n            val maybeItem: Future[Option[Item]] = fetchItem(id)\n\n            onSuccess(maybeItem) {\n              case Some(item) => complete(item)\n              case None       => complete(StatusCodes.NotFound)\n            }\n          }\n        },\n        post {\n          path(\"create-order\") {\n            entity(as[Order]) { order =>\n              val saved: Future[Done] = saveOrder(order)\n              onSuccess(saved) { _ => // we are not interested in the result value `Done` but only in the fact that it was successful\n                complete(\"order created\")\n              }\n            }\n          }\n        })\n\n    val bindingFuture = Http().newServerAt(\"localhost\", 8080).bind(route)\n    println(s\"Server online at http://localhost:8080/\\nPress RETURN to stop...\")\n    StdIn.readLine() // let it run until user presses return\n    bindingFuture\n      .flatMap(_.unbind()) // trigger unbinding from the port\n      .onComplete(_ => system.terminate()) // and shutdown when done\n  }\n} Java copysourceimport org.apache.pekko.Done;\nimport org.apache.pekko.NotUsed;\nimport org.apache.pekko.actor.typed.ActorSystem;\nimport org.apache.pekko.actor.typed.javadsl.Behaviors;\nimport org.apache.pekko.http.javadsl.ConnectHttp;\nimport org.apache.pekko.http.javadsl.Http;\nimport org.apache.pekko.http.javadsl.ServerBinding;\nimport org.apache.pekko.http.javadsl.marshallers.jackson.Jackson;\nimport org.apache.pekko.http.javadsl.model.HttpRequest;\nimport org.apache.pekko.http.javadsl.model.HttpResponse;\nimport org.apache.pekko.http.javadsl.model.StatusCodes;\nimport org.apache.pekko.http.javadsl.server.AllDirectives;\nimport org.apache.pekko.http.javadsl.server.Route;\nimport org.apache.pekko.stream.javadsl.Flow;\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionStage;\n\nimport static org.apache.pekko.http.javadsl.server.PathMatchers.longSegment;\n\npublic class JacksonExampleTest extends AllDirectives {\n\n  public static void main(String[] args) throws Exception {\n    // boot up server using the route as defined below\n    ActorSystem<Void> system = ActorSystem.create(Behaviors.empty(), \"routes\");\n\n    final Http http = Http.get(system);\n\n    //In order to access all directives we need an instance where the routes are define.\n    JacksonExampleTest app = new JacksonExampleTest();\n\n    final CompletionStage<ServerBinding> binding =\n        http.newServerAt(\"localhost\", 8080)\n            .bind(app.createRoute());\n\n    System.out.println(\"Server online at http://localhost:8080/\\nPress RETURN to stop...\");\n    System.in.read(); // let it run until user presses return\n\n    binding\n      .thenCompose(ServerBinding::unbind) // trigger unbinding from the port\n      .thenAccept(unbound -> system.terminate()); // and shutdown when done\n  }\n\n  // (fake) async database query api\n  private CompletionStage<Optional<Item>> fetchItem(long itemId) {\n    return CompletableFuture.completedFuture(Optional.of(new Item(\"foo\", itemId)));\n  }\n\n  // (fake) async database query api\n  private CompletionStage<Done> saveOrder(final Order order) {\n    return CompletableFuture.completedFuture(Done.getInstance());\n  }\n\n  private Route createRoute() {\n\n    return concat(\n      get(() ->\n        pathPrefix(\"item\", () ->\n          path(longSegment(), (Long id) -> {\n            final CompletionStage<Optional<Item>> futureMaybeItem = fetchItem(id);\n            return onSuccess(futureMaybeItem, maybeItem ->\n              maybeItem.map(item -> completeOK(item, Jackson.marshaller()))\n                .orElseGet(() -> complete(StatusCodes.NOT_FOUND, \"Not Found\"))\n            );\n          }))),\n      post(() ->\n        path(\"create-order\", () ->\n          entity(Jackson.unmarshaller(Order.class), order -> {\n            CompletionStage<Done> futureSaved = saveOrder(order);\n            return onSuccess(futureSaved, done ->\n              complete(\"order created\")\n            );\n          })))\n    );\n  }\n\n  private static class Item {\n\n    final String name;\n    final long id;\n\n    @JsonCreator\n    Item(@JsonProperty(\"name\") String name,\n         @JsonProperty(\"id\") long id) {\n      this.name = name;\n      this.id = id;\n    }\n\n    public String getName() {\n      return name;\n    }\n\n    public long getId() {\n      return id;\n    }\n  }\n\n  private static class Order {\n\n    final List<Item> items;\n\n    @JsonCreator\n    Order(@JsonProperty(\"items\") List<Item> items) {\n      this.items = items;\n    }\n\n    public List<Item> getItems() {\n      return items;\n    }\n  }\n}\nWhen you run this server, you can update the inventory via curl -H \"Content-Type: application/json\" -X POST -d '{\"items\":[{\"name\":\"hhgtg\",\"id\":42}]}' http://localhost:8080/create-order on your terminal - adding an item named \"hhgtg\" and having an id=42; and then view the inventory either in a browser, at a url like: http://localhost:8080/item/42 - or on the terminal, via curl http://localhost:8080/item/42.\nThe logic for the marshalling and unmarshalling JSON in this example is provided by the “spray-json”“Jackson” library. See JSON Support)JSON Support) for more information about integration with this library.","title":"Marshalling"},{"location":"/introduction.html#streaming","text":"One of the strengths of Apache Pekko HTTP is that streaming data is at its heart meaning that both request and response bodies can be streamed through the server achieving constant memory usage even for very large requests or responses. Streaming responses will be backpressured by the remote client so that the server will not push data faster than the client can handle, streaming requests means that the server decides how fast the remote client can push the data of the request body.\nExample that streams random numbers as long as the client accepts them:\nScala copysource/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * license agreements; and to You under the Apache License, version 2.0:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * This file is part of the Apache Pekko project, derived from Akka.\n */\n\n/*\n * Copyright (C) 2020-2022 Lightbend Inc. <https://www.lightbend.com>\n */\n\npackage docs.http.scaladsl\n\nimport org.apache.pekko\nimport pekko.actor.typed.ActorSystem\nimport pekko.actor.typed.scaladsl.Behaviors\nimport pekko.stream.scaladsl._\nimport pekko.util.ByteString\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.model.{ ContentTypes, HttpEntity }\nimport pekko.http.scaladsl.server.Directives._\nimport scala.util.Random\nimport scala.io.StdIn\n\nobject HttpServerStreamingRandomNumbers {\n\n  def main(args: Array[String]): Unit = {\n\n    implicit val system = ActorSystem(Behaviors.empty, \"RandomNumbers\")\n    // needed for the future flatMap/onComplete in the end\n    implicit val executionContext = system.executionContext\n\n    // streams are re-usable so we can define it here\n    // and use it for every request\n    val numbers = Source.fromIterator(() =>\n      Iterator.continually(Random.nextInt()))\n\n    val route =\n      path(\"random\") {\n        get {\n          complete(\n            HttpEntity(\n              ContentTypes.`text/plain(UTF-8)`,\n              // transform each number to a chunk of bytes\n              numbers.map(n => ByteString(s\"$n\\n\"))))\n        }\n      }\n\n    val bindingFuture = Http().newServerAt(\"localhost\", 8080).bind(route)\n    println(s\"Server online at http://localhost:8080/\\nPress RETURN to stop...\")\n    StdIn.readLine() // let it run until user presses return\n    bindingFuture\n      .flatMap(_.unbind()) // trigger unbinding from the port\n      .onComplete(_ => system.terminate()) // and shutdown when done\n  }\n} Java copysourceimport org.apache.pekko.NotUsed;\nimport org.apache.pekko.actor.typed.ActorSystem;\nimport org.apache.pekko.actor.typed.javadsl.Behaviors;\nimport org.apache.pekko.http.javadsl.ConnectHttp;\nimport org.apache.pekko.http.javadsl.Http;\nimport org.apache.pekko.http.javadsl.ServerBinding;\nimport org.apache.pekko.http.javadsl.model.*;\nimport org.apache.pekko.http.javadsl.server.AllDirectives;\nimport org.apache.pekko.http.javadsl.server.Route;\nimport org.apache.pekko.stream.javadsl.Flow;\nimport org.apache.pekko.stream.javadsl.Source;\nimport org.apache.pekko.util.ByteString;\n\nimport java.util.Random;\nimport java.util.concurrent.CompletionStage;\nimport java.util.stream.Stream;\n\npublic class HttpServerStreamRandomNumbersTest extends AllDirectives {\n\n  public static void main(String[] args) throws Exception {\n    // boot up server using the route as defined below\n    ActorSystem<Void> system = ActorSystem.create(Behaviors.empty(), \"routes\");\n\n    final Http http = Http.get(system);\n\n    //In order to access all directives we need an instance where the routes are define.\n    HttpServerStreamRandomNumbersTest app = new HttpServerStreamRandomNumbersTest();\n\n    final CompletionStage<ServerBinding> binding =\n        http.newServerAt(\"localhost\", 8080)\n                .bind(app.createRoute());\n\n    System.out.println(\"Server online at http://localhost:8080/\\nPress RETURN to stop...\");\n    System.in.read(); // let it run until user presses return\n\n    binding\n        .thenCompose(ServerBinding::unbind) // trigger unbinding from the port\n        .thenAccept(unbound -> system.terminate()); // and shutdown when done\n  }\n\n\n  private Route createRoute() {\n    final Random rnd = new Random();\n    // streams are re-usable so we can define it here\n    // and use it for every request\n    Source<Integer, NotUsed> numbers = Source.fromIterator(() -> Stream.generate(rnd::nextInt).iterator());\n\n    return concat(\n        path(\"random\", () ->\n            get(() ->\n                complete(HttpEntities.create(ContentTypes.TEXT_PLAIN_UTF8,\n                    // transform each number to a chunk of bytes\n                    numbers.map(x -> ByteString.fromString(x + \"\\n\")))))));\n  }\n}\nConnecting to this service with a slow HTTP client would backpressure so that the next random number is produced on demand with constant memory usage on the server. This can be seen using curl and limiting the rate curl --limit-rate 50b 127.0.0.1:8080/random\nApache Pekko HTTP routes easily interact with actors. In this example one route allows for placing bids in a fire-and-forget style while the second route contains a request-response interaction with an actor. The resulting response is rendered as JSON and returned when the response arrives from the actor.\nScala copysource/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * license agreements; and to You under the Apache License, version 2.0:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * This file is part of the Apache Pekko project, derived from Akka.\n */\n\n/*\n * Copyright (C) 2020-2022 Lightbend Inc. <https://www.lightbend.com>\n */\n\npackage docs.http.scaladsl\n\nimport org.apache.pekko\nimport pekko.actor.typed.scaladsl.AskPattern._\nimport pekko.actor.typed.scaladsl.Behaviors\nimport pekko.actor.typed.{ ActorRef, ActorSystem }\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._\nimport pekko.http.scaladsl.model.StatusCodes\nimport pekko.http.scaladsl.server.Directives._\nimport pekko.util.Timeout\nimport spray.json.DefaultJsonProtocol._\n\nimport scala.concurrent.duration._\nimport scala.concurrent.{ ExecutionContext, Future }\nimport scala.io.StdIn\n\nobject HttpServerWithActorInteraction {\n\n  object Auction {\n\n    sealed trait Message\n\n    case class Bid(userId: String, offer: Int) extends Message\n\n    case class GetBids(replyTo: ActorRef[Bids]) extends Message\n\n    case class Bids(bids: List[Bid])\n\n    def apply: Behaviors.Receive[Message] = apply(List.empty)\n\n    def apply(bids: List[Bid]): Behaviors.Receive[Message] = Behaviors.receive {\n      case (ctx, bid @ Bid(userId, offer)) =>\n        ctx.log.info(s\"Bid complete: $userId, $offer\")\n        apply(bids :+ bid)\n      case (_, GetBids(replyTo)) =>\n        replyTo ! Bids(bids)\n        Behaviors.same\n    }\n\n  }\n\n  // these are from spray-json\n  implicit val bidFormat = jsonFormat2(Auction.Bid)\n  implicit val bidsFormat = jsonFormat1(Auction.Bids)\n\n  def main(args: Array[String]): Unit = {\n    implicit val system: ActorSystem[Auction.Message] = ActorSystem(Auction.apply, \"auction\")\n    // needed for the future flatMap/onComplete in the end\n    implicit val executionContext: ExecutionContext = system.executionContext\n\n    val auction: ActorRef[Auction.Message] = system\n    import Auction._\n\n    val route =\n      path(\"auction\") {\n        concat(\n          put {\n            parameters(\"bid\".as[Int], \"user\") { (bid, user) =>\n              // place a bid, fire-and-forget\n              auction ! Bid(user, bid)\n              complete(StatusCodes.Accepted, \"bid placed\")\n            }\n          },\n          get {\n            implicit val timeout: Timeout = 5.seconds\n\n            // query the actor for the current auction state\n            val bids: Future[Bids] = (auction ? GetBids).mapTo[Bids]\n            complete(bids)\n          })\n      }\n\n    val bindingFuture = Http().newServerAt(\"localhost\", 8080).bind(route)\n    println(s\"Server online at http://localhost:8080/\\nPress RETURN to stop...\")\n    StdIn.readLine() // let it run until user presses return\n    bindingFuture\n      .flatMap(_.unbind()) // trigger unbinding from the port\n      .onComplete(_ => system.terminate()) // and shutdown when done\n\n  }\n} Java copysource import org.apache.pekko.NotUsed;\nimport org.apache.pekko.actor.typed.ActorRef;\nimport org.apache.pekko.actor.typed.ActorSystem;\nimport org.apache.pekko.actor.typed.Behavior;\nimport org.apache.pekko.actor.typed.javadsl.AbstractBehavior;\nimport org.apache.pekko.actor.typed.javadsl.ActorContext;\nimport org.apache.pekko.actor.typed.javadsl.Behaviors;\nimport org.apache.pekko.actor.typed.javadsl.Receive;\nimport org.apache.pekko.http.javadsl.ConnectHttp;\nimport org.apache.pekko.http.javadsl.Http;\nimport org.apache.pekko.http.javadsl.ServerBinding;\nimport org.apache.pekko.http.javadsl.marshallers.jackson.Jackson;\nimport org.apache.pekko.http.javadsl.model.HttpRequest;\nimport org.apache.pekko.http.javadsl.model.HttpResponse;\nimport org.apache.pekko.http.javadsl.model.StatusCodes;\nimport org.apache.pekko.http.javadsl.server.AllDirectives;\nimport org.apache.pekko.http.javadsl.server.Route;\nimport org.apache.pekko.http.javadsl.unmarshalling.StringUnmarshallers;\nimport org.apache.pekko.stream.javadsl.Flow;\n\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CompletionStage;\n\nimport static org.apache.pekko.actor.typed.javadsl.AskPattern.ask;\n\npublic class HttpServerActorInteractionExample extends AllDirectives {\n\n  private final ActorSystem<Auction.Message> system;\n  private final ActorRef<Auction.Message> auction;\n\n  public static void main(String[] args) throws Exception {\n    // boot up server using the route as defined below\n    ActorSystem<Auction.Message> system = ActorSystem.create(Auction.create(), \"routes\");\n\n    final Http http = Http.get(system);\n\n    //In order to access all directives we need an instance where the routes are define.\n    HttpServerActorInteractionExample app = new HttpServerActorInteractionExample(system);\n\n    final CompletionStage<ServerBinding> binding =\n      http.newServerAt(\"localhost\", 8080)\n        .bind(app.createRoute());\n\n    System.out.println(\"Server online at http://localhost:8080/\\nPress RETURN to stop...\");\n    System.in.read(); // let it run until user presses return\n\n    binding\n      .thenCompose(ServerBinding::unbind) // trigger unbinding from the port\n      .thenAccept(unbound -> system.terminate()); // and shutdown when done\n  }\n\n  private HttpServerActorInteractionExample(final ActorSystem<Auction.Message> system) {\n    this.system = system;\n    this.auction = system;\n  }\n\n  private Route createRoute() {\n    return concat(\n      path(\"auction\", () -> concat(\n        put(() ->\n          parameter(StringUnmarshallers.INTEGER, \"bid\", bid ->\n            parameter(\"user\", user -> {\n              // place a bid, fire-and-forget\n              auction.tell(new Auction.Bid(user, bid));\n              return complete(StatusCodes.ACCEPTED, \"bid placed\");\n            })\n          )),\n        get(() -> {\n          // query the actor for the current auction state\n          CompletionStage<Auction.Bids> bids = ask(auction, Auction.GetBids::new, Duration.ofSeconds(5), system.scheduler());\n          return completeOKWithFuture(bids, Jackson.marshaller());\n        }))));\n  }\n\n  static class Auction extends AbstractBehavior<Auction.Message> {\n    interface Message {}\n\n    static class Bid implements Message {\n      public final String userId;\n      public final int offer;\n\n      Bid(String userId, int offer) {\n        this.userId = userId;\n        this.offer = offer;\n      }\n    }\n\n    static class GetBids implements Message {\n      final ActorRef<Bids> replyTo;\n\n      GetBids(ActorRef<Bids> replyTo) {\n        this.replyTo = replyTo;\n      }\n    }\n\n    static class Bids {\n      public final List<Bid> bids;\n\n      Bids(List<Bid> bids) {\n        this.bids = bids;\n      }\n    }\n\n    public Auction(ActorContext<Message> context) {\n      super(context);\n    }\n\n    private List<Bid> bids = new ArrayList<>();\n\n    public static Behavior<Message> create() {\n      return Behaviors.setup(Auction::new);\n    }\n\n    @Override\n    public Receive<Message> createReceive() {\n      return newReceiveBuilder()\n        .onMessage(Bid.class, this::onBid)\n        .onMessage(GetBids.class, this::onGetBids)\n        .build();\n    }\n\n    private Behavior<Message> onBid(Bid bid) {\n      bids.add(bid);\n      getContext().getLog().info(\"Bid complete: {}, {}\", bid.userId, bid.offer);\n      return this;\n    }\n\n    private Behavior<Message> onGetBids(GetBids getBids) {\n      getBids.replyTo.tell(new Bids(bids));\n      return this;\n    }\n  }\n}\nWhen you run this server, you can add an auction bid via curl -X PUT \"http://localhost:8080/auction?bid=22&user=MartinO\" on the terminal; and then you can view the auction status either in a browser, at the url http://localhost:8080/auction, or, on the terminal, via curl http://localhost:8080/auction.\nMore details on how JSON marshalling and unmarshalling works can be found in the JSON Support section.\nRead more about the details of the high level APIs in the section High-level Server-Side API.","title":"Streaming"},{"location":"/introduction.html#low-level-http-server-apis","text":"The low-level Apache Pekko HTTP server APIs allows for handling connections or individual requests by accepting HttpRequestHttpRequest s and answering them by producing HttpResponseHttpResponse s. This is provided by the pekko-http-core module, which is included automatically when you depend on pekko-http but can also be used on its own. APIs for handling such request-responses as function calls and as a Flow<HttpRequest, HttpResponse, ?>Flow[HttpRequest, HttpResponse, _] are available.\nScala copysource/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * license agreements; and to You under the Apache License, version 2.0:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * This file is part of the Apache Pekko project, derived from Akka.\n */\n\n/*\n * Copyright (C) 2020-2022 Lightbend Inc. <https://www.lightbend.com>\n */\n\npackage docs.http.scaladsl\n\nimport org.apache.pekko\nimport pekko.actor.typed.ActorSystem\nimport pekko.actor.typed.scaladsl.Behaviors\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.model.HttpMethods._\nimport pekko.http.scaladsl.model._\n\nimport scala.concurrent.ExecutionContext\nimport scala.io.StdIn\n\nobject HttpServerLowLevel {\n\n  def main(args: Array[String]): Unit = {\n    implicit val system = ActorSystem(Behaviors.empty, \"lowlevel\")\n    // needed for the future map/flatmap in the end\n    implicit val executionContext: ExecutionContext = system.executionContext\n\n    val requestHandler: HttpRequest => HttpResponse = {\n      case HttpRequest(GET, Uri.Path(\"/\"), _, _, _) =>\n        HttpResponse(entity = HttpEntity(\n          ContentTypes.`text/html(UTF-8)`,\n          \"<html><body>Hello world!</body></html>\"))\n\n      case HttpRequest(GET, Uri.Path(\"/ping\"), _, _, _) =>\n        HttpResponse(entity = \"PONG!\")\n\n      case HttpRequest(GET, Uri.Path(\"/crash\"), _, _, _) =>\n        sys.error(\"BOOM!\")\n\n      case r: HttpRequest =>\n        r.discardEntityBytes() // important to drain incoming HTTP Entity stream\n        HttpResponse(404, entity = \"Unknown resource!\")\n    }\n\n    val bindingFuture = Http().newServerAt(\"localhost\", 8080).bindSync(requestHandler)\n    println(s\"Server online at http://localhost:8080/\\nPress RETURN to stop...\")\n    StdIn.readLine() // let it run until user presses return\n    bindingFuture\n      .flatMap(_.unbind()) // trigger unbinding from the port\n      .onComplete(_ => system.terminate()) // and shutdown when done\n\n  }\n} Java copysourceimport org.apache.pekko.actor.typed.ActorSystem;\nimport org.apache.pekko.actor.typed.javadsl.Behaviors;\nimport org.apache.pekko.http.javadsl.ConnectHttp;\nimport org.apache.pekko.http.javadsl.Http;\nimport org.apache.pekko.http.javadsl.ServerBinding;\nimport org.apache.pekko.http.javadsl.model.ContentTypes;\nimport org.apache.pekko.http.javadsl.model.HttpResponse;\nimport org.apache.pekko.http.javadsl.model.StatusCodes;\nimport org.apache.pekko.stream.SystemMaterializer;\nimport org.apache.pekko.util.ByteString;\n\nimport java.util.concurrent.CompletionStage;\n\npublic class HttpServerLowLevelExample {\n\n  public static void main(String[] args) throws Exception {\n    ActorSystem<Void> system = ActorSystem.create(Behaviors.empty(), \"lowlevel\");\n\n    try {\n      CompletionStage<ServerBinding> serverBindingFuture =\n        Http.get(system).newServerAt(\"localhost\", 8080).bindSync(\n          request -> {\n            if (request.getUri().path().equals(\"/\"))\n              return HttpResponse.create().withEntity(ContentTypes.TEXT_HTML_UTF8,\n                ByteString.fromString(\"<html><body>Hello world!</body></html>\"));\n            else if (request.getUri().path().equals(\"/ping\"))\n              return HttpResponse.create().withEntity(ByteString.fromString(\"PONG!\"));\n            else if (request.getUri().path().equals(\"/crash\"))\n              throw new RuntimeException(\"BOOM!\");\n            else {\n              request.discardEntityBytes(system);\n              return HttpResponse.create().withStatus(StatusCodes.NOT_FOUND).withEntity(\"Unknown resource!\");\n            }\n          });\n\n      System.out.println(\"Server online at http://localhost:8080/\\nPress RETURN to stop...\");\n      System.in.read(); // let it run until user presses return\n\n      serverBindingFuture\n        .thenCompose(ServerBinding::unbind) // trigger unbinding from the port\n        .thenAccept(unbound -> system.terminate()); // and shutdown when done\n\n    } catch (RuntimeException e) {\n      system.terminate();\n    }\n  }\n}\nRead more details about the low level APIs in the section Core Server API.","title":"Low-level HTTP server APIs"},{"location":"/introduction.html#http-client-api","text":"The client APIs provide methods for calling an HTTP server using the same HttpRequestHttpRequest and HttpResponseHttpResponse abstractions that Apache Pekko HTTP server uses but adds the concept of connection pools to allow multiple requests to the same server to be handled more performantly by re-using TCP connections to the server.\nExample simple request:\nScala copysource/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * license agreements; and to You under the Apache License, version 2.0:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * This file is part of the Apache Pekko project, derived from Akka.\n */\n\n/*\n * Copyright (C) 2020-2022 Lightbend Inc. <https://www.lightbend.com>\n */\n\npackage docs.http.scaladsl\n\nimport org.apache.pekko\nimport pekko.actor.typed.ActorSystem\nimport pekko.actor.typed.scaladsl.Behaviors\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.model._\n\nimport scala.concurrent.Future\nimport scala.util.{ Failure, Success }\n\nobject HttpClientSingleRequest {\n  def main(args: Array[String]): Unit = {\n    implicit val system = ActorSystem(Behaviors.empty, \"SingleRequest\")\n    // needed for the future flatMap/onComplete in the end\n    implicit val executionContext = system.executionContext\n\n    val responseFuture: Future[HttpResponse] = Http().singleRequest(HttpRequest(uri = \"http://pekko.apache.org\"))\n\n    responseFuture\n      .onComplete {\n        case Success(res) => println(res)\n        case Failure(_)   => sys.error(\"something wrong\")\n      }\n  }\n} Java copysourceimport org.apache.pekko.actor.typed.ActorSystem;\nimport org.apache.pekko.actor.typed.javadsl.Behaviors;\nimport org.apache.pekko.http.javadsl.Http;\nimport org.apache.pekko.http.javadsl.model.*;\nimport org.apache.pekko.http.javadsl.server.examples.petstore.Pet;\nimport org.apache.pekko.stream.SystemMaterializer;\n\nimport java.util.concurrent.CompletionStage;\n\npublic class ClientSingleRequestExample {\n\n  public static void main(String[] args) {\n    final ActorSystem<Void> system = ActorSystem.create(Behaviors.empty(), \"SingleRequest\");\n\n    final CompletionStage<HttpResponse> responseFuture =\n      Http.get(system)\n        .singleRequest(HttpRequest.create(\"https://pekko.apache.org\"));\n  }\n}\nRead more about the details of the client APIs in the section Consuming HTTP-based Services (Client-Side).","title":"HTTP Client API"},{"location":"/introduction.html#the-modules-that-make-up-apache-pekko-http","text":"Apache Pekko HTTP is structured into several modules:\npekko-http Higher-level functionality, like (un)marshalling, (de)compression as well as a powerful DSL for defining HTTP-based APIs on the server-side, this is the recommended way to write HTTP servers with Apache Pekko HTTP. Details can be found in the section High-level Server-Side API pekko-http-core A complete, mostly low-level, server- and client-side implementation of HTTP (incl. WebSockets) Details can be found in sections Core Server API and Consuming HTTP-based Services (Client-Side) pekko-http-testkit A test harness and set of utilities for verifying server-side service implementations pekko-http2-support The HTTP/2 implementation to be included only if HTTP/2 support is needed.\npekko-http-spray-json Predefined glue-code for (de)serializing custom types from/to JSON with spray-json Details can be found here: JSON Support\npekko-http-xml Predefined glue-code for (de)serializing custom types from/to XML with scala-xml Details can be found here: XML Support\npekko-http-jackson Predefined glue-code for (de)serializing custom types from/to JSON with jackson","title":"The modules that make up Apache Pekko HTTP"},{"location":"/usage.html","text":"","title":"2. Usage"},{"location":"/usage.html#2-usage","text":"Configuration Migration Guides Compatibility Guidelines Binary Compatibility Rules Versioning and Compatibility Specific versions inter-op discussion","title":"2. Usage"},{"location":"/configuration.html","text":"","title":"Configuration"},{"location":"/configuration.html#configuration","text":"Just like any other Apache Pekko module, Apache Pekko HTTP is configured via Typesafe Config. Usually this means that you provide an application.conf which contains all the application-specific settings that differ from the default ones provided by the reference configuration files from the individual Apache Pekko modules.\nThese are the relevant default configuration values for the Apache Pekko HTTP modules.\npekko-http-core copysource########################################\n# pekko-http-core Reference Config File #\n########################################\n\n# This is the reference config file that contains all the default settings.\n# Make your edits/overrides in your application.conf.\n\n# Akka HTTP version, checked against the runtime version of Akka HTTP.\n# Loaded from generated conf file.\ninclude \"pekko-http-version\"\n\npekko.http {\n\n  server {\n    # The default value of the `Server` header to produce if no\n    # explicit `Server`-header was included in a response.\n    # If this value is the empty string and no header was included in\n    # the request, no `Server` header will be rendered at all.\n    server-header = pekko-http/${pekko.http.version}\n\n    # \"PREVIEW\" features that are not yet fully production ready.\n    # These flags can change or be removed between patch releases.\n    preview {\n      # If this setting is enabled AND the akka-http2-support is found\n      # on the classpath, `Http().newServerAt(...).bind` and `bindSync`\n      # will be enabled to use HTTP/2.\n      #\n      # `Http().newServerAt(...).bindFlow` and `connectionSource()` are not supported.\n      enable-http2 = off\n    }\n\n    # The time after which an idle connection will be automatically closed.\n    # Set to `infinite` to completely disable idle connection timeouts.\n    idle-timeout = 60 s\n\n    # Defines the default time period within which the application has to\n    # produce an HttpResponse for any given HttpRequest it received.\n    # The timeout begins to run when the *end* of the request has been\n    # received, so even potentially long uploads can have a short timeout.\n    # Set to `infinite` to completely disable request timeout checking.\n    #\n    # Make sure this timeout is smaller than the idle-timeout, otherwise,\n    # the idle-timeout will kick in first and reset the TCP connection\n    # without a response.\n    #\n    # If this setting is not `off` the HTTP server layer attaches a\n    # `Timeout-Access` header to the request, which enables programmatic\n    # customization of the timeout period and timeout response for each\n    # request individually.\n    request-timeout = 20 s\n\n    # The time period within which the TCP binding process must be completed.\n    bind-timeout = 1s\n\n    # Default port to bind HTTP server to when no port was explicitly given.\n    default-http-port = 80\n\n    # Default port to bind HTTPS server to when no port was explicitly given.\n    default-https-port = 443\n\n    # The time period the HTTP server implementation will keep a connection open after\n    # all data has been delivered to the network layer. This setting is similar to the SO_LINGER socket option\n    # but does not only include the OS-level socket but also covers the Akka IO / Akka Streams network stack.\n    # The setting is an extra precaution that prevents clients from keeping open a connection that is\n    # already considered completed from the server side.\n    #\n    # If the network level buffers (including the Akka Stream / Akka IO networking stack buffers)\n    # contains more data than can be transferred to the client in the given time when the server-side considers\n    # to be finished with this connection, the client may encounter a connection reset.\n    #\n    # Set to 'infinite' to disable automatic connection closure (which will risk to leak connections).\n    linger-timeout = 1 min\n\n    # The maximum number of concurrently accepted connections when binding a server using\n    # `Http().newServerAt().bindXYZ()` methods.\n    #\n    # This setting doesn't apply to the `Http().bind` method which will still\n    # deliver an unlimited backpressured stream of incoming connections.\n    #\n    # Note, that this setting limits the number of the connections on a best-effort basis.\n    # It does *not* strictly guarantee that the number of established TCP connections will never\n    # exceed the limit (but it will be approximately correct) because connection termination happens\n    # asynchronously. It also does *not* guarantee that the number of concurrently active handler\n    # flow materializations will never exceed the limit for the reason that it is impossible to reliably\n    # detect when a materialization has ended.\n    max-connections = 1024\n\n    # The maximum number of requests that are accepted (and dispatched to\n    # the application) on one single connection before the first request\n    # has to be completed.\n    # Incoming requests that would cause the pipelining limit to be exceeded\n    # are not read from the connections socket so as to build up \"back-pressure\"\n    # to the client via TCP flow control.\n    # A setting of 1 disables HTTP pipelining, since only one request per\n    # connection can be \"open\" (i.e. being processed by the application) at any\n    # time. Set to higher values to enable HTTP pipelining.\n    # This value must be > 0 and <= 1024.\n    pipelining-limit = 1\n\n    # Enables/disables the addition of a `Remote-Address` header\n    # holding the clients (remote) IP address.\n    # Deprecated since Akka HTTP 10.2.0: please use `remote-address-attribute` instead.\n    remote-address-header = off\n\n    # Enables/disables the addition of a remote-address attribute in HttpRequest\n    # holding the clients (remote) IP address. This is preferred over `remote-address-header`\n    # because it cannot be confused with a real header.\n    remote-address-attribute = off\n\n    # Enables/disables the addition of a `Raw-Request-URI` header holding the\n    # original raw request URI as the client has sent it.\n    raw-request-uri-header = off\n\n    # Enables/disables automatic handling of HEAD requests.\n    # If this setting is enabled the server dispatches HEAD requests as GET\n    # requests to the application and automatically strips off all message\n    # bodies from outgoing responses.\n    # Note that, even when this setting is off the server will never send\n    # out message bodies on responses to HEAD requests.\n    transparent-head-requests = off\n\n    # Enables/disables the returning of more detailed error messages to\n    # the client in the error response.\n    # Should be disabled for browser-facing APIs due to the risk of XSS attacks\n    # and (probably) enabled for internal or non-browser APIs.\n    # Note that akka-http will always produce log messages containing the full\n    # error details.\n    verbose-error-messages = off\n\n    # The initial size of the buffer to render the response headers in.\n    # Can be used for fine-tuning response rendering performance but probably\n    # doesn't have to be fiddled with in most applications.\n    response-header-size-hint = 512\n\n    # The requested maximum length of the queue of incoming connections.\n    # If the server is busy and the backlog is full the OS will start dropping\n    # SYN-packets and connection attempts may fail. Note, that the backlog\n    # size is usually only a maximum size hint for the OS and the OS can\n    # restrict the number further based on global limits.\n    backlog = 100\n\n    # If this setting is empty the server only accepts requests that carry a\n    # non-empty `Host` header. Otherwise it responds with `400 Bad Request`.\n    # Set to a non-empty value to be used in lieu of a missing or empty `Host`\n    # header to make the server accept such requests.\n    # Note that the server will never accept HTTP/1.1 request without a `Host`\n    # header, i.e. this setting only affects HTTP/1.1 requests with an empty\n    # `Host` header as well as HTTP/1.0 requests.\n    # Examples: `www.spray.io` or `example.com:8080`\n    default-host-header = \"\"\n\n    # Socket options to set for the listening socket. If a setting is left\n    # undefined, it will use whatever the default on the system is.\n    socket-options {\n      so-receive-buffer-size = undefined\n      so-send-buffer-size = undefined\n      so-reuse-address = undefined\n      so-traffic-class = undefined\n      tcp-keep-alive = undefined\n      tcp-oob-inline = undefined\n      tcp-no-delay = undefined\n    }\n\n    # When graceful termination is enabled and used invoked with a deadline,\n    # after the deadline passes pending requests will be replied to with a \"terminating\" http response,\n    # instead of delivering those requests to the user-handler.\n    # This response is configurable here using configuration, or via code in case more a sophisticated (e.g. with response entity)\n    # response is needed.\n    #\n    termination-deadline-exceeded-response {\n      # Status code of the \"terminating\" response to be automatically sent to pending requests once the termination deadline is exceeded.\n      status = 503 # ServiceUnavailable\n    }\n\n    # Modify to tweak parsing settings on the server-side only.\n    parsing {\n      # no overrides by default, see `pekko.http.parsing` for default values\n\n      # Server-specific parsing settings:\n\n      # Default maximum content length which should not be exceeded by incoming request entities.\n      # Can be changed at runtime (to a higher or lower value) via the `HttpEntity::withSizeLimit` method.\n      # Note that it is not necessarily a problem to set this to a high value as all stream operations\n      # are always properly backpressured.\n      # Nevertheless you might want to apply some limit in order to prevent a single client from consuming\n      # an excessive amount of server resources.\n      #\n      # Set to `infinite` to completely disable entity length checks. (Even then you can still apply one\n      # programmatically via `withSizeLimit`.)\n      max-content-length = 8m\n\n      # When a request is so malformed we cannot create a RequestContext out of it,\n      # the regular exception handling does not apply, and a default error handling\n      # is applied that only has access to the parse error and not the actual request.\n      # To customize this error response, set error-handler to the FQCN of an\n      # implementation of org.apache.pekko.http.ParsingErrorHandler\n      error-handler = \"org.apache.pekko.http.DefaultParsingErrorHandler$\"\n    }\n\n    # Enables/disables the logging of unencrypted HTTP traffic to and from the HTTP\n    # server for debugging reasons.\n    #\n    # Note: Use with care. Logging of unencrypted data traffic may expose secret data.\n    #\n    # Incoming and outgoing traffic will be logged in hexdump format. To enable logging,\n    # specify the number of bytes to log per chunk of data (the actual chunking depends\n    # on implementation details and networking conditions and should be treated as\n    # arbitrary).\n    #\n    # For logging on the client side, see pekko.http.client.log-unencrypted-network-bytes.\n    #\n    # `off` : no log messages are produced\n    # Int   : determines how many bytes should be logged per data chunk\n    log-unencrypted-network-bytes = off\n\n    # Cancellation in the HTTP streams is delayed by this duration to prevent race conditions between cancellation\n    # and stream completion / failure. In most cases, the value chosen here should make no difference because\n    # HTTP streams are loops where completion and failures should propagate immediately and make the handling of\n    # cancellations redundant.\n    #\n    # In most cases, there should be no reason to change this setting.\n    #\n    # Set to 0 to disable the delay.\n    stream-cancellation-delay = 100 millis\n\n    http2 {\n      # The maximum number of request per connection concurrently dispatched to the request handler.\n      # This limit is enforced as soon as the connection between the peers is established. Enforcing\n      # the limit even before the SETTINGS/SETTINGS_ACK exchange has completed, means\n      # that we will refuse extra streams/requests that were sent by the client right after\n      # the connection was established but before it received our SETTINGS.\n      max-concurrent-streams = 256\n\n      # The maximum number of bytes to receive from a request entity in a single chunk.\n      #\n      # The reasoning to limit that amount (instead of delivering all buffered data for a stream) is that\n      # the amount of data in the internal buffers will drive backpressure and flow control on the HTTP/2 level. Bigger\n      # chunks would mean that the user-level entity reader will have to buffer all that data if it cannot read it in one\n      # go. The implementation would not be able to backpressure further data in that case because it does not know about\n      # this user-level buffer.\n      request-entity-chunk-size = 65536 b\n\n      # The number of request data bytes the HTTP/2 implementation is allowed to buffer internally per connection. Free\n      # space in this buffer is communicated to the peer using HTTP/2 flow-control messages to backpressure data if it\n      # isn't read fast enough.\n      #\n      # When there is no backpressure, this amount will limit the amount of in-flight data. It might need to be increased\n      # for high bandwidth-delay-product connections.\n      #\n      # There is a relation between the `incoming-connection-level-buffer-size` and the `incoming-stream-level-buffer-size`:\n      # If incoming-connection-level-buffer-size < incoming-stream-level-buffer-size * number_of_streams, then\n      # head-of-line blocking is possible between different streams on the same connection.\n      incoming-connection-level-buffer-size = 10 MB\n\n      # The number of request data bytes the HTTP/2 implementation is allowed to buffer internally per stream. Free space\n      # in this buffer is communicated to the peer using HTTP/2 flow-control messages to backpressure data if it isn't\n      # read fast enough.\n      #\n      # When there is no backpressure, this amount will limit the amount of in-flight data per stream. It might need to\n      # be increased for high bandwidth-delay-product connections.\n      incoming-stream-level-buffer-size = 512kB\n\n      # For incoming requests, the infrastructure collects at least the given number of bytes before dispatching a HttpRequest.\n      # If all request data is received before or when the threshold is reached, the entity data is dispatched as a strict entity\n      # which allows more efficient processing of the request data without involving streams.\n      #\n      # If the given value is 0, the request is immediately dispatched and always carries a stream of data.\n      # You can use value `1` to create a strict entity if the request contains at most a single data frame, and a streamed\n      # entity otherwise.\n      #\n      # If `min-collect-strict-entity-size > 0` and a request is cancelled (RST_STREAM) before enough data has been collected and the request\n      # is dispatched, then the request is silently discarded.\n      #\n      # To avoid flow control dead-locks, the value must be both smaller or equal than `incoming-stream-level-buffer-size`\n      # and `incoming-connection-level-buffer-size / max-concurrent-streams`.\n      #\n      # Note, that if enabled, requests that expect data (endStream = false on HEADERS) but never received a DATA frame will never be\n      # dispatched. In a regular HTTP context, this is uncommon. It would require that a client would expect data from the server first\n      # before sending any own data.\n      min-collect-strict-entity-size = 0\n\n      # The maximum number of outgoing control frames to buffer when the peer does not read from its TCP connection before\n      # backpressuring incoming frames.\n      #\n      # On a healthy HTTP/2 connection this setting should have little effect because control frames are given priority over\n      # data frames and should not be buffered for a long time.\n      #\n      # The limit is necessary to prevent a malicious peer to solicit buffering of outgoing control frames (e.g. by sending PINGs)\n      # without ever reading frames ultimately leading to an out of memory situation. With the limit in place, the implementation\n      # stops reading incoming frames when the number of outgoing control frames has reached the given amount. This way an attacker\n      # isn't able to communicate any further without first freeing space in the TCP window, draining the buffered control frames.\n      #\n      # See CVE-2019-9512 for an example of such an attack.\n      #\n      # Note that only control frames are affected because data frames, in contrast, are covered by the HTTP/2 flow control.\n      outgoing-control-frame-buffer-size = 1024\n\n      # Enable verbose debug logging for all ingoing and outgoing frames\n      log-frames = false\n\n      # When there is no data transmitted in either direction, but there are active streams, send a HTTP/2 ping frame with this initial\n      # delay and subsequent interval to make sure the connection is kept alive, 0s disables sending ping frames.\n      ping-interval = 0s\n\n      # Fail the connection if a sent ping is not acknowledged within this timeout.\n      # When zero the ping-interval is used, if set the value must be evenly divisible by less than or equal to the ping-interval.\n      ping-timeout = 0s\n    }\n\n    websocket {\n      # periodic keep alive may be implemented using by sending Ping frames\n      # upon which the other side is expected to reply with a Pong frame,\n      # or by sending a Pong frame, which serves as unidirectional heartbeat.\n      # Valid values:\n      #   ping - default, for bi-directional ping/pong keep-alive heartbeating\n      #   pong - for uni-directional pong keep-alive heartbeating\n      #\n      # It is also possible to provide a payload for each heartbeat message,\n      # this setting can be configured programatically by modifying the websocket settings.\n      # See: https://doc.akka.io/docs/akka-http/current/server-side/websocket-support.html\n      periodic-keep-alive-mode = ping\n\n      # Interval for sending periodic keep-alives\n      # The frame sent will be the one configured in pekko.http.server.websocket.periodic-keep-alive-mode\n      # `infinite` by default, or a duration that is the max idle interval after which an keep-alive frame should be sent\n      # The value `infinite` means that *no* keep-alive heartbeat will be sent, as: \"the allowed idle time is infinite\"\n      periodic-keep-alive-max-idle = infinite\n\n      # Enable verbose debug logging for all ingoing and outgoing frames\n      log-frames = false\n    }\n  }\n\n  #client-settings\n  client {\n    # The default value of the `User-Agent` header to produce if no\n    # explicit `User-Agent`-header was included in a request.\n    # If this value is the empty string and no header was included in\n    # the request, no `User-Agent` header will be rendered at all.\n    user-agent-header = pekko-http/${pekko.http.version}\n\n    # The time period within which the TCP connecting process must be completed.\n    connecting-timeout = 10s\n\n    # The time after which an idle connection will be automatically closed.\n    # Set to `infinite` to completely disable idle timeouts.\n    idle-timeout = 60 s\n\n    # The initial size of the buffer to render the request headers in.\n    # Can be used for fine-tuning request rendering performance but probably\n    # doesn't have to be fiddled with in most applications.\n    request-header-size-hint = 512\n\n    # Socket options to set for the listening socket. If a setting is left\n    # undefined, it will use whatever the default on the system is.\n    socket-options {\n      so-receive-buffer-size = undefined\n      so-send-buffer-size = undefined\n      so-reuse-address = undefined\n      so-traffic-class = undefined\n      tcp-keep-alive = undefined\n      tcp-oob-inline = undefined\n      tcp-no-delay = undefined\n    }\n\n    # Client https proxy options. When using ClientTransport.httpsProxy() with or without credentials,\n    # host/port must be either passed explicitly or set here. If a host is not set, the proxy will not be used.\n    proxy {\n      https {\n        host = \"\"\n        port = 443\n      }\n    }\n\n    # Modify to tweak parsing settings on the client-side only.\n    parsing {\n      # no overrides by default, see `pekko.http.parsing` for default values\n\n      # Default maximum content length which should not be exceeded by incoming response entities.\n      # Can be changed at runtime (to a higher or lower value) via the `HttpEntity::withSizeLimit` method.\n      # Note that it is not necessarily a problem to set this to a high value as all stream operations\n      # are always properly backpressured.\n      #\n      # On the client-side, this limit is disabled by default because a client controls the requests it runs.\n      #\n      # Set to `infinite` to completely disable entity length checks. (Even then you can still apply one\n      # programmatically via `withSizeLimit`.)\n      max-content-length = infinite\n    }\n\n    # Enables/disables the logging of unencrypted HTTP traffic to and from the HTTP\n    # client for debugging reasons.\n    #\n    # Note: Use with care. Logging of unencrypted data traffic may expose secret data.\n    #\n    # Incoming and outgoing traffic will be logged in hexdump format. To enable logging,\n    # specify the number of bytes to log per chunk of data (the actual chunking depends\n    # on implementation details and networking conditions and should be treated as\n    # arbitrary).\n    #\n    # For logging on the server side, see pekko.http.server.log-unencrypted-network-bytes.\n    #\n    # `off` : no log messages are produced\n    # Int   : determines how many bytes should be logged per data chunk\n    log-unencrypted-network-bytes = off\n\n    #client-settings\n    // FIXME: unify with server-side part (by importing or similar to parsing)\n    http2 {\n      # The maximum number of request per connection concurrently dispatched to the request handler.\n      # This limit is enforced as soon as the connection between the peers is established. Enforcing\n      # the limit even before the SETTINGS/SETTINGS_ACK exchange has completed, means\n      # that we will refuse extra streams/push promises that were sent by the client right after\n      # the connection was established but before it received our SETTINGS.\n      max-concurrent-streams = 256\n\n      # The maximum number of bytes to receive from a request entity in a single chunk.\n      #\n      # The reasoning to limit that amount (instead of delivering all buffered data for a stream) is that\n      # the amount of data in the internal buffers will drive backpressure and flow control on the HTTP/2 level. Bigger\n      # chunks would mean that the user-level entity reader will have to buffer all that data if it cannot read it in one\n      # go. The implementation would not be able to backpressure further data in that case because it does not know about\n      # this user-level buffer.\n      request-entity-chunk-size = 65536 b\n\n      # The number of request data bytes the HTTP/2 implementation is allowed to buffer internally per connection. Free\n      # space in this buffer is communicated to the peer using HTTP/2 flow-control messages to backpressure data if it\n      # isn't read fast enough.\n      #\n      # When there is no backpressure, this amount will limit the amount of in-flight data. It might need to be increased\n      # for high bandwidth-delay-product connections.\n      #\n      # There is a relation between the `incoming-connection-level-buffer-size` and the `incoming-stream-level-buffer-size`:\n      # If incoming-connection-level-buffer-size < incoming-stream-level-buffer-size * number_of_streams, then\n      # head-of-line blocking is possible between different streams on the same connection.\n      incoming-connection-level-buffer-size = 10 MB\n\n      # The number of request data bytes the HTTP/2 implementation is allowed to buffer internally per stream. Free space\n      # in this buffer is communicated to the peer using HTTP/2 flow-control messages to backpressure data if it isn't\n      # read fast enough.\n      #\n      # When there is no backpressure, this amount will limit the amount of in-flight data per stream. It might need to\n      # be increased for high bandwidth-delay-product connections.\n      incoming-stream-level-buffer-size = 512kB\n\n      # The maximum number of outgoing control frames to buffer when the peer does not read from its TCP connection before\n      # backpressuring incoming frames.\n      #\n      # On a healthy HTTP/2 connection this setting should have little effect because control frames are given priority over\n      # data frames and should not be buffered for a long time.\n      #\n      # The limit is necessary to prevent a malicious peer to solicit buffering of outgoing control frames (e.g. by sending PINGs)\n      # without ever reading frames ultimately leading to an out of memory situation. With the limit in place, the implementation\n      # stops reading incoming frames when the number of outgoing control frames has reached the given amount. This way an attacker\n      # isn't able to communicate any further without first freeing space in the TCP window, draining the buffered control frames.\n      #\n      # See CVE-2019-9512 for an example of such an attack.\n      #\n      # Note that only control frames are affected because data frames, in contrast, are covered by the HTTP/2 flow control.\n      outgoing-control-frame-buffer-size = 1024\n\n      # Enable verbose debug logging for all ingoing and outgoing frames\n      log-frames = false\n\n      # When there is no data transmitted in either direction, but there are active streams, send a HTTP/2 ping frame with this initial\n      # delay and subsequent interval to make sure the connection is kept alive, 0s disables sending ping frames.\n      ping-interval = 0s\n\n      # Fail the connection if a sent ping is not acknowledged within this timeout.\n      # When zero the ping-interval is used, if set the value must be evenly divisible by less than or equal to the ping-interval.\n      ping-timeout = 0s\n\n      # The maximum number of times a connections is attempted\n      # before giving up and returning an error.\n      # Set to zero to retry indefinitely.\n      max-persistent-attempts = 0\n\n      # Starting backoff before reconnecting when a persistent HTTP/2 client connection fails\n      # see `pekko.http.host-connection-pool.base-connection-backoff` for details on the backoff mechanism.\n      base-connection-backoff = ${pekko.http.host-connection-pool.base-connection-backoff}\n\n      # Max backoff between reconnect attempts when a persistent HTTP/2 client connection fails\n      # see `pekko.http.host-connection-pool.max-connection-backoff` for details on the backoff mechanism.\n      max-connection-backoff = ${pekko.http.host-connection-pool.max-connection-backoff}\n\n      # When gracefully closing the HTTP/2 client, await at most `completion-timeout` for in-flight\n      # requests to complete.\n      completion-timeout = 3s\n\n    }\n\n    #client-settings\n    websocket {\n      # periodic keep alive may be implemented using by sending Ping frames\n      # upon which the other side is expected to reply with a Pong frame,\n      # or by sending a Pong frame, which serves as unidirectional heartbeat.\n      # Valid values:\n      #   ping - default, for bi-directional ping/pong keep-alive heartbeating\n      #   pong - for uni-directional pong keep-alive heartbeating\n      #\n      # See https://tools.ietf.org/html/rfc6455#section-5.5.2\n      # and https://tools.ietf.org/html/rfc6455#section-5.5.3 for more information\n      periodic-keep-alive-mode = ping\n\n      # Interval for sending periodic keep-alives\n      # The frame sent will be the one configured in pekko.http.server.websocket.periodic-keep-alive-mode\n      # `infinite` by default, or a duration that is the max idle interval after which an keep-alive frame should be sent\n      periodic-keep-alive-max-idle = infinite\n\n      # Enable verbose debug logging for all ingoing and outgoing frames\n      log-frames = false\n    }\n\n    # Cancellation in the HTTP streams is delayed by this duration to prevent race conditions between cancellation\n    # and stream completion / failure. In most cases, the value chosen here should make no difference because\n    # HTTP streams are loops where completion and failures should propagate immediately and make the handling of\n    # cancellations redundant.\n    #\n    # In most cases, there should be no reason to change this setting.\n    #\n    # Set to 0 to disable the delay.\n    stream-cancellation-delay = 100 millis\n  }\n  #client-settings\n\n  #pool-settings\n  host-connection-pool {\n    # The maximum number of parallel connections that a connection pool to a\n    # single host endpoint is allowed to establish. Must be greater than zero.\n    max-connections = 4\n\n    # The minimum number of parallel connections that a pool should keep alive (\"hot\").\n    # If the number of connections is falling below the given threshold, new ones are being spawned.\n    # You can use this setting to build a hot pool of \"always on\" connections.\n    # Default is 0, meaning there might be no active connection at given moment.\n    # Keep in mind that `min-connections` should be smaller than `max-connections` or equal\n    min-connections = 0\n\n    # The maximum number of times failed requests are attempted again,\n    # (if the request can be safely retried) before giving up and returning an error.\n    # Set to zero to completely disable request retries.\n    max-retries = 5\n\n    # The maximum number of open requests accepted into the pool across all\n    # materializations of any of its client flows.\n    # Protects against (accidentally) overloading a single pool with too many client flow materializations.\n    # Note that with N concurrent materializations the max number of open request in the pool\n    # will never exceed N * max-connections * pipelining-limit.\n    # Must be a power of 2 and > 0!\n    max-open-requests = 32\n\n    # The maximum duration for a connection to be kept alive\n    # This amount gets modified by a 10 percent fuzzyness to avoid the simultanous reconnections\n    # defaults to 'infinite'\n    # Note that this is only implemented in the new host connection pool\n    max-connection-lifetime = infinite\n\n    # Client-side pipelining is not currently supported. See https://github.com/apache/incubator-pekko-http/issues/32\n    pipelining-limit = 1\n\n    # The minimum duration to backoff new connection attempts after the previous connection attempt failed.\n    #\n    # The pool uses an exponential randomized backoff scheme. After the first failure, the next attempt will only be\n    # tried after a random duration between the base connection backoff and twice the base connection backoff. If that\n    # attempt fails as well, the next attempt will be delayed by twice that amount. The total delay is capped using the\n    # `max-connection-backoff` setting.\n    #\n    # The backoff applies for the complete pool. I.e. after one failed connection attempt, further connection attempts\n    # to that host will backoff for all connections of the pool. After the service recovered, connections will come out\n    # of backoff one by one due to the random extra backoff time. This is to avoid overloading just recently recovered\n    # services with new connections (\"thundering herd\").\n    #\n    # Example: base-connection-backoff = 100ms, max-connection-backoff = 10 seconds\n    #   - After 1st failure, backoff somewhere between 100ms and 200ms\n    #   - After 2nd, between  200ms and  400ms\n    #   - After 3rd, between  200ms and  400ms\n    #   - After 4th, between  400ms and  800ms\n    #   - After 5th, between  800ms and 1600ms\n    #   - After 6th, between 1600ms and 3200ms\n    #   - After 7th, between 3200ms and 6400ms\n    #   - After 8th, between 5000ms and 10 seconds (max capped by max-connection-backoff, min by half of that)\n    #   - After 9th, etc., stays between 5000ms and 10 seconds\n    #\n    # This setting only applies to the new pool implementation and is ignored for the legacy one.\n    base-connection-backoff = 100ms\n\n    # Maximum backoff duration between failed connection attempts. For more information see the above comment for the\n    # `base-connection-backoff` setting.\n    #\n    # This setting only applies to the new pool implementation and is ignored for the legacy one.\n    max-connection-backoff = 2 min\n\n    # The time after which an idle connection pool (without pending requests)\n    # will automatically terminate itself. Set to `infinite` to completely disable idle timeouts.\n    idle-timeout = 30 s\n\n    # HTTP connections are commonly used for multiple requests, that is, they are kept alive between requests. The\n    # `pekko.http.host-connection-pool.keep-alive-timeout` setting configures how long a pool keeps a connection alive between\n    # requests before it closes the connection (and eventually reestablishes it).\n    #\n    # A common scenario where this setting is useful is to prevent a race-condition inherent in HTTP: in most cases, a server\n    # or reverse-proxy closes a persistent (kept-alive) connection after some time. HTTP does not define a protocol between\n    # client and server to negotiate a graceful teardown of an idle persistent connection. Therefore, it can happen that a server decides to\n    # close a connection at the same time that a client decides to send a new request. In that case, the request will fail to be processed,\n    # but the client cannot determine for which reason the server closed the connection and whether the request was (partly) processed or not.\n    # Such a condition can be observed when a request fails with an `UnexpectedConnectionClosureException` or a `StreamTcpException` stating\n    # \"Connection reset by peer\".\n    #\n    # To prevent this from happening, you can set the timeout to a lower value than the server-side keep-alive timeout\n    # (which you either have to know or find out experimentally).\n    #\n    # Set to `infinite` to allow the connection to remain open indefinitely (or be closed by the more general `idle-timeout`).\n    keep-alive-timeout = infinite\n\n    # The pool implementation will fail a connection early and clear the slot if a response entity was not\n    # subscribed during the given time period after the response was dispatched. In busy systems the timeout might be\n    # too tight if a response is not picked up quick enough after it was dispatched by the pool.\n    response-entity-subscription-timeout = 1.second\n\n    # Modify this section to tweak client settings only for host connection pools APIs like `Http().superPool` or\n    # `Http().singleRequest`.\n    client = {\n      # no overrides by default, see `pekko.http.client` for default values\n    }\n\n    #per-host-overrides\n    # Allows overriding settings per host. The setting must be a list in which each entry\n    # is an object with a `host-pattern` entry that specifies for which hosts the overrides\n    # should take effect. All other entries have the same syntax as entries in the\n    # `host-connection-pool` section.\n    #\n    # The `host-pattern` can have these forms:\n    #  * `regex:<pattern>`: the host name is matched against the regular expression pattern\n    #  * `glob:<glob-pattern>` or just `<glob-pattern>`: the host is matched against the given\n    #    pattern. In the pattern the wildcard `*` stands for zero or more characters and `?`\n    #    for any single character\n    #\n    # In both cases, a pattern that matches `*.` at the beginning, i.e. every subdomain,\n    # is expanded to also cover the domain itself (without the leading dot).\n    #\n    # If patterns from multiple entries in the list are matched, only settings from the\n    # first entry found are applied.\n    #\n    # Example:\n    #\n    # per-host-override = [\n    # {\n    #   host-pattern = \"doc.akka.io\"\n    #   # Use the same entries as in the `host-connection-pool` section\n    #   max-connections = 10\n    # },\n    # {\n    #   # `*.akka.io` matches all subdomains like `repo.akka.io` but also `akka.io` itself.\n    #   # `doc.akka.io` is already covered by a previous entry, so these settings here\n    #   # will not apply to `doc.akka.io`.\n    #   host-pattern = \"*.akka.io\"\n    #   max-connections = 11\n    # }\n    # ]\n    per-host-override = []\n    #per-host-overrides\n\n  }\n  #pool-settings\n\n  # Modify to tweak default parsing settings.\n  #\n  # IMPORTANT:\n  # Please note that this sections settings can be overridden by the corresponding settings in:\n  # `pekko.http.server.parsing`, `pekko.http.client.parsing` or `pekko.http.host-connection-pool.client.parsing`.\n  parsing {\n    # The limits for the various parts of the HTTP message parser.\n    max-uri-length             = 2k\n    max-method-length          = 16\n    max-response-reason-length = 64\n    max-header-name-length     = 64\n    max-header-value-length    = 8k\n    max-header-count           = 64\n    max-chunk-ext-length       = 256\n    max-chunk-size             = 1m\n\n    # HTTP comments (as e.g. prominently used in User-Agent headers) can be nested. To avoid too deep nesting\n    # and the associated parsing and storage cost, the depth of nested comments is limited to the given value.\n    max-comment-parsing-depth  = 5\n\n    # The maximum number of bytes to allow when reading the entire entity into memory with `toStrict`\n    # (which is used by the `toStrictEntity` and `extractStrictEntity` directives)\n    max-to-strict-bytes = 8m\n\n    # Sets the strictness mode for parsing request target URIs.\n    # The following values are defined:\n    #\n    # `strict`: RFC3986-compliant URIs are required,\n    #     a 400 response is triggered on violations\n    #\n    # `relaxed`: all visible 7-Bit ASCII chars are allowed\n    #\n    uri-parsing-mode = strict\n\n    # Sets the parsing mode for parsing cookies.\n    # The following value are defined:\n    #\n    # `rfc6265`: Only RFC6265-compliant cookies are parsed. Surrounding double-quotes are accepted and\n    #   automatically removed. Non-compliant cookies are silently discarded.\n    # `raw`: Raw parsing allows any non-control character but ';' to appear in a cookie value. There's no further\n    #   post-processing applied, so that the resulting value string may contain any number of whitespace, unicode,\n    #   double quotes, or '=' characters at any position.\n    #   The rules for parsing the cookie name are the same ones from RFC 6265.\n    #\n    cookie-parsing-mode = rfc6265\n\n    # Enables/disables the logging of warning messages in case an incoming\n    # message (request or response) contains an HTTP header which cannot be\n    # parsed into its high-level model class due to incompatible syntax.\n    # Note that, independently of this settings, akka-http will accept messages\n    # with such headers as long as the message as a whole would still be legal\n    # under the HTTP specification even without this header.\n    # If a header cannot be parsed into a high-level model instance it will be\n    # provided as a `RawHeader`.\n    # If logging is enabled it is performed with the configured\n    # `error-logging-verbosity`.\n    illegal-header-warnings = on\n\n    # Sets the list of headers for which illegal values will *not* cause warning logs to be emitted;\n    #\n    # Adding a header name to this setting list disables the logging of warning messages in case an incoming　message\n    # contains an HTTP header which cannot be　parsed into its high-level model class due to incompatible syntax.\n    ignore-illegal-header-for = []\n\n    # Parse headers into typed model classes in the Pekko Http core layer.\n    #\n    # If set to `off`, only essential headers will be parsed into their model classes. All other ones will be provided\n    # as instances of `RawHeader`. Currently, `Connection`, `Host`, and `Expect` headers will still be provided in their\n    # typed model. The full list of headers still provided as modeled instances can be found in the source code of\n    # `org.apache.pekko.http.impl.engine.parsing.HttpHeaderParser.alwaysParsedHeaders`. Note that (regardless of this setting)\n    # some headers like `Content-Type` are treated specially and will never be provided in the list of headers.\n    modeled-header-parsing = on\n\n    # Configures the verbosity with which message (request or response) parsing\n    # errors are written to the application log.\n    #\n    # Supported settings:\n    # `off`   : no log messages are produced\n    # `simple`: a condensed single-line message is logged\n    # `full`  : the full error details (potentially spanning several lines) are logged\n    error-logging-verbosity = full\n\n    # Configures the processing mode when encountering illegal characters in\n    # header name of response.\n    #\n    # Supported mode:\n    # `error`  : default mode, reject the request\n    # `warn`   : ignore the illegal characters in response header value and log a warning message\n    # `ignore` : just ignore the illegal characters in response header value\n    illegal-response-header-name-processing-mode = error\n\n    # Configures the processing mode when encountering illegal characters in\n    # header value of response.\n    #\n    # Supported mode:\n    # `error`  : default mode, throw an ParsingException and terminate the processing\n    # `warn`   : ignore the illegal characters in response header value and log a warning message\n    # `ignore` : just ignore the illegal characters in response header value\n    illegal-response-header-value-processing-mode = error\n\n    # Configures the processing mode when encountering conflicting `Content-Type` headers.\n    #\n    # Supported mode:\n    # `error`           : default mode, throw an ParsingException and terminate the processing\n    # `first`           : use the value of the first `Content-Type` header and add all subsequent `Content-Type` headers to the headers list\n    # `last`            : use the value of the last `Content-Type` header and add all preceding `Content-Type` headers to the headers list\n    # `no-content-type` : use `ContentTypes.NoContentType` and add all `Content-Type` headers to the headers list\n    conflicting-content-type-header-processing-mode = error\n\n    # limits for the number of different values per header type that the\n    # header cache will hold\n    header-cache {\n      default = 12\n      Content-MD5 = 0\n      Date = 0\n      If-Match = 0\n      If-Modified-Since = 0\n      If-None-Match = 0\n      If-Range = 0\n      If-Unmodified-Since = 0\n      User-Agent = 32\n    }\n\n    # Enables/disables inclusion of an Tls-Session-Info header in parsed\n    # messages over Tls transports (i.e., HttpRequest on server side and\n    # HttpResponse on client side).\n    tls-session-info-header = off\n\n    # Enables/disables inclusion of an SslSession attribute in parsed\n    # messages over Tls transports (i.e., HttpRequest on server side and\n    # HttpResponse on client side).\n    ssl-session-attribute = off\n  }\n\n} pekko-http copysource###################################\n# akka-http Reference Config File #\n###################################\n\n# This is the reference config file that contains all the default settings.\n# Make your edits/overrides in your application.conf.\n\npekko.http {\n  routing {\n    # Enables/disables the returning of more detailed error messages to the\n    # client in the error response\n    # Should be disabled for browser-facing APIs due to the risk of XSS attacks\n    # and (probably) enabled for internal or non-browser APIs\n    # (Note that akka-http will always produce log messages containing the full error details)\n    verbose-error-messages = off\n\n    # Enables/disables ETag and `If-Modified-Since` support for FileAndResourceDirectives\n    file-get-conditional = on\n\n    # Enables/disables the rendering of the \"rendered by\" footer in directory listings\n    render-vanity-footer = yes\n\n    # The maximum size between two requested ranges. Ranges with less space in between will be coalesced.\n    #\n    # When multiple ranges are requested, a server may coalesce any of the ranges that overlap or that are separated\n    # by a gap that is smaller than the overhead of sending multiple parts, regardless of the order in which the\n    # corresponding byte-range-spec appeared in the received Range header field. Since the typical overhead between\n    # parts of a multipart/byteranges payload is around 80 bytes, depending on the selected representation's\n    # media type and the chosen boundary parameter length, it can be less efficient to transfer many small\n    # disjoint parts than it is to transfer the entire selected representation.\n    range-coalescing-threshold = 80\n\n    # The maximum number of allowed ranges per request.\n    # Requests with more ranges will be rejected due to DOS suspicion.\n    range-count-limit = 16\n\n    # The maximum number of bytes per ByteString a decoding directive will produce\n    # for an entity data stream.\n    decode-max-bytes-per-chunk = 1m\n\n    # Maximum content length after applying a decoding directive. When the directive\n    # decompresses, for example, an entity compressed with gzip, the resulting stream can be much\n    # larger than the max-content-length. Like with max-content-length, this is not necessarilly a\n    # problem when consuming the entity in a streaming fashion, but does risk high memory use\n    # when the entity is made strict or marshalled into an in-memory object.\n    # This limit (like max-content-length) can be overridden on a case-by-case basis using the\n    # withSizeLimit directive.\n    decode-max-size = 8m\n  }\n\n  # server-sent events\n  sse {\n    # The maximum size for parsing server-sent events.\n    max-event-size = 8192\n\n    # The maximum size for parsing lines of a server-sent event.\n    max-line-size = 4096\n\n    # Empty events are used by the akka-http SSE infrastructure for heartbeats. Received heartbeats are ignored by default\n    # and not delivered in the user stream.\n    #\n    # This setting can be enabled to pass those empty events to the application for explicit handling.\n    emit-empty-events = off\n  }\n} pekko-http-caching copysource###########################################\n# akka-http-caching Reference Config File #\n###########################################\n\n# This is the reference config file that contains all the default settings.\n# Make your edits/overrides in your application.conf.\n\npekko.http.caching {\n\n  # Default configuration values for LfuCache\n  lfu-cache {\n    # Maximum number of entries the cache may store.\n    # After the maximum capacity is reached the cache evicts entries that are\n    # less likely to be used again. For example, the cache may evict an entry\n    # because it hasn't been used recently or very often.\n    max-capacity = 512\n\n    # Minimum total size for the internal data structures.\n    initial-capacity = 16\n\n    # Upper limit to the time period an entry is allowed to remain in the cache.\n    # Set to 'infinite' to disable eviction based on time of write (create or update).\n    time-to-live = infinite\n\n    # Maximum time period an entry is allowed to remain in the cache after last access.\n    # Access time is reset by all cache read and write operations.\n    # Set to 'infinite' to disable time-based expiration.\n    time-to-idle = infinite\n  }\n\n}\nThe other Apache Pekko HTTP modules do not offer any configuration via Typesafe Config.","title":"Configuration"},{"location":"/migration-guide/index.html","text":"","title":"Migration Guides"},{"location":"/migration-guide/index.html#migration-guides","text":"If you are currently using an old version of Akka HTTP or Spray, you should first follow the Akka HTTP migration guide We will soon provide a guide for migrating from Akka HTTP v10.2 to Apache Pekko HTTP","title":"Migration Guides"},{"location":"/compatibility-guidelines.html","text":"","title":"Compatibility Guidelines"},{"location":"/compatibility-guidelines.html#compatibility-guidelines","text":"","title":"Compatibility Guidelines"},{"location":"/compatibility-guidelines.html#binary-compatibility-rules","text":"Apache Pekko HTTP follows the same binary compatibility rules as Apache Pekko itself. In short it means that the versioning scheme should be read as major.minor.patch, wherein all versions with the same major version are backwards binary-compatible, with the exception of @ApiMayChange, @InternalApi or @DoNotInherit marked APIs or other specifically documented special-cases.\nFor more information and a detailed discussion of these rules and guarantees please refer to The @DoNotInherit and @ApiMayChange markers.","title":"Binary Compatibility Rules"},{"location":"/compatibility-guidelines.html#components-with-no-binary-compatibility-guarantee","text":"The following components and modules don’t have the previously mentioned binary compatibility guaranteed within minor or patch versions. However, binary compatibility will be attempted to be kept as much as possible.","title":"Components with no Binary Compatibility Guarantee"},{"location":"/compatibility-guidelines.html#pekko-http","text":"Scala org.apache.pekko.http.scaladsl.server.directives.FileUploadDirectives#storeUploadedFile\norg.apache.pekko.http.scaladsl.server.directives.FileUploadDirectives#storeUploadedFiles\norg.apache.pekko.http.scaladsl.server.directives.FileUploadDirectives#fileUploadAll\norg.apache.pekko.http.scaladsl.marshalling.sse.EventStreamMarshalling\norg.apache.pekko.http.scaladsl.server.HttpApp\norg.apache.pekko.http.scaladsl.unmarshalling.sse.EventStreamParser\norg.apache.pekko.http.scaladsl.unmarshalling.sse.EventStreamUnmarshalling\norg.apache.pekko.http.scaladsl.OutgoingConnectionBuilder#managedPersistentHttp2\norg.apache.pekko.http.scaladsl.OutgoingConnectionBuilder#managedPersistentHttp2WithPriorKnowledge\n Java org.apache.pekko.http.javadsl.common.PartialApplication#bindParameter\norg.apache.pekko.http.javadsl.server.Directives#anyOf (all overloads)\norg.apache.pekko.http.javadsl.server.Directives#allOf (all overloads)\norg.apache.pekko.http.javadsl.server.directives.FileUploadDirectives#storeUploadedFile\norg.apache.pekko.http.javadsl.server.directives.FileUploadDirectives#storeUploadedFiles\norg.apache.pekko.http.javadsl.server.directives.FileUploadDirectives#fileUploadAll\norg.apache.pekko.http.javadsl.server.HttpApp\norg.apache.pekko.http.javadsl.model.RequestResponseAssociation\norg.apache.pekko.http.javadsl.OutgoingConnectionBuilder#managedPersistentHttp2WithPriorKnowledge\norg.apache.pekko.http.javadsl.OutgoingConnectionBuilder#managedPersistentHttp2","title":"pekko-http"},{"location":"/compatibility-guidelines.html#pekko-http-caching","text":"Scala org.apache.pekko.http.caching.LfuCache\norg.apache.pekko.http.caching.scaladsl.Cache\norg.apache.pekko.http.scaladsl.server.directives.CachingDirectives\n Java org.apache.pekko.http.caching.LfuCache\norg.apache.pekko.http.caching.javadsl.Cache\norg.apache.pekko.http.javadsl.server.directives.CachingDirectives","title":"pekko-http-caching"},{"location":"/compatibility-guidelines.html#pekko-http-core","text":"Scala org.apache.pekko.http.scaladsl.ClientTransport\norg.apache.pekko.http.scaladsl.ConnectionContext#httpsClient\norg.apache.pekko.http.scaladsl.ConnectionContext#httpsServer\norg.apache.pekko.http.scaladsl.settings.PoolImplementation\norg.apache.pekko.http.scaladsl.settings.ClientConnectionSettings#transport\norg.apache.pekko.http.scaladsl.settings.ClientConnectionSettings#withTransport\norg.apache.pekko.http.scaladsl.settings.ConnectionPoolSettings#appendHostOverride\norg.apache.pekko.http.scaladsl.settings.ConnectionPoolSettings#poolImplementation\norg.apache.pekko.http.scaladsl.settings.ConnectionPoolSettings#responseEntitySubscriptionTimeout\norg.apache.pekko.http.scaladsl.settings.ConnectionPoolSettings#withHostOverrides\norg.apache.pekko.http.scaladsl.settings.ConnectionPoolSettings#withOverrides\norg.apache.pekko.http.scaladsl.settings.ConnectionPoolSettings#withPoolImplementation\norg.apache.pekko.http.scaladsl.settings.ConnectionPoolSettings#withResponseEntitySubscriptionTimeout\norg.apache.pekko.http.scaladsl.settings.HostOverride\norg.apache.pekko.http.scaladsl.settings.Http2ServerSettings\norg.apache.pekko.http.scaladsl.settings.Http2ClientSettings\norg.apache.pekko.http.scaladsl.settings.PreviewServerSettings\norg.apache.pekko.http.scaladsl.settings.ServerSentEventSettings\norg.apache.pekko.http.scaladsl.model.headers.CacheDirectives.immutableDirective\norg.apache.pekko.http.scaladsl.model.headers.X-Forwarded-Host\norg.apache.pekko.http.scaladsl.model.headers.X-Forwarded-Proto\norg.apache.pekko.http.scaladsl.model.http2.PeerClosedStreamException\norg.apache.pekko.http.scaladsl.model.http2.Http2Exception\norg.apache.pekko.http.scaladsl.model.SimpleRequestResponseAttribute\norg.apache.pekko.http.scaladsl.model.RequestResponseAssociation\n Java org.apache.pekko.http.javadsl.ClientTransport\norg.apache.pekko.http.javadsl.ConnectionContext#httpsClient\norg.apache.pekko.http.javadsl.ConnectionContext#httpsServer\norg.apache.pekko.http.javadsl.settings.ClientConnectionSettings#getTransport\norg.apache.pekko.http.javadsl.settings.ClientConnectionSettings#withTransport\norg.apache.pekko.http.javadsl.settings.ConnectionPoolSettings#appendHostOverride\norg.apache.pekko.http.javadsl.settings.ConnectionPoolSettings#getPoolImplementation\norg.apache.pekko.http.javadsl.settings.ConnectionPoolSettings#getResponseEntitySubscriptionTimeout\norg.apache.pekko.http.javadsl.settings.ConnectionPoolSettings#withHostOverrides\norg.apache.pekko.http.javadsl.settings.ConnectionPoolSettings#withPoolImplementation\norg.apache.pekko.http.javadsl.settings.ConnectionPoolSettings#withResponseEntitySubscriptionTimeout\norg.apache.pekko.http.javadsl.settings.PoolImplementation\norg.apache.pekko.http.javadsl.settings.PreviewServerSettings\norg.apache.pekko.http.javadsl.settings.ServerSentEventSettings","title":"pekko-http-core"},{"location":"/compatibility-guidelines.html#versioning-and-compatibility","text":"The Apache Pekko HTTP Team currently does not intend to break binary compatibility, i.e. no binary incompatible 2.x.y release is currently planned.","title":"Versioning and Compatibility"},{"location":"/compatibility-guidelines.html#specific-versions-inter-op-discussion","text":"In this section we discuss some of the specific cases of compatibility between versions of Apache Pekko HTTP and Apache Pekko itself.\nFor example, you may be interested in those examples if you encountered the following exception in your system when upgrading parts of your libraries: Detected java.lang.NoSuchMethodError error, which MAY be caused by incompatible Pekko versions on the classpath. Please note that a given Pekko version MUST be the same across all modules of Apache Pekko that you are using, e.g. if you use pekko-actor [2.5.3 (resolved from current classpath)] all other core Apache Pekko modules MUST be of the same version. External projects like Apache Pekko Connectors, Persistence plugins or Apache Pekko HTTP etc. have their own version numbers - please make sure you're using a compatible set of libraries.","title":"Specific versions inter-op discussion"},{"location":"/compatibility-guidelines.html#compatibility-with-apache-pekko","text":"To facilitate supporting multiple minor versions of Apache Pekko we do not depend on pekko-stream explicitly but mark it as a provided dependency in our build. That means that you will always have to add a manual dependency to pekko-stream.\nThe same goes for pekko-http-testkit: If the testkit is used, explicitly declare the dependency on pekko-stream-testkit of same Pekko version as pekko-stream.\nsbt val PekkoVersion = \"0.0.0+26602-317cbb52-SNAPSHOT\"\nval PekkoHttpVersion = \"0.0.0+4308-98f0ff9c-SNAPSHOT\"\nlibraryDependencies ++= Seq(\n  \"org.apache.pekko\" %% \"pekko-http\" % PekkoHttpVersion,\n  \"org.apache.pekko\" %% \"pekko-stream\" % PekkoVersion,\n  \"org.apache.pekko\" %% \"pekko-http-testkit\" % PekkoHttpVersion % \"Test\",\n  \"org.apache.pekko\" %% \"pekko-stream-testkit\" % PekkoVersion % \"Test\"\n) Gradle def versions = [\n  PekkoVersion: \"0.0.0+26602-317cbb52-SNAPSHOT\",\n  ScalaBinary: \"2.13\"\n]\ndependencies {\n  implementation platform(\"org.apache.pekko:pekko-http-bom_${versions.ScalaBinary}:0.0.0+4308-98f0ff9c-SNAPSHOT\")\n\n  implementation \"org.apache.pekko:pekko-http_${versions.ScalaBinary}\"\n  implementation \"org.apache.pekko:pekko-stream_${versions.ScalaBinary}:${versions.PekkoVersion}\"\n  Test \"org.apache.pekko:pekko-http-testkit_${versions.ScalaBinary}\"\n  Test \"org.apache.pekko:pekko-stream-testkit_${versions.ScalaBinary}:${versions.PekkoVersion}\"\n} Maven <properties>\n  <pekko.version>0.0.0+26602-317cbb52-SNAPSHOT</pekko.version>\n  <scala.binary.version>2.13</scala.binary.version>\n</properties>\n<dependencyManagement>\n  <dependencies>\n    <dependency>\n      <groupId>org.apache.pekko</groupId>\n      <artifactId>pekko-http-bom_${scala.binary.version}</artifactId>\n      <version>0.0.0+4308-98f0ff9c-SNAPSHOT</version>\n      <type>pom</type>\n      <scope>import</scope>\n    </dependency>\n  </dependencies>\n</dependencyManagement>\n<dependencies>\n  <dependency>\n    <groupId>org.apache.pekko</groupId>\n    <artifactId>pekko-http_${scala.binary.version}</artifactId>\n  </dependency>\n  <dependency>\n    <groupId>org.apache.pekko</groupId>\n    <artifactId>pekko-stream_${scala.binary.version}</artifactId>\n    <version>${pekko.version}</version>\n  </dependency>\n  <dependency>\n    <groupId>org.apache.pekko</groupId>\n    <artifactId>pekko-http-testkit_${scala.binary.version}</artifactId>\n    <scope>Test</scope>\n  </dependency>\n  <dependency>\n    <groupId>org.apache.pekko</groupId>\n    <artifactId>pekko-stream-testkit_${scala.binary.version}</artifactId>\n    <version>${pekko.version}</version>\n    <scope>Test</scope>\n  </dependency>\n</dependencies>","title":"Compatibility with Apache Pekko"},{"location":"/common/index.html","text":"","title":"3. Data Types & Abstractions"},{"location":"/common/index.html#3-data-types-abstractions","text":"HTTP and related specifications define a great number of concepts and functionality that is not specific to either HTTP’s client- or server-side since they are meaningful on both end of an HTTP connection. The documentation for their counterparts in Apache Pekko HTTP lives in this section rather than in the ones for the Client-Side API, Core Server API or High-level Server-Side API, which are specific to one side only.\nHTTP Model Overview HttpRequest Synthetic Headers HttpResponse HttpEntity Limiting message entity length Special processing for HEAD requests Header Model HTTP Headers Custom Headers Attributes Parsing / Rendering Registering Custom Media Types Registering Custom Status Codes Registering Custom HTTP Method The URI model Parsing a URI string Invalid URI strings and IllegalUriException Directives to extract URI components Obtaining the raw request URI Query string in URI Strict and Relaxed Mode Directives to extract query parameters Marshalling Basic Design Predefined Marshallers Implicit Resolution Custom Marshallers Deriving Marshallers Using Marshallers Unmarshalling Basic Design Using unmarshallers Predefined Unmarshallers Implicit Resolution Custom Unmarshallers Deriving Unmarshallers Using Unmarshallers Encoding / Decoding Server side Client side JSON Support Jackson Support spray-json Support Consuming JSON Streaming style APIs Pretty printing XML Support Scala XML Support Server-Sent Events Support Model Server-side usage: marshalling Client-side usage: unmarshalling Timeouts Common timeouts Connection-level idle timeout Server timeouts Request timeout Bind timeout Linger timeout Client timeouts Connecting timeout Client pool timeouts Keep-alive timeout Connection Lifetime timeout Pool Idle timeout Caching Dependency Basic design Frequency-biased LFU cache","title":"3. Data Types & Abstractions"},{"location":"/common/http-model.html","text":"","title":"HTTP Model"},{"location":"/common/http-model.html#http-model","text":"Apache Pekko HTTP model contains a deeply structured, fully immutable, case-class based model of all the major HTTP data structures, like HTTP requests, responses and common headers. It lives in the pekko-http-core module and forms the basis for most of Apache Pekko HTTP’s APIs.","title":"HTTP Model"},{"location":"/common/http-model.html#overview","text":"Since pekko-http-core provides the central HTTP data structures you will find the following import in quite a few places around the code base (and probably your own code as well):\nScala copysourceimport org.apache.pekko.http.scaladsl.model._ Java copysourceimport org.apache.pekko.http.javadsl.model.*;\nimport org.apache.pekko.http.javadsl.model.headers.*;\n\nimport java.util.Optional;\nThis brings all of the most relevant types in scope, mainly:\nHttpRequestHttpRequest and HttpResponseHttpResponse, the central message model headers, the package containing all the predefined HTTP header models and supporting types Supporting types like UriUri, HttpMethodsHttpMethods, MediaTypesMediaTypes, StatusCodesStatusCodes, etc.\nA common pattern is that the model of a certain entity is represented by an immutable type (class or trait), while the actual instances of the entity defined by the HTTP spec live in an accompanying object carrying the name of the type plus a trailing plural ‘s’.\nFor example:\nDefined HttpMethodHttpMethod instances live inare defined as static fields of the HttpMethodsHttpMethods objectclass. Defined HttpCharsetHttpCharset instances live inare defined as static fields of the HttpCharsetsHttpCharsets objectclass. Defined HttpEncodingHttpEncoding instances live inare defined as static fields of the HttpEncodingsHttpEncodings objectclass. Defined HttpProtocolHttpProtocol instances live inare defined as static fields of the HttpProtocolsHttpProtocols objectclass. Defined MediaTypeMediaType instances live inare defined as static fields of the MediaTypesMediaTypes objectclass. Defined StatusCodeStatusCode instances live inare defined as static fields of the StatusCodesStatusCodes objectclass.","title":"Overview"},{"location":"/common/http-model.html#httprequest","text":"HttpRequestHttpRequest and HttpResponseHttpResponse are the basic caseimmutable classes representing HTTP messages.\nAn HttpRequestHttpRequest consists of\na method (GET, POST, etc.) a URI (see URI model for more information) a seq of headers an entity (body data) a protocol\nHere are some examples how to construct an HttpRequestHttpRequest:\nScala copysourceimport org.apache.pekko.http.scaladsl.model._\nimport HttpMethods._\n\n// construct a simple GET request to `homeUri`\nval homeUri = Uri(\"/abc\")\nHttpRequest(GET, uri = homeUri)\n\n// construct simple GET request to \"/index\" (implicit string to Uri conversion)\nHttpRequest(GET, uri = \"/index\")\n\n// construct simple POST request containing entity\nval data = ByteString(\"abc\")\nHttpRequest(POST, uri = \"/receive\", entity = data)\n\n// customize every detail of HTTP request\nimport HttpProtocols._\nimport MediaTypes._\nimport HttpCharsets._\nval userData = ByteString(\"abc\")\nval authorization = headers.Authorization(BasicHttpCredentials(\"user\", \"pass\"))\nHttpRequest(\n  PUT,\n  uri = \"/user\",\n  entity = HttpEntity(`text/plain`.withCharset(`UTF-8`), userData),\n  headers = List(authorization),\n  protocol = `HTTP/1.0`) Java copysourceimport org.apache.pekko.http.javadsl.model.*;\nimport org.apache.pekko.http.javadsl.model.headers.*;\n\nimport java.util.Optional;\n\n// construct a simple GET request to `homeUri`\nUri homeUri = Uri.create(\"/home\");\nHttpRequest request1 = HttpRequest.create().withUri(homeUri);\n\n// construct simple GET request to \"/index\" using helper methods\nHttpRequest request2 = HttpRequest.GET(\"/index\");\n\n// construct simple POST request containing entity\nByteString data = ByteString.fromString(\"abc\");\nHttpRequest postRequest1 = HttpRequest.POST(\"/receive\").withEntity(data);\n\n// customize every detail of HTTP request\n//import HttpProtocols.*\n//import MediaTypes.*\nAuthorization authorization = Authorization.basic(\"user\", \"pass\");\nHttpRequest complexRequest =\n    HttpRequest.PUT(\"/user\")\n        .withEntity(HttpEntities.create(ContentTypes.TEXT_PLAIN_UTF8, \"abc\"))\n        .addHeader(authorization)\n        .withProtocol(HttpProtocols.HTTP_1_0);\nAll parameters of HttpRequest.apply have default values set, so headers for example don’t need to be specified if there are none. Many of the parameters types (like HttpEntityHttpEntity and UriUri) define implicit conversions for common use cases to simplify the creation of request and response instances.\nIn its basic form HttpRequest.create creates an empty default GET request without headers which can then be transformed using one of the withX methods, addHeader, or addHeaders. Each of those will create a new immutable instance, so instances can be shared freely. There exist some overloads for HttpRequest.create that simplify creating requests for common cases. Also, to aid readability, there are predefined alternatives for create named after HTTP methods to create a request with a given method and URI directly.\nString representation There are certain environments where it is easy to inadvertently print, write or log entries built out of string representations of HttpRequestHttpRequest instances. On the other hand, it is not uncommon for HTTP headers and entities to contain Personal Identifying Information (PII) or Sensitive Personal Information (SPI) . To avoid accidentally leaking such information, these fields are omitted from HttpRequestHttpRequest toString output. If needed, it is possible to define a custom string representation including all fields as shown in the following example: Scala copysource/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * license agreements; and to You under the Apache License, version 2.0:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * This file is part of the Apache Pekko project, derived from Akka.\n */\n\n/*\n * Copyright (C) 2009-2022 Lightbend Inc. <https://www.lightbend.com>\n */\n\npackage docs.http.scaladsl\n\nimport org.apache.pekko\nimport pekko.http.scaladsl.model.{ HttpEntity, HttpRequest }\nimport pekko.http.scaladsl.model.headers.{ Authorization, BasicHttpCredentials }\nimport pekko.testkit.PekkoSpec\n\nimport scala.collection.immutable\n\nclass HttpRequestDetailedStringExampleSpec extends PekkoSpec {\n\n  // Custom string representation which includes headers\n  def toDetailedString(request: HttpRequest): String = {\n    import request._\n    s\"\"\"HttpRequest(${_1},${_2},${_3},${_4},${_5})\"\"\"\n  }\n\n  \"Include headers in custom string representation\" in {\n\n    // An HTTP header containing Personal Identifying Information\n    val piiHeader = Authorization(BasicHttpCredentials(\"user\", \"password\"))\n\n    // An HTTP entity containing Personal Identifying Information\n    val piiBody: HttpEntity.Strict =\n      \"This body contains information about [user]\"\n\n    val httpRequestWithHeadersAndBody =\n      HttpRequest(entity = piiBody, headers = immutable.Seq(piiHeader))\n\n    // Our custom string representation includes body and headers string representations...\n    assert(\n      toDetailedString(httpRequestWithHeadersAndBody)\n        .contains(piiHeader.toString))\n    assert(\n      toDetailedString(httpRequestWithHeadersAndBody).contains(piiBody.toString))\n\n    // ... while default `toString` doesn't.\n    assert(!s\"$httpRequestWithHeadersAndBody\".contains(piiHeader.unsafeToString))\n    assert(!s\"$httpRequestWithHeadersAndBody\".contains(piiBody.data.utf8String))\n  }\n\n} Java copysource/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * license agreements; and to You under the Apache License, version 2.0:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * This file is part of the Apache Pekko project, derived from Akka.\n */\n\n/*\n * Copyright (C) 2009-2022 Lightbend Inc. <https://www.lightbend.com>\n */\n\npackage docs.http.javadsl;\n\nimport org.apache.pekko.http.javadsl.model.*;\nimport org.apache.pekko.http.javadsl.model.headers.Authorization;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\nimport java.util.Arrays;\n\npublic class HttpRequestDetailedStringExampleTest {\n\n    // Custom string representation which includes headers\n    public String toDetailedString(HttpRequest request) {\n\n        HttpMethod method = request.method();\n        Uri uri = request.getUri();\n        Iterable<HttpHeader> headers = request.getHeaders();\n        RequestEntity entity = request.entity();\n        HttpProtocol protocol = request.protocol();\n\n        return String.format(\"HttpRequest(%s, %s, %s, %s, %s)\", method, uri, headers, entity, protocol);\n    }\n\n    @Test\n    public void headersInCustomStringRepresentation() {\n\n        // An HTTP header containing Personal Identifying Information\n        Authorization piiHeader = Authorization.basic(\"user\", \"password\");\n\n        // An HTTP entity containing Personal Identifying Information\n        HttpEntity.Strict piiBody = HttpEntities.create(\"This body contains information about [user]\");\n\n        HttpRequest httpRequestWithHeadersAndBody = HttpRequest.create()\n                .withEntity(piiBody)\n                .withHeaders(Arrays.asList(piiHeader));\n\n        // Our custom string representation includes body and headers string representations...\n        assertTrue(toDetailedString(httpRequestWithHeadersAndBody).contains(piiHeader.toString()));\n        assertTrue(toDetailedString(httpRequestWithHeadersAndBody).contains(piiBody.toString()));\n\n        // ... while default `toString` doesn't.\n        assertFalse(httpRequestWithHeadersAndBody.toString().contains(piiHeader.unsafeToString()));\n        assertFalse(httpRequestWithHeadersAndBody.toString().contains(piiBody.getData().utf8String()));\n\n    }\n\n}","title":"HttpRequest"},{"location":"/common/http-model.html#synthetic-headers","text":"In some cases it may be necessary to deviate from fully RFC-Compliant behavior. For instance, Amazon S3 treats the + character in the path part of the URL as a space, even though the RFC specifies that this behavior should be limited exclusively to the query portion of the URI.\nIn order to work around these types of edge cases, Apache Pekko HTTP provides for the ability to provide extra, non-standard information to the request via synthetic headers. These headers are not passed to the client but are instead consumed by the request engine and used to override default behavior.\nFor instance, in order to provide a raw request URI, bypassing the default URL normalization, you could do the following:\nScala copysourceimport org.apache.pekko.http.scaladsl.model.headers.`Raw-Request-URI`\nval req = HttpRequest(uri = \"/ignored\", headers = List(`Raw-Request-URI`(\"/a/b%2Bc\"))) Java copysource// imports org.apache.pekko.http.javadsl.model.headers.RawRequestURI\nHttpRequest.create(\"/ignored\").addHeader(RawRequestURI.create(\"/a/b%2Bc\"));","title":"Synthetic Headers"},{"location":"/common/http-model.html#httpresponse","text":"An HttpResponseHttpResponse consists of\na status code a Seqlist of headers an entity (body data) a protocol\nHere are some examples how to construct an HttpResponseHttpResponse:\nScala copysourceimport StatusCodes._\n\n// simple OK response without data created using the integer status code\nHttpResponse(200)\n\n// 404 response created using the named StatusCode constant\nHttpResponse(NotFound)\n\n// 404 response with a body explaining the error\nHttpResponse(404, entity = \"Unfortunately, the resource couldn't be found.\")\n\n// A redirecting response containing an extra header\nval locationHeader = headers.Location(\"http://example.com/other\")\nHttpResponse(Found, headers = List(locationHeader))\n Java copysource// simple OK response without data created using the integer status code\nHttpResponse ok = HttpResponse.create().withStatus(200);\n\n// 404 response created using the named StatusCode constant\nHttpResponse notFound = HttpResponse.create().withStatus(StatusCodes.NOT_FOUND);\n\n// 404 response with a body explaining the error\nHttpResponse notFoundCustom =\n    HttpResponse.create()\n        .withStatus(404)\n        .withEntity(\"Unfortunately, the resource couldn't be found.\");\n\n// A redirecting response containing an extra header\nLocation locationHeader = Location.create(\"http://example.com/other\");\nHttpResponse redirectResponse =\n    HttpResponse.create()\n        .withStatus(StatusCodes.FOUND)\n        .addHeader(locationHeader);\nIn addition to the simple HttpEntityHttpEntity constructorsHttpEntities.create methods which create an entity from a fixed String or ByteStringByteString as shown here the Apache Pekko HTTP model defines a number of subclasses of HttpEntityHttpEntity which allow body data to be specified as a stream of bytes. All of these types can be created using the method on HttpEntites.\nString representation There are certain environments where it is easy to inadvertently print, write or log entries built out of string representations of HttpResponseHttpResponse instances. On the other hand, it is not uncommon for HTTP headers and entities to contain Personal Identifying Information (PII) or Sensitive Personal Information (SPI) . To avoid accidentally leaking such information, these fields are omitted from HttpResponseHttpResponse toString output. If needed, it is possible to define a custom string representation including all fields as shown in the following example: Scala copysource/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * license agreements; and to You under the Apache License, version 2.0:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * This file is part of the Apache Pekko project, derived from Akka.\n */\n\n/*\n * Copyright (C) 2009-2022 Lightbend Inc. <https://www.lightbend.com>\n */\n\npackage docs.http.scaladsl\n\nimport org.apache.pekko\nimport pekko.http.scaladsl.model.{ HttpEntity, HttpResponse }\nimport pekko.http.scaladsl.model.headers.{ Authorization, BasicHttpCredentials }\nimport pekko.testkit.PekkoSpec\n\nimport scala.collection.immutable\n\nclass HttpResponseDetailedStringExampleSpec extends PekkoSpec {\n\n  // Custom string representation which includes headers\n  def toDetailedString(response: HttpResponse): String = {\n    import response._\n    s\"\"\"HttpResponse(${_1},${_2},${_3},${_4})\"\"\"\n  }\n\n  \"Include headers in custom string representation\" in {\n\n    // An HTTP header containing Personal Identifying Information\n    val piiHeader = Authorization(BasicHttpCredentials(\"user\", \"password\"))\n\n    // An HTTP entity containing Personal Identifying Information\n    val piiBody: HttpEntity.Strict =\n      \"This body contains information about [user]\"\n\n    val httpResponseWithHeadersAndBody =\n      HttpResponse(entity = piiBody, headers = immutable.Seq(piiHeader))\n\n    // Our custom string representation includes body and headers string representations...\n    assert(\n      toDetailedString(httpResponseWithHeadersAndBody)\n        .contains(piiHeader.toString))\n    assert(\n      toDetailedString(httpResponseWithHeadersAndBody)\n        .contains(piiBody.toString))\n\n    // ... while default `toString` doesn't.\n    assert(!s\"$httpResponseWithHeadersAndBody\".contains(piiHeader.unsafeToString))\n    assert(!s\"$httpResponseWithHeadersAndBody\".contains(piiBody.data.utf8String))\n  }\n\n} Java copysource/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * license agreements; and to You under the Apache License, version 2.0:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * This file is part of the Apache Pekko project, derived from Akka.\n */\n\n/*\n * Copyright (C) 2009-2022 Lightbend Inc. <https://www.lightbend.com>\n */\n\npackage docs.http.javadsl;\n\nimport org.apache.pekko.http.javadsl.model.*;\nimport org.apache.pekko.http.javadsl.model.headers.Authorization;\nimport org.junit.Test;\n\nimport java.util.Arrays;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\npublic class HttpResponseDetailedStringExampleTest {\n\n    // Custom string representation which includes headers\n    public String toDetailedString(HttpResponse response) {\n\n        StatusCode status = response.status();\n        Iterable<HttpHeader> headers = response.getHeaders();\n        HttpEntity entity = response.entity();\n        HttpProtocol protocol = response.protocol();\n\n\n        return String.format(\"HttpResponse(%s, %s, %s, %s)\", status, headers, entity, protocol);\n    }\n\n    @Test\n    public void headersInCustomStringRepresentation() {\n\n        // An HTTP header containing Personal Identifying Information\n        Authorization piiHeader = Authorization.basic(\"user\", \"password\");\n\n        // An HTTP entity containing Personal Identifying Information\n        HttpEntity.Strict piiBody = HttpEntities.create(\"This body contains information about [user]\");\n\n        HttpResponse httpResponseWithHeadersAndBody = HttpResponse.create()\n                .withEntity(piiBody)\n                .withHeaders(Arrays.asList(piiHeader));\n\n        // Our custom string representation includes body and headers string representations...\n        assertTrue(toDetailedString(httpResponseWithHeadersAndBody).contains(piiHeader.toString()));\n        assertTrue(toDetailedString(httpResponseWithHeadersAndBody).contains(piiBody.toString()));\n\n        // ... while default `toString` doesn't.\n        assertFalse(httpResponseWithHeadersAndBody.toString().contains(piiHeader.unsafeToString()));\n        assertFalse(httpResponseWithHeadersAndBody.toString().contains(piiBody.getData().utf8String()));\n\n    }\n\n}","title":"HttpResponse"},{"location":"/common/http-model.html#httpentity","text":"An HttpEntityHttpEntity carries the data bytes of a message together with its Content-Type and, if known, its Content-Length. In Apache Pekko HTTP, there are five different kinds of entities which model the various ways that message content can be received or sent:\nHttpEntity.StrictHttpEntityStrict The simplest entity, which is used when all the entity are already available in memory. It wraps a plain ByteStringByteString and represents a standard, unchunked entity with a known Content-Length. HttpEntity.DefaultHttpEntityDefault The general, unchunked HTTP/1.1 message entity. It has a known length and presents its data as a Source<ByteString, ?>Source[ByteString, _] which can be only materialized once. It is an error if the provided source doesn’t produce exactly as many bytes as specified. The distinction of StrictHttpEntityStrict and DefaultHttpEntityDefault is an API-only one. On the wire, both kinds of entities look the same. HttpEntity.ChunkedHttpEntityChunked The model for HTTP/1.1 chunked content (i.e. sent with Transfer-Encoding: chunked). The content length is unknown and the individual chunks are presented as a Source[HttpEntity.ChunkStreamPart]Source<ChunkStreamPart, ?>Source[ChunkStreamPart, ?]. A ChunkStreamPart is either a non-empty Chunkchunk or a LastChunkthe empty last chunk containing optional trailer headers. The stream consists of zero or more Chunkednon-empty chunks parts and can be terminated by an optional LastChunk partlast chunk. HttpEntity.CloseDelimitedHttpEntityCloseDelimited An unchunked entity of unknown length that is implicitly delimited by closing the connection (Connection: close). The content data are presented as a Source<ByteString, ?>Source[ByteString, _]. Since the connection must be closed after sending an entity of this type it can only be used on the server-side for sending a response. Also, the main purpose of CloseDelimited entities is compatibility with HTTP/1.0 peers, which do not support chunked transfer encoding. If you are building a new application and are not constrained by legacy requirements you shouldn’t rely on CloseDelimited entities, since implicit terminate-by-connection-close is not a robust way of signaling response end, especially in the presence of proxies. Additionally this type of entity prevents connection reuse which can seriously degrade performance. Use HttpEntity.ChunkedHttpEntityChunked instead! HttpEntity.IndefiniteLengthHttpEntityIndefiniteLength A streaming entity of unspecified length for use in a Multipart.BodyPart.\nEntity types StrictHttpEntityStrict, DefaultHttpEntityDefault, and ChunkedHttpEntityChunked are a subtype of HttpEntity.RegularRequestEntityRequestEntity which allows to use them for requests and responses. In contrast, HttpEntity.CloseDelimitedHttpEntityCloseDelimited can only be used for responses.\nStreaming entity types (i.e. all but StrictHttpEntityStrict) cannot be shared or serialized. To create a strict, shareable copy of an entity or message use HttpEntity.toStrict or HttpMessage.toStrict which returns a FutureCompletionStage of the object with the body data collected into a ByteStringByteString.\nThe HttpEntityHttpEntity companion objectclass HttpEntities contains several helper constructorsstatic methods to create entities from common types easily.\nYou can pattern match overuse the subtypesisX methods of HttpEntityHttpEntity to find out of which subclass an entity is if you want to provide special handling for each of the subtypes. However, in many cases a recipient of an HttpEntityHttpEntity doesn’t care about of which subtype an entity is (and how data is transported exactly on the HTTP layer). Therefore, the general method HttpEntity.dataBytesHttpEntity.getDataBytes() is provided which returns a Source<ByteString, ?>Source[ByteString, _] that allows access to the data of an entity regardless of its concrete subtype.\nWhen to use which subtype? Use StrictHttpEntityStrict if the amount of data is “small” and already available in memory (e.g. as a String or ByteStringByteString) Use DefaultHttpEntityDefault if the data is generated by a streaming data source and the size of the data is known Use ChunkedHttpEntityChunked for an entity of unknown length Use CloseDelimitedHttpEntityCloseDelimited for a response as a legacy alternative to ChunkedHttpEntityChunked if the client doesn’t support chunked transfer encoding. Otherwise use ChunkedHttpEntityChunked! In a Multipart.BodyPart use IndefiniteLengthHttpEntityIndefiniteLength for content of unknown length.\nCaution When you receive a non-strict message from a connection then additional data are only read from the network when you request them by consuming the entity data stream. This means that, if you don’t consume the entity stream then the connection will effectively be stalled. In particular no subsequent message (request or response) will be read from the connection as the entity of the current message “blocks” the stream. Therefore you must make sure that you always consume the entity data, even in the case that you are not actually interested in it!","title":"HttpEntity"},{"location":"/common/http-model.html#limiting-message-entity-length","text":"All message entities that Apache Pekko HTTP reads from the network automatically get a length verification check attached to them. This check makes sure that the total entity size is less than or equal to the configured max-content-length [1], which is an important defense against certain Denial-of-Service attacks. However, a single global limit for all requests (or responses) is often too inflexible for applications that need to allow large limits for some requests (or responses) but want to clamp down on all messages not belonging into that group.\nIn order to give you maximum flexibility in defining entity size limits according to your needs the HttpEntityHttpEntity features a withSizeLimit method, which lets you adjust the globally configured maximum size for this particular entity, be it to increase or decrease any previously set value. This means that your application will receive all requests (or responses) from the HTTP layer, even the ones whose Content-Length exceeds the configured limit (because you might want to increase the limit yourself). Only when the actual data stream SourceSource contained in the entity is materialized will the boundary checks be actually applied. In case the length verification fails the respective stream will be terminated with an EntityStreamSizeException either directly at materialization time (if the Content-Length is known) or whenever more data bytes than allowed have been read.\nWhen called on Strict entities the withSizeLimit method will return the entity itself if the length is within the bound, otherwise a Default entity with a single element data stream. This allows for potential refinement of the entity size limit at a later point (before materialization of the data stream).\nBy default all message entities produced by the HTTP layer automatically carry the limit that is defined in the application’s max-content-length config setting. If the entity is transformed in a way that changes the content-length and then another limit is applied then this new limit will be evaluated against the new content-length. If the entity is transformed in a way that changes the content-length and no new limit is applied then the previous limit will be applied against the previous content-length. Generally this behavior should be in line with your expectations.\n[1] pekko.http.parsing.max-content-length (applying to server- as well as client-side), pekko.http.server.parsing.max-content-length (server-side only), pekko.http.client.parsing.max-content-length (client-side only) or pekko.http.host-connection-pool.client.parsing.max-content-length (only host-connection-pools)","title":"Limiting message entity length"},{"location":"/common/http-model.html#special-processing-for-head-requests","text":"RFC 7230 defines very clear rules for the entity length of HTTP messages.\nEspecially this rule requires special treatment in Apache Pekko HTTP:\nAny response to a HEAD request and any response with a 1xx (Informational), 204 (No Content), or 304 (Not Modified) status code is always terminated by the first empty line after the header fields, regardless of the header fields present in the message, and thus cannot contain a message body.\nResponses to HEAD requests introduce the complexity that Content-Length or Transfer-Encoding headers can be present but the entity is empty. This is modeled by allowing HttpEntity.DefaultHttpEntityDefault and HttpEntity.ChunkedHttpEntityChunked to be used for HEAD responses with an empty data stream.\nAlso, when a HEAD response has an HttpEntity.CloseDelimitedHttpEntityCloseDelimited entity the Apache Pekko HTTP implementation will not close the connection after the response has been sent. This allows the sending of HEAD responses without Content-Length header across persistent HTTP connections.","title":"Special processing for HEAD requests"},{"location":"/common/http-model.html#header-model","text":"Apache Pekko HTTP contains a rich model of the most common HTTP headers. Parsing and rendering is done automatically so that applications don’t need to care for the actual syntax of headers. Headers not modelled explicitly are represented as a RawHeaderRawHeader, which is essentially a String/String name/value pair.\nSee these examples of how to deal with headers:\nScala copysourceimport org.apache.pekko.http.scaladsl.model.headers._\n\n// create a ``Location`` header\nval loc = Location(\"http://example.com/other\")\n\n// create an ``Authorization`` header with HTTP Basic authentication data\nval auth = Authorization(BasicHttpCredentials(\"joe\", \"josepp\"))\n\n// custom type\ncase class User(name: String, pass: String)\n\n// a method that extracts basic HTTP credentials from a request\ndef credentialsOfRequest(req: HttpRequest): Option[User] =\n  for {\n    Authorization(BasicHttpCredentials(user, pass)) <- req.header[Authorization]\n  } yield User(user, pass) Java copysource        // create a ``Location`` header\n        Location locationHeader = Location.create(\"http://example.com/other\");\n\n        // create an ``Authorization`` header with HTTP Basic authentication data\n        Authorization authorization = Authorization.basic(\"user\", \"pass\");\n\n    // a method that extracts basic HTTP credentials from a request\n\tprivate Optional<BasicHttpCredentials> getCredentialsOfRequest(HttpRequest request) {\n        Optional<Authorization> auth = request.getHeader(Authorization.class);\n        if (auth.isPresent() && auth.get().credentials() instanceof BasicHttpCredentials)\n            return Optional.of((BasicHttpCredentials) auth.get().credentials());\n        else\n            return Optional.empty();\n    }","title":"Header Model"},{"location":"/common/http-model.html#http-headers","text":"When the Apache Pekko HTTP server receives an HTTP request it tries to parse all its headers into their respective model classes. Independently of whether this succeeds or not, the HTTP layer will always pass on all received headers to the application. Unknown headers as well as ones with invalid syntax (according to the header parser) will be made available as RawHeaderRawHeader instances. For the ones exhibiting parsing errors a warning message is logged depending on the value of the illegal-header-warnings config setting.\nSome headers have special status in HTTP and are therefore treated differently from “regular” headers:\nContent-Type The Content-Type of an HTTP message is modeled as the contentType field of the HttpEntityHttpEntity. The Content-Type header therefore doesn’t appear in the headers sequence of a message. Also, a Content-Type header instance that is explicitly added to the headers of a request or response will not be rendered onto the wire and trigger a warning being logged instead! Transfer-Encoding Messages with Transfer-Encoding: chunked are represented via the HttpEntity.Chunkedas a HttpEntityChunked entity. As such chunked messages that do not have another deeper nested transfer encoding will not have a Transfer-Encoding header in their headers sequencelist. Similarly, a Transfer-Encoding header instance that is explicitly added to the headers of a request or response will not be rendered onto the wire and trigger a warning being logged instead! Content-Length The content length of a message is modelled via its HttpEntity. As such no Content-Length header will ever be part of a message’s header sequence. Similarly, a Content-Length header instance that is explicitly added to the headers of a request or response will not be rendered onto the wire and trigger a warning being logged instead! Server A Server header is usually added automatically to any response and its value can be configured via the pekko.http.server.server-header setting. Additionally an application can override the configured header with a custom one by adding it to the response’s header sequence. User-Agent A User-Agent header is usually added automatically to any request and its value can be configured via the pekko.http.client.user-agent-header setting. Additionally an application can override the configured header with a custom one by adding it to the request’s header sequence. Date The DateDate response header is added automatically but can be overridden by supplying it manually. Connection On the server-side Apache Pekko HTTP watches for explicitly added Connection: close response headers and as such honors the potential wish of the application to close the connection after the respective response has been sent out. The actual logic for determining whether to close the connection is quite involved. It takes into account the request’s method, protocol and potential ConnectionConnection header as well as the response’s protocol, entity and potential ConnectionConnection header. See this test for a full table of what happens when. Strict-Transport-Security HTTP Strict Transport Security (HSTS) is a web security policy mechanism which is communicated by the Strict-Transport-Security header. The most important security vulnerability that HSTS can fix is SSL-stripping man-in-the-middle attacks. The SSL-stripping attack works by transparently converting a secure HTTPS connection into a plain HTTP connection. The user can see that the connection is insecure, but crucially there is no way of knowing whether the connection should be secure. HSTS addresses this problem by informing the browser that connections to the site should always use TLS/SSL. See also RFC 6797.","title":"HTTP Headers"},{"location":"/common/http-model.html#custom-headers","text":"Sometimes you may need to model a custom header type which is not part of HTTP and still be able to use it as convenient as is possible with the built-in types.\nBecause of the number of ways one may interact with headers (i.e. try to matchconvert a CustomHeaderCustomHeader againstto a RawHeaderRawHeader or the other way around etc), a helper traitclasses for custom Header types and their companions classes are provided by Apache Pekko HTTP. Thanks to extending ModeledCustomHeaderModeledCustomHeader instead of the plain CustomHeaderCustomHeader such header can be matchedthe following methods are at your disposal:\nScala copysourcefinal class ApiTokenHeader(token: String) extends ModeledCustomHeader[ApiTokenHeader] {\n  override def renderInRequests = true\n  override def renderInResponses = true\n  override val companion = ApiTokenHeader\n  override def value: String = token\n}\nobject ApiTokenHeader extends ModeledCustomHeaderCompanion[ApiTokenHeader] {\n  override val name = \"apiKey\"\n  override def parse(value: String) = Try(new ApiTokenHeader(value))\n} Java copysourcepublic static class ApiTokenHeader extends ModeledCustomHeader {\n\n  ApiTokenHeader(String name, String value) {\n    super(name, value);\n  }\n\n  public boolean renderInResponses() {\n    return false;\n  }\n\n  public boolean renderInRequests() {\n    return false;\n  }\n\n}\n\nstatic class ApiTokenHeaderFactory extends ModeledCustomHeaderFactory<ApiTokenHeader> {\n\n  public String name() {\n    return \"apiKey\";\n  }\n\n  @Override\n  public ApiTokenHeader parse(String value) {\n    return new ApiTokenHeader(name(), value);\n  }\n\n}\nWhich allows this CustomHeadermodeled custom header to be used in the following scenarios:\nScala copysourceval ApiTokenHeader(t1) = ApiTokenHeader(\"token\")\nt1 should ===(\"token\")\n\nval RawHeader(k2, v2) = ApiTokenHeader(\"token\")\nk2 should ===(\"apiKey\")\nv2 should ===(\"token\")\n\n// will match, header keys are case insensitive\nval ApiTokenHeader(v3) = RawHeader(\"APIKEY\", \"token\")\nv3 should ===(\"token\")\n\nintercept[MatchError] {\n  // won't match, different header name\n  val ApiTokenHeader(v4) = DifferentHeader(\"token\")\n}\n\nintercept[MatchError] {\n  // won't match, different header name\n  val RawHeader(\"something\", v5) = DifferentHeader(\"token\")\n}\n\nintercept[MatchError] {\n  // won't match, different header name\n  val ApiTokenHeader(v6) = RawHeader(\"different\", \"token\")\n} Java copysourcefinal ApiTokenHeaderFactory apiTokenHeaderFactory = new ApiTokenHeaderFactory();\nfinal ApiTokenHeader token = apiTokenHeaderFactory.create(\"token\");\nassertEquals(\"token\", token.value());\n\nfinal HttpHeader header = apiTokenHeaderFactory.create(\"token\");\nassertEquals(\"apiKey\", header.name());\nassertEquals(\"token\", header.value());\n\nfinal Optional<ApiTokenHeader> fromRaw = apiTokenHeaderFactory\n  .from(RawHeader.create(\"apiKey\", \"token\"));\nassertTrue(\"Expected a header\", fromRaw.isPresent());\nassertEquals(\"apiKey\", fromRaw.get().name());\nassertEquals(\"token\", fromRaw.get().value());\n\n// will match, header keys are case insensitive\nfinal Optional<ApiTokenHeader> fromRawUpper = apiTokenHeaderFactory\n  .from(RawHeader.create(\"APIKEY\", \"token\"));\nassertTrue(\"Expected a header\", fromRawUpper.isPresent());\nassertEquals(\"apiKey\", fromRawUpper.get().name());\nassertEquals(\"token\", fromRawUpper.get().value());\n\n// won't match, different header name\nfinal Optional<ApiTokenHeader> wrong = apiTokenHeaderFactory\n  .from(RawHeader.create(\"different\", \"token\"));\nassertFalse(wrong.isPresent());\nIncluding usage within the header directives like in the following headerValuePF example:\nScala copysourcedef extractFromCustomHeader = headerValuePF {\n  case t @ ApiTokenHeader(token) => s\"extracted> $t\"\n  case raw: RawHeader            => s\"raw> $raw\"\n}\n\nval routes = extractFromCustomHeader { s =>\n  complete(s)\n}\n\nGet().withHeaders(RawHeader(\"apiKey\", \"TheKey\")) ~> routes ~> check {\n  status should ===(StatusCodes.OK)\n  responseAs[String] should ===(\"extracted> apiKey: TheKey\")\n}\n\nGet().withHeaders(RawHeader(\"somethingElse\", \"TheKey\")) ~> routes ~> check {\n  status should ===(StatusCodes.OK)\n  responseAs[String] should ===(\"raw> somethingElse: TheKey\")\n}\n\nGet().withHeaders(ApiTokenHeader(\"TheKey\")) ~> routes ~> check {\n  status should ===(StatusCodes.OK)\n  responseAs[String] should ===(\"extracted> apiKey: TheKey\")\n} Java copysourceimport org.apache.pekko.http.javadsl.server.Directives;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.headerValuePF;\n\nfinal ApiTokenHeaderFactory apiTokenHeaderFactory = new ApiTokenHeaderFactory();\nfinal PartialFunction<HttpHeader, String> extractFromCustomHeader =\n  new JavaPartialFunction<HttpHeader, String>() {\n\n    @Override\n    public String apply(HttpHeader header, boolean isCheck) throws Exception {\n      if (isCheck)\n        return null;\n      return apiTokenHeaderFactory.from(header)\n        .map(apiTokenHeader -> \"extracted> \" + apiTokenHeader)\n        .orElseGet(() -> \"raw> \" + header);\n    }\n  };\n\nfinal Route route = headerValuePF(extractFromCustomHeader, Directives::complete);\n\ntestRoute(route)\n  .run(HttpRequest.GET(\"/\").addHeader(RawHeader.create(\"apiKey\", \"TheKey\")))\n  .assertStatusCode(StatusCodes.OK)\n  .assertEntity(\"extracted> apiKey: TheKey\");\n\ntestRoute(route)\n  .run(HttpRequest.GET(\"/\").addHeader(RawHeader.create(\"somethingElse\", \"TheKey\")))\n  .assertStatusCode(StatusCodes.OK)\n  .assertEntity(\"raw> somethingElse: TheKey\");\n\ntestRoute(route)\n  .run(HttpRequest.GET(\"/\").addHeader(apiTokenHeaderFactory.create(\"TheKey\")))\n  .assertStatusCode(StatusCodes.OK)\n  .assertEntity(\"extracted> apiKey: TheKey\");\nNote When defining custom headers, it is better to extend ModeledCustomHeaderModeledCustomHeader instead of its parent CustomHeaderCustomHeader. Custom headers that extend ModeledCustomHeaderModeledCustomHeader automatically comply with the pattern matching semantics that usually apply to built-in types (such as matching a custom header against a RawHeaderRawHeader in routing layers of Apache Pekko HTTP applications).\nNote Implement ModeledCustomHeaderModeledCustomHeader and ModeledCustomHeaderFactory instead of CustomHeaderCustomHeader to be able to use the convenience methods that allow parsing the custom user-defined header from HttpHeaderHttpHeader.","title":"Custom Headers"},{"location":"/common/http-model.html#attributes","text":"Sometimes it can be useful to keep track of some information associated with a request without explicitly closing over it. Such information can be attached to a request or response though message attributes:\nScala copysourcecase class User(name: String)\nobject User {\n  val attributeKey = AttributeKey[User](\"user\")\n}\n\ndef determineUser(req: HttpRequest): HttpRequest = {\n  val user = // ... somehow determine the user for this request\n\n  // Add the attribute\n  req.addAttribute(User.attributeKey, user)\n}\n\n// Retrieve the attribute\nval user: Option[User] = requestWithAttribute.attribute(User.attributeKey) Java copysourceclass User {\n    final String name;\n    public User(String name) {\n        this.name = name;\n    }\n\n    public static final AttributeKey<User> attributeKey = AttributeKey.create(\"user\", User.class);\n}\n\npublic HttpRequest determineUser(HttpRequest request) {\n    User user = //... somehow determine the user for this request\n\n    // Add the attribute\n    return request.addAttribute(User.attributeKey, user);\n}\n\n// Retrieve the attribute\nOptional<User> user = requestWithAttribute.getAttribute(User.attributeKey);\nMessage attributes are only to be used within in your application, they are not present on the wire.","title":"Attributes"},{"location":"/common/http-model.html#parsing-rendering","text":"Parsing and rendering of HTTP data structures is heavily optimized and for most types there’s currently no public API provided to parse (or render to) Strings or byte arrays.\nNote Various parsing and rendering settings are available to tweak in the configuration under pekko.http.client[.parsing], pekko.http.server[.parsing] and pekko.http.host-connection-pool[.client.parsing], with defaults for all of these being defined in the pekko.http.parsing configuration section. For example, if you want to change a parsing setting for all components, you can set the pekko.http.parsing.illegal-header-warnings = off value. However this setting can be still overridden by the more specific sections, like for example pekko.http.server.parsing.illegal-header-warnings = on. In this case both client and host-connection-pool APIs will see the setting off, however the server will see on. In the case of pekko.http.host-connection-pool.client settings, they default to settings set in pekko.http.client, and can override them if needed. This is useful, since both client and host-connection-pool APIs, such as the Client API Http().outgoingConnectionHttp.get(sys).outgoingConnection or the Host Connection Pool APIs Http().singleRequestHttp.get(sys).singleRequest or Http().superPoolHttp.get(sys).superPool, usually need the same settings, however the server most likely has a very different set of settings.","title":"Parsing / Rendering"},{"location":"/common/http-model.html#registering-custom-media-types","text":"Apache Pekko HTTP predefinespredefines most commonly encountered media types and emits them in their well-typed form while parsing http messages. Sometimes you may want to define a custom media type and inform the parser infrastructure about how to handle these custom media types, e.g. that application/custom is to be treated as NonBinary with WithFixedCharset. To achieve this you need to register the custom media type in the server’s settings by configuring ParserSettingsParserSettings like this:\nScala copysource // similarly in Java: `org.apache.pekko.http.javadsl.settings.[...]`\nimport org.apache.pekko\nimport pekko.http.scaladsl.settings.ParserSettings\nimport pekko.http.scaladsl.settings.ServerSettings\n\n// define custom media type:\nval utf8 = HttpCharsets.`UTF-8`\nval `application/custom`: WithFixedCharset =\n  MediaType.customWithFixedCharset(\"application\", \"custom\", utf8)\n\n// add custom media type to parser settings:\nval parserSettings = ParserSettings.forServer(system).withCustomMediaTypes(`application/custom`)\nval serverSettings = ServerSettings(system).withParserSettings(parserSettings)\n\nval routes = extractRequest { r =>\n  complete(r.entity.contentType.toString + \" = \" + r.entity.contentType.getClass)\n}\nval binding = Http().newServerAt(\"localhost\", 0).withSettings(serverSettings).bind(routes) Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.extractRequest;\n\n// Define custom media type:\nfinal MediaType.WithFixedCharset applicationCustom =\n  MediaTypes.customWithFixedCharset(\"application\", \"custom\", // The new Media Type name\n    HttpCharsets.UTF_8, // The charset used\n    new HashMap<>(), // Empty parameters\n    false); // No arbitrary subtypes are allowed\n\n// Add custom media type to parser settings:\nfinal ParserSettings parserSettings = ParserSettings.forServer(system)\n  .withCustomMediaTypes(applicationCustom);\nfinal ServerSettings serverSettings = ServerSettings.create(system)\n  .withParserSettings(parserSettings);\n\nfinal Route route = extractRequest(req ->\n  complete(req.entity().getContentType().toString() + \" = \"\n    + req.entity().getContentType().getClass())\n);\n\nfinal CompletionStage<ServerBinding> binding =\n  Http.get(system)\n    .newServerAt(host, 0)\n    .withSettings(serverSettings)\n    .bind(route);\nYou may also want to read about MediaType Registration trees, in order to register your vendor specific media types in the right style / place.","title":"Registering Custom Media Types"},{"location":"/common/http-model.html#registering-custom-status-codes","text":"Similarly to media types, Apache Pekko HTTP predefinespredefines well-known status codes, however sometimes you may need to use a custom one (or are forced to use an API which returns custom status codes). Similarly to the media types registration, you can register custom status codes by configuring ParserSettingsParserSettings like this:\nScala copysource// similarly in Java: `org.apache.pekko.http.javadsl.settings.[...]`\nimport org.apache.pekko.http.scaladsl.settings.{ ParserSettings, ServerSettings }\n\n// define custom status code:\nval LeetCode = StatusCodes.custom(777, \"LeetCode\", \"Some reason\", isSuccess = true, allowsEntity = false)\n\n// add custom method to parser settings:\nval parserSettings = ParserSettings.forServer(system).withCustomStatusCodes(LeetCode)\nval serverSettings = ServerSettings(system).withParserSettings(parserSettings)\n\nval clientConSettings = ClientConnectionSettings(system).withParserSettings(parserSettings)\nval clientSettings = ConnectionPoolSettings(system).withConnectionSettings(clientConSettings)\n\nval routes =\n  complete(HttpResponse(status = LeetCode))\n\n// use serverSettings in server:\nval binding = Http().newServerAt(\"127.0.0.1\", 0).withSettings(serverSettings).bind(routes).futureValue\n\n// use clientSettings in client:\nval request = HttpRequest(uri = s\"http://127.0.0.1:${binding.localAddress.getPort}/\")\nval response = Http().singleRequest(request, settings = clientSettings)\n\n// futureValue is a ScalaTest helper:\nresponse.futureValue.status should ===(LeetCode) Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.extractRequest;\n\n// Define custom status code:\nfinal StatusCode leetCode = StatusCodes.custom(777, // Our custom status code\n  \"LeetCode\", // Our custom reason\n  \"Some reason\", // Our custom default message\n  true, // It should be considered a success response\n  false);// Does not allow entities\n\n// Add custom method to parser settings:\nfinal ParserSettings parserSettings = ParserSettings.forServer(system)\n  .withCustomStatusCodes(leetCode);\nfinal ServerSettings serverSettings = ServerSettings.create(system)\n  .withParserSettings(parserSettings);\n\nfinal ClientConnectionSettings clientConSettings = ClientConnectionSettings.create(system)\n  .withParserSettings(parserSettings);\nfinal ConnectionPoolSettings clientSettings = ConnectionPoolSettings.create(system)\n  .withConnectionSettings(clientConSettings);\n\nfinal Route route = extractRequest(req ->\n  complete(HttpResponse.create().withStatus(leetCode))\n);\n\n// Use serverSettings in server:\nfinal CompletionStage<ServerBinding> binding = Http.get(system)\n  .newServerAt(host, 0)\n  .withSettings(serverSettings)\n  .bind(route);\n\nfinal ServerBinding serverBinding = binding.toCompletableFuture().get();\n\nfinal int port = serverBinding.localAddress().getPort();\n\n// Use clientSettings in client:\nfinal HttpResponse response = Http.get(system)\n  .singleRequest(HttpRequest\n    .GET(\"http://\" + host + \":\" + port + \"/\"),\n    ConnectionContext.https(SSLContext.getDefault()),\n    clientSettings,\n    system.log())\n  .toCompletableFuture()\n  .get();\n\n// Check we get the right code back\nassertEquals(leetCode, response.status());","title":"Registering Custom Status Codes"},{"location":"/common/http-model.html#registering-custom-http-method","text":"Apache Pekko HTTP also allows you to define custom HTTP methods, other than the well-known methods predefinedpredefined in Apache Pekko HTTP. To use a custom HTTP method, you need to define it, and then add it to parser settings like below:\nScala copysourceimport org.apache.pekko.http.scaladsl.settings.{ ParserSettings, ServerSettings }\n\n// define custom method type:\nval BOLT = HttpMethod.custom(\"BOLT\", safe = false,\n  idempotent = true, requestEntityAcceptance = Expected)\n\n// add custom method to parser settings:\nval parserSettings = ParserSettings.forServer(system).withCustomMethods(BOLT)\nval serverSettings = ServerSettings(system).withParserSettings(parserSettings)\n\nval routes = extractMethod { method =>\n  complete(s\"This is a ${method.name} method request.\")\n}\nval binding = Http().newServerAt(host, port).withSettings(serverSettings).bind(routes)\n\nval request = HttpRequest(BOLT, s\"http://$host:$port/\", protocol = `HTTP/1.1`) Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.extractMethod;\n\n\n// define custom method type:\nHttpMethod BOLT =\n  HttpMethods.custom(\"BOLT\", false, true, Expected);\n\n// add custom method to parser settings:\nfinal ParserSettings parserSettings =\n  ParserSettings.forServer(system).withCustomMethods(BOLT);\nfinal ServerSettings serverSettings =\n  ServerSettings.create(system).withParserSettings(parserSettings);\n\nfinal Route routes = concat(\n  extractMethod( method ->\n    complete( \"This is a \" + method.name() + \" request.\")\n  )\n);\nfinal Http http = Http.get(system);\nfinal CompletionStage<ServerBinding> binding =\n  http.newServerAt(host, port)\n      .withSettings(serverSettings)\n      .logTo(loggingAdapter)\n      .bind(routes);\n\nHttpRequest request = HttpRequest.create()\n  .withUri(\"http://\" + host + \":\" + Integer.toString(port))\n  .withMethod(BOLT)\n  .withProtocol(HTTP_1_1);\n\nCompletionStage<HttpResponse> response = http.singleRequest(request);","title":"Registering Custom HTTP Method"},{"location":"/common/uri-model.html","text":"","title":"The URI model"},{"location":"/common/uri-model.html#the-uri-model","text":"Apache Pekko HTTP offers its own specialised UriUri model class which is tuned for both performance and idiomatic usage within other types of the HTTP model. For example, an HttpRequestHttpRequest’s target URI is parsed into this type, where all character escaping and other URI specific semantics are applied.","title":"The URI model"},{"location":"/common/uri-model.html#parsing-a-uri-string","text":"We follow RFC 3986 to implement the URI parsing rules. When you try to parse a URI string, Apache Pekko HTTP internally creates an instance of the UriUri class, which holds the modeled URI components inside.\nFor example, the following creates an instance of a simple valid URI:\nScala Uri(\"http://localhost\")\n Java Uri.create(\"http://localhost\");\nBelow are some more examples of valid URI strings, and how you can construct a UriUri model class instances ,using Uri.from() method by passing scheme, host, path and query parameters.\nScala copysourceUri(\"ftp://ftp.is.co.za/rfc/rfc1808.txt\") shouldEqual\nUri.from(scheme = \"ftp\", host = \"ftp.is.co.za\", path = \"/rfc/rfc1808.txt\")\n\nUri(\"http://www.ietf.org/rfc/rfc2396.txt\") shouldEqual\nUri.from(scheme = \"http\", host = \"www.ietf.org\", path = \"/rfc/rfc2396.txt\")\n\nUri(\"ldap://[2001:db8::7]/c=GB?objectClass?one\") shouldEqual\nUri.from(scheme = \"ldap\", host = \"[2001:db8::7]\", path = \"/c=GB\", queryString = Some(\"objectClass?one\"))\n\nUri(\"mailto:John.Doe@example.com\") shouldEqual\nUri.from(scheme = \"mailto\", path = \"John.Doe@example.com\")\n\nUri(\"news:comp.infosystems.www.servers.unix\") shouldEqual\nUri.from(scheme = \"news\", path = \"comp.infosystems.www.servers.unix\")\n\nUri(\"tel:+1-816-555-1212\") shouldEqual\nUri.from(scheme = \"tel\", path = \"+1-816-555-1212\")\n\nUri(\"s3:image.png\") shouldEqual\nUri.from(scheme = \"s3\", path = \"image.png\")\n\nUri(\"telnet://192.0.2.16:80/\") shouldEqual\nUri.from(scheme = \"telnet\", host = \"192.0.2.16\", port = 80, path = \"/\")\n\nUri(\"urn:oasis:names:specification:docbook:dtd:xml:4.1.2\") shouldEqual\nUri.from(scheme = \"urn\", path = \"oasis:names:specification:docbook:dtd:xml:4.1.2\") Java copysourceUri uri1 = Uri.create(\"ftp://ftp.is.co.za/rfc/rfc1808.txt\");\nassertEquals(\"ftp\", uri1.getScheme());\nassertEquals(Host.create(\"ftp.is.co.za\"), uri1.getHost());\nassertEquals(\"/rfc/rfc1808.txt\", uri1.getPathString());\n\nUri uri2 = Uri.create(\"http://www.ietf.org/rfc/rfc2396.txt\");\nassertEquals(\"http\", uri2.getScheme());\nassertEquals(Host.create(\"www.ietf.org\"), uri2.getHost());\nassertEquals(\"/rfc/rfc2396.txt\", uri2.getPathString());\n\nUri uri3 = Uri.create(\"ldap://[2001:db8::7]/c=GB?objectClass?one\");\nassertEquals(\"ldap\", uri3.getScheme());\nassertEquals(Host.create(\"[2001:db8::7]\"), uri3.getHost());\nassertEquals(\"objectClass?one\", uri3.query().toString());\n\nUri uri4 = Uri.create(\"mailto:John.Doe@example.com\");\nassertEquals(\"mailto\", uri4.getScheme());\nassertEquals(\"John.Doe@example.com\", uri4.getPathString());\n\nUri uri5 = Uri.create(\"news:comp.infosystems.www.servers.unix\");\nassertEquals(\"news\", uri5.getScheme());\nassertEquals(\"comp.infosystems.www.servers.unix\", uri5.getPathString());\n\nUri uri6 = Uri.create(\"tel:+1-816-555-1212\");\nassertEquals(\"tel\", uri6.getScheme());\nassertEquals(\"+1-816-555-1212\", uri6.getPathString());\n\nUri uri7 = Uri.create(\"telnet://192.0.2.16:80/\");\nassertEquals(\"telnet\", uri7.getScheme());\nassertEquals(Host.create(\"192.0.2.16\"), uri7.getHost());\nassertEquals(\"/\", uri7.getPathString());\n\nUri uri8 = Uri.create(\"urn:oasis:names:specification:docbook:dtd:xml:4.1.2\");\nassertEquals(\"urn\", uri8.getScheme());\nassertEquals(\"oasis:names:specification:docbook:dtd:xml:4.1.2\", uri8.getPathString());\nFor exact definitions of the parts of a URI, like scheme, path and query refer to RFC 3986. Here’s a little overview:\nfoo://example.com:8042/over/there?name=ferret#nose\n  \\_/   \\______________/\\_________/ \\_________/ \\__/\n   |           |            |            |        |\nscheme     authority       path        query   fragment\n   |   _____________________|__\n  / \\ /                        \\\n  urn:example:animal:ferret:nose\nFor “special” characters in URI, you typically use percent encoding like below. Percent encoding is discussed in more detail in the Query String in URI section.\nScala copysource// don't double decode\nUri(\"%2520\").path.head shouldEqual \"%20\"\nUri(\"/%2F%5C\").path shouldEqual Path / \"\"\"/\\\"\"\" Java copysourceUri uri1 = Uri.create(\"http://foo.com?foo=%2520\");\nassertEquals(Optional.of(\"%20\"), uri1.query().get(\"foo\"));\nUri uri2 = Uri.create(\"http://foo.com?foo=%2F%5C\");\nassertEquals(Optional.of(\"/\\\\\"), uri2.query().get(\"foo\"));","title":"Parsing a URI string"},{"location":"/common/uri-model.html#invalid-uri-strings-and-illegaluriexception","text":"When an invalid URI string is passed to Uri() as below, an IllegalUriException is thrown.\nScala copysource// illegal scheme\nthe[IllegalUriException] thrownBy Uri(\"foö:/a\") shouldBe {\n  IllegalUriException(\n    \"Illegal URI reference: Invalid input 'ö', expected scheme-char, ':', pchar, slashSegments, '?', '#' or 'EOI' (line 1, column 3)\",\n    \"foö:/a\\n\" +\n    \"  ^\")\n}\n\n// illegal userinfo\nthe[IllegalUriException] thrownBy Uri(\"http://user:ö@host\") shouldBe {\n  IllegalUriException(\n    \"Illegal URI reference: Invalid input 'ö', expected userinfo-char, pct-encoded, '@' or port (line 1, column 13)\",\n    \"http://user:ö@host\\n\" +\n    \"            ^\")\n}\n\n// illegal percent-encoding\nthe[IllegalUriException] thrownBy Uri(\"http://use%2G@host\") shouldBe {\n  IllegalUriException(\n    \"Illegal URI reference: Invalid input 'G', expected HEXDIG (line 1, column 13)\",\n    \"http://use%2G@host\\n\" +\n    \"            ^\")\n}\n\n// illegal percent-encoding ends with %\nthe[IllegalUriException] thrownBy Uri(\"http://www.example.com/%CE%B8%\") shouldBe {\n  IllegalUriException(\n    \"Illegal URI reference: Unexpected end of input, expected HEXDIG (line 1, column 31)\",\n    \"http://www.example.com/%CE%B8%\\n\" +\n    \"                              ^\")\n}\n\n// illegal percent-encoding in a query string\nthe[IllegalUriException] thrownBy Uri(\"http://host?use%2G\") shouldBe {\n  IllegalUriException(\n    \"Illegal URI reference: Invalid input 'G', expected HEXDIG (line 1, column 18)\",\n    \"http://host?use%2G\\n\" +\n    \"                 ^\")\n}\n// illegal percent-encoding in a fragment\nthe[IllegalUriException] thrownBy Uri(\"http://host#use%2G\") shouldBe {\n  IllegalUriException(\n    \"Illegal URI reference: Invalid input 'G', expected HEXDIG (line 1, column 18)\",\n    \"http://host#use%2G\\n\" +\n    \"                 ^\")\n}\n\n// illegal path\nthe[IllegalUriException] thrownBy Uri(\"http://www.example.com/name with spaces/\") shouldBe {\n  IllegalUriException(\n    \"Illegal URI reference: Invalid input ' ', expected pchar, '/', '?', '#' or 'EOI' (line 1, column 28)\",\n    \"http://www.example.com/name with spaces/\\n\" +\n    \"                           ^\")\n}\n\n// illegal path with control character\nthe[IllegalUriException] thrownBy Uri(\"http:///with\\newline\") shouldBe {\n  IllegalUriException(\n    \"Illegal URI reference: Invalid input '\\\\n', expected pchar, '/', '?', '#' or 'EOI' (line 1, column 13)\",\n    \"http:///with\\n\" +\n    \"            ^\")\n} Java copysource@Test(expected = IllegalUriException.class)\npublic void testIllegalScheme() {\n  Uri.create(\"foö:/a\");\n  //IllegalUriException(\n  //  \"Illegal URI reference: Invalid input 'ö', expected scheme-char, 'EOI', '#', ':', '?', slashSegments or pchar (line 1, column 3)\",\n  //  \"http://user:ö@host\\n\" +\n  //  \"            ^\"\n  //)\n}\n@Test(expected = IllegalUriException.class)\npublic void testIllegalUserInfo() {\n  Uri.create(\"http://user:ö@host\");\n  //IllegalUriException(\n  //  \"Illegal URI reference: Invalid input 'ö', expected userinfo-char, pct-encoded, '@' or port (line 1, column 13)\",\n  //  \"http://use%2G@host\\n\" +\n  //  \"            ^\"\n  //)\n}\n@Test(expected = IllegalUriException.class)\npublic void testIllegalPercentEncoding() {\n  Uri.create(\"http://use%2G@host\");\n  //IllegalUriException(\n  //  \"Illegal URI reference: Invalid input 'G', expected HEXDIG (line 1, column 13)\",\n  //  \"http://www.example.com/name with spaces/\\n\" +\n  //  \"                           ^\"\n  //)\n}\n@Test(expected = IllegalUriException.class)\npublic void testIllegalPath() {\n  Uri.create(\"http://www.example.com/name with spaces/\");\n  //IllegalUriException(\n  //  \"Illegal URI reference: Invalid input ' ', expected '/', 'EOI', '#', '?' or pchar (line 1, column 28)\",\n  //  \"http://www.example.com/name with spaces/\\n\" +\n  //  \"                           ^\"\n  //)\n}\n@Test(expected = IllegalUriException.class)\npublic void testIllegalPathWithControlCharacter() {\n  Uri.create(\"http:///with\\newline\");\n  //IllegalUriException(\n  //  \"Illegal URI reference: Invalid input '\\\\n', expected '/', 'EOI', '#', '?' or pchar (line 1, column 13)\",\n  //  \"http:///with\\n\" +\n  //  \"            ^\"\n  //)\n}","title":"Invalid URI strings and IllegalUriException"},{"location":"/common/uri-model.html#directives-to-extract-uri-components","text":"To extract URI components with directives, see following references:\nextractUri extractScheme scheme PathDirectives ParameterDirectives","title":"Directives to extract URI components"},{"location":"/common/uri-model.html#obtaining-the-raw-request-uri","text":"Sometimes it may be needed to obtain the “raw” value of an incoming URI, without applying any escaping or parsing to it. While this use case is rare, it comes up every once in a while. It is possible to obtain the “raw” request URI in Apache Pekko HTTP Server side by turning on the pekko.http.server.raw-request-uri-header flag. When enabled, a Raw-Request-URI header will be added to each request. This header will hold the original raw request’s URI that was used. For an example check the reference configuration.","title":"Obtaining the raw request URI"},{"location":"/common/uri-model.html#query-string-in-uri","text":"Although any part of URI can have special characters, it is more common for the query string in URI to have special characters, which are typically percent encoded.\nUriUri class’s query() methodThe method Uri::query() returns the query string of the URI, which is modeled in an instance of the Query class. When you instantiate a UriUri class by passing a URI string, the query string is stored in its raw string form. Then, when you call the query() method, the query string is parsed from the raw string.\nYou can add query parameters with UriUri class’s withQuery() methodUri::query() method\nScala copysourceval uriWithQuery = uri.withQuery(Query(\"param1\" -> \"value1\")) Java copysourceUri uri = Uri.create(\"http://foo.com\").query(Query.create(Pair.create(\"foo\",\"bar\")));\nThe below code illustrates how valid query strings are parsed. Especially, you can check how percent encoding is used and how special characters like + and ; are parsed.\nNote The mode parameter to Query() and Uri.query() is discussed in Strict and Relaxed Mode.\nScala copysourcedef strict(queryString: String): Query = Query(queryString, mode = Uri.ParsingMode.Strict) Java copysourcepublic Query strict(String query){\n  return Query.create(query, org.apache.pekko.http.javadsl.model.Uri.STRICT);\n}\nScala copysource// query component \"a=b\" is parsed into parameter name: \"a\", and value: \"b\"\nstrict(\"a=b\") shouldEqual (\"a\", \"b\") +: Query.Empty\n\nstrict(\"\") shouldEqual Query.Empty\nstrict(\"a\") shouldEqual (\"a\", \"\") +: Query.Empty\nstrict(\"a=\") shouldEqual (\"a\", \"\") +: Query.Empty\nstrict(\"a=+\") shouldEqual (\"a\", \" \") +: Query.Empty // '+' is parsed to ' '\nstrict(\"a=%2B\") shouldEqual (\"a\", \"+\") +: Query.Empty\nstrict(\"=a\") shouldEqual (\"\", \"a\") +: Query.Empty\nstrict(\"a&\") shouldEqual (\"a\", \"\") +: (\"\", \"\") +: Query.Empty\nstrict(\"a=%62\") shouldEqual (\"a\", \"b\") +: Query.Empty\n\nstrict(\"a%3Db=c\") shouldEqual (\"a=b\", \"c\") +: Query.Empty\nstrict(\"a%26b=c\") shouldEqual (\"a&b\", \"c\") +: Query.Empty\nstrict(\"a%2Bb=c\") shouldEqual (\"a+b\", \"c\") +: Query.Empty\nstrict(\"a%3Bb=c\") shouldEqual (\"a;b\", \"c\") +: Query.Empty\n\nstrict(\"a=b%3Dc\") shouldEqual (\"a\", \"b=c\") +: Query.Empty\nstrict(\"a=b%26c\") shouldEqual (\"a\", \"b&c\") +: Query.Empty\nstrict(\"a=b%2Bc\") shouldEqual (\"a\", \"b+c\") +: Query.Empty\nstrict(\"a=b%3Bc\") shouldEqual (\"a\", \"b;c\") +: Query.Empty\n\nstrict(\"a+b=c\") shouldEqual (\"a b\", \"c\") +: Query.Empty // '+' is parsed to ' '\nstrict(\"a=b+c\") shouldEqual (\"a\", \"b c\") +: Query.Empty // '+' is parsed to ' ' Java copysource//query component (name: \"a\", and value: \"b\") is equal to parsed query string \"a=b\"\nassertEquals(Query.create(Pair.create(\"a\", \"b\")), strict(\"a=b\"));\n\nassertEquals(Query.EMPTY, strict(\"\"));\nassertEquals(Query.create(Pair.create(\"a\", \"\")), strict(\"a\"));\nassertEquals(Query.create(Pair.create(\"a\", \"\")), strict(\"a=\"));\nassertEquals(Query.create(Pair.create(\"a\", \" \")), strict(\"a=+\"));\nassertEquals(Query.create(Pair.create(\"a\", \"+\")), strict(\"a=%2B\"));\nassertEquals(Query.create(Pair.create(\"\", \"a\")), strict(\"=a\"));\nassertEquals(Query.create(Pair.create(\"a\", \"\")).withParam(\"\", \"\"), strict(\"a&\"));\nassertEquals(Query.create(Pair.create(\"a\", \"b\")), strict(\"a=%62\"));\n\nassertEquals(Query.create(Pair.create(\"a=b\", \"c\")), strict(\"a%3Db=c\"));\nassertEquals(Query.create(Pair.create(\"a&b\", \"c\")), strict(\"a%26b=c\"));\nassertEquals(Query.create(Pair.create(\"a+b\", \"c\")), strict(\"a%2Bb=c\"));\nassertEquals(Query.create(Pair.create(\"a;b\", \"c\")), strict(\"a%3Bb=c\"));\n\nassertEquals(Query.create(Pair.create(\"a\", \"b=c\")), strict(\"a=b%3Dc\"));\nassertEquals(Query.create(Pair.create(\"a\", \"b&c\")), strict(\"a=b%26c\"));\nassertEquals(Query.create(Pair.create(\"a\", \"b+c\")), strict(\"a=b%2Bc\"));\nassertEquals(Query.create(Pair.create(\"a\", \"b;c\")), strict(\"a=b%3Bc\"));\n\nassertEquals(Query.create(Pair.create(\"a b\", \"c\")), strict(\"a+b=c\")); //'+' is parsed to ' '\nassertEquals(Query.create(Pair.create(\"a\", \"b c\")), strict(\"a=b+c\")); //'+' is parsed to ' '\nNote that:\nUri(\"http://localhost?a=b\").query()\nis equivalent to:\nQuery(\"a=b\")\nAs in the section 3.4 of RFC 3986, some special characters like “/” and “?” are allowed inside a query string, without escaping them using (“%”) signs.\nThe characters slash (“/”) and question mark (“?”) may represent data within the query component.\n“/” and “?” are commonly used when you have a URI whose query parameter has another URI.\nScala copysourcestrict(\"a?b=c\") shouldEqual (\"a?b\", \"c\") +: Query.Empty\nstrict(\"a/b=c\") shouldEqual (\"a/b\", \"c\") +: Query.Empty\n\nstrict(\"a=b?c\") shouldEqual (\"a\", \"b?c\") +: Query.Empty\nstrict(\"a=b/c\") shouldEqual (\"a\", \"b/c\") +: Query.Empty Java copysourceassertEquals(Query.create(Pair.create(\"a?b\", \"c\")), strict(\"a?b=c\"));\nassertEquals(Query.create(Pair.create(\"a/b\", \"c\")), strict(\"a/b=c\"));\n\nassertEquals(Query.create(Pair.create(\"a\", \"b?c\")), strict(\"a=b?c\"));\nassertEquals(Query.create(Pair.create(\"a\", \"b/c\")), strict(\"a=b/c\"));\nHowever, some other special characters can cause IllegalUriException without percent encoding as follows.\nScala copysourcethe[IllegalUriException] thrownBy strict(\"a^=b\") shouldBe {\n  IllegalUriException(\n    \"Illegal query: Invalid input '^', expected '+', query-char, pct-encoded, '=', '&' or 'EOI' (line 1, column 2)\",\n    \"a^=b\\n\" +\n    \" ^\")\n}\nthe[IllegalUriException] thrownBy strict(\"a;=b\") shouldBe {\n  IllegalUriException(\n    \"Illegal query: Invalid input ';', expected '+', query-char, pct-encoded, '=', '&' or 'EOI' (line 1, column 2)\",\n    \"a;=b\\n\" +\n    \" ^\")\n} Java copysource@Test(expected = IllegalUriException.class)\npublic void testStrictModeException1() {\n  strict(\"a^=b\");\n  //IllegalUriException(\n  //  \"Illegal query: Invalid input '^', expected '+', '=', query-char, 'EOI', '&' or pct-encoded (line 1, column 2)\",\n  //  \"a^=b\\n\" +\n  //  \" ^\")\n}\nScala copysource// double '=' in query string is invalid\nthe[IllegalUriException] thrownBy strict(\"a=b=c\") shouldBe {\n  IllegalUriException(\n    \"Illegal query: Invalid input '=', expected '+', query-char, pct-encoded, '&' or 'EOI' (line 1, column 4)\",\n    \"a=b=c\\n\" +\n    \"   ^\")\n}\n// following '%', it should be percent encoding (HEXDIG), but \"%b=\" is not a valid percent encoding\nthe[IllegalUriException] thrownBy strict(\"a%b=c\") shouldBe {\n  IllegalUriException(\n    \"Illegal query: Invalid input '=', expected HEXDIG (line 1, column 4)\",\n    \"a%b=c\\n\" +\n    \"   ^\")\n} Java copysource@Test(expected = IllegalUriException.class)\npublic void testStrictModeException2() {\n  strict(\"a;=b\");\n  //IllegalUriException(\n  //  \"Illegal query: Invalid input ';', expected '+', '=', query-char, 'EOI', '&' or pct-encoded (line 1, column 2)\",\n  //  \"a;=b\\n\" +\n  //  \" ^\")\n}","title":"Query string in URI"},{"location":"/common/uri-model.html#strict-and-relaxed-mode","text":"The Uri.query() method and Query() take a parameter mode, which is either Uri.ParsingMode.Strict or Uri.ParsingMode.Relaxed. Switching the mode gives different behavior on parsing some special characters in URI.\nScala copysourcedef relaxed(queryString: String): Query = Query(queryString, mode = Uri.ParsingMode.Relaxed) Java copysourcepublic Query relaxed(String query){\n  return Query.create(query,  org.apache.pekko.http.javadsl.model.Uri.RELAXED);\n}\nThe below two cases threw IllegalUriException when you specified the Strict mode,\nScala copysourcethe[IllegalUriException] thrownBy strict(\"a^=b\") shouldBe {\n  IllegalUriException(\n    \"Illegal query: Invalid input '^', expected '+', query-char, pct-encoded, '=', '&' or 'EOI' (line 1, column 2)\",\n    \"a^=b\\n\" +\n    \" ^\")\n}\nthe[IllegalUriException] thrownBy strict(\"a;=b\") shouldBe {\n  IllegalUriException(\n    \"Illegal query: Invalid input ';', expected '+', query-char, pct-encoded, '=', '&' or 'EOI' (line 1, column 2)\",\n    \"a;=b\\n\" +\n    \" ^\")\n} Java copysource@Test(expected = IllegalUriException.class)\npublic void testStrictModeException1() {\n  strict(\"a^=b\");\n  //IllegalUriException(\n  //  \"Illegal query: Invalid input '^', expected '+', '=', query-char, 'EOI', '&' or pct-encoded (line 1, column 2)\",\n  //  \"a^=b\\n\" +\n  //  \" ^\")\n}\n@Test(expected = IllegalUriException.class)\npublic void testStrictModeException2() {\n  strict(\"a;=b\");\n  //IllegalUriException(\n  //  \"Illegal query: Invalid input ';', expected '+', '=', query-char, 'EOI', '&' or pct-encoded (line 1, column 2)\",\n  //  \"a;=b\\n\" +\n  //  \" ^\")\n}\nbut the Relaxed mode parses them as they are.\nScala copysourcerelaxed(\"a^=b\") shouldEqual (\"a^\", \"b\") +: Query.Empty\nrelaxed(\"a;=b\") shouldEqual (\"a;\", \"b\") +: Query.Empty\nrelaxed(\"a=b=c\") shouldEqual (\"a\", \"b=c\") +: Query.Empty Java copysourceassertEquals(Query.create(Pair.create(\"a^\", \"b\")), relaxed(\"a^=b\"));\nassertEquals(Query.create(Pair.create(\"a;\", \"b\")), relaxed(\"a;=b\"));\nassertEquals(Query.create(Pair.create(\"a\", \"b=c\")), relaxed(\"a=b=c\"));\nHowever, even with the Relaxed mode, there are still invalid special characters which require percent encoding.\nScala copysource// following '%', it should be percent encoding (HEXDIG), but \"%b=\" is not a valid percent encoding\n// still invalid even in relaxed mode\nthe[IllegalUriException] thrownBy relaxed(\"a%b=c\") shouldBe {\n  IllegalUriException(\n    \"Illegal query: Invalid input '=', expected HEXDIG (line 1, column 4)\",\n    \"a%b=c\\n\" +\n    \"   ^\")\n} Java copysource@Test(expected = IllegalUriException.class)\npublic void testRelaxedModeException1() {\n  //following '%', it should be percent encoding (HEXDIG), but \"%b=\" is not a valid percent encoding\n  //still invalid even in relaxed mode\n  relaxed(\"a%b=c\");\n  //IllegalUriException(\n  //  \"Illegal query: Invalid input '=', expected '+', query-char, 'EOI', '&' or pct-encoded (line 1, column 4)\",\n  //  \"a%b=c\\n\" +\n  //  \"   ^\")\n}\nOther than specifying the mode in the parameters, like when using directives, you can specify the mode in your configuration as follows.\n# Sets the strictness mode for parsing request target URIs.\n    # The following values are defined:\n    #\n    # `strict`: RFC3986-compliant URIs are required,\n    #     a 400 response is triggered on violations\n    #\n    # `relaxed`: all visible 7-Bit ASCII chars are allowed\n    #\n    uri-parsing-mode = strict\nTo access the raw, unparsed representation of the query part of a URI use the rawQueryString member of the UriUri class.","title":"Strict and Relaxed Mode"},{"location":"/common/uri-model.html#directives-to-extract-query-parameters","text":"If you want to use directives to extract query parameters, see below pages.\nparameters parameter","title":"Directives to extract query parameters"},{"location":"/common/marshalling.html","text":"","title":"Marshalling"},{"location":"/common/marshalling.html#marshalling","text":"TODO overhaul for Java\nMarshalling is the process of converting a higher-level (object) structure into some kind of lower-level representation, often a “wire format”. Other popular names for marshalling are “serialization” or “pickling”.\nIn Apache Pekko HTTP, marshalling means the conversion of an object of type T into a lower-level target type, e.g. a MessageEntity (which forms the “entity body” of an HTTP request or response) or a full HttpRequestHttpRequest or HttpResponseHttpResponse.\nOn the server-side, for example, marshalling is used to convert an application-domain object to a response entity. Requests can contain an AcceptAccept header that lists acceptable content types for the client, such as application/json and application/xml. A marshaller contains the logic to negotiate the result content types based on the AcceptAccept and the AcceptCharset headers.","title":"Marshalling"},{"location":"/common/marshalling.html#basic-design","text":"Marshalling of instances of type A into instances of type B is performed by a Marshaller<A, B>Marshaller[A, B].\nContrary to what you might initially expect, Marshaller<A, B>Marshaller[A, B] is not a plain function A => B but rather essentially a function A => Future[List[Marshalling[B]]]A => CompletionStage<List<Marshalling<B>>>. Let’s dissect this rather complicated looking signature piece by piece to understand why marshallers are designed this way. Given an instance of type A a Marshaller<A, B>Marshaller[A, B] produces:\nA FutureCompletionStage: This is probably quite clear. Marshallers are not required to synchronously produce a result, so instead they return a future, which allows for asynchronicity in the marshalling process. of List: Rather than only a single target representation for A marshallers can offer several ones. Which one will be rendered onto the wire in the end is decided by content negotiation. For example, the Marshaller<OrderConfirmation, MessageEntity>Marshaller[OrderConfirmation, MessageEntity] might offer a JSON as well as an XML representation. The client can decide through the addition of an AcceptAccept request header which one is preferred. If the client doesn’t express a preference the first representation is picked. of Marshalling[B]Marshalling<B>: Rather than returning an instance of B directly marshallers first produce a Marshalling[B]Marshalling<B>. This allows for querying the MediaTypeMediaType and potentially the HttpCharsetHttpCharset that the marshaller will produce before the actual marshalling is triggered. Apart from enabling content negotiation this design allows for delaying the actual construction of the marshalling target instance to the very last moment when it is really needed.\nThis is how Marshalling is defined: copysource/**\n * Describes one possible option for marshalling a given value.\n */\nsealed trait Marshalling[+A] {\n  def map[B](f: A => B): Marshalling[B]\n\n  /**\n   * Converts this marshalling to an opaque marshalling, i.e. a marshalling result that\n   * does not take part in content type negotiation. The given charset is used if this\n   * instance is a `WithOpenCharset` marshalling.\n   */\n  def toOpaque(charset: HttpCharset): Marshalling[A]\n}\n\nobject Marshalling {\n\n  /**\n   * A Marshalling to a specific [[pekko.http.scaladsl.model.ContentType]].\n   */\n  final case class WithFixedContentType[A](\n      contentType: ContentType,\n      marshal: () => A) extends Marshalling[A] {\n    def map[B](f: A => B): WithFixedContentType[B] = copy(marshal = () => f(marshal()))\n    def toOpaque(charset: HttpCharset): Marshalling[A] = Opaque(marshal)\n  }\n\n  /**\n   * A Marshalling to a specific [[pekko.http.scaladsl.model.MediaType]] with a flexible charset.\n   */\n  final case class WithOpenCharset[A](\n      mediaType: MediaType.WithOpenCharset,\n      marshal: HttpCharset => A) extends Marshalling[A] {\n    def map[B](f: A => B): WithOpenCharset[B] = copy(marshal = cs => f(marshal(cs)))\n    def toOpaque(charset: HttpCharset): Marshalling[A] = Opaque(() => marshal(charset))\n  }\n\n  /**\n   * A Marshalling to an unknown MediaType and charset.\n   * Circumvents content negotiation.\n   */\n  final case class Opaque[A](marshal: () => A) extends Marshalling[A] {\n    def map[B](f: A => B): Opaque[B] = copy(marshal = () => f(marshal()))\n    def toOpaque(charset: HttpCharset): Marshalling[A] = this\n  }\n} Apache Pekko HTTP also defines a number of helpful aliases for the types of marshallers that you’ll likely work with most: copysourcetype ToEntityMarshaller[T] = Marshaller[T, MessageEntity]\ntype ToByteStringMarshaller[T] = Marshaller[T, ByteString]\ntype ToHeadersAndEntityMarshaller[T] = Marshaller[T, (immutable.Seq[HttpHeader], MessageEntity)]\ntype ToResponseMarshaller[T] = Marshaller[T, HttpResponse]\ntype ToRequestMarshaller[T] = Marshaller[T, HttpRequest]","title":"Basic Design"},{"location":"/common/marshalling.html#predefined-marshallers","text":"Apache Pekko HTTP already predefines a number of marshallers for the most common types. Specifically these are:\nPredefinedToEntityMarshallers Array[Byte] ByteStringByteString Array[Char] String org.apache.pekko.http.scaladsl.model.FormData org.apache.pekko.http.scaladsl.model.MessageEntity T <: org.apache.pekko.http.scaladsl.model.Multipart PredefinedToResponseMarshallers T, if a ToEntityMarshaller[T] is available HttpResponseHttpResponse StatusCodeStatusCode (StatusCode, T), if a ToEntityMarshaller[T] is available (Int, T), if a ToEntityMarshaller[T] is available (StatusCode, immutable.Seq[HttpHeader], T), if a ToEntityMarshaller[T] is available (Int, immutable.Seq[HttpHeader], T), if a ToEntityMarshaller[T] is available PredefinedToRequestMarshallers HttpRequestHttpRequest UriUri (HttpMethod, Uri, T), if a ToEntityMarshaller[T] is available (HttpMethod, Uri, immutable.Seq[HttpHeader], T), if a ToEntityMarshaller[T] is available GenericMarshallers Marshaller<Throwable, T>Marshaller[Throwable, T] Marshaller<Option<A>, B>Marshaller[Option[A], B], if a Marshaller<A, B>Marshaller[A, B] and an EmptyValue[B] is available Marshaller<Either<A1, A2>, B>Marshaller[Either[A1, A2], B], if a Marshaller<A1, B>Marshaller[A1, B] and a Marshaller<A2, B>Marshaller[A2, B] is available Marshaller<Future<A>, B>Marshaller[Future[A], B], if a Marshaller<A, B>Marshaller[A, B] is available Marshaller<Try<A>, B>Marshaller[Try[A], B], if a Marshaller<A, B>Marshaller[A, B] is available\nPredefined RequestEntityRequestEntity marshallers: byte[] ByteStringByteString char[] String FormDataFormData Optional<T> using an existing RequestEntityRequestEntity marshaller for T. An empty optional will yield an empty entity. Predefined HttpResponseHttpResponse marshallers: T using an existing RequestEntityRequestEntity marshaller for T T and StatusCodeStatusCode using an existing RequestEntityRequestEntity marshaller for T T, StatusCodeStatusCode and Iterable[HttpHeader] using an existing RequestEntityRequestEntity marshaller for T All marshallers can be found in MarshallerMarshaller.\nImplicit Resolution The marshalling infrastructure of Apache Pekko HTTP relies on a type-class based approach, which means that MarshallerMarshaller instances from a certain type A to a certain type B have to be available implicitly. The implicits for most of the predefined marshallers in Apache Pekko HTTP are provided through the companion object of the MarshallerMarshaller trait. This means that they are always available and never need to be explicitly imported. Additionally, you can simply “override” them by bringing your own custom version into local scope.","title":"Predefined Marshallers"},{"location":"/common/marshalling.html#custom-marshallers","text":"Apache Pekko HTTP gives you a few convenience tools for constructing marshallers for your own types. Before you do that you need to think about what kind of marshaller you want to create. If all your marshaller needs to produce is a MessageEntity then you should probably provide a ToEntityMarshaller[T]Marshaller<T, MessageEntity>Marshaller[T, MessageEntity]. The advantage here is that it will work on both the client- as well as the server-side since a ToResponseMarshaller[T]Marshaller<T, HttpResponse>Marshaller[T, HttpResponse] as well as a ToRequestMarshaller[T]Marshaller<T, HttpRequest>Marshaller[T, HttpRequest] can automatically be created if a ToEntityMarshaller[T]Marshaller<T, MessageEntity>Marshaller[T, MessageEntity] is available.\nIf, however, your marshaller also needs to set things like the response status code, the request method, the request URI or any headers then a ToEntityMarshaller[T]Marshaller<T, MessageEntity>Marshaller[T, MessageEntity] won’t work. You’ll need to fall down to providing a ToResponseMarshaller[T]Marshaller<T, HttpResponse>Marshaller[T, HttpResponse] or a ToRequestMarshaller[T]]Marshaller<T, HttpRequest>Marshaller[T, HttpRequest] directly.\nFor writing your own marshallers you won’t have to “manually” implement the MarshallerMarshaller traitclass directly.\nRather, it should be possible to use one of the convenience construction helpers defined on the MarshallerMarshaller companion: copysourceobject Marshaller\n    extends GenericMarshallers\n    with PredefinedToEntityMarshallers\n    with PredefinedToResponseMarshallers\n    with PredefinedToRequestMarshallers {\n\n  /**\n   * Creates a [[Marshaller]] from the given function.\n   */\n  def apply[A, B](f: ExecutionContext => A => Future[List[Marshalling[B]]]): Marshaller[A, B] =\n    new Marshaller[A, B] {\n      def apply(value: A)(implicit ec: ExecutionContext) =\n        try f(ec)(value)\n        catch { case NonFatal(e) => FastFuture.failed(e) }\n    }\n\n  /**\n   * Helper for creating a [[Marshaller]] using the given function.\n   */\n  def strict[A, B](f: A => Marshalling[B]): Marshaller[A, B] =\n    Marshaller { _ => a => FastFuture.successful(f(a) :: Nil) }\n\n  /**\n   * Helper for creating a \"super-marshaller\" from a number of \"sub-marshallers\".\n   * Content-negotiation determines, which \"sub-marshaller\" eventually gets to do the job.\n   *\n   * Please note that all marshallers will actually be invoked in order to get the Marshalling object\n   * out of them, and later decide which of the marshallings should be returned. This is by-design,\n   * however in ticket as discussed in ticket https://github.com/apache/incubator-pekko-http/issues/243 it MAY be\n   * changed in later versions of Akka HTTP.\n   */\n  def oneOf[A, B](marshallers: Marshaller[A, B]*): Marshaller[A, B] =\n    Marshaller { implicit ec => a => FastFuture.sequence(marshallers.map(_(a))).fast.map(_.flatten.toList) }\n\n  /**\n   * Helper for creating a \"super-marshaller\" from a number of values and a function producing \"sub-marshallers\"\n   * from these values. Content-negotiation determines, which \"sub-marshaller\" eventually gets to do the job.\n   *\n   * Please note that all marshallers will actually be invoked in order to get the Marshalling object\n   * out of them, and later decide which of the marshallings should be returned. This is by-design,\n   * however in ticket as discussed in ticket https://github.com/apache/incubator-pekko-http/issues/243 it MAY be\n   * changed in later versions of Akka HTTP.\n   */\n  def oneOf[T, A, B](values: T*)(f: T => Marshaller[A, B]): Marshaller[A, B] =\n    oneOf(values.map(f): _*)\n\n  /**\n   * Helper for creating a synchronous [[Marshaller]] to content with a fixed charset from the given function.\n   */\n  def withFixedContentType[A, B](contentType: ContentType)(marshal: A => B): Marshaller[A, B] =\n    new Marshaller[A, B] {\n      def apply(value: A)(implicit ec: ExecutionContext) =\n        try FastFuture.successful {\n            Marshalling.WithFixedContentType(contentType, () => marshal(value)) :: Nil\n          }\n        catch {\n          case NonFatal(e) => FastFuture.failed(e)\n        }\n\n      override def compose[C](f: C => A): Marshaller[C, B] =\n        Marshaller.withFixedContentType(contentType)(marshal.compose(f))\n    }\n\n  /**\n   * Helper for creating a synchronous [[Marshaller]] to content with a negotiable charset from the given function.\n   */\n  def withOpenCharset[A, B](mediaType: MediaType.WithOpenCharset)(marshal: (A, HttpCharset) => B): Marshaller[A, B] =\n    new Marshaller[A, B] {\n      def apply(value: A)(implicit ec: ExecutionContext) =\n        try FastFuture.successful {\n            Marshalling.WithOpenCharset(mediaType, charset => marshal(value, charset)) :: Nil\n          }\n        catch {\n          case NonFatal(e) => FastFuture.failed(e)\n        }\n\n      override def compose[C](f: C => A): Marshaller[C, B] =\n        Marshaller.withOpenCharset(mediaType)((c: C, hc: HttpCharset) => marshal(f(c), hc))\n    }\n\n  /**\n   * Helper for creating a synchronous [[Marshaller]] to non-negotiable content from the given function.\n   */\n  def opaque[A, B](marshal: A => B): Marshaller[A, B] =\n    strict { value => Marshalling.Opaque(() => marshal(value)) }\n\n  /**\n   * Helper for creating a [[Marshaller]] combined of the provided `marshal` function\n   * and an implicit Marshaller which is able to produce the required final type.\n   */\n  def combined[A, B, C](marshal: A => B)(implicit m2: Marshaller[B, C]): Marshaller[A, C] =\n    Marshaller[A, C] { ec => a => m2.compose(marshal).apply(a)(ec) }\n}","title":"Custom Marshallers"},{"location":"/common/marshalling.html#deriving-marshallers","text":"Sometimes you can save yourself some work by reusing existing marshallers for your custom ones. The idea is to “wrap” an existing marshaller with some logic to “re-target” it to your type.\nIn this regard wrapping a marshaller can mean one or both of the following two things:\nTransform the input before it reaches the wrapped marshaller Transform the output of the wrapped marshaller\nFor the latter (transforming the output) you can use baseMarshaller.map, which works exactly as it does for functions. For the former (transforming the input) you have four alternatives:\nbaseMarshaller.compose baseMarshaller.composeWithEC baseMarshaller.wrap baseMarshaller.wrapWithEC\ncompose works just like it does for functions. wrap is a compose that allows you to also change the ContentType that the marshaller marshals to. The ...WithEC variants allow you to receive an ExecutionContext internally if you need one, without having to depend on one being available implicitly at the usage site.","title":"Deriving Marshallers"},{"location":"/common/marshalling.html#using-marshallers","text":"In many places throughout Apache Pekko HTTP, marshallers are used implicitly, e.g. when you define how to complete a request using the Routing DSL.\nHowever, you can also use the marshalling infrastructure directly if you wish, which can be useful for example in tests. The best entry point for this is the Marshal object, which you can use like this: copysourceimport scala.concurrent.Await\nimport scala.concurrent.duration._\n\nimport org.apache.pekko\nimport pekko.http.scaladsl.marshalling.Marshal\nimport pekko.http.scaladsl.model._\n\nimport system.dispatcher // ExecutionContext\n\nval string = \"Yeah\"\nval entityFuture = Marshal(string).to[MessageEntity]\nval entity = Await.result(entityFuture, 1.second) // don't block in non-test code!\nentity.contentType shouldEqual ContentTypes.`text/plain(UTF-8)`\n\nval errorMsg = \"Easy, pal!\"\nval responseFuture = Marshal(420 -> errorMsg).to[HttpResponse]\nval response = Await.result(responseFuture, 1.second) // don't block in non-test code!\nresponse.status shouldEqual StatusCodes.EnhanceYourCalm\nresponse.entity.contentType shouldEqual ContentTypes.`text/plain(UTF-8)`\n\nval request = HttpRequest(headers = List(headers.Accept(MediaTypes.`application/json`)))\nval responseText = \"Plaintext\"\nval respFuture = Marshal(responseText).toResponseFor(request) // with content negotiation!\na[Marshal.UnacceptableResponseContentTypeException] should be thrownBy {\n  Await.result(respFuture, 1.second) // client requested JSON, we only have text/plain!\n}\nHowever, many directives dealing with marshalling also require that you pass a marshaller explicitly. The following example shows how to marshal Java bean classes to JSON using the Jackson JSON support: copysourceimport org.apache.pekko.http.javadsl.marshallers.jackson.Jackson;\nimport org.apache.pekko.http.javadsl.model.StatusCodes;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport static org.apache.pekko.http.javadsl.server.Directives.*;\nimport static org.apache.pekko.http.javadsl.unmarshalling.StringUnmarshallers.INTEGER;\n\nprivate static Route putPetHandler(Map<Integer, Pet> pets, Pet thePet) {\n    pets.put(thePet.getId(), thePet);\n    return complete(StatusCodes.OK, thePet, Jackson.<Pet>marshaller());\n}\n\nprivate static Route alternativeFuturePutPetHandler(Map<Integer, Pet> pets, Pet thePet) {\n    pets.put(thePet.getId(), thePet);\n  CompletableFuture<Pet> futurePet = CompletableFuture.supplyAsync(() -> thePet);\n    return completeOKWithFuture(futurePet, Jackson.<Pet>marshaller());\n}","title":"Using Marshallers"},{"location":"/common/unmarshalling.html","text":"","title":"Unmarshalling"},{"location":"/common/unmarshalling.html#unmarshalling","text":"“Unmarshalling” is the process of converting some kind of a lower-level representation, often a “wire format”, into a higher-level (object) structure. Other popular names for it are “Deserialization” or “Unpickling”.\nIn Apache Pekko HTTP “Unmarshalling” means the conversion of a lower-level source object, e.g. a MessageEntity (which forms the “entity body” of an HTTP request or response) or a full HttpRequestHttpRequest or HttpResponseHttpResponse, into an instance of type T.","title":"Unmarshalling"},{"location":"/common/unmarshalling.html#basic-design","text":"Unmarshalling of instances of type A into instances of type B is performed by an Unmarshaller<A, B>Unmarshaller[A, B].\nApache Pekko HTTP also predefines a number of helpful aliases for the types of unmarshallers that you’ll likely work with most: copysourcetype FromEntityUnmarshaller[T] = Unmarshaller[HttpEntity, T]\ntype FromMessageUnmarshaller[T] = Unmarshaller[HttpMessage, T]\ntype FromResponseUnmarshaller[T] = Unmarshaller[HttpResponse, T]\ntype FromRequestUnmarshaller[T] = Unmarshaller[HttpRequest, T]\ntype FromByteStringUnmarshaller[T] = Unmarshaller[ByteString, T]\ntype FromStringUnmarshaller[T] = Unmarshaller[String, T]\ntype FromStrictFormFieldUnmarshaller[T] = Unmarshaller[StrictForm.Field, T]\nAt its core an Unmarshaller<A, B>Unmarshaller[A, B] is very similar to a function A => Future[B]Function<A, CompletionStage<B>> and as such quite a bit simpler than its marshalling counterpart. The process of unmarshalling does not have to support content negotiation which saves two additional layers of indirection that are required on the marshalling side.","title":"Basic Design"},{"location":"/common/unmarshalling.html#using-unmarshallers","text":"For an example on how to use an unmarshaller on the server side, see for example the Dynamic Routing Example. For the client side, see Processing Responses","title":"Using unmarshallers"},{"location":"/common/unmarshalling.html#predefined-unmarshallers","text":"Apache Pekko HTTP already predefines a number of unmarshallers for the most common types. Specifically these are:\nPredefinedFromStringUnmarshallers StringUnmarshallers Byte Short IntInteger Long Float Double Boolean PredefinedFromEntityUnmarshallers UnmarshallerUnmarshaller Array[Byte]byte[] ByteStringByteString Array[Char]char[] String org.apache.pekko.http.scaladsl.model.FormDataorg.apache.pekko.http.javadsl.model.FormData\nGenericUnmarshallers Unmarshaller<T, T>Unmarshaller[T, T] (identity unmarshaller) Unmarshaller<Option<A>, B>Unmarshaller[Option[A], B], if an Unmarshaller<A, B>Unmarshaller[A, B] is available Unmarshaller<A, Option<B>>Unmarshaller[A, Option[B]], if an Unmarshaller<A, B>Unmarshaller[A, B] is available\nAdditional unmarshallers are available in separate modules for specific content types, such as JSON and XML.\nImplicit Resolution The unmarshalling infrastructure of Apache Pekko HTTP relies on a type-class based approach, which means that UnmarshallerUnmarshaller instances from a certain type A to a certain type B have to be available implicitly. The implicits for most of the predefined unmarshallers in Apache Pekko HTTP are provided through the companion object of the UnmarshallerUnmarshaller trait. This means that they are always available and never need to be explicitly imported. Additionally, you can simply “override” them by bringing your own custom version into local scope.","title":"Predefined Unmarshallers"},{"location":"/common/unmarshalling.html#custom-unmarshallers","text":"Apache Pekko HTTP gives you a few convenience tools for constructing unmarshallers for your own types. Usually you won’t have to “manually” implement the UnmarshallerUnmarshaller traitclass directly. Rather, it should be possible to use one of the convenience construction helpers defined on the UnmarshallerUnmarshaller companionUnmarshallerUnmarshaller:\nScala copysource/**\n * Creates an `Unmarshaller` from the given function.\n */\ndef apply[A, B](f: ExecutionContext => A => Future[B]): Unmarshaller[A, B] =\n  withMaterializer(ec => _ => f(ec))\n\ndef withMaterializer[A, B](f: ExecutionContext => Materializer => A => Future[B]): Unmarshaller[A, B] =\n  new Unmarshaller[A, B] {\n    def apply(a: A)(implicit ec: ExecutionContext, materializer: Materializer) =\n      try f(ec)(materializer)(a)\n      catch { case NonFatal(e) => FastFuture.failed(e) }\n  }\n\n/**\n * Helper for creating a synchronous `Unmarshaller` from the given function.\n */\ndef strict[A, B](f: A => B): Unmarshaller[A, B] = Unmarshaller(_ => a => FastFuture.successful(f(a)))\n\n/**\n * Helper for creating a \"super-unmarshaller\" from a sequence of \"sub-unmarshallers\", which are tried\n * in the given order. The first successful unmarshalling of a \"sub-unmarshallers\" is the one produced by the\n * \"super-unmarshaller\".\n */\ndef firstOf[A, B](unmarshallers: Unmarshaller[A, B]*): Unmarshaller[A, B] = //... Java copysource<A, B> Unmarshaller<A, B> async(java.util.function.Function<A, java.util.concurrent.CompletionStage<B>> f);\n<A, B> Unmarshaller<A, B> sync(java.util.function.Function<A, B> f);\n<A, B> Unmarshaller<A, B> firstOf(Unmarshaller<A, B> u1, Unmarshaller<A, B> u2);\n<A, B> Unmarshaller<A, B> firstOf(Unmarshaller<A, B> u1, Unmarshaller<A, B> u2, Unmarshaller<A, B> u3);\n<A, B> Unmarshaller<A, B> firstOf(Unmarshaller<A, B> u1, Unmarshaller<A, B> u2, Unmarshaller<A, B> u3, Unmarshaller<A, B> u4);\n<A, B> Unmarshaller<A, B> firstOf(Unmarshaller<A, B> u1, Unmarshaller<A, B> u2, Unmarshaller<A, B> u3, Unmarshaller<A, B> u4, Unmarshaller<A, B> u5);\nNote To avoid unnecessary memory pressure, unmarshallers should make sure to either fully consume the incoming entity data stream, or make sure it is properly cancelled on error. Failure to do so might keep the remaining part of the stream in memory for longer than necessary.","title":"Custom Unmarshallers"},{"location":"/common/unmarshalling.html#deriving-unmarshallers","text":"Sometimes you can save yourself some work by reusing existing unmarshallers for your custom ones. The idea is to “wrap” an existing unmarshaller with some logic to “re-target” it to your type.\nUsually what you want to do is to transform the output of some existing unmarshaller and convert it to your type. For this type of unmarshaller transformation Apache Pekko HTTP defines these methods:\nbaseUnmarshaller.transform baseUnmarshaller.map baseUnmarshaller.mapWithInput baseUnmarshaller.flatMap baseUnmarshaller.flatMapWithInput baseUnmarshaller.recover baseUnmarshaller.withDefaultValue baseUnmarshaller.mapWithCharset (only available for FromEntityUnmarshallers) baseUnmarshaller.forContentTypes (only available for FromEntityUnmarshallers)\nbaseMarshaller.thenApply baseMarshaller.flatMap Unmarshaller.forMediaType (to derive from a HttpEntityHttpEntity unmarshaller) Unmarshaller.forMediaTypes (to derive from a HttpEntityHttpEntity unmarshaller)\nThe method signatures should make their semantics relatively clear.","title":"Deriving Unmarshallers"},{"location":"/common/unmarshalling.html#using-unmarshallers","text":"In many places throughout Apache Pekko HTTP unmarshallers are used implicitly, e.g. when you want to access the entity of a request using the Routing DSL.\nHowever, you can also use the unmarshalling infrastructure directly if you wish, which can be useful for example in tests. The best entry point for this is the org.apache.pekko.http.scaladsl.unmarshalling.Unmarshal objectorg.apache.pekko.http.javadsl.unmarshalling.StringUnmarshallers class, which you can use like this:\nScala copysourceimport org.apache.pekko.http.scaladsl.unmarshalling.Unmarshal\nimport system.dispatcher // Optional ExecutionContext (default from Materializer)\n\nimport scala.concurrent.Await\nimport scala.concurrent.duration._\n\nval intFuture = Unmarshal(\"42\").to[Int]\nval int = Await.result(intFuture, 1.second) // don't block in non-test code!\nint shouldEqual 42\n\nval boolFuture = Unmarshal(\"off\").to[Boolean]\nval bool = Await.result(boolFuture, 1.second) // don't block in non-test code!\nbool shouldBe false Java copysourceimport org.apache.pekko.http.javadsl.model.*;\nimport org.apache.pekko.http.javadsl.unmarshalling.StringUnmarshallers;\nimport org.apache.pekko.http.javadsl.unmarshalling.Unmarshaller;\n\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.TimeUnit;\n\nCompletionStage<Integer> integerStage =\n  StringUnmarshallers.INTEGER.unmarshal(\"42\", system());\nint integer = integerStage.toCompletableFuture().get(1, TimeUnit.SECONDS); // don't block in non-test code!\nassertEquals(integer, 42);\n\nCompletionStage<Boolean> boolStage =\n  StringUnmarshallers.BOOLEAN.unmarshal(\"off\", system());\nboolean bool = boolStage.toCompletableFuture().get(1, TimeUnit.SECONDS); // don't block in non-test code!\nassertEquals(bool, false);","title":"Using Unmarshallers"},{"location":"/common/encoding.html","text":"","title":"Encoding / Decoding"},{"location":"/common/encoding.html#encoding-decoding","text":"The HTTP spec defines a Content-Encoding header, which signifies whether the entity body of an HTTP message is “encoded” and, if so, by which algorithm. The only commonly used content encodings are compression algorithms.\nCurrently, Apache Pekko HTTP supports the compression and decompression of HTTP requests and responses with the gzip or deflate encodings. The core logic for this lives in the org.apache.pekko.http.scaladsl.coding package.org.apache.pekko.http.javadsl.coding.Coder enum class.","title":"Encoding / Decoding"},{"location":"/common/encoding.html#server-side","text":"The support is not enabled automatically, but must be explicitly requested. For enabling message encoding/decoding with Routing DSL see the CodingDirectives.\nUsually, it suffices to surround routes that should support response encoding by the encodeResponse directive, and routes that should support request decoding by the decodeRequest directive. Those directives will automatically and transparently enable support for encodings and negotiating which encoding to use out of the default encodings supported. The set of predefined MediaTypesMediaTypes contains a hint whether content of a given media type would benefit from compression.","title":"Server side"},{"location":"/common/encoding.html#client-side","text":"There is currently no high-level or automatic support for decoding responses on the client-side.\nThe following example shows how to decode responses manually based on the Content-Encoding header:\nScala copysourceimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.coding.Coders\nimport pekko.http.scaladsl.model._, headers.HttpEncodings\n\nimport scala.concurrent.Future\n\nimplicit val system = ActorSystem()\nimplicit val ec: ExecutionContext = system.dispatcher\n\nval http = Http()\n\nval requests: Seq[HttpRequest] = Seq(\n  \"https://httpbin.org/gzip\", // Content-Encoding: gzip in response\n  \"https://httpbin.org/deflate\", // Content-Encoding: deflate in response\n  \"https://httpbin.org/get\" // no Content-Encoding in response\n).map(uri => HttpRequest(uri = uri))\n\ndef decodeResponse(response: HttpResponse): HttpResponse = {\n  val decoder = response.encoding match {\n    case HttpEncodings.gzip =>\n      Coders.Gzip\n    case HttpEncodings.deflate =>\n      Coders.Deflate\n    case HttpEncodings.identity =>\n      Coders.NoCoding\n    case other =>\n      log.warning(s\"Unknown encoding [$other], not decoding\")\n      Coders.NoCoding\n  }\n\n  decoder.decodeMessage(response)\n}\n\nval futureResponses: Future[Seq[HttpResponse]] =\n  Future.traverse(requests)(http.singleRequest(_).map(decodeResponse))\n\nfutureResponses.futureValue.foreach { resp =>\n  system.log.info(s\"response is ${resp.toStrict(1.second).futureValue}\")\n}\n\nsystem.terminate() Java copysourceimport org.apache.pekko.actor.ActorSystem;\nimport org.apache.pekko.http.javadsl.Http;\nimport org.apache.pekko.http.javadsl.coding.Coder;\nimport org.apache.pekko.http.javadsl.model.HttpRequest;\nimport org.apache.pekko.http.javadsl.model.HttpResponse;\nimport org.apache.pekko.http.scaladsl.model.headers.HttpEncodings;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionStage;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\npublic class HttpClientDecodingExampleTest {\n\n  public static void main(String[] args) throws Exception {\n\n    final ActorSystem system = ActorSystem.create();\n\n    final List<HttpRequest> httpRequests = Arrays.asList(\n      HttpRequest.create(\"https://httpbin.org/gzip\"), // Content-Encoding: gzip in response\n      HttpRequest.create(\"https://httpbin.org/deflate\"), // Content-Encoding: deflate in response\n      HttpRequest.create(\"https://httpbin.org/get\") // no Content-Encoding in response\n    );\n\n    final Http http = Http.get(system);\n\n    final Function<HttpResponse, HttpResponse> decodeResponse = response -> {\n      // Pick the right coder\n      final Coder coder;\n      if (HttpEncodings.gzip().equals(response.encoding())) {\n        coder = Coder.Gzip;\n      } else if (HttpEncodings.deflate().equals(response.encoding())) {\n        coder = Coder.Deflate;\n      } else {\n        coder = Coder.NoCoding;\n      }\n\n      // Decode the entity\n      return coder.decodeMessage(response);\n    };\n\n    List<CompletableFuture<HttpResponse>> futureResponses = httpRequests.stream()\n      .map(req -> http.singleRequest(req)\n        .thenApply(decodeResponse))\n      .map(CompletionStage::toCompletableFuture)\n      .collect(Collectors.toList());\n\n    for (CompletableFuture<HttpResponse> futureResponse : futureResponses) {\n      final HttpResponse httpResponse = futureResponse.get();\n      system.log().info(\"response is: \" + httpResponse.entity()\n                        .toStrict(1000, system)\n                        .toCompletableFuture()\n                        .get());\n    }\n\n    system.terminate();\n  }\n}","title":"Client side"},{"location":"/common/json-support.html","text":"","title":"JSON Support"},{"location":"/common/json-support.html#json-support","text":"Apache Pekko HTTP’s marshalling and unmarshalling infrastructure makes it rather easy to seamlessly convert application-domain objects from and to JSON. Integration with spray-jsonJackson is provided out of the box through the pekko-http-spray-jsonpekko-http-jackson module. Integration with other JSON libraries are supported by the community. See the list of current community extensions for Apache Pekko HTTP.\nJackson Support To make use of the support module for (un)marshalling from and to JSON with Jackson, add a library dependency onto: sbt val PekkoHttpVersion = \"0.0.0+4308-98f0ff9c-SNAPSHOT\"\nlibraryDependencies += \"org.apache.pekko\" %% \"pekko-http-jackson\" % PekkoHttpVersion Gradle def versions = [\n  ScalaBinary: \"2.13\"\n]\ndependencies {\n  implementation platform(\"org.apache.pekko:pekko-http-bom_${versions.ScalaBinary}:0.0.0+4308-98f0ff9c-SNAPSHOT\")\n\n  implementation \"org.apache.pekko:pekko-http-jackson_${versions.ScalaBinary}\"\n} Maven <properties>\n  <scala.binary.version>2.13</scala.binary.version>\n</properties>\n<dependencyManagement>\n  <dependencies>\n    <dependency>\n      <groupId>org.apache.pekko</groupId>\n      <artifactId>pekko-http-bom_${scala.binary.version}</artifactId>\n      <version>0.0.0+4308-98f0ff9c-SNAPSHOT</version>\n      <type>pom</type>\n      <scope>import</scope>\n    </dependency>\n  </dependencies>\n</dependencyManagement>\n<dependencies>\n  <dependency>\n    <groupId>org.apache.pekko</groupId>\n    <artifactId>pekko-http-jackson_${scala.binary.version}</artifactId>\n  </dependency>\n</dependencies> Use org.apache.pekko.http.javadsl.marshallers.jackson.Jackson.unmarshaller(T.class) to create an Unmarshaller<HttpEntity,T>Unmarshaller[HttpEntity,T] which expects the request body (HttpEntity) to be of type application/json and converts it to T using Jackson. copysourceimport org.apache.pekko.http.javadsl.marshallers.jackson.Jackson;\nimport org.apache.pekko.http.javadsl.model.StatusCodes;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport static org.apache.pekko.http.javadsl.server.Directives.*;\nimport static org.apache.pekko.http.javadsl.unmarshalling.StringUnmarshallers.INTEGER;\n\npublic static Route appRoute(final Map<Integer, Pet> pets) {\n  PetStoreController controller = new PetStoreController(pets);\n\n  // Defined as Function in order to refer to [pets], but this could also be an ordinary method.\n  Function<Integer, Route> existingPet = petId -> {\n      Pet pet = pets.get(petId);\n      return (pet == null) ? reject() : complete(StatusCodes.OK, pet, Jackson.<Pet>marshaller());\n  };\n\n  // The directives here are statically imported, but you can also inherit from AllDirectives.\n  return\n    concat(\n      path(\"\", () ->\n        getFromResource(\"web/index.html\")\n      ),\n      pathPrefix(\"pet\", () ->\n        path(INTEGER, petId -> concat(\n          // demonstrates different ways of handling requests:\n\n          // 1. using a Function\n          get(() -> existingPet.apply(petId)),\n\n          // 2. using a method\n          put(() ->\n            entity(Jackson.unmarshaller(Pet.class), thePet ->\n              putPetHandler(pets, thePet)\n            )\n          ),\n          // 2.1. using a method, and internally handling a Future value\n          path(\"alternate\", () ->\n            put(() ->\n              entity(Jackson.unmarshaller(Pet.class), thePet ->\n                putPetHandler(pets, thePet)\n              )\n            )\n          ),\n\n          // 3. calling a method of a controller instance\n          delete(() -> controller.deletePet(petId))\n        ))\n      )\n    );\n} Use org.apache.pekko.http.javadsl.marshallers.jackson.Jackson.marshaller(T.class) to create a Marshaller<T,RequestEntity>Marshaller[T,RequestEntity] which can be used with RequestContext.complete or RouteDirectives.complete to convert a POJO to an HttpResponse. copysourceimport org.apache.pekko.http.javadsl.marshallers.jackson.Jackson;\nimport org.apache.pekko.http.javadsl.model.StatusCodes;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport static org.apache.pekko.http.javadsl.server.Directives.*;\nimport static org.apache.pekko.http.javadsl.unmarshalling.StringUnmarshallers.INTEGER;\n\nprivate static Route putPetHandler(Map<Integer, Pet> pets, Pet thePet) {\n    pets.put(thePet.getId(), thePet);\n    return complete(StatusCodes.OK, thePet, Jackson.<Pet>marshaller());\n}\n\nprivate static Route alternativeFuturePutPetHandler(Map<Integer, Pet> pets, Pet thePet) {\n    pets.put(thePet.getId(), thePet);\n  CompletableFuture<Pet> futurePet = CompletableFuture.supplyAsync(() -> thePet);\n    return completeOKWithFuture(futurePet, Jackson.<Pet>marshaller());\n} Refer to this file in the sources for the complete example.\nspray-json Support The SprayJsonSupport trait provides a FromEntityUnmarshaller[T] and ToEntityMarshaller[T] for every type T that an implicit spray.json.RootJsonReader and/or spray.json.RootJsonWriter (respectively) is available for. To enable automatic support for (un)marshalling from and to JSON with spray-json, add a library dependency onto: sbt val PekkoHttpVersion = \"0.0.0+4308-98f0ff9c-SNAPSHOT\"\nlibraryDependencies += \"org.apache.pekko\" %% \"pekko-http-spray-json\" % PekkoHttpVersion Gradle def versions = [\n  ScalaBinary: \"2.13\"\n]\ndependencies {\n  implementation platform(\"org.apache.pekko:pekko-http-bom_${versions.ScalaBinary}:0.0.0+4308-98f0ff9c-SNAPSHOT\")\n\n  implementation \"org.apache.pekko:pekko-http-spray-json_${versions.ScalaBinary}\"\n} Maven <properties>\n  <scala.binary.version>2.13</scala.binary.version>\n</properties>\n<dependencyManagement>\n  <dependencies>\n    <dependency>\n      <groupId>org.apache.pekko</groupId>\n      <artifactId>pekko-http-bom_${scala.binary.version}</artifactId>\n      <version>0.0.0+4308-98f0ff9c-SNAPSHOT</version>\n      <type>pom</type>\n      <scope>import</scope>\n    </dependency>\n  </dependencies>\n</dependencyManagement>\n<dependencies>\n  <dependency>\n    <groupId>org.apache.pekko</groupId>\n    <artifactId>pekko-http-spray-json_${scala.binary.version}</artifactId>\n  </dependency>\n</dependencies> Next, provide a RootJsonFormat[T] for your type and bring it into scope. Check out the spray-json documentation for more info on how to do this. Finally, import the FromEntityUnmarshaller[T] and ToEntityMarshaller[T] implicits directly from SprayJsonSupport as shown in the example below or mix the org.apache.pekko.http.scaladsl.marshallers.sprayjson.SprayJsonSupport trait into your JSON support module. Once you have done this (un)marshalling between JSON and your type T should work nicely and transparently. copysourceimport org.apache.pekko\nimport pekko.http.scaladsl.server.Directives\nimport pekko.http.scaladsl.marshallers.sprayjson.SprayJsonSupport\nimport spray.json._\n\n// domain model\nfinal case class Item(name: String, id: Long)\nfinal case class Order(items: List[Item])\n\n// collect your json format instances into a support trait:\ntrait JsonSupport extends SprayJsonSupport with DefaultJsonProtocol {\n  implicit val itemFormat = jsonFormat2(Item)\n  implicit val orderFormat = jsonFormat1(Order) // contains List[Item]\n}\n\n// use it wherever json (un)marshalling is needed\nclass MyJsonService extends Directives with JsonSupport {\n\n  val route =\n    concat(\n      get {\n        pathSingleSlash {\n          complete(Item(\"thing\", 42)) // will render as JSON\n        }\n      },\n      post {\n        entity(as[Order]) { order => // will unmarshal JSON to Order\n          val itemsCount = order.items.size\n          val itemNames = order.items.map(_.name).mkString(\", \")\n          complete(s\"Ordered $itemsCount items: $itemNames\")\n        }\n      })\n}","title":"JSON Support"},{"location":"/common/json-support.html#consuming-json-streaming-style-apis","text":"A popular way of implementing streaming APIs is JSON Streaming (see Source Streaming for documentation on building server-side of such API).\nDepending on the way the API returns the streamed JSON (newline delimited, raw sequence of objects, or “infinite array”) you may have to apply a different framing mechanism, but the general idea remains the same: consuming the infinite entity stream and applying a framing to it, such that the single objects can be easily deserialized using the usual marshalling infrastructure:\nScala copysourceimport MyJsonProtocol._\nimport org.apache.pekko\nimport pekko.http.scaladsl.unmarshalling._\nimport pekko.http.scaladsl.common.EntityStreamingSupport\nimport pekko.http.scaladsl.common.JsonEntityStreamingSupport\n\nimplicit val jsonStreamingSupport: JsonEntityStreamingSupport =\n  EntityStreamingSupport.json()\n\nval input = \"\"\"{\"uid\":1,\"txt\":\"#Pekko rocks!\"}\"\"\" + \"\\n\" +\n  \"\"\"{\"uid\":2,\"txt\":\"Streaming is so hot right now!\"}\"\"\" + \"\\n\" +\n  \"\"\"{\"uid\":3,\"txt\":\"You cannot enter the same river twice.\"}\"\"\"\n\nval response = HttpResponse(entity = HttpEntity(ContentTypes.`application/json`, input))\n\n// unmarshal:\nval unmarshalled: Future[Source[Tweet, NotUsed]] =\n  Unmarshal(response).to[Source[Tweet, NotUsed]]\n\n// flatten the Future[Source[]] into a Source[]:\nval source: Source[Tweet, Future[NotUsed]] =\n  Source.fromFutureSource(unmarshalled)\n Java copysourceUnmarshaller<ByteString, JavaTweet> unmarshal = Jackson.byteStringUnmarshaller(JavaTweet.class);\nJsonEntityStreamingSupport support = EntityStreamingSupport.json();\n\n// imagine receiving such response from a service:\nString payload = \"{\\\"uid\\\":1,\\\"txt\\\":\\\"#Pekko rocks!\\\"}\\n\" +\n    \"{\\\"uid\\\":2,\\\"txt\\\":\\\"Streaming is so hot right now!\\\"}\\n\" +\n    \"{\\\"uid\\\":3,\\\"txt\\\":\\\"You cannot enter the same river twice.\\\"}\";\nHttpEntity.Strict entity = HttpEntities.create(ContentTypes.APPLICATION_JSON, payload);\nHttpResponse response = HttpResponse.create().withEntity(entity);\n\nSource<JavaTweet, Object> tweets =\n    response.entity().getDataBytes()\n    .via(support.framingDecoder()) // apply JSON framing\n    .mapAsync(1, // unmarshal each element\n        bs -> unmarshal.unmarshal(bs, system())\n    );\nIn the above example the marshalling is handled by the implicitly provided JsonEntityStreamingSupport, which is also used when building server-side streaming APIs. You can also achieve the same more explicitly, by manually connecting the entity byte stream through a framing and then deserialization stage: Scala copysourceimport MyJsonProtocol._\nimport org.apache.pekko\nimport pekko.http.scaladsl.unmarshalling._\nimport pekko.http.scaladsl.common.EntityStreamingSupport\nimport pekko.http.scaladsl.common.JsonEntityStreamingSupport\n\nimplicit val jsonStreamingSupport: JsonEntityStreamingSupport =\n  EntityStreamingSupport.json()\n\nval input = \"\"\"{\"uid\":1,\"txt\":\"#Pekko rocks!\"}\"\"\" + \"\\n\" +\n  \"\"\"{\"uid\":2,\"txt\":\"Streaming is so hot right now!\"}\"\"\" + \"\\n\" +\n  \"\"\"{\"uid\":3,\"txt\":\"You cannot enter the same river twice.\"}\"\"\"\n\nval response = HttpResponse(entity = HttpEntity(ContentTypes.`application/json`, input))\n\nval value: Source[Tweet, Any] =\n  response.entity.dataBytes\n    .via(jsonStreamingSupport.framingDecoder) // pick your Framing (could be \"\\n\" etc)\n    .mapAsync(1)(bytes => Unmarshal(bytes).to[Tweet]) // unmarshal one by one\nIn the above example the JsonEntityStreamingSupport class is used to obtain the proper framing, though you could also pick the framing manually by using org.apache.pekko.stream.javadsl.Framing or org.apache.pekko.stream.javadsl.JsonFraming. Framing stages are used to “chunk up” the pieces of incoming bytes into appropriately sized pieces of valid JSON, which then can be handled easily by a not-streaming JSON serializer such as jackson in the example. This technique is simpler to use and often good enough rather than writing a fully streaming JSON parser (which also is possible).\nPretty printing By default, spray-json marshals your types to compact printed JSON by implicit conversion using CompactPrinter, as defined in: copysourceimplicit def sprayJsonMarshallerConverter[T](writer: RootJsonWriter[T])(implicit printer: JsonPrinter =\n      CompactPrinter): ToEntityMarshaller[T] =\n  sprayJsonMarshaller[T](writer, printer) Alternatively to marshal your types to pretty printed JSON, bring a PrettyPrinter in scope to perform implicit conversion. copysourceimport pekko.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._\nimport spray.json._\n\n// domain model\nfinal case class PrettyPrintedItem(name: String, id: Long)\n\nobject PrettyJsonFormatSupport {\n  import DefaultJsonProtocol._\n  implicit val printer = PrettyPrinter\n  implicit val prettyPrintedItemFormat = jsonFormat2(PrettyPrintedItem)\n}\n\n// use it wherever json (un)marshalling is needed\nclass MyJsonService extends Directives {\n  import PrettyJsonFormatSupport._\n\n  // format: OFF\n  val route =\n    get {\n      pathSingleSlash {\n        complete {\n          PrettyPrintedItem(\"akka\", 42) // will render as JSON\n        }\n      }\n    }\n  // format: ON\n}\n\nval service = new MyJsonService\n\n// verify the pretty printed JSON\nGet(\"/\") ~> service.route ~> check {\n  responseAs[String] shouldEqual\n  \"\"\"{\"\"\" + \"\\n\" +\n  \"\"\"  \"id\": 42,\"\"\" + \"\\n\" +\n  \"\"\"  \"name\": \"akka\"\"\"\" + \"\\n\" +\n  \"\"\"}\"\"\"\n} To learn more about how spray-json works please refer to its documentation.","title":"Consuming JSON Streaming style APIs"},{"location":"/common/xml-support.html","text":"","title":"XML Support"},{"location":"/common/xml-support.html#xml-support","text":"Apache Pekko HTTP’s marshalling and unmarshalling infrastructure makes it rather easy to seamlessly support specific wire representations of your data objects, like JSON, XML or even binary encodings.\nApache Pekko HTTP does not currently provide a Java API for XML support. If you need to produce and consume XML, you can write a custom marshaller using Jackson, which is also the library used for providing JSON support. copysourceimport java.io.IOException;\nimport java.util.List;\nimport java.util.Arrays;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport com.fasterxml.jackson.dataformat.xml.XmlMapper;\nimport org.apache.pekko.http.javadsl.model.*;\nimport org.apache.pekko.http.javadsl.marshalling.Marshaller;\nimport org.apache.pekko.http.javadsl.unmarshalling.Unmarshaller;\n\npublic class JacksonXmlSupport {\n  private static final ObjectMapper DEFAULT_XML_MAPPER =\n    new XmlMapper().enable(SerializationFeature.WRAP_ROOT_VALUE);\n  private static final List<MediaType> XML_MEDIA_TYPES = Arrays.asList(MediaTypes.APPLICATION_XML, MediaTypes.TEXT_XML);\n\n  public static <T> Marshaller<T, RequestEntity> marshaller() {\n    return Marshaller.wrapEntity(\n      u -> toXML(DEFAULT_XML_MAPPER, u),\n      Marshaller.stringToEntity(),\n      MediaTypes.APPLICATION_XML\n    );\n  }\n\n  public static <T> Unmarshaller<HttpEntity, T> unmarshaller(Class<T> expectedType) {\n    return Unmarshaller.forMediaTypes(XML_MEDIA_TYPES, Unmarshaller.entityToString())\n                       .thenApply(xml -> fromXML(DEFAULT_XML_MAPPER, xml, expectedType));\n  }\n\n  private static <T> String toXML(ObjectMapper mapper, T object) {\n    try {\n      return mapper.writeValueAsString(object);\n    } catch (IOException e) {\n      throw new IllegalArgumentException(\"Cannot marshal to XML: \" + object, e);\n    }\n  }\n\n  private static <T> T fromXML(ObjectMapper mapper, String xml, Class<T> expectedType) {\n    try {\n      return mapper.readerFor(expectedType).readValue(xml);\n    } catch (IOException e) {\n      throw new IllegalArgumentException(\"Cannot unmarshal XML as \" + expectedType.getSimpleName(), e);\n    }\n  }\n} The custom XML (un)marshalling code shown above requires that you depend on the jackson-dataformat-xml library. sbt libraryDependencies += \"com.fasterxml.jackson.dataformat\" % \"jackson-dataformat-xml\" % \"2.10.5\" Gradle dependencies {\n  implementation \"com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.10.5\"\n} Maven <dependencies>\n  <dependency>\n    <groupId>com.fasterxml.jackson.dataformat</groupId>\n    <artifactId>jackson-dataformat-xml</artifactId>\n    <version>2.10.5</version>\n  </dependency>\n</dependencies>\nFor XML Apache Pekko HTTP currently provides support for Scala XML right out of the box through it’s pekko-http-xml module. Scala XML Support The ScalaXmlSupport trait provides a FromEntityUnmarshaller[NodeSeq] and ToEntityMarshaller[NodeSeq] that you can use directly or build upon. In order to enable support for (un)marshalling from and to XML with Scala XML NodeSeq you must add the following dependency: sbt val PekkoHttpVersion = \"0.0.0+4308-98f0ff9c-SNAPSHOT\"\nlibraryDependencies += \"org.apache.pekko\" %% \"pekko-http-xml\" % PekkoHttpVersion Gradle def versions = [\n  ScalaBinary: \"2.13\"\n]\ndependencies {\n  implementation platform(\"org.apache.pekko:pekko-http-bom_${versions.ScalaBinary}:0.0.0+4308-98f0ff9c-SNAPSHOT\")\n\n  implementation \"org.apache.pekko:pekko-http-xml_${versions.ScalaBinary}\"\n} Maven <properties>\n  <scala.binary.version>2.13</scala.binary.version>\n</properties>\n<dependencyManagement>\n  <dependencies>\n    <dependency>\n      <groupId>org.apache.pekko</groupId>\n      <artifactId>pekko-http-bom_${scala.binary.version}</artifactId>\n      <version>0.0.0+4308-98f0ff9c-SNAPSHOT</version>\n      <type>pom</type>\n      <scope>import</scope>\n    </dependency>\n  </dependencies>\n</dependencyManagement>\n<dependencies>\n  <dependency>\n    <groupId>org.apache.pekko</groupId>\n    <artifactId>pekko-http-xml_${scala.binary.version}</artifactId>\n  </dependency>\n</dependencies> Once you have done this (un)marshalling between XML and NodeSeq instances should work nicely and transparently, by either using import org.apache.pekko.http.scaladsl.marshallers.xml.ScalaXmlSupport._ or mixing in the org.apache.pekko.http.scaladsl.marshallers.xml.ScalaXmlSupport trait.","title":"XML Support"},{"location":"/common/sse-support.html","text":"","title":"Server-Sent Events Support"},{"location":"/common/sse-support.html#server-sent-events-support","text":"Server-Sent Events (SSE) is a lightweight and standardized protocol for pushing notifications from an HTTP server to a client. In contrast to WebSocket, which offers bi-directional communication, SSE only allows for one-way communication from the server to the client. If that’s all you need, SSE has the advantages to be much simpler, to rely on HTTP only and to offer retry semantics on broken connections by the browser.\nAccording to the SSE specification clients can request an event stream from the server via HTTP. The server responds with the media type text/event-stream which has the fixed character encoding UTF-8 and keeps the response open to send events to the client when available. Events are textual structures which carry fields and are terminated by an empty line, e.g.\ndata: { \"username\": \"John Doe\" }\nevent: added\nid: 42\n\ndata: another event\nClients can optionally signal the last seen event to the server via the Last-Event-IDLastEventId header, e.g. after a reconnect.","title":"Server-Sent Events Support"},{"location":"/common/sse-support.html#model","text":"Apache Pekko HTTP represents event streams as Source<ServerSentEvent, ?>Source[ServerSentEvent, _] where ServerSentEventServerSentEvent is a case class with the following read-only properties:\ndata: StringString data – the actual payload, may span multiple lines eventType: Option[String]Optional<String> type – optional qualifier, e.g. “added”, “removed”, etc. id: Option[String]Optional<String> id – optional identifier retry: Option[Int]OptionalInt retry – optional reconnection delay in milliseconds\nIn accordance to the SSE specification Apache Pekko HTTP also provides the Last-Event-IDLastEventId header and the text/event-streamTEXT_EVENT_STREAM media type.","title":"Model"},{"location":"/common/sse-support.html#server-side-usage-marshalling","text":"In order to respond to an HTTP request with an event stream, you have to bring the implicit ToResponseMarshaller[Source[ServerSentEvent, \\_]] defined by EventStreamMarshallingEventStreamMarshalling into the scope defining the respective routeuse the EventStreamMarshalling.toEventStream marshaller:\nScala copysourceimport org.apache.pekko\nimport pekko.NotUsed\nimport pekko.stream.scaladsl.Source\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.unmarshalling.Unmarshal\nimport pekko.http.scaladsl.model.sse.ServerSentEvent\nimport scala.concurrent.duration._\n\nimport java.time.LocalTime\nimport java.time.format.DateTimeFormatter.ISO_LOCAL_TIME\n\ndef route: Route = {\n  import pekko.http.scaladsl.marshalling.sse.EventStreamMarshalling._\n\n  path(\"events\") {\n    get {\n      complete {\n        Source\n          .tick(2.seconds, 2.seconds, NotUsed)\n          .map(_ => LocalTime.now())\n          .map(time => ServerSentEvent(ISO_LOCAL_TIME.format(time)))\n          .keepAlive(1.second, () => ServerSentEvent.heartbeat)\n      }\n    }\n  }\n} Java copysourcefinal List<ServerSentEvent> events = new ArrayList<>();\nevents.add(ServerSentEvent.create(\"1\"));\nevents.add(ServerSentEvent.create(\"2\"));\nfinal Route route = completeOK(Source.from(events), EventStreamMarshalling.toEventStream());","title":"Server-side usage: marshalling"},{"location":"/common/sse-support.html#client-side-usage-unmarshalling","text":"In order to unmarshal an event stream as Source<ServerSentEvent, ?>Source[ServerSentEvent, _], you have to bring the implicit FromEntityUnmarshaller[Source[ServerSentEvent, _]] defined by EventStreamUnmarshallingEventStreamUnmarshalling into scopeuse the EventStreamUnmarshalling.fromEventsStream unmarshaller:\nScala copysourceimport org.apache.pekko.http.scaladsl.unmarshalling.sse.EventStreamUnmarshalling._\n\nHttp()\n  .singleRequest(Get(\"http://localhost:8000/events\"))\n  .flatMap(Unmarshal(_).to[Source[ServerSentEvent, NotUsed]])\n  .foreach(_.runForeach(println)) Java copysourceList<ServerSentEvent> unmarshalledEvents =\n        EventStreamUnmarshalling.fromEventsStream(system)\n                .unmarshal(entity, system)\n                .thenCompose(source -> source.runWith(Sink.seq(), mat))\n                .toCompletableFuture()\n                .get(3000, TimeUnit.SECONDS);\nNotice that if you are looking for a resilient way to permanently subscribe to an event stream, Apache Pekko Connectors provides the EventSource connector which reconnects automatically with the id of the last seen event.","title":"Client-side usage: unmarshalling"},{"location":"/common/timeouts.html","text":"","title":"Timeouts"},{"location":"/common/timeouts.html#timeouts","text":"Apache Pekko HTTP comes with a variety of built-in timeout mechanisms to protect your servers from malicious attacks or programming mistakes. Some of these are simply configuration options (which may be overridden in code) while others are left to the streaming APIs and are easily implementable as patterns in user-code directly.","title":"Timeouts"},{"location":"/common/timeouts.html#common-timeouts","text":"","title":"Common timeouts"},{"location":"/common/timeouts.html#connection-level-idle-timeout","text":"The idle-timeout is a setting which sets the maximum inactivity time of a given connection. If no data is sent or received on a connection for over idle-timeout time, the connection will be automatically closed.\nThis setting should be used as a last-resort safeguard to prevent unused or stuck connections from consuming resources for an indefinite time.\nThe setting works the same way for server and client connections and it is configurable independently using the following keys:\npekko.http.server.idle-timeout\npekko.http.client.idle-timeout\npekko.http.host-connection-pool.client.idle-timeout","title":"Connection-level idle timeout"},{"location":"/common/timeouts.html#server-timeouts","text":"","title":"Server timeouts"},{"location":"/common/timeouts.html#request-timeout","text":"Request timeouts are a mechanism that limits the maximum time it may take to produce an HttpResponseHttpResponse from a route. If that deadline is not met the server will automatically inject a Service Unavailable HTTP response and close the connection to prevent it from leaking and staying around indefinitely (for example if by programming error a Future would never complete, never sending the real response otherwise).\nThe default HttpResponseHttpResponse that is written when a request timeout is exceeded looks like this:\ncopysourceHttpResponse(StatusCodes.ServiceUnavailable,\n  entity = \"The server was not able \" +\n    \"to produce a timely response to your request.\\r\\nPlease try again in a short while!\")\nA default request timeout is applied globally to all routes and can be configured using the pekko.http.server.request-timeout setting (which defaults to 20 seconds).\nThe request timeout can be configured at run-time for a given route using the any of the TimeoutDirectives.","title":"Request timeout"},{"location":"/common/timeouts.html#bind-timeout","text":"The bind timeout is the time period within which the TCP binding process must be completed (using any of the Http().bind* methods). It can be configured using the pekko.http.server.bind-timeout setting.","title":"Bind timeout"},{"location":"/common/timeouts.html#linger-timeout","text":"The linger timeout is the time period the HTTP server implementation will keep a connection open after all data has been delivered to the network layer. This setting is similar to the SO_LINGER socket option but does not only include the OS-level socket but also covers the Appache Pekko IO and Streams network stack. The setting is an extra precaution that prevents clients from keeping open a connection that is already considered completed from the server side.\nIf the network level buffers (including the Appache Pekko IO and Streams networking stack buffers) contains more data than can be transferred to the client in the given time when the server-side considers to be finished with this connection, the client may encounter a connection reset.\nSet to infinite to disable automatic connection closure (which will risk to leak connections).","title":"Linger timeout"},{"location":"/common/timeouts.html#client-timeouts","text":"","title":"Client timeouts"},{"location":"/common/timeouts.html#connecting-timeout","text":"The connecting timeout is the time period within which the TCP connecting process must be completed. Tweaking it should rarely be required, but it allows erroring out the connection in case a connection is unable to be established for a given amount of time.\nIt can be configured using the pekko.http.client.connecting-timeout setting.","title":"Connecting timeout"},{"location":"/common/timeouts.html#client-pool-timeouts","text":"","title":"Client pool timeouts"},{"location":"/common/timeouts.html#keep-alive-timeout","text":"HTTP connections are commonly used for multiple requests, that is, they are kept alive between requests. The pekko.http.host-connection-pool.keep-alive-timeout setting configures how long a pool keeps a connection alive between requests before it closes the connection (and eventually reestablishes it).\nA common scenario where this setting is useful is to prevent a race-condition inherent in HTTP: in most cases, a server or reverse-proxy closes a persistent (kept-alive) connection after some time. HTTP does not define a protocol between client and server to negotiate a graceful teardown of an idle persistent connection. Therefore, it can happen that a server decides to close a connection at the same time that a client decides to send a new request. In that case, the request will fail to be processed, but the client cannot determine for which reason the server closed the connection and whether the request was (partly) processed or not. Such a condition can be observed when a request fails with an UnexpectedConnectionClosureException or a StreamTcpException stating “Connection reset by peer”.\nTo prevent this from happening, you can set the timeout to a lower value than the server-side keep-alive timeout (which you either have to know or find out experimentally).\nSet to infinite to allow the connection to remain open indefinitely (or be closed by the more general idle-timeout).","title":"Keep-alive timeout"},{"location":"/common/timeouts.html#connection-lifetime-timeout","text":"This timeout configures a maximum amount of time, while the connection can be kept open. This is useful, when you reach the server through a load balancer and client reconnecting helps the process of rebalancing between service instances.\nIt can be configured using the pekko.http.host-connection-pool.max-connection-lifetime setting.","title":"Connection Lifetime timeout"},{"location":"/common/timeouts.html#pool-idle-timeout","text":"A connection pool to a target host will be shut down after the timeout given as pekko.http.host-connection-pool.idle-timeout. This frees resources like open but idle pool connections and management structures.\nIf the application connects to only a limited set of target hosts over its lifetime and resource usage for the pool is of no concern, the idle-timeout can be completely disabled by setting it to infinite.\nA pool will be automatically reestablished when a new request comes in for a target host.","title":"Pool Idle timeout"},{"location":"/common/caching.html","text":"","title":"Caching"},{"location":"/common/caching.html#caching","text":"Apache Pekko HTTP’s caching support provides a lightweight and fast in-memory caching functionality based on futures. The primary use-case is the “wrapping” of an expensive operation with a caching layer that, based on a certain key of type K, runs the wrapped operation only once and returns the cached value for all future accesses for the same key (as long as the respective entry has not expired).\nApache Pekko HTTP comes with one implementation of the CacheCache API built on Caffeine featuring frequency-biased cache eviction semantics with support for time-based entry expiration.","title":"Caching"},{"location":"/common/caching.html#dependency","text":"To use Apache Pekko HTTP Caching, add the module to your project:\nsbt val PekkoHttpVersion = \"0.0.0+4308-98f0ff9c-SNAPSHOT\"\nlibraryDependencies += \"org.apache.pekko\" %% \"pekko-http-caching\" % PekkoHttpVersion Gradle def versions = [\n  ScalaBinary: \"2.13\"\n]\ndependencies {\n  implementation platform(\"org.apache.pekko:pekko-http-bom_${versions.ScalaBinary}:0.0.0+4308-98f0ff9c-SNAPSHOT\")\n\n  implementation \"org.apache.pekko:pekko-http-caching_${versions.ScalaBinary}\"\n} Maven <properties>\n  <scala.binary.version>2.13</scala.binary.version>\n</properties>\n<dependencyManagement>\n  <dependencies>\n    <dependency>\n      <groupId>org.apache.pekko</groupId>\n      <artifactId>pekko-http-bom_${scala.binary.version}</artifactId>\n      <version>0.0.0+4308-98f0ff9c-SNAPSHOT</version>\n      <type>pom</type>\n      <scope>import</scope>\n    </dependency>\n  </dependencies>\n</dependencyManagement>\n<dependencies>\n  <dependency>\n    <groupId>org.apache.pekko</groupId>\n    <artifactId>pekko-http-caching_${scala.binary.version}</artifactId>\n  </dependency>\n</dependencies>","title":"Dependency"},{"location":"/common/caching.html#basic-design","text":"The central idea of the cache API is to not store the actual values of type T themselves in the cache but rather the corresponding futures, i.e. instances of type CompletableFuture<T>Future[T]. This approach has the advantage of taking care of the thundering herds problem where many requests to a particular cache key (e.g. a resource URI) arrive before the first one could be completed. Normally (without special guarding techniques, like so-called “cowboy” entries) this can cause many requests to compete for system resources while trying to compute the same result thereby greatly reducing overall system performance. When you use an Apache Pekko HTTP cache the very first request that arrives for a certain cache key causes a future to be put into the cache which all later requests then “hook into”. As soon as the first request completes all other ones complete as well. This minimizes processing time and server load for all requests.\nAll Apache Pekko HTTP cache implementations adheres to the CacheCache interfaceclass, which allows you to interact with the cache.\nAlong with the cache API, the routing DSL provides several caching directives to use caching in your routes.","title":"Basic design"},{"location":"/common/caching.html#frequency-biased-lfu-cache","text":"The frequency-biased LFU cache implementation has a defined maximum number of entries it can store. After the maximum capacity is reached the cache will evict entries that are less likely to be used again. For example, the cache may evict an entry because it hasn’t been used recently or very often.\nTime-based entry expiration is enabled when time-to-live and/or time-to-idle expirations are set to a finite duration. The former provides an upper limit to the time period an entry is allowed to remain in the cache while the latter limits the maximum time an entry is kept without having been accessed, ie. either read or updated. If both values are finite the time-to-live has to be greater or equal than the time-to-idle.\nNote Expired entries are only evicted upon next access (or by being thrown out by the capacity constraint), so they might prevent garbage collection of their values for longer than expected.\nFor simple cases, configure the capacity and expiration settings in your application.conf file via the settings under pekko.http.caching and use LfuCache.create()LfuCache.apply() to create the cache. For more advanced usage you can create an LfuCacheLfuCache with settings specialized for your use case:\nJava copysourceimport org.apache.pekko.http.caching.javadsl.Cache;\nimport org.apache.pekko.http.caching.javadsl.CachingSettings;\nimport org.apache.pekko.http.caching.javadsl.LfuCacheSettings;\nimport org.apache.pekko.http.caching.LfuCache;\nimport static org.apache.pekko.http.javadsl.server.directives.CachingDirectives.*;\nimport java.util.concurrent.TimeUnit;\n\n// Use the request's URI as the cache's key\nfinal JavaPartialFunction<RequestContext, Uri> keyerFunction = new JavaPartialFunction<RequestContext, Uri>() {\n  public Uri apply(RequestContext in, boolean isCheck) {\n    return in.getRequest().getUri();\n  }\n};\nfinal CachingSettings defaultCachingSettings = CachingSettings.create(system());\nfinal LfuCacheSettings lfuCacheSettings = defaultCachingSettings.lfuCacheSettings()\n  .withInitialCapacity(25)\n  .withMaxCapacity(50)\n  .withTimeToLive(Duration.create(20, TimeUnit.SECONDS))\n  .withTimeToIdle(Duration.create(10, TimeUnit.SECONDS));\nfinal CachingSettings cachingSettings = defaultCachingSettings.withLfuCacheSettings(lfuCacheSettings);\nfinal Cache<Uri, RouteResult> lfuCache = LfuCache.create(cachingSettings);\n\n// Create the route\nfinal Route route = cache(lfuCache, keyerFunction, () -> innerRoute); Scala copysourceimport org.apache.pekko\nimport pekko.http.caching.scaladsl.Cache\nimport pekko.http.caching.scaladsl.CachingSettings\nimport pekko.http.caching.LfuCache\nimport pekko.http.scaladsl.server.RequestContext\nimport pekko.http.scaladsl.server.RouteResult\nimport pekko.http.scaladsl.model.Uri\nimport pekko.http.scaladsl.server.directives.CachingDirectives._\nimport scala.concurrent.duration._\n\n// Use the request's URI as the cache's key\nval keyerFunction: PartialFunction[RequestContext, Uri] = {\n  case r: RequestContext => r.request.uri\n}\nval defaultCachingSettings = CachingSettings(system)\nval lfuCacheSettings =\n  defaultCachingSettings.lfuCacheSettings\n    .withInitialCapacity(25)\n    .withMaxCapacity(50)\n    .withTimeToLive(20.seconds)\n    .withTimeToIdle(10.seconds)\nval cachingSettings =\n  defaultCachingSettings.withLfuCacheSettings(lfuCacheSettings)\nval lfuCache: Cache[Uri, RouteResult] = LfuCache(cachingSettings)\n\n// Create the route\nval route = cache(lfuCache, keyerFunction)(innerRoute)","title":"Frequency-biased LFU cache"},{"location":"/server-side/index.html","text":"","title":"4. Server API"},{"location":"/server-side/index.html#4-server-api","text":"Apache Pekko HTTP also provides an embedded, Reactive-Streams-based, fully asynchronous HTTP/1.1 server implemented on top of Streams.\nIt supports the following features:\nFull support for HTTP persistent connections Full support for asynchronous HTTP streaming including “chunked” transfer encoding accessible through an idiomatic API WebSocket support Optional SSL/TLS encryption Optional support for HTTP pipelining\nThe server-side components of Apache Pekko HTTP are split into two layers:\nHigh-level Server-Side API Higher-level functionality in the pekko-http module which offers a very flexible “Routing DSL” for elegantly defining RESTful web services as well as functionality of typical web servers or frameworks, like deconstruction of URIs, content negotiation or static content serving. Core Server API The basic low-level server implementation in the pekko-http-core module.\nDepending on your needs you can either use the low-level API directly or rely on the high-level Routing DSL which can make the definition of more complex service logic much easier. You can also interact with different API levels at the same time and, independently of which API level you choose Apache Pekko HTTP will happily serve many thousand concurrent connections to a single or many clients.\nNote It is recommended to read the Implications of the streaming nature of Request/Response Entities section, as it explains the underlying full-stack streaming concepts, which may be unexpected when coming from a background with non-“streaming first” HTTP Servers.\nRouting DSL Minimal Example Longer Example Getting started Compared with Play framework routes Interaction with Actors Dynamic Routing Example Handling HTTP Server failures in the High-Level API File uploads Configuring Server-side HTTPS Routing DSL Overview Compared with Play routes Routes Directives Rejections Exception Handling Case Class Extraction Source Streaming Routing DSL style guide Route TestKit Core Server API Streams and HTTP Starting and Stopping Request-Response Cycle Configuring Server-side HTTPS Stand-Alone HTTP Layer Usage Controlling server parallelism Handling HTTP Server failures in the Low-Level API Server WebSocket Support Model Routing support WebSocketUpgrade Automatic keep-alive Ping support Server HTTPS Support Obtaining SSL/TLS Certificates Using HTTPS Running both HTTP and HTTPS Mutual authentication Further reading Graceful termination Pekko Coordinated Shutdown Graceful termination using ServerTerminator Server-Side HTTP/2 (Preview) Enable HTTP/2 support Use newServerAt(...).bind() and HTTPS Trailing headers Testing with cURL","title":"4. Server API"},{"location":"/routing-dsl/index.html","text":"","title":"Routing DSL"},{"location":"/routing-dsl/index.html#routing-dsl","text":"Apache Pekko HTTP provides a flexible routing DSL for elegantly defining RESTful web services. It picks up where the low-level API leaves off and offers much of the higher-level functionality of typical web servers or frameworks, like deconstruction of URIs, content negotiation or static content serving.\nNote It is recommended to read the Implications of the streaming nature of Request/Response Entities section, as it explains the underlying full-stack streaming concepts, which may be unexpected when coming from a background with non-“streaming first” HTTP Servers.\nMinimal Example Longer Example Getting started Compared with Play framework routes Interaction with Actors Dynamic Routing Example Handling HTTP Server failures in the High-Level API File uploads Configuring Server-side HTTPS Routing DSL Overview Compared with Play routes Routes Directives Rejections Exception Handling Case Class Extraction Source Streaming Routing DSL style guide Route TestKit","title":"Routing DSL"},{"location":"/routing-dsl/index.html#minimal-example","text":"This is a complete, very basic Apache Pekko HTTP application relying on the Routing DSL:\nScala copysource/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * license agreements; and to You under the Apache License, version 2.0:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * This file is part of the Apache Pekko project, derived from Akka.\n */\n\n/*\n * Copyright (C) 2020-2022 Lightbend Inc. <https://www.lightbend.com>\n */\n\npackage docs.http.scaladsl\n\nimport org.apache.pekko\nimport pekko.actor.typed.ActorSystem\nimport pekko.actor.typed.scaladsl.Behaviors\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.model._\nimport pekko.http.scaladsl.server.Directives._\nimport scala.io.StdIn\n\nobject HttpServerRoutingMinimal {\n\n  def main(args: Array[String]): Unit = {\n\n    implicit val system = ActorSystem(Behaviors.empty, \"my-system\")\n    // needed for the future flatMap/onComplete in the end\n    implicit val executionContext = system.executionContext\n\n    val route =\n      path(\"hello\") {\n        get {\n          complete(HttpEntity(ContentTypes.`text/html(UTF-8)`, \"<h1>Say hello to akka-http</h1>\"))\n        }\n      }\n\n    val bindingFuture = Http().newServerAt(\"localhost\", 8080).bind(route)\n\n    println(s\"Server now online. Please navigate to http://localhost:8080/hello\\nPress RETURN to stop...\")\n    StdIn.readLine() // let it run until user presses return\n    bindingFuture\n      .flatMap(_.unbind()) // trigger unbinding from the port\n      .onComplete(_ => system.terminate()) // and shutdown when done\n  }\n} Java copysourceimport org.apache.pekko.actor.typed.ActorSystem;\nimport org.apache.pekko.actor.typed.javadsl.Behaviors;\nimport org.apache.pekko.http.javadsl.Http;\nimport org.apache.pekko.http.javadsl.ServerBinding;\nimport org.apache.pekko.http.javadsl.server.AllDirectives;\nimport org.apache.pekko.http.javadsl.server.Route;\n\nimport java.util.concurrent.CompletionStage;\n\npublic class HttpServerMinimalExampleTest extends AllDirectives {\n\n  public static void main(String[] args) throws Exception {\n    // boot up server using the route as defined below\n    ActorSystem<Void> system = ActorSystem.create(Behaviors.empty(), \"routes\");\n\n    final Http http = Http.get(system);\n\n    //In order to access all directives we need an instance where the routes are define.\n    HttpServerMinimalExampleTest app = new HttpServerMinimalExampleTest();\n\n    final CompletionStage<ServerBinding> binding =\n      http.newServerAt(\"localhost\", 8080)\n          .bind(app.createRoute());\n\n    System.out.println(\"Server online at http://localhost:8080/\\nPress RETURN to stop...\");\n    System.in.read(); // let it run until user presses return\n\n    binding\n        .thenCompose(ServerBinding::unbind) // trigger unbinding from the port\n        .thenAccept(unbound -> system.terminate()); // and shutdown when done\n  }\n\n  private Route createRoute() {\n    return concat(\n        path(\"hello\", () ->\n            get(() ->\n                complete(\"<h1>Say hello to pekko-http</h1>\"))));\n  }\n}\nIt starts an HTTP Server on localhost and replies to GET requests to /hello with a simple response.\nLonger Example The following is an Apache Pekko HTTP route definition that tries to show off a few features. The resulting service does not really do anything useful but its definition should give you a feel for what an actual API definition with the Routing DSL will look like: copysourceimport org.apache.pekko\nimport pekko.actor.{ ActorRef, ActorSystem }\nimport pekko.http.scaladsl.coding.Coders\nimport pekko.http.scaladsl.marshalling.ToResponseMarshaller\nimport pekko.http.scaladsl.model.StatusCodes.MovedPermanently\nimport pekko.http.scaladsl.server.Directives._\nimport pekko.http.scaladsl.unmarshalling.FromRequestUnmarshaller\nimport pekko.pattern.ask\nimport pekko.util.Timeout\n\n// types used by the API routes\ntype Money = Double // only for demo purposes, don't try this at home!\ntype TransactionResult = String\ncase class User(name: String)\ncase class Order(email: String, amount: Money)\ncase class Update(order: Order)\ncase class OrderItem(i: Int, os: Option[String], s: String)\n\n// marshalling would usually be derived automatically using libraries\nimplicit val orderUM: FromRequestUnmarshaller[Order] = ???\nimplicit val orderM: ToResponseMarshaller[Order] = ???\nimplicit val orderSeqM: ToResponseMarshaller[Seq[Order]] = ???\nimplicit val timeout: Timeout = ??? // for actor asks\nimplicit val ec: ExecutionContext = ???\nimplicit val sys: ActorSystem = ???\n\n// backend entry points\ndef myAuthenticator: Authenticator[User] = ???\ndef retrieveOrdersFromDB: Future[Seq[Order]] = ???\ndef myDbActor: ActorRef = ???\ndef processOrderRequest(id: Int, complete: Order => Unit): Unit = ???\n\nlazy val binding = Http().newServerAt(\"localhost\", 8080).bind(topLevelRoute)\n// ...\n\nlazy val topLevelRoute: Route =\n  // provide top-level path structure here but delegate functionality to subroutes for readability\n  concat(\n    path(\"orders\")(ordersRoute),\n    // extract URI path element as Int\n    pathPrefix(\"order\" / IntNumber)(orderRoute),\n    pathPrefix(\"documentation\")(documentationRoute),\n    path(\"oldApi\" / Remaining) { pathRest =>\n      redirect(\"http://oldapi.example.com/\" + pathRest, MovedPermanently)\n    })\n\n// For bigger routes, these sub-routes can be moved to separate files\nlazy val ordersRoute: Route =\n  authenticateBasic(realm = \"admin area\", myAuthenticator) { user =>\n    concat(\n      get {\n        encodeResponseWith(Coders.Deflate) {\n          complete {\n            // unpack future and marshal custom object with in-scope marshaller\n            retrieveOrdersFromDB\n          }\n        }\n      },\n      post {\n        // decompress gzipped or deflated requests if required\n        decodeRequest {\n          // unmarshal with in-scope unmarshaller\n          entity(as[Order]) { order =>\n            complete {\n              // ... write order to DB\n              \"Order received\"\n            }\n          }\n        }\n      })\n  }\n\ndef orderRoute(orderId: Int): Route =\n  concat(\n    pathEnd {\n      concat(\n        put {\n          // form extraction from multipart or www-url-encoded forms\n          formFields(\"email\", \"total\".as[Money]).as(Order) { order =>\n            complete {\n              // complete with serialized Future result\n              (myDbActor ? Update(order)).mapTo[TransactionResult]\n            }\n          }\n        },\n        get {\n          // debugging helper\n          logRequest(\"GET-ORDER\") {\n            // use in-scope marshaller to create completer function\n            completeWith(instanceOf[Order]) { completer =>\n              // custom\n              processOrderRequest(orderId, completer)\n            }\n          }\n        })\n    },\n    path(\"items\") {\n      get {\n        // parameters to case class extraction\n        parameters(\"size\".as[Int], \"color\".optional, \"dangerous\".withDefault(\"no\"))\n          .as(OrderItem) { orderItem =>\n            // ... route using case class instance created from\n            // required and optional query parameters\n          }\n      }\n    })\n\nlazy val documentationRoute: Route =\n  // optionally compresses the response with Gzip or Deflate\n  // if the client accepts compressed responses\n  encodeResponse {\n    // serve up static content from a JAR resource\n    getFromResourceDirectory(\"docs\")\n  }","title":"Minimal Example"},{"location":"/routing-dsl/index.html#getting-started","text":"The project template in Apache Pekko HTTP Quickstart for ScalaApache Pekko HTTP Quickstart for Java will help you to get a working Apache Pekko HTTP server running.","title":"Getting started"},{"location":"/routing-dsl/index.html#compared-with-play-framework-routes","text":"If you have been using Play framework’s routes file notation before this Play comparison may help you to get started with Apache Pekko HTTP routing.","title":"Compared with Play framework routes"},{"location":"/routing-dsl/index.html#interaction-with-akka-typed","text":"The following example shows how to use Apache Pekko HTTP with Apache Pekko Actors.\nWe will create a small web server responsible to record build jobs with its state and duration, query jobs by id and status, and clear the job history.\nFirst let’s start by defining the BehaviorBehavior that will act as a repository for the build job information. This isn’t strictly needed for our sample, but just to have an actual actor to interact with:\nScala copysourceimport org.apache.pekko\nimport pekko.actor.typed.{ ActorRef, Behavior }\nimport pekko.actor.typed.scaladsl.Behaviors\n\nobject JobRepository {\n\n  // Definition of the a build job and its possible status values\n  sealed trait Status\n  object Successful extends Status\n  object Failed extends Status\n\n  final case class Job(id: Long, projectName: String, status: Status, duration: Long)\n\n  // Trait defining successful and failure responses\n  sealed trait Response\n  case object OK extends Response\n  final case class KO(reason: String) extends Response\n\n  // Trait and its implementations representing all possible messages that can be sent to this Behavior\n  sealed trait Command\n  final case class AddJob(job: Job, replyTo: ActorRef[Response]) extends Command\n  final case class GetJobById(id: Long, replyTo: ActorRef[Option[Job]]) extends Command\n  final case class ClearJobs(replyTo: ActorRef[Response]) extends Command\n\n  // This behavior handles all possible incoming messages and keeps the state in the function parameter\n  def apply(jobs: Map[Long, Job] = Map.empty): Behavior[Command] = Behaviors.receiveMessage {\n    case AddJob(job, replyTo) if jobs.contains(job.id) =>\n      replyTo ! KO(\"Job already exists\")\n      Behaviors.same\n    case AddJob(job, replyTo) =>\n      replyTo ! OK\n      JobRepository(jobs.+(job.id -> job))\n    case GetJobById(id, replyTo) =>\n      replyTo ! jobs.get(id)\n      Behaviors.same\n    case ClearJobs(replyTo) =>\n      replyTo ! OK\n      JobRepository(Map.empty)\n  }\n\n} Java copysourceimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\n\nimport org.apache.pekko.actor.typed.ActorRef;\nimport org.apache.pekko.actor.typed.Behavior;\nimport org.apache.pekko.actor.typed.javadsl.*;\nimport com.fasterxml.jackson.annotation.*;\n\n/**\n * Actor for use with the HttpServerWithActorsSample\n */\npublic class JobRepository extends AbstractBehavior<JobRepository.Command> {\n\n  @JsonFormat\n  public static final class Job {\n    @JsonProperty(\"id\")\n    final Long id;\n    @JsonProperty(\"project-name\")\n    final String projectName;\n    @JsonProperty(\"status\")\n    final String status;\n    @JsonProperty(\"duration\")\n    final Long duration;\n\n    @JsonCreator(mode = JsonCreator.Mode.PROPERTIES)\n    public Job(@JsonProperty(\"id\") Long id, @JsonProperty(\"project-name\") String projectName, @JsonProperty(\"duration\") Long duration) {\n      this(id, projectName, \"Success\", duration);\n    }\n    public Job(Long id, String projectName, String status, Long duration) {\n      this.id = id;\n      this.projectName = projectName;\n      this.status = status;\n      this.duration = duration;\n    }\n  }\n\n  // Successful and failure responses\n  interface Response {}\n\n  public static final class OK implements Response {\n    private static OK INSTANCE = new OK();\n\n    private OK() {}\n\n    public static OK getInstance() {\n      return INSTANCE;\n    }\n  }\n\n  public static final class KO implements Response {\n    final String reason;\n\n    public KO(String reason) {\n      this.reason = reason;\n    }\n  }\n\n  // All possible messages that can be sent to this Behavior\n  interface Command {}\n\n  public static final class AddJob implements Command {\n    final Job job;\n    final ActorRef<Response> replyTo;\n\n    public AddJob(Job job, ActorRef<Response> replyTo) {\n      this.job = job;\n      this.replyTo = replyTo;\n    }\n  }\n\n  public static final class GetJobById implements Command {\n    final Long id;\n    final ActorRef<Optional<Job>> replyTo;\n\n    public GetJobById(Long id, ActorRef<Optional<Job>> replyTo) {\n      this.id = id;\n      this.replyTo = replyTo;\n    }\n  }\n\n  public static final class ClearJobs implements Command {\n    final ActorRef<Response> replyTo;\n\n    public ClearJobs(ActorRef<Response> replyTo) {\n      this.replyTo = replyTo;\n    }\n  }\n\n  public static Behavior<Command> create() {\n    return create(new HashMap<Long, Job>());\n  }\n\n  public static Behavior<Command> create(Map<Long, Job> jobs) {\n    return Behaviors.setup(ctx -> new JobRepository(ctx, jobs));\n  }\n\n  private Map<Long, Job> jobs;\n\n  private JobRepository(ActorContext<Command> context, Map<Long, Job> jobs) {\n    super(context);\n    this.jobs = jobs;\n  }\n\n  // This receive handles all possible incoming messages and keeps the state in the actor\n  @Override\n  public Receive<Command> createReceive() {\n    return newReceiveBuilder()\n            .onMessage(AddJob.class, this::addJob)\n            .onMessage(GetJobById.class, this::getJobById)\n            .onMessage(ClearJobs.class, this::clearJobs)\n            .build();\n  }\n\n  private Behavior<Command> addJob(AddJob msg) {\n    if (jobs.containsKey(msg.job.id))\n      msg.replyTo.tell(new KO(\"Job already exists\"));\n    else {\n      jobs.put(msg.job.id, msg.job);\n      msg.replyTo.tell(OK.getInstance());\n    }\n    return Behaviors.same();\n  }\n\n  private Behavior<Command> getJobById(GetJobById msg) {\n    if (jobs.containsKey(msg.id)) {\n      msg.replyTo.tell(Optional.of(jobs.get(msg.id)));\n    } else {\n      msg.replyTo.tell(Optional.empty());\n    }\n    return Behaviors.same();\n  }\n\n  private Behavior<Command> clearJobs(ClearJobs msg) {\n    msg.replyTo.tell(OK.getInstance());\n    jobs.clear();\n    return Behaviors.same();\n  }\n}\nThen, let’s define the JSON marshaller and unmarshallers for the HTTP routes: Scala copysourceimport org.apache.pekko.http.scaladsl.marshallers.sprayjson.SprayJsonSupport\nimport spray.json.DefaultJsonProtocol\nimport spray.json.DeserializationException\nimport spray.json.JsString\nimport spray.json.JsValue\nimport spray.json.RootJsonFormat\n\ntrait JsonSupport extends SprayJsonSupport {\n  // import the default encoders for primitive types (Int, String, Lists etc)\n  import DefaultJsonProtocol._\n  import JobRepository._\n\n  implicit object StatusFormat extends RootJsonFormat[Status] {\n    def write(status: Status): JsValue = status match {\n      case Failed     => JsString(\"Failed\")\n      case Successful => JsString(\"Successful\")\n    }\n\n    def read(json: JsValue): Status = json match {\n      case JsString(\"Failed\")     => Failed\n      case JsString(\"Successful\") => Successful\n      case _                      => throw new DeserializationException(\"Status unexpected\")\n    }\n  }\n\n  implicit val jobFormat = jsonFormat4(Job)\n}\nNext step is to define the Route Route that will communicate with the previously defined behavior and handle all its possible responses:\nScala copysourceimport org.apache.pekko\nimport pekko.actor.typed.ActorSystem\nimport pekko.util.Timeout\n\nimport pekko.http.scaladsl.server.Directives._\nimport pekko.http.scaladsl.model.StatusCodes\nimport pekko.http.scaladsl.server.Route\n\nimport scala.concurrent.duration._\nimport scala.concurrent.Future\n\nclass JobRoutes(buildJobRepository: ActorRef[JobRepository.Command])(\n    implicit system: ActorSystem[_]) extends JsonSupport {\n\n  import pekko.actor.typed.scaladsl.AskPattern.schedulerFromActorSystem\n  import pekko.actor.typed.scaladsl.AskPattern.Askable\n\n  // asking someone requires a timeout and a scheduler, if the timeout hits without response\n  // the ask is failed with a TimeoutException\n  implicit val timeout: Timeout = 3.seconds\n\n  lazy val theJobRoutes: Route =\n    pathPrefix(\"jobs\") {\n      concat(\n        pathEnd {\n          concat(\n            post {\n              entity(as[JobRepository.Job]) { job =>\n                val operationPerformed: Future[JobRepository.Response] =\n                  buildJobRepository.ask(JobRepository.AddJob(job, _))\n                onSuccess(operationPerformed) {\n                  case JobRepository.OK         => complete(\"Job added\")\n                  case JobRepository.KO(reason) => complete(StatusCodes.InternalServerError -> reason)\n                }\n              }\n            },\n            delete {\n              val operationPerformed: Future[JobRepository.Response] =\n                buildJobRepository.ask(JobRepository.ClearJobs(_))\n              onSuccess(operationPerformed) {\n                case JobRepository.OK         => complete(\"Jobs cleared\")\n                case JobRepository.KO(reason) => complete(StatusCodes.InternalServerError -> reason)\n              }\n            })\n        },\n        (get & path(LongNumber)) { id =>\n          val maybeJob: Future[Option[JobRepository.Job]] =\n            buildJobRepository.ask(JobRepository.GetJobById(id, _))\n          rejectEmptyResponse {\n            complete(maybeJob)\n          }\n        })\n    }\n} Java copysourceimport java.time.Duration;\nimport java.util.Optional;\nimport java.util.concurrent.CompletionStage;\n\nimport org.apache.pekko.actor.typed.ActorRef;\nimport org.apache.pekko.actor.typed.ActorSystem;\nimport org.apache.pekko.actor.typed.javadsl.AskPattern;\n\nimport org.apache.pekko.http.javadsl.marshallers.jackson.Jackson;\nimport org.apache.pekko.http.javadsl.model.StatusCodes;\nimport org.apache.pekko.http.javadsl.server.Route;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.*;\nimport static org.apache.pekko.http.javadsl.unmarshalling.StringUnmarshallers.LONG;\n\n/**\n * Routes for use with the HttpServerWithActorsSample\n */\npublic class JobRoutes {\n  private final ActorSystem<?> system;\n  private final ActorRef<JobRepository.Command> buildJobRepository;\n\n  public JobRoutes(ActorRef<JobRepository.Command> buildJobRepository, ActorSystem<?> system) {\n    this.system = system;\n    this.buildJobRepository = buildJobRepository;\n  }\n\n  private Route addOrDelete() {\n    return concat(\n            post(() ->\n                    entity(Jackson.unmarshaller(JobRepository.Job.class), job ->\n                      onSuccess(add(job), r -> complete(\"Job added\"))\n                    )),\n            delete(() -> onSuccess(deleteAll(), r -> complete(\"Jobs cleared\")))\n    );\n  }\n\n  private CompletionStage<JobRepository.OK> add(JobRepository.Job job) {\n    return handleKO(AskPattern.ask(\n            buildJobRepository,\n            replyTo -> new JobRepository.AddJob(job, replyTo),\n            Duration.ofSeconds(3),\n            system.scheduler()));\n  }\n\n  private CompletionStage<JobRepository.OK> deleteAll() {\n    return handleKO(AskPattern.ask(\n            buildJobRepository,\n            JobRepository.ClearJobs::new,\n            Duration.ofSeconds(3),\n            system.scheduler()));\n  }\n\n  public Route jobRoutes() {\n    return pathPrefix(\"jobs\", () ->\n            concat(\n                    pathEnd(this::addOrDelete),\n                    get(() ->\n                            path(LONG, jobId ->\n                              onSuccess(getJob(jobId), jobOption -> {\n                                if (jobOption.isPresent()) {\n                                  return complete(StatusCodes.OK, jobOption.get(), Jackson.<JobRepository.Job>marshaller());\n                                } else {\n                                  return complete(StatusCodes.NOT_FOUND);\n                                }\n                              })\n                            )\n                    )\n            )\n    );\n  }\n\n  private CompletionStage<Optional<JobRepository.Job>> getJob(Long jobId) {\n    return AskPattern.ask(\n            buildJobRepository,\n            replyTo -> new JobRepository.GetJobById(jobId, replyTo),\n            Duration.ofSeconds(3),\n            system.scheduler());\n  }\n\n  private CompletionStage<JobRepository.OK> handleKO(CompletionStage<JobRepository.Response> stage) {\n    return stage.thenApply(response -> {\n      if (response instanceof JobRepository.OK) {\n        return (JobRepository.OK)response;\n      } else if (response instanceof JobRepository.KO) {\n        throw new IllegalStateException(((JobRepository.KO) response).reason);\n      } else {\n        throw new IllegalStateException(\"Invalid response\");\n      }\n    });\n  }\n}\nFinally, we create a BehaviorBehavior that bootstraps the web server and use it as the root behavior of our actor system:\nScala copysourceimport org.apache.pekko\nimport pekko.actor.typed.PostStop\nimport pekko.http.scaladsl.Http.ServerBinding\nimport pekko.http.scaladsl.Http\n\nimport scala.util.{ Failure, Success }\n\nobject Server {\n\n  sealed trait Message\n  private final case class StartFailed(cause: Throwable) extends Message\n  private final case class Started(binding: ServerBinding) extends Message\n  case object Stop extends Message\n\n  def apply(host: String, port: Int): Behavior[Message] = Behaviors.setup { ctx =>\n    implicit val system = ctx.system\n\n    val buildJobRepository = ctx.spawn(JobRepository(), \"JobRepository\")\n    val routes = new JobRoutes(buildJobRepository)\n\n    val serverBinding: Future[Http.ServerBinding] =\n      Http().newServerAt(host, port).bind(routes.theJobRoutes)\n    ctx.pipeToSelf(serverBinding) {\n      case Success(binding) => Started(binding)\n      case Failure(ex)      => StartFailed(ex)\n    }\n\n    def running(binding: ServerBinding): Behavior[Message] =\n      Behaviors.receiveMessagePartial[Message] {\n        case Stop =>\n          ctx.log.info(\n            \"Stopping server http://{}:{}/\",\n            binding.localAddress.getHostString,\n            binding.localAddress.getPort)\n          Behaviors.stopped\n      }.receiveSignal {\n        case (_, PostStop) =>\n          binding.unbind()\n          Behaviors.same\n      }\n\n    def starting(wasStopped: Boolean): Behaviors.Receive[Message] =\n      Behaviors.receiveMessage[Message] {\n        case StartFailed(cause) =>\n          throw new RuntimeException(\"Server failed to start\", cause)\n        case Started(binding) =>\n          ctx.log.info(\n            \"Server online at http://{}:{}/\",\n            binding.localAddress.getHostString,\n            binding.localAddress.getPort)\n          if (wasStopped) ctx.self ! Stop\n          running(binding)\n        case Stop =>\n          // we got a stop message but haven't completed starting yet,\n          // we cannot stop until starting has completed\n          starting(wasStopped = true)\n      }\n\n    starting(wasStopped = false)\n  }\n}\n\ndef main(args: Array[String]): Unit = {\n  val system: ActorSystem[Server.Message] =\n    ActorSystem(Server(\"localhost\", 8080), \"BuildJobsServer\")\n} Java copysource import org.apache.pekko.actor.typed.ActorRef;\nimport org.apache.pekko.actor.typed.ActorSystem;\nimport org.apache.pekko.actor.typed.Behavior;\nimport org.apache.pekko.actor.typed.PostStop;\nimport org.apache.pekko.actor.typed.javadsl.BehaviorBuilder;\nimport org.apache.pekko.actor.typed.javadsl.Behaviors;\nimport org.apache.pekko.http.javadsl.Http;\nimport org.apache.pekko.http.javadsl.ServerBinding;\nimport org.apache.pekko.http.javadsl.server.Route;\n\nimport java.util.concurrent.CompletionStage;\n\npublic class HttpServerWithActorsSample {\n\n  interface Message {}\n\n  private static final class StartFailed implements Message {\n    final Throwable ex;\n\n    public StartFailed(Throwable ex) {\n      this.ex = ex;\n    }\n  }\n\n  private static final class Started implements Message {\n    final ServerBinding binding;\n\n    public Started(ServerBinding binding) {\n      this.binding = binding;\n    }\n  }\n\n  private static final class Stop implements Message {}\n\n  public static Behavior<Message> create(String host, Integer port) {\n    return Behaviors.setup(ctx -> {\n      ActorSystem<Void> system = ctx.getSystem();\n      ActorRef<JobRepository.Command> buildJobRepository = ctx.spawn(JobRepository.create(), \"JobRepository\");\n      Route routes = new JobRoutes(buildJobRepository, ctx.getSystem()).jobRoutes();\n\n      CompletionStage<ServerBinding> serverBinding =\n              Http.get(system)\n                .newServerAt(host, port)\n                .bind(routes);\n\n      ctx.pipeToSelf(serverBinding, (binding, failure) -> {\n        if (binding != null) return new Started(binding);\n        else return new StartFailed(failure);\n      });\n\n      return starting(false);\n    });\n  }\n\n  private static Behavior<Message> starting(boolean wasStopped) {\n    return Behaviors.setup(ctx ->\n            BehaviorBuilder.<Message>create()\n                    .onMessage(StartFailed.class, failed -> {\n                      throw new RuntimeException(\"Server failed to start\", failed.ex);\n                    })\n                    .onMessage(Started.class, msg -> {\n                      ctx.getLog().info(\n                              \"Server online at http://{}:{}\",\n                              msg.binding.localAddress().getAddress(),\n                              msg.binding.localAddress().getPort());\n\n                      if (wasStopped) ctx.getSelf().tell(new Stop());\n\n                      return running(msg.binding);\n                    })\n                    .onMessage(Stop.class, s -> {\n                      // we got a stop message but haven't completed starting yet,\n                      // we cannot stop until starting has completed\n                      return starting(true);\n                    })\n                    .build());\n  }\n\n  private static Behavior<Message> running(ServerBinding binding) {\n    return BehaviorBuilder.<Message>create()\n            .onMessage(Stop.class, msg -> Behaviors.stopped())\n            .onSignal(PostStop.class, msg -> {\n              binding.unbind();\n              return Behaviors.same();\n            })\n            .build();\n  }\n\n  public static void main(String[] args) {\n    ActorSystem<Message> system = ActorSystem.create(\n            HttpServerWithActorsSample.create(\"localhost\", 8080), \"BuildJobsServer\");\n  }\n}","title":"Interaction with Actors"},{"location":"/routing-dsl/index.html#dynamic-routing-example","text":"As the routes are evaluated for each request, it is possible to make changes at runtime. Please note that every access may happen on a separated thread, so any shared mutable state must be thread safe.\nThe following is an Apache Pekko HTTP route definition that allows dynamically adding new or updating mock endpoints with associated request-response pairs at runtime.\nScala copysourcecase class MockDefinition(path: String, requests: Seq[JsValue], responses: Seq[JsValue])\nimplicit val format = jsonFormat3(MockDefinition)\n\n@volatile var state = Map.empty[String, Map[JsValue, JsValue]]\n\n// fixed route to update state\nval fixedRoute: Route = post {\n  pathSingleSlash {\n    entity(as[MockDefinition]) { mock =>\n      val mapping = mock.requests.zip(mock.responses).toMap\n      state = state + (mock.path -> mapping)\n      complete(\"ok\")\n    }\n  }\n}\n\n// dynamic routing based on current state\nval dynamicRoute: Route = ctx => {\n  val routes = state.map {\n    case (segment, responses) =>\n      post {\n        path(segment) {\n          entity(as[JsValue]) { input =>\n            complete(responses.get(input))\n          }\n        }\n      }\n  }\n  concat(routes.toList: _*)(ctx)\n}\n\nval route = fixedRoute ~ dynamicRoute Java copysourcefinal private Map<String, Map<JsonNode, JsonNode>> state = new ConcurrentHashMap<>();\n\nprivate Route createRoute() {\n  // fixed route to update state\n  Route fixedRoute = post(() ->\n    pathSingleSlash(() ->\n      entity(Jackson.unmarshaller(MockDefinition.class), mock -> {\n        Map<JsonNode, JsonNode> mappings = new HashMap<>();\n        int size = Math.min(mock.getRequests().size(), mock.getResponses().size());\n        for (int i = 0; i < size; i++) {\n          mappings.put(mock.getRequests().get(i), mock.getResponses().get(i));\n        }\n        state.put(mock.getPath(), mappings);\n        return complete(\"ok\");\n      })\n    )\n  );\n\n  // dynamic routing based on current state\n  Route dynamicRoute = post(() ->\n    state.entrySet().stream().map(mock ->\n      path(mock.getKey(), () ->\n        entity(Jackson.unmarshaller(JsonNode.class), input ->\n          complete(StatusCodes.OK, mock.getValue().get(input), Jackson.marshaller())\n        )\n      )\n    ).reduce(reject(), Route::orElse)\n  );\n\n  return concat(fixedRoute, dynamicRoute);\n}\n\nprivate static class MockDefinition {\n  private final String path;\n  private final List<JsonNode> requests;\n  private final List<JsonNode> responses;\n\n  public MockDefinition(@JsonProperty(\"path\") String path,\n                        @JsonProperty(\"requests\") List<JsonNode> requests,\n                        @JsonProperty(\"responses\") List<JsonNode> responses) {\n    this.path = path;\n    this.requests = requests;\n    this.responses = responses;\n  }\n\n  public String getPath() {\n    return path;\n  }\n\n  public List<JsonNode> getRequests() {\n    return requests;\n  }\n\n  public List<JsonNode> getResponses() {\n    return responses;\n  }\n}\nFor example, let’s say we do a POST request with body:\n{\n  \"path\": \"test\",\n  \"requests\": [\n    {\"id\": 1},\n    {\"id\": 2}\n  ],\n  \"responses\": [\n    {\"amount\": 1000},\n    {\"amount\": 2000}\n  ]\n}\nSubsequent POST request to /test with body {\"id\": 1} will be responded with {\"amount\": 1000}.","title":"Dynamic Routing Example"},{"location":"/routing-dsl/index.html#handling-http-server-failures-in-the-high-level-api","text":"There are various situations when failure may occur while initialising or running an Apache Pekko HTTP server. Apache Pekko by default will log all these failures, however sometimes one may want to react to failures in addition to them just being logged, for example by shutting down the actor system, or notifying some external monitoring end-point explicitly.","title":"Handling HTTP Server failures in the High-Level API"},{"location":"/routing-dsl/index.html#bind-failures","text":"For example the server might be unable to bind to the given port. For example when the port is already taken by another application, or if the port is privileged (i.e. only usable by root). In this case the “binding future” will fail immediately, and we can react to it by listening on the FutureCompletionStage’s completion:\nScala copysource/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * license agreements; and to You under the Apache License, version 2.0:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * This file is part of the Apache Pekko project, derived from Akka.\n */\n\n/*\n * Copyright (C) 2020-2022 Lightbend Inc. <https://www.lightbend.com>\n */\n\npackage docs.http.scaladsl\n\nimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.Http.ServerBinding\nimport pekko.http.scaladsl.server.Directives._\n\nimport scala.concurrent.Future\n\nobject HttpServerBindingFailure {\n  def main(args: Array[String]): Unit = {\n    implicit val system = ActorSystem()\n    // needed for the future foreach in the end\n    implicit val executionContext = system.dispatcher\n\n    val handler = get {\n      complete(\"Hello world!\")\n    }\n\n    // let's say the OS won't allow us to bind to 80.\n    val (host, port) = (\"localhost\", 80)\n    val bindingFuture: Future[ServerBinding] =\n      Http().newServerAt(host, port).bindFlow(handler)\n\n    bindingFuture.failed.foreach { ex =>\n      system.log.error(ex, \"Failed to bind to {}:{}!\", host, port)\n    }\n  }\n} Java copysource import org.apache.pekko.actor.ActorSystem;\nimport org.apache.pekko.http.javadsl.Http;\nimport org.apache.pekko.http.javadsl.ServerBinding;\nimport org.apache.pekko.http.javadsl.server.Route;\n\nimport java.io.IOException;\nimport java.util.concurrent.CompletionStage;\n\npublic class HighLevelServerBindFailureExample {\n  public static void main(String[] args) throws IOException {\n    // boot up server using the route as defined below\n    final ActorSystem system = ActorSystem.create();\n\n    final HighLevelServerExample app = new HighLevelServerExample();\n    final Route route = app.createRoute();\n\n    final CompletionStage<ServerBinding> binding =\n        Http.get(system).newServerAt(\"127.0.0.1\", 8080).bind(route);\n\n    binding.exceptionally(failure -> {\n      System.err.println(\"Something very bad happened! \" + failure.getMessage());\n      system.terminate();\n      return null;\n    });\n\n    system.terminate();\n  }\n}\nNote For a more low-level overview of the kinds of failures that can happen and also more fine-grained control over them refer to the Handling HTTP Server failures in the Low-Level API documentation.","title":"Bind failures"},{"location":"/routing-dsl/index.html#failures-and-exceptions-inside-the-routing-dsl","text":"Exception handling within the Routing DSL is done by providing ExceptionHandlerExceptionHandler s which are documented in-depth in the Exception Handling section of the documentation. You can use them to transform exceptions into HttpResponseHttpResponse s with appropriate error codes and human-readable failure descriptions.","title":"Failures and exceptions inside the Routing DSL"},{"location":"/routing-dsl/index.html#file-uploads","text":"For high level directives to handle uploads see the FileUploadDirectives.\nHandling a simple file upload from for example a browser form with a file input can be done by accepting a Multipart.FormData entity, note that the body parts are Source rather than all available right away, and so is the individual body part payload so you will need to consume those streams both for the file and for the form fields.\nHere is a simple example which just dumps the uploaded file into a temporary file on disk, collects some form fields and saves an entry to a fictive database:\nScala copysourceval uploadVideo =\n  path(\"video\") {\n    entity(as[Multipart.FormData]) { formData =>\n      // collect all parts of the multipart as it arrives into a map\n      val allPartsF: Future[Map[String, Any]] = formData.parts.mapAsync[(String, Any)](1) {\n\n        case b: BodyPart if b.name == \"file\" =>\n          // stream into a file as the chunks of it arrives and return a future\n          // file to where it got stored\n          val file = File.createTempFile(\"upload\", \"tmp\")\n          b.entity.dataBytes.runWith(FileIO.toPath(file.toPath)).map(_ =>\n            b.name -> file)\n\n        case b: BodyPart =>\n          // collect form field values\n          b.toStrict(2.seconds).map(strict =>\n            b.name -> strict.entity.data.utf8String)\n\n      }.runFold(Map.empty[String, Any])((map, tuple) => map + tuple)\n\n      val done = allPartsF.map { allParts =>\n        // You would have some better validation/unmarshalling here\n        db.create(Video(\n          file = allParts(\"file\").asInstanceOf[File],\n          title = allParts(\"title\").asInstanceOf[String],\n          author = allParts(\"author\").asInstanceOf[String]))\n      }\n\n      // when processing have finished create a response for the user\n      onSuccess(allPartsF) { allParts =>\n        complete {\n          \"ok!\"\n        }\n      }\n    }\n  } Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.entity;\nimport static org.apache.pekko.http.javadsl.server.Directives.onSuccess;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\n\n  path(\"video\", () ->\n  entity(Unmarshaller.entityToMultipartFormData(), formData -> {\n    // collect all parts of the multipart as it arrives into a map\n    final CompletionStage<Map<String, Object>> allParts =\n      formData.getParts().mapAsync(1, bodyPart -> {\n        if (\"file\".equals(bodyPart.getName())) {\n          // stream into a file as the chunks of it arrives and return a CompletionStage\n          // file to where it got stored\n          final File file = File.createTempFile(\"upload\", \"tmp\");\n          return bodyPart.getEntity().getDataBytes()\n            .runWith(FileIO.toPath(file.toPath()), materializer)\n            .thenApply(ignore ->\n              new Pair<String, Object>(bodyPart.getName(), file)\n            );\n        } else {\n          // collect form field values\n          return bodyPart.toStrict(2 * 1000, materializer)\n            .thenApply(strict ->\n              new Pair<String, Object>(bodyPart.getName(),\n                strict.getEntity().getData().utf8String())\n            );\n        }\n      }).runFold(new HashMap<String, Object>(), (acc, pair) -> {\n        acc.put(pair.first(), pair.second());\n        return acc;\n      }, materializer);\n\n    // simulate a DB call\n    final CompletionStage<Void> done = allParts.thenCompose(map ->\n      // You would have some better validation/unmarshalling here\n      DB.create((File) map.get(\"file\"),\n        (String) map.get(\"title\"),\n        (String) map.get(\"author\")\n      ));\n\n    // when processing have finished create a response for the user\n    return onSuccess(allParts, x -> complete(\"ok!\"));\n  })\n);\nYou can transform the uploaded files as they arrive rather than storing them in a temporary file as in the previous example. In this example we accept any number of .csv files, parse those into lines and split each line before we send it to an actor for further processing:\nScala copysourceval splitLines = Framing.delimiter(ByteString(\"\\n\"), 256)\n\nval csvUploads =\n  path(\"metadata\" / LongNumber) { id =>\n    entity(as[Multipart.FormData]) { formData =>\n      val done: Future[Done] = formData.parts.mapAsync(1) {\n        case b: BodyPart if b.filename.exists(_.endsWith(\".csv\")) =>\n          b.entity.dataBytes\n            .via(splitLines)\n            .map(_.utf8String.split(\",\").toVector)\n            .runForeach(csv =>\n              metadataActor ! MetadataActor.Entry(id, csv))\n        case _ => Future.successful(Done)\n      }.runWith(Sink.ignore)\n\n      // when processing have finished create a response for the user\n      onSuccess(done) { _ =>\n        complete {\n          \"ok!\"\n        }\n      }\n    }\n  } Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.entity;\nimport static org.apache.pekko.http.javadsl.server.Directives.onComplete;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\n\nRoute csvUploads() {\n  final Flow<ByteString, ByteString, NotUsed> splitLines =\n    Framing.delimiter(ByteString.fromString(\"\\n\"), 256);\n\n  return path(segment(\"metadata\").slash(longSegment()), id ->\n    entity(Unmarshaller.entityToMultipartFormData(), formData -> {\n\n      final CompletionStage<Done> done = formData.getParts().mapAsync(1, bodyPart ->\n        bodyPart.getFilename().filter(name -> name.endsWith(\".csv\")).map(ignored ->\n          bodyPart.getEntity().getDataBytes()\n            .via(splitLines)\n            .map(bs -> bs.utf8String().split(\",\"))\n            .runForeach(csv ->\n                metadataActor.tell(new Entry(id, csv), ActorRef.noSender()),\n              materializer)\n        ).orElseGet(() ->\n          // in case the uploaded file is not a CSV\n          CompletableFuture.completedFuture(Done.getInstance()))\n      ).runWith(Sink.ignore(), materializer);\n\n      // when processing have finished create a response for the user\n      return onComplete(() -> done, ignored -> complete(\"ok!\"));\n    })\n  );\n}","title":"File uploads"},{"location":"/routing-dsl/index.html#configuring-server-side-https","text":"For detailed documentation about configuring and using HTTPS on the server-side refer to Server-Side HTTPS Support.","title":"Configuring Server-side HTTPS"},{"location":"/routing-dsl/overview.html","text":"","title":"Routing DSL Overview"},{"location":"/routing-dsl/overview.html#routing-dsl-overview","text":"The Apache Pekko HTTP Core Server API provides a FlowFlow- or Function-level interface that allows an application to respond to incoming HTTP requests by mapping requests to responses (excerpt from Low-level server side example):\nScala copysource/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * license agreements; and to You under the Apache License, version 2.0:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * This file is part of the Apache Pekko project, derived from Akka.\n */\n\n/*\n * Copyright (C) 2020-2022 Lightbend Inc. <https://www.lightbend.com>\n */\n\npackage docs.http.scaladsl\n\nimport org.apache.pekko\nimport pekko.actor.typed.ActorSystem\nimport pekko.actor.typed.scaladsl.Behaviors\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.model.HttpMethods._\nimport pekko.http.scaladsl.model._\n\nimport scala.concurrent.ExecutionContext\nimport scala.io.StdIn\n\nobject HttpServerLowLevel {\n\n  def main(args: Array[String]): Unit = {\n    implicit val system = ActorSystem(Behaviors.empty, \"lowlevel\")\n    // needed for the future map/flatmap in the end\n    implicit val executionContext: ExecutionContext = system.executionContext\n\n    val requestHandler: HttpRequest => HttpResponse = {\n      case HttpRequest(GET, Uri.Path(\"/\"), _, _, _) =>\n        HttpResponse(entity = HttpEntity(\n          ContentTypes.`text/html(UTF-8)`,\n          \"<html><body>Hello world!</body></html>\"))\n\n      case HttpRequest(GET, Uri.Path(\"/ping\"), _, _, _) =>\n        HttpResponse(entity = \"PONG!\")\n\n      case HttpRequest(GET, Uri.Path(\"/crash\"), _, _, _) =>\n        sys.error(\"BOOM!\")\n\n      case r: HttpRequest =>\n        r.discardEntityBytes() // important to drain incoming HTTP Entity stream\n        HttpResponse(404, entity = \"Unknown resource!\")\n    }\n\n    val bindingFuture = Http().newServerAt(\"localhost\", 8080).bindSync(requestHandler)\n    println(s\"Server online at http://localhost:8080/\\nPress RETURN to stop...\")\n    StdIn.readLine() // let it run until user presses return\n    bindingFuture\n      .flatMap(_.unbind()) // trigger unbinding from the port\n      .onComplete(_ => system.terminate()) // and shutdown when done\n\n  }\n} Java copysourcefinal Function<HttpRequest, HttpResponse> requestHandler =\n  new Function<HttpRequest, HttpResponse>() {\n    private final HttpResponse NOT_FOUND =\n      HttpResponse.create()\n        .withStatus(404)\n        .withEntity(\"Unknown resource!\");\n\n\n    @Override\n    public HttpResponse apply(HttpRequest request) throws Exception {\n      Uri uri = request.getUri();\n      if (request.method() == HttpMethods.GET) {\n        if (uri.path().equals(\"/\")) {\n          return\n            HttpResponse.create()\n              .withEntity(ContentTypes.TEXT_HTML_UTF8,\n                \"<html><body>Hello world!</body></html>\");\n        } else if (uri.path().equals(\"/hello\")) {\n          String name = uri.query().get(\"name\").orElse(\"Mister X\");\n\n          return\n            HttpResponse.create()\n              .withEntity(\"Hello \" + name + \"!\");\n        } else if (uri.path().equals(\"/ping\")) {\n          return HttpResponse.create().withEntity(\"PONG!\");\n        } else {\n          return NOT_FOUND;\n        }\n      } else {\n        return NOT_FOUND;\n      }\n    }\n  };\nWhile it’d be perfectly possible to define a complete REST API service purely by pattern-matching againstinspecting the incoming HttpRequestHttpRequest (maybe with the help of a few extractors in the way of Unfiltered) this approach becomes somewhat unwieldy for larger services due to the amount of syntax “ceremony” required. Also, it doesn’t help in keeping your service definition as DRY as you might like.\nAs an alternative Apache Pekko HTTP provides a flexible DSL for expressing your service behavior as a structure of composable elements (called Directives) in a concise and readable way. Directives are assembled into a so called route structure which, at its top-level, can be used to create a handler FlowFlow or async handler function that can be directly supplied to a bind call. The conversion from Route to flow can either be invoked explicitly using Route.toFlow or, otherwise, the conversion is also provided implicitly by RouteResult.routeToFlow [1].\nHere’s the complete example rewritten using the composable high-level API:\nScala copysource/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * license agreements; and to You under the Apache License, version 2.0:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * This file is part of the Apache Pekko project, derived from Akka.\n */\n\n/*\n * Copyright (C) 2020-2022 Lightbend Inc. <https://www.lightbend.com>\n */\n\npackage docs.http.scaladsl\n\nimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.model.{ ContentTypes, HttpEntity }\nimport pekko.http.scaladsl.server.Directives._\nimport scala.io.StdIn\n\nobject HttpServerHighLevel {\n  def main(args: Array[String]): Unit = {\n    implicit val system = ActorSystem()\n    // needed for the future flatMap/onComplete in the end\n    implicit val executionContext = system.dispatcher\n\n    val route =\n      get {\n        concat(\n          pathSingleSlash {\n            complete(HttpEntity(ContentTypes.`text/html(UTF-8)`, \"<html><body>Hello world!</body></html>\"))\n          },\n          path(\"ping\") {\n            complete(\"PONG!\")\n          },\n          path(\"crash\") {\n            sys.error(\"BOOM!\")\n          })\n      }\n\n    // `route` will be implicitly converted to an async handler\n    val bindingFuture = Http().newServerAt(\"localhost\", 8080).bind(route)\n    println(s\"Server online at http://localhost:8080/\\nPress RETURN to stop...\")\n    StdIn.readLine() // let it run until user presses return\n    bindingFuture\n      .flatMap(_.unbind()) // trigger unbinding from the port\n      .onComplete(_ => system.terminate()) // and shutdown when done\n  }\n} Java copysource import org.apache.pekko.actor.ActorSystem;\nimport org.apache.pekko.http.javadsl.Http;\nimport org.apache.pekko.http.javadsl.ServerBinding;\nimport org.apache.pekko.http.javadsl.model.ContentTypes;\nimport org.apache.pekko.http.javadsl.model.HttpEntities;\nimport org.apache.pekko.http.javadsl.server.AllDirectives;\nimport org.apache.pekko.http.javadsl.server.Route;\n\nimport java.io.IOException;\nimport java.util.concurrent.CompletionStage;\n\npublic class HighLevelServerExample extends AllDirectives {\n  public static void main(String[] args) throws IOException {\n    // boot up server using the route as defined below\n    ActorSystem system = ActorSystem.create();\n\n    final HighLevelServerExample app = new HighLevelServerExample();\n\n    final Http http = Http.get(system);\n\n    final CompletionStage<ServerBinding> binding = http.newServerAt(\"localhost\", 8080).bind(app.createRoute());\n\n    System.out.println(\"Type RETURN to exit\");\n    System.in.read();\n\n    binding\n      .thenCompose(ServerBinding::unbind)\n      .thenAccept(unbound -> system.terminate());\n  }\n\n  public Route createRoute() {\n    // This handler generates responses to `/hello?name=XXX` requests\n    Route helloRoute =\n      parameterOptional(\"name\", optName -> {\n        String name = optName.orElse(\"Mister X\");\n        return complete(\"Hello \" + name + \"!\");\n      });\n\n    return\n      // here the complete behavior for this server is defined\n\n      // only handle GET requests\n      get(() -> concat(\n        // matches the empty path\n        pathSingleSlash(() ->\n          // return a constant string with a certain content type\n          complete(HttpEntities.create(ContentTypes.TEXT_HTML_UTF8, \"<html><body>Hello world!</body></html>\"))\n        ),\n        path(\"ping\", () ->\n          // return a simple `text/plain` response\n          complete(\"PONG!\")\n        ),\n        path(\"hello\", () ->\n          // uses the route defined above\n          helloRoute\n        )\n      ));\n  }\n}\nThe core of the Routing DSL becomes available with a single import:\nScala import org.apache.pekko.http.scaladsl.server.Directives._\n Java import static org.apache.pekko.http.javadsl.server.Directives.*;\nOr by extending the org.apache.pekko.http.javadsl.server.AllDirectives class which brings together all directives into a single class for easier access: extends AllDirectives\n Of course it is possible to directly import only the directives you need (i.e. WebSocketDirectivesWebSocketDirectives etc).\nThis example also relies on the pre-defined support for Scala XML with: import org.apache.pekko.http.scaladsl.marshallers.xml.ScalaXmlSupport._\nThe very short example shown here is certainly not the best for illustrating the savings in “ceremony” and improvements in conciseness and readability that the Routing DSL promises. The Long Example might do a better job in this regard.\nFor learning how to work with the Routing DSL you should first understand the concept of Routes.\n[1] To be picked up automatically, the implicit conversion needs to be provided in the companion object of the source type. However, as RouteRoute is just a type alias for RequestContext => Future[RouteResult], there’s no companion object for RouteRoute. Fortunately, the implicit scope for finding an implicit conversion also includes all types that are “associated with any part” of the source type which in this case means that the implicit conversion will also be picked up from RouteResult.routeToFlow automatically.","title":"Routing DSL Overview"},{"location":"/routing-dsl/play-comparison.html","text":"","title":"Compared with Play routes"},{"location":"/routing-dsl/play-comparison.html#compared-with-play-routes","text":"If you have been using Play’s routes file syntaxPlay’s routes file syntax earlier, this page may help you to use the Apache Pekko HTTP routing DSL.","title":"Compared with Play routes"},{"location":"/routing-dsl/play-comparison.html#conceptual-differences","text":"The most apparent difference is Play’s use of special purpose syntax implemented as an external DSL, whereas Apache Pekko HTTP routes are described in Scala source codeJava source code with regular methods and values (as “embedded DSL”). Both are crafted to make the reader “grasp the code’s intention”.\nThe Apache Pekko HTTP DSL uses Directives to describe how incoming requests translate to functionality in the server. Play allows splitting the routes definitions in multiple routes files. The Apache Pekko HTTP DSL is very flexible and allows for composition so that different concerns can be properly split and organized as other source code would be.\nBoth Play and Apache Pekko HTTP choose the first matching route within the routes file/routes definition. In Play routes are listed with one route per line, in Apache Pekko HTTP multiple routes must be concatenated with the concat method.","title":"Conceptual differences"},{"location":"/routing-dsl/play-comparison.html#side-by-side","text":"These examples are a non-comprehensive list of how Play routes could be written in Apache Pekko HTTP. They try to mimic the structure which Play uses, to aid understanding, even though it might not be the most Apache Pekko HTTP-idiomatic notation.","title":"Side-by-side"},{"location":"/routing-dsl/play-comparison.html#static-path","text":"For example, to exactly match incoming GET /clients/all requests, you can define this route in Play.\nGET   /clients/all          controllers.Clients.list()\nIn Apache Pekko HTTP every path segment is specified as a separate String concatenated with the / methodconcatenated by the slash method on segment.\nScala copysource(get & path(\"clients\" / \"all\")) {\n  complete(Clients.list())\n} Scala test copysourceGet(\"/clients/all\") ~> clientsAll ~> check {\n  responseAs[String] shouldEqual \"clientA,clientB,clientC\"\n} Java copysourceget(() ->\n        path(segment(\"clients\").slash(\"all\"), () ->\n                complete(Clients.list())\n        )\n); Java test copysourceTestRoute route = testRoute(new Routes().clientsAll());\nroute.run(HttpRequest.GET(\"/clients/all\"))\n        .assertStatusCode(StatusCodes.OK)\n        .assertEntity(\"clientA,clientB,clientC\");","title":"Static path"},{"location":"/routing-dsl/play-comparison.html#dynamic-parts","text":"If you want to define a route that retrieves a client by ID, you’ll need to add a dynamic part.\nGET   /clients/:id          controllers.Clients.show(id: Long)\nApache Pekko HTTP uses path matchers which match certain data types and pass their data on.\nScala copysource(get & path(\"client\" / LongNumber)) { id =>\n  complete(Clients.get(id))\n} Scala test copysourceGet(\"/client/321433\") ~> clientById ~> check {\n  responseAs[String] shouldEqual \"clientB\"\n} Java copysourceget(() ->\n        path(segment(\"client\").slash(longSegment()), id ->\n                complete(Clients.get(id))\n        )\n); Java test copysourceTestRoute route = testRoute(new Routes().clientById());\nroute.run(HttpRequest.GET(\"/client/321433\"))\n        .assertStatusCode(StatusCodes.OK)\n        .assertEntity(\"clientB\");","title":"Dynamic parts"},{"location":"/routing-dsl/play-comparison.html#dynamic-parts-spanning-several-","text":"You may want to capture a dynamic part of more than one URI path segment, separated by forward slashes.\nGET   /files/*name          controllers.Application.download(name)\nThe Apache Pekko HTTP directive Remainingremaining() makes a list of the segments to be passed. (See Path Matchers for other ways to extract the path.)\nScala copysource(get & path(\"files\" / Remaining)) { name =>\n  complete(download(name))\n} Scala test copysourceGet(\"/files/images/logo.png\") ~> files ~> check {\n  responseAs[String] shouldEqual \"images/logo.png: file contents\"\n} Java copysourceget(() ->\n        path(segment(\"files\").slash(remaining()), names ->\n                complete(download(names))\n        )\n); Java test copysourceTestRoute route = testRoute(new Routes().files());\nroute.run(HttpRequest.GET(\"/files/images/logo.png\"))\n        .assertStatusCode(StatusCodes.OK)\n        .assertEntity(\"images/logo.png: file contents\");","title":"Dynamic parts spanning several /"},{"location":"/routing-dsl/play-comparison.html#access-parameters","text":"The Parameter directives give access to parameters passed on the URL.","title":"Access parameters"},{"location":"/routing-dsl/play-comparison.html#mandatory-parameters","text":"By default parameters are expected to be of type String. To make Apache Pekko HTTP convert a parameter to a different type, specify an unmarshaller.\n# Extract the page parameter from the query string.\n# i.e. http://myserver.com/?page=index\nGET   /                     controllers.Application.show(page)\nScala copysource(get & path(\"\") & parameter(\"page\")) { page =>\n  complete(getPage(page))\n} Scala test copysourceGet(\"/?page=example.txt\") ~> pageParameter ~> check {\n  responseAs[String] shouldEqual \"The requested [example.txt].\"\n} Java copysourceget(() ->\n        parameter(\"page\", page ->\n                complete(getPage(page))\n        )\n); Java test copysourceTestRoute route = testRoute(new Routes().pageParameter());\nroute.run(HttpRequest.GET(\"?page=example.txt\"))\n        .assertStatusCode(StatusCodes.OK)\n        .assertEntity(\"The requested [example.txt].\");\nroute.run(HttpRequest.GET(\"/\"))\n        .assertStatusCode(StatusCodes.NOT_FOUND);","title":"Mandatory parameters"},{"location":"/routing-dsl/play-comparison.html#optional-parameters","text":"# The version parameter is optional. E.g. /api/list-all?version=3.0\nGET   /api/list-all         controllers.Api.list(version: Option[String])\nThe parameter name may be decorated with .optional to mark it as optional (for other variants see other parameter extractors).\nThe parameterOptional directive passes the parameter as Optional<String>. The directive parameterRequiredValue makes the route match only if the parameter contains the specified value. See parameter extractors.\nScala copysource(get & path(\"api\" / \"list-all\") & parameter(\"version\".optional)) { version =>\n  complete(listAll(version))\n} Scala test copysourceGet(\"/api/list-all?version=3.0\") ~> optionalPageParameter ~> check {\n  responseAs[String] shouldEqual \"aa,bb,cc\"\n}\nGet(\"/api/list-all\") ~> optionalPageParameter ~> check {\n  responseAs[String] shouldEqual \"ff\"\n} Java copysourceget(() ->\n        path(segment(\"api\").slash(\"list\"), () ->\n                parameterOptional(\"version\", version ->\n                        complete(apiList(version)))\n        )\n); Java test copysourceTestRoute route = testRoute(new Routes().apiListWithVersion());\nroute.run(HttpRequest.GET(\"/api/list?version=3.0\"))\n        .assertStatusCode(StatusCodes.OK)\n        .assertEntity(\"aa,bb,cc\");\nroute.run(HttpRequest.GET(\"/api/list\"))\n        .assertStatusCode(StatusCodes.OK)\n        .assertEntity(\"ff\");","title":"Optional parameters"},{"location":"/routing-dsl/play-comparison.html#list-parameters","text":"This shows how a repeated URL parameter is captured.\n# The item parameter is a list.\n# E.g. /api/list-items?item=red&item=new&item=slippers\nGET   /api/list-items      controllers.Api.listItems(item: List[String])\nDecorating the parameter name with a .repeated makes Apache Pekko HTTP pass all values of that parameter as an Iterable[String]].\nThe parameterList directive may take a parameter name to specify a single parameter name to pass on as a List<String>.]\nScala copysource(get & path(\"api\" / \"list-items\") & parameters(\"item\".repeated)) { items =>\n  complete(listItems(items))\n} Scala test copysourceGet(\"/api/list-items?item=red&item=new&item=slippers\") ~> itemParameterList ~> check {\n  responseAs[String] shouldEqual \"slippers,new,red\"\n} Java copysourceget(() ->\n        path(segment(\"api\").slash(\"list-items\"), () ->\n                parameterList(\"item\", items ->\n                        complete(apiItems(items)))\n        )\n); Java test copysourceTestRoute route = testRoute(new Routes().apiListItems());\nroute.run(HttpRequest.GET(\"/api/list-items?item=red&item=new&item=slippers\"))\n        .assertStatusCode(StatusCodes.OK)\n        .assertEntity(\"slippers,new,red\"); // order is not kept","title":"List parameters"},{"location":"/routing-dsl/routes.html","text":"","title":"Routes"},{"location":"/routing-dsl/routes.html#routes","text":"The “Route” is the central concept of Apache Pekko HTTP’s Routing DSL. All the structures you build with the DSL, no matter whether they consists of a single line or span several hundred lines, are typefunction turning a RequestContextRequestContext into a Future[RouteResult]CompletionStage<RouteResult>.\ntype Route = RequestContext => Future[RouteResult]\n It’s a simple alias for a function turning a RequestContextRequestContext into a Future[RouteResult].\nA RouteRoute itself is a function that operates on a RequestContextRequestContext and returns a RouteResultRouteResult. The RequestContextRequestContext is a data structure that contains the current request and auxiliary data like the so far unmatched path of the request URI that gets passed through the route structure. It also contains the current ExecutionContext and MaterializerMaterializer, so that these don’t have to be passed around manually.\nGenerally when a route receives a request (or rather a RequestContextRequestContext for it) it can do one of these things:\nComplete the request by returning the value of requestContext.complete(...) Reject the request by returning the value of requestContext.reject(...) (see Rejections) Fail the request by returning the value of requestContext.fail(...) or by just throwing an exception (see Exception Handling) Do any kind of asynchronous processing and instantly return a Future[RouteResult]CompletionStage<RouteResult> to be eventually completed later\nThe first case is pretty clear, by calling complete a given response is sent to the client as reaction to the request. In the second case “reject” means that the route does not want to handle the request. You’ll see further down in the section about route composition what this is good for.\nA RouteRoute can be “sealed” using Route.seal, which relies on the in-scope RejectionHandler and ExceptionHandlerExceptionHandler instances to convert rejections and exceptions into appropriate HTTP responses for the client. Sealing a Route is described more in detail later.\nUsing Route.toFlow or Route.toFunction a RouteRoute can be lifted into a handler FlowFlow or async handler function to be used with a bindAndHandleXXX call from the Core Server API.\nNote: There is also an implicit conversion from RouteRoute to Flow<HttpRequest, HttpResponse, Unit>Flow[HttpRequest, HttpResponse, Unit] defined in the RouteResultRouteResult companion, which relies on Route.toFlow.","title":"Routes"},{"location":"/routing-dsl/routes.html#requestcontext","text":"The request context wraps an HttpRequestHttpRequest instance to enrich it with additional information that are typically required by the routing logic, like an ExecutionContext, MaterializerMaterializer, LoggingAdapterLoggingAdapter and the configured RoutingSettingsRoutingSettings. It also contains the unmatchedPath, a value that describes how much of the request URI has not yet been matched by a Path Directive.\nThe RequestContextRequestContext itself is immutable but contains several helper methods which allow for convenient creation of modified copies.","title":"RequestContext"},{"location":"/routing-dsl/routes.html#routeresult","text":"RouteResultRouteResult is a simple algebraic data type (ADT) that models the possible non-error results of a RouteRoute. It is defined as such:\nsealed trait RouteResult\n\nobject RouteResult {\n  final case class Complete(response: HttpResponse) extends RouteResult\n  final case class Rejected(rejections: immutable.Seq[Rejection]) extends RouteResult\n}\nUsually you don’t create any RouteResultRouteResult instances yourself, but rather rely on the pre-defined RouteDirectives (like complete, reject or redirect) or the respective methods on the RequestContext instead.","title":"RouteResult"},{"location":"/routing-dsl/routes.html#composing-routes","text":"There are three basic operations we need for building more complex routes from simpler ones:\nRoute transformation, which delegates processing to another, “inner” route but in the process changes some properties of either the incoming request, the outgoing response or both Route filtering, which only lets requests satisfying a given filter condition pass and rejects all others Route chaining, which tries a second route if a given first one was rejected\nThe first two points are provided by so-called Directives of which a large number is already predefined by Apache Pekko HTTP and is extensible with user code.\nThe last point is achieved with the concat method.\nDirectives deliver most of Apache Pekko HTTP’s power and flexibility.","title":"Composing Routes"},{"location":"/routing-dsl/routes.html#the-routing-tree","text":"Essentially, when you combine directives and custom routes via the concat method, you build a routing structure that forms a tree. When a request comes in it is injected into this tree at the root and flows down through all the branches in a depth-first manner until either some node completes it or it is fully rejected.\nConsider this schematic example:\nval route =\n  a {\n    concat(\n      b {\n        concat(\n          c {\n            ... // route 1\n          },\n          d {\n            ... // route 2\n          },\n          ... // route 3\n        )\n      },\n      e {\n        ... // route 4\n      }\n    )\n  }\nimport static org.apache.http.javadsl.server.Directives.*;\n\nRoute route =\n  directiveA(concat(() ->\n    directiveB(concat(() ->\n      directiveC(\n        ... // route 1\n      ),\n      directiveD(\n        ... // route 2\n      ),\n      ... // route 3\n    )),\n    directiveE(\n      ... // route 4\n    )\n  ));\nHere five directives form a routing tree.\nRoute 1 will only be reached if directives a, b and c all let the request pass through. Route 2 will run if a and b pass, c rejects and d passes. Route 3 will run if a and b pass, but c and d reject.\nRoute 3 can therefore be seen as a “catch-all” route that only kicks in, if routes chained into preceding positions reject. This mechanism can make complex filtering logic quite easy to implement: simply put the most specific cases up front and the most general cases in the back.","title":"The Routing Tree"},{"location":"/routing-dsl/routes.html#sealing-a-route","text":"A sealed route has these properties:\nThe result of the route will always be a complete response, i.e. the result of the future is a Success(RouteResult.Complete(response)), never a failed future and never a rejected route. Consequently, no route alternatives will be tried that were combined with this route.\nAs described in Rejections and Exception Handling, there are generally two ways to handle rejections and exceptions.\nBring rejection/exception handlers into implicit scope at the top-levelseal() method of the Route Supply handlers as arguments to handleRejections and handleExceptions directives\nIn the first case your handlers will be “sealed”, (which means that it will receive the default handler as a fallback for all cases your handler doesn’t handle itself) and used for all rejections/exceptions that are not handled within the route structure itself.","title":"Sealing a Route"},{"location":"/routing-dsl/routes.html#route-seal-method-to-modify-httpresponse","text":"In application code, unlike test code, you don’t need to use the Route.seal() method to seal a route. As long as you bring implicit rejection and/or exception handlers to the top-level scope, your route is sealed.\nHowever, you can use Route.seal() to perform modification on HttpResponseHttpResponse from the route. For example, if you want to add a special header, but still use the default rejection handler, then you can do the following. In the below case, the special header is added to rejected responses which did not match the route, as well as successful responses which matched the route.\nScala copysourceval route = respondWithHeader(RawHeader(\"special-header\", \"you always have this even in 404\")) {\n  Route.seal(\n    get {\n      pathSingleSlash {\n        complete {\n          \"Captain on the bridge!\"\n        }\n      }\n    })\n} Java copysourcepublic class RouteSealExample extends AllDirectives {\n\n  public static void main(String [] args) {\n    RouteSealExample app = new RouteSealExample();\n    app.runServer();\n  }\n\n  public void runServer(){\n    ActorSystem system = ActorSystem.create();\n\n    Route sealedRoute = get(\n      () -> pathSingleSlash( () ->\n        complete(\"Captain on the bridge!\")\n      )\n    ).seal();\n\n    Route route = respondWithHeader(\n      RawHeader.create(\"special-header\", \"you always have this even in 404\"),\n      () -> sealedRoute\n    );\n\n    final Http http = Http.get(system);\n    final CompletionStage<ServerBinding> binding = http.newServerAt(\"localhost\", 8080).bind(route);\n  }\n}","title":"Route.seal() method to modify HttpResponse"},{"location":"/routing-dsl/routes.html#converting-routes-between-java-and-scala-dsls","text":"In some cases when building reusable libraries that expose routes, it may be useful to be able to convert routes between their Java and Scala DSL representations. You can do so using the asScala method on a Java DSL route, or by using an RouteAdapter to wrap an Scala DSL route.\nConverting Scala DSL routes to Java DSL:\nScala copysourceimport org.apache.pekko\n\nval scalaRoute: pekko.http.scaladsl.server.Route =\n  pekko.http.scaladsl.server.Directives.get {\n    pekko.http.scaladsl.server.Directives.complete(\"OK\")\n  }\n\nval javaRoute: pekko.http.javadsl.server.Route =\n  pekko.http.javadsl.server.directives.RouteAdapter.asJava(scalaRoute) Java copysourcescala.Function1<\n    org.apache.pekko.http.scaladsl.server.RequestContext,\n    scala.concurrent.Future<org.apache.pekko.http.scaladsl.server.RouteResult>> scalaRoute = someRoute();\n\norg.apache.pekko.http.javadsl.server.Route javaRoute =\n    RouteAdapter.asJava(scalaRoute);\nConverting Java DSL routes to Scala DSL:\nScala copysourceimport org.apache.pekko\n\nval javaRoute =\n  pekko.http.javadsl.server.Directives.get(new Supplier[pekko.http.javadsl.server.Route] {\n    override def get(): Route = pekko.http.javadsl.server.Directives.complete(\"ok\")\n  })\n\n// Remember that Route in Scala is just a type alias:\n//   type Route = RequestContext => Future[RouteResult]\nval scalaRoute: pekko.http.scaladsl.server.Route = javaRoute.asScala Java copysourceRoute javaRoute = Directives.get(() ->\n    Directives.complete(\"okey\")\n);\n\nscala.Function1<RequestContext, Future<RouteResult>> scalaRoute =\n    javaRoute.asScala();","title":"Converting routes between Java and Scala DSLs"},{"location":"/routing-dsl/directives/index.html","text":"","title":"Directives"},{"location":"/routing-dsl/directives/index.html#directives","text":"A “Directive” is a small building block used for creating arbitrarily complex route structures. Apache Pekko HTTP already pre-defines a large number of directives and you can easily construct your own:\nBasics Structure What Directives do Composing Directives Type Safety of Directives Automatic Tuple extraction (flattening) Predefined Directives (alphabetically) Predefined Directives (by trait) Custom Directives","title":"Directives"},{"location":"/routing-dsl/directives/index.html#basics","text":"Directives create Routes. To understand how directives work it is helpful to contrast them with the “primitive” way of creating routes.\nRoutes effectively are simply highly specialised functions that take a RequestContextRequestContext and eventually complete it, which could (and often should) happen asynchronously.\nThe complete directive simply completes the request with a response:\nSince RouteRoute is just a type alias for a function type RouteRoute instances can be written in any way in which function instances can be written, e.g. as a function literal: val route: Route = { ctx => ctx.complete(\"yeah\") }\n or shorter: val route: Route = _.complete(\"yeah\")\n With the complete directive this becomes even shorter:\nScala val route = complete(\"yeah\")\n Java Route route = complete(\"yeah\");\nThese three ways of writing this RouteRoute are fully equivalent, the created route will behave identically in all cases. Let’s look at a slightly more complicated example to highlight one important point in particular. Consider these two routes: val a: Route = {\n  println(\"MARK\")\n  ctx => ctx.complete(\"yeah\")\n}\n\nval b: Route = { ctx =>\n  println(\"MARK\")\n  ctx.complete(\"yeah\")\n}\n The difference between a and b is when the println statement is executed. In the case of a it is executed once, when the route is constructed, whereas in the case of b it is executed every time the route is run. Using the complete directive the same effects are achieved like this: val a = {\n  println(\"MARK\")\n  complete(\"yeah\")\n}\n\nval b = complete {\n  println(\"MARK\")\n  \"yeah\"\n}\n This works because the argument to the complete directive is evaluated by-name, i.e. it is re-evaluated every time the produced route is run. Let’s take things one step further: val route: Route = { ctx =>\n  if (ctx.request.method == HttpMethods.GET)\n    ctx.complete(\"Received GET\")\n  else\n    ctx.complete(\"Received something else\")\n}\n Using the get and complete directives we can write this route like this: val route =\n  concat(\n    get {\n      complete(\"Received GET\")\n    },\n    complete(\"Received something else\")\n  )\n Again, the produced routes will behave identically in all cases. Note that, if you wish, you can also mix the two styles of route creation: val route =\n  concat(\n    get { ctx =>\n      ctx.complete(\"Received GET\")\n    },\n    complete(\"Received something else\")\n  )\n Here, the inner route of the get directive is written as an explicit function literal. However, as you can see from these examples, building routes with directives rather than “manually” results in code that is a lot more concise and as such more readable and maintainable. In addition it provides for better composability (as you will see in the coming sections). So, when using Apache Pekko HTTP’s Routing DSL you should almost never have to fall back to creating routes via RouteRoute function literals that directly manipulate the RequestContext.\nWriting multiple routes that are tried as alternatives (in-order of definition), is as simple as using the concat(route1, route2), method: Route routes = concat(\n  pathSingleSlash(() ->\n    getFromResource(\"web/calculator.html\")\n  ),\n  path(\"hello\", () -> complete(\"World!))\n);\n You could also simply define a “catch all” completion by providing it as the last route to attempt to match. In the example below we use the get() (one of the MethodDirectives) to match all incoming GET requests for that route, and all other requests will be routed towards the other “catch all” route, that completes the route: Route route =\n  get(\n    () -> complete(\"Received GET\")\n  ).orElse(\n    () -> complete(\"Received something else\")\n  )\nIf no route matches a given request, a default 404 Not Found response will be returned as response.","title":"Basics"},{"location":"/routing-dsl/directives/index.html#structure","text":"The general anatomy of a directive is as follows:\nScala name(arguments) { extractions =>\n  ... // inner route\n}\n Java directiveName(arguments [, ...], (extractions [, ...]) -> {\n  ... // inner route\n})\nIt has a name, zero or more arguments and optionally an inner route (The RouteDirectives are special in that they are always used at the leaf-level and as such cannot have inner routes).\nAdditionally directives can “extract” a number of values and make them available to their inner routes as function arguments. When seen “from the outside” a directive with its inner route form an expression of type RouteRoute.","title":"Structure"},{"location":"/routing-dsl/directives/index.html#what-directives-do","text":"A directive can do one or more of the following:\nTransform the incoming RequestContextRequestContext before passing it on to its inner route (i.e. modify the request) Filter the RequestContextRequestContext according to some logic, i.e. only pass on certain requests and reject others Extract values from the RequestContextRequestContext and make them available to its inner route as “extractions” Chain some logic into the RouteResult future transformation chain (i.e. modify the response or rejection) Complete the request\nThis means a Directive completely wraps the functionality of its inner route and can apply arbitrarily complex transformations, both (or either) on the request and on the response side.","title":"What Directives do"},{"location":"/routing-dsl/directives/index.html#composing-directives","text":"As you have seen from the examples presented so far the “normal” way of composing directives is nesting. Let’s take a look at this concrete example:\nScala copysourceval route: Route =\n  path(\"order\" / IntNumber) { id =>\n    concat(\n      get {\n        complete {\n          \"Received GET request for order \" + id\n        }\n      },\n      put {\n        complete {\n          \"Received PUT request for order \" + id\n        }\n      })\n  } Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.get;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\nimport static org.apache.pekko.http.javadsl.server.Directives.put;\n\nimport static org.apache.pekko.http.javadsl.server.PathMatchers.integerSegment;\nimport static org.apache.pekko.http.javadsl.server.PathMatchers.segment;\n\nRoute orElse() {\n  return path(segment(\"order\").slash(integerSegment()), id ->\n    get(() -> complete(\"Received GET request for order \" + id))\n      .orElse(\n        put(() -> complete(\"Received PUT request for order \" + id)))\n  );\n}\nHere the get and put directives are chained together with the concat combinatorusing the orElse method to form a higher-level route that serves as the inner route of the path directive. Let’s rewrite it in the following way:\nScala copysourcedef innerRoute(id: Int): Route =\n  concat(\n    get {\n      complete {\n        \"Received GET request for order \" + id\n      }\n    },\n    put {\n      complete {\n        \"Received PUT request for order \" + id\n      }\n    })\n\nval route: Route = path(\"order\" / IntNumber) { id => innerRoute(id) } Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.extractMethod;\nimport static org.apache.pekko.http.javadsl.server.Directives.get;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\nimport static org.apache.pekko.http.javadsl.server.Directives.put;\nimport static org.apache.pekko.http.javadsl.server.PathMatchers.integerSegment;\nimport static org.apache.pekko.http.javadsl.server.PathMatchers.segment;\n\nRoute getOrPut(Supplier<Route> inner) {\n  return get(inner)\n    .orElse(put(inner));\n}\n\nRoute customDirective() {\n  return path(segment(\"order\").slash(integerSegment()), id ->\n    getOrPut(() ->\n      extractMethod(method -> complete(\"Received \" + method + \" for order \" + id)))\n  );\n}\nIn this previous example, we combined the get and put directives into one composed directive and extracted it to its own method, which could be reused anywhere else in our code. Instead of extracting the composed directives to its own method, we can also use the available anyOf combinator. The following code is equivalent to the previous one:\nWhat you can’t see from this snippet is that directives are not implemented as simple methods but rather as stand-alone objects of type Directive. This gives you more flexibility when composing directives. For example you can also use the | operator (or the or method) on directives. Here is yet another way to write the example:\nScala copysourceval route =\n  path(\"order\" / IntNumber) { id =>\n    (get | put) { ctx =>\n      ctx.complete(s\"Received ${ctx.request.method.name} request for order $id\")\n    }\n  } Java copysourceimport org.apache.pekko.http.javadsl.server.Directives;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.anyOf;\n\nimport static org.apache.pekko.http.javadsl.server.PathMatchers.integerSegment;\nimport static org.apache.pekko.http.javadsl.server.PathMatchers.segment;\n\nRoute usingAnyOf() {\n  return path(segment(\"order\").slash(integerSegment()), id ->\n    anyOf(Directives::get, Directives::put, () ->\n      extractMethod(method -> complete(\"Received \" + method + \" for order \" + id)))\n  );\n}\nOr better (without dropping down to writing an explicit RouteRoute function manually): copysourceval route =\n  path(\"order\" / IntNumber) { id =>\n    (get | put) {\n      extractMethod { m =>\n        complete(s\"Received ${m.name} request for order $id\")\n      }\n    }\n  } If you have a larger route structure where the (get | put) snippet appears several times you could also factor it out like this: copysourceval getOrPut = get | put\nval route =\n  path(\"order\" / IntNumber) { id =>\n    getOrPut {\n      extractMethod { m =>\n        complete(s\"Received ${m.name} request for order $id\")\n      }\n    }\n  } Note that, because getOrPut doesn’t take any parameters, it can be a val here. As an alternative to nesting you can also use the & operator (or the and method): copysourceval getOrPut = get | put\nval route =\n  (path(\"order\" / IntNumber) & getOrPut & extractMethod) { (id, m) =>\n    complete(s\"Received ${m.name} request for order $id\")\n  } Here you can see that, when directives producing extractions are combined with &, the resulting “super-directive” simply extracts the concatenation of its sub-extractions. And once again, you can factor things out if you want, thereby pushing the “factoring out” of directive configurations to its extreme: copysourceval orderGetOrPutWithMethod =\n  path(\"order\" / IntNumber) & (get | put) & extractMethod\nval route =\n  orderGetOrPutWithMethod { (id, m) =>\n    complete(s\"Received ${m.name} request for order $id\")\n  } This type of combining directives with the | and & operators as well as “saving” more complex directive configurations as a val works across the board, with all directives taking inner routes.\nThe previous example, tries to complete the route first with a GET or with a PUT if the first one was rejected. In case you are constantly nesting the same directives several times in you code, you could factor them out in their own method and use it everywhere: copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.extractClientIP;\nimport static org.apache.pekko.http.javadsl.server.Directives.get;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\n\nRoute getWithIP(Function<RemoteAddress, Route> inner) {\n  return get(() ->\n      extractClientIP(address -> inner.apply(address))\n  );\n}\n\nRoute complexRoute() {\n  return path(segment(\"order\").slash(integerSegment()), id ->\n    getWithIP(address ->\n      complete(\"Received request for order \" + id + \" from IP \" + address))\n  );\n} Here we simple created our own combined directive that accepts GET requests, then extracts the method and completes it with an inner route that takes this HTTP method as a parameter. Again, instead of extracting own combined directives to its own method, we can make use of the allOf combinator. The following code is equivalent to the previous one: copysourceRoute complexRouteUsingAllOf() {\n  return path(segment(\"order\").slash(integerSegment()), id ->\n    allOf(Directives::get, Directives::extractClientIP, address ->\n      complete(\"Received request for order \" + id + \" from IP \" + address))\n  );\n} In this previous example, the inner route function provided to allOf will be called when the request is a GET and with the extracted client IP obtained from the second directive. As you have already seen in the previous section, you can also use the concat method defined in RouteDirectivesRouteDirectives as an alternative to orElse chaining. Here you can see the first example again, rewritten using concat: copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.get;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\nimport static org.apache.pekko.http.javadsl.server.Directives.put;\nimport static org.apache.pekko.http.javadsl.server.PathMatchers.integerSegment;\nimport static org.apache.pekko.http.javadsl.server.PathMatchers.segment;\n\nRoute usingConcat() {\n  return path(segment(\"order\").slash(integerSegment()), id ->\n    concat(get(() -> complete(\"Received GET request for order \" + id)),\n          put(() -> complete(\"Received PUT request for order \" + id)))\n  );\n} The concat combinator comes handy when you want to avoid nesting. Here you can see an illustrative example: copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.get;\nimport static org.apache.pekko.http.javadsl.server.Directives.head;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\nimport static org.apache.pekko.http.javadsl.server.Directives.put;\nimport static org.apache.pekko.http.javadsl.server.PathMatchers.integerSegment;\nimport static org.apache.pekko.http.javadsl.server.PathMatchers.segment;\n\nRoute multipleRoutes() {\n  return path(segment(\"order\").slash(integerSegment()), id ->\n    concat(get(()  -> complete(\"Received GET request for order \" + id)),\n          put(()  -> complete(\"Received PUT request for order \" + id)),\n          head(() -> complete(\"Received HEAD request for order \" + id)))\n  );\n} Notice how you could adjust the indentation in these last two examples to have a more readable code.\nNote that going too far with “compressing” several directives into a single one probably doesn’t result in the most readable and therefore maintainable routing code. It might even be that the very first of this series of examples is in fact the most readable one.\nStill, the purpose of the exercise presented here is to show you how flexible directives can be and how you can use their power to define your web service behavior at the level of abstraction that is right for your application.\nComposing Directives with ~ Operator\nNote Gotcha: forgetting the ~ (tilde) character in between directives can result in perfectly valid Scala code that compiles but does not work as expected. What would be intended as a single expression would actually be multiple expressions, and only the final one would be used as the result of the parent directive. Because of this, the recommended way to compose routes is with the concat combinator.\nAlternatively we can combine directives using the ~ operator where we chain them together instead of passing each directive as a separate argument. Let’s take a look at the usage of this combinator: copysourcedef innerRoute(id: Int): Route =\n  get {\n    complete {\n      \"Received GET request for order \" + id\n    }\n  } ~\n  put {\n    complete {\n      \"Received PUT request for order \" + id\n    }\n  }\n\nval route: Route = path(\"order\" / IntNumber) { id => innerRoute(id) }","title":"Composing Directives"},{"location":"/routing-dsl/directives/index.html#type-safety-of-directives","text":"When you combine directives with the | and & operatorsanyOf and allOf methods the routing DSL makes sure that all extractions work as expected and logical constraints are enforced at compile-time.\nFor example you cannot |anyOf a directive producing an extraction with one that doesn’t:\nScala val route = path(\"order\" / IntNumber) | get // doesn't compile\n Java anyOf(this::get, this::extractClientIP, routeProvider) // doesn't compile\nAlso the number of extractions and their types have to match up:\nScala val route = path(\"order\" / IntNumber) | path(\"order\" / DoubleNumber)   // doesn't compile\nval route = path(\"order\" / IntNumber) | parameter(\"order\".as[Int])     // ok\n Java anyOf(this::extractClientIP, this::extractMethod, routeProvider) // doesn't compile\nanyOf(bindParameter(this::parameter, \"foo\"), bindParameter(this::parameter, \"bar\"), routeProvider) // ok\n In this previous example we make use of the bindParameter function located in http/org.apache.pekko.http.javadsl.common.PartialApplication. In order to be able to call anyOf, we need to convert our directive that takes 2 parameters to a function that takes only 1. In this particular case we want to use the parameter directive that takes a String and a function from String to RouteRoute, so to be able to use it in combination with anyOf, we need to bind the first parameter to foo and to bar in the second one. bindParameter(this::parameter, \"foo\") is equivalent to define your own function like this: Route parameterFoo(Function<String, Route> inner) {\n  return parameter(\"foo\", inner);\n}\nWhen you combine directives producing extractions with the & operatorallOf method all extractions will be properly gathered up:\nScala val order = path(\"order\" / IntNumber) & parameters(\"oem\", \"expired\".optional)\nval route =\n  order { (orderId, oem, expired) =>\n...\n  }\n Java allOf(this::extractScheme, this::extractMethod, (scheme, method) -> ...)\nDirectives offer a great way of constructing your web service logic from small building blocks in a plug and play fashion while maintaining DRYness and full type-safety. If the large range of Predefined Directives does not fully satisfy your needs you can also easily create Custom Directives.\nAutomatic Tuple extraction (flattening) Convenient Scala DSL syntax described in Basics, and Composing Directives are made possible by Tuple extraction internally. Let’s see how this works with examples. val futureOfInt: Future[Int] = Future.successful(1)\nval route =\n  path(\"success\") {\n    onSuccess(futureOfInt) { //: Directive[Tuple1[Int]]\n      i => complete(\"Future was completed.\")\n    }\n  }\n Looking at the above code, onSuccess(futureOfInt) returns a Directive1[Int] = Directive[Tuple1[Int]]. val futureOfTuple2: Future[Tuple2[Int,Int]] = Future.successful( (1,2) )\nval route =\n  path(\"success\") {\n    onSuccess(futureOfTuple2) { //: Directive[Tuple2[Int,Int]]\n      (i, j) => complete(\"Future was completed.\")\n    }\n  }\n Similarly, onSuccess(futureOfTuple2) returns a Directive1[Tuple2[Int,Int]] = Directive[Tuple1[Tuple2[Int,Int]]], but this will be automatically converted to Directive[Tuple2[Int,Int]] to avoid nested Tuples. val futureOfUnit: Future[Unit] = Future.successful( () )\nval route =\n  path(\"success\") {\n    onSuccess(futureOfUnit) { //: Directive0\n        complete(\"Future was completed.\")\n    }\n  }\n If the future returns Future[Unit], it is a bit special case as it results in Directive0. Looking at the above code, onSuccess(futureOfUnit) returns a Directive1[Unit] = Directive[Tuple1[Unit]]. However, the DSL interprets Unit as Tuple0, and automatically converts the result to Directive[Unit] = Directive0,","title":"Type Safety of Directives"},{"location":"/routing-dsl/directives/alphabetically.html","text":"","title":"Predefined Directives (alphabetically)"},{"location":"/routing-dsl/directives/alphabetically.html#predefined-directives-alphabetically-","text":"Directive Description alwaysCache Wraps its inner Route with caching support using the given CacheCache implementation and the in-scope keyer function. attribute Extracts the value of the request attribute with a given key authenticateBasic Wraps the inner route with Http Basic authentication support using a given Authenticator[T]Authenticator<T> authenticateBasicAsync Wraps the inner route with Http Basic authentication support using a given AsyncAuthenticator[T]AsyncAuthenticator<T> authenticateBasicPF Wraps the inner route with Http Basic authentication support using a given AuthenticatorPF[T]AuthenticatorPF<T> authenticateBasicPFAsync Wraps the inner route with Http Basic authentication support using a given AsyncAuthenticatorPF[T]AsyncAuthenticatorPF<T> authenticateOAuth2 Wraps the inner route with OAuth Bearer Token authentication support using a given AuthenticatorPF[T]AuthenticatorPF<T> authenticateOAuth2Async Wraps the inner route with OAuth Bearer Token authentication support using a given AsyncAuthenticator[T]AsyncAuthenticator<T> authenticateOAuth2PF Wraps the inner route with OAuth Bearer Token authentication support using a given AuthenticatorPF[T]AuthenticatorPF<T> authenticateOAuth2PFAsync Wraps the inner route with OAuth Bearer Token authentication support using a given AsyncAuthenticatorPF[T]AsyncAuthenticatorPF<T> authenticateOrRejectWithChallenge Lifts an authenticator function into a directive authorize Applies the given authorization check to the request authorizeAsync Applies the given asynchronous authorization check to the request cache Wraps its inner Route with caching support using the given CacheCache implementation and the in-scope keyer function. cachingProhibited Passes only requests that explicitly forbid caching with a Cache-Control header with either a no-cache or max-age=0 setting. cancelRejection Adds a TransformationRejectionTransformationRejection cancelling all rejections equal to the given one to the rejections potentially coming back from the inner route. cancelRejections Adds a TransformationRejectionTransformationRejection cancelling all matching rejections to the rejections potentially coming back from the inner route checkSameOrigin Checks that the request comes from the same origin complete Completes the request using the given arguments completeOrRecoverWith “Unwraps” a Future[T]CompletionStage<T> and runs the inner route when the future has failed with the error as an extraction of type Throwable completeWith Uses the marshaller for a given type to extract a completion function conditional Wraps its inner route with support for conditional requests as defined by RFC 7232 cookie Extracts the HttpCookieHttpCookie with the given name decodeRequest Decompresses the request if it is gzip or deflate compressed decodeRequestWith Decodes the incoming request using one of the given decoders delete Rejects all non-DELETE requests deleteCookie Adds a Set-Cookie response header expiring the given cookies encodeResponse Encodes the response with the encoding that is requested by the client via the Accept-Encoding header (NoCoding, Gzip and Deflate) encodeResponseWith Encodes the response with the encoding that is requested by the client via the Accept-Encoding header (from a user-defined set) entity Extracts the request entity unmarshalled to a given type extract Extracts a single value using a RequestContext => TFunction<RequestContext, T> function extractDataBytes Extracts the entities data bytes as a stream Source<ByteString, ?>Source[ByteString, _] extractClientIP Extracts the client’s IP from either the X-Forwarded-, Remote-Address or X-Real-IP header extractCredentials Extracts the potentially present HttpCredentialsHttpCredentials provided with the request’s AuthorizationAuthorization header extractExecutionContext Extracts the ExecutionContext from the RequestContextRequestContext extractMatchedPath Extracts the already matched path from the RequestContextRequestContext extractMaterializer Extracts the MaterializerMaterializer from the RequestContextRequestContext extractHost Extracts the hostname part of the Host request header value extractLog Extracts the LoggingAdapterLoggingAdapter from the RequestContextRequestContext extractMethod Extracts the request method extractOfferedWsProtocols Extract the list of websocket subprotocols offered by the client in the Sec-WebSocket-Protocol header if this is a websocket request and otherwise rejects with an ExpectedWebSocketRequestRejectionExpectedWebSocketRequestRejection extractParserSettings Extracts the ParserSettingsParserSettings from the RequestContextRequestContext extractRequest Extracts the current HttpRequestHttpRequest instance extractRequestContext Extracts the RequestContextRequestContext itself extractRequestEntity Extracts the RequestEntityRequestEntity from the RequestContextRequestContext extractScheme Extracts the URI scheme from the request extractSettings Extracts the RoutingSettingsRoutingSettings from the RequestContextRequestContext extractUnmatchedPath Extracts the yet unmatched path from the RequestContextRequestContext extractUpgradeToWebSocket Extract the UpgradeToWebSocketUpgradeToWebSocket header if existent and otherwise rejects with an ExpectedWebSocketRequestRejectionExpectedWebSocketRequestRejection extractUri Extracts the complete request URI failWith Bubbles the given error up the response chain where it is dealt with by the closest handleExceptions directive and its ExceptionHandlerExceptionHandler fileUpload Provides a stream of an uploaded file from a multipart request fileUploadAll Provides streams of all uploaded files from a multipart request formField Extracts an HTTP form field (of Content-Type application/x-www-form-urlencoded or multipart/form-data) from the request formFieldMap Extracts a number of HTTP form field (of Content-Type application/x-www-form-urlencoded or multipart/form-data) from the request as a Map[String, String]Map<String, String> formFieldMultiMap Extracts a number of HTTP form field (of Content-Type application/x-www-form-urlencoded or multipart/form-data) from the request as a Map[String, List[String]]Map<String, List<String>> formFields Extracts a number of HTTP form field (of Content-Type application/x-www-form-urlencoded or multipart/form-data) from the request formFieldSeq Extracts a number of HTTP form field (of Content-Type application/x-www-form-urlencoded or multipart/form-data) from the request as a Seq[(String, String)]List<Map.Entry<String, String>> get Rejects all non-GET requests getFromBrowseableDirectories Serves the content of the given directories as a file-system browser, i.e. files are sent and directories served as browseable listings getFromBrowseableDirectory Serves the content of the given directory as a file-system browser, i.e. files are sent and directories served as browseable listings getFromDirectory Completes GET requests with the content of a file underneath a given file-system directory getFromFile Completes GET requests with the content of a given file getFromResource Completes GET requests with the content of a given class-path resource getFromResourceDirectory Completes GET requests with the content of a file underneath a given “class-path resource directory” handleExceptions Transforms exceptions thrown during evaluation of the inner route using the given ExceptionHandlerExceptionHandler handleRejections Transforms rejections produced by the inner route using the given RejectionHandler handleWebSocketMessages Handles websocket requests with the given handler and rejects other requests with an ExpectedWebSocketRequestRejectionExpectedWebSocketRequestRejection handleWebSocketMessagesForOptionalProtocol Handles websocket requests with the given handler if the subprotocol matches and rejects other requests. If the subprotocol parameter is Noneempty any WebSocket request is accepted.. handleWebSocketMessagesForProtocol Handles websocket requests with the given handler if the subprotocol matches and rejects other requests with an ExpectedWebSocketRequestRejectionExpectedWebSocketRequestRejection or an UnsupportedWebSocketSubprotocolRejectionUnsupportedWebSocketSubprotocolRejection. handleWith Completes the request using a given function head Rejects all non-HEAD requests headerValue Extracts an HTTP header value using a given HttpHeader => Option[T]Function<HttpHeader, Optional<T>> function headerValueByName Extracts the value of the first HTTP request header with a given name headerValueByType Extracts the first HTTP request header of the given type headerValuePF Extracts an HTTP header value using a given PartialFunction[HttpHeader, T]]PartialFunction<HttpHeader, T> host Rejects all requests with a non-matching host name ignoreTrailingSlash Retries the inner route adding (or removing) the trailing slash in case of empty rejections listDirectoryContents Completes GET requests with a unified listing of the contents of all given file-system directories logRequest Produces a log entry for every incoming request logRequestResult Produces a log entry for every incoming request and RouteResultRouteResult logResult Produces a log entry for every RouteResultRouteResult mapInnerRoute Transforms its inner RouteRoute with a Route => RouteUnaryOperator<Route> function mapRejections Transforms rejections from a previous route with an immutable.Seq[Rejection] => immutable.Seq[Rejection]UnaryOperator<List<Rejection>> function mapRequest Transforms the request with an HttpRequest => HttpRequestUnaryOperator<HttpRequest> function mapRequestContext Transforms the RequestContextRequestContext with a RequestContext => RequestContextUnaryOperator<RequestContext> function mapResponse Transforms the response with an HttpResponse => HttpResponseUnaryOperator<HttpResponse> function mapResponseEntity Transforms the response entity with an ResponseEntity => ResponseEntityUnaryOperator<ResponseEntity> function mapResponseHeaders Transforms the response headers with an immutable.Seq[HttpHeader] => immutable.Seq[HttpHeader]UnaryOperator<List<HttpHeader>> function mapRouteResult Transforms the RouteResultRouteResult with a RouteResult => RouteResultUnaryOperator<RouteResult> function mapRouteResultFuture Transforms the RouteResultRouteResult future with a Future[RouteResult] => Future[RouteResult]UnaryOperator<CompletionStage<RouteResult>> function mapRouteResultPF Transforms the RouteResultRouteResult with a PartialFunction[RouteResult, RouteResult]PartialFunction<RouteResult, RouteResult> mapRouteResultWith Transforms the RouteResultRouteResult with a RouteResult => Future[RouteResult]Function<RouteResult, CompletionStage<RouteResult>> function mapRouteResultWithPF Transforms the RouteResultRouteResult with a PartialFunction[RouteResult, Future[RouteResult]]PartialFunction<RouteResult, CompletionStage<RouteResult>> mapSettings Transforms the RoutingSettingsRoutingSettings with a RoutingSettings => RoutingSettingsUnaryOperator<RoutingSettings> function mapUnmatchedPath Transforms the unmatchedPath of the RequestContextRequestContext using a Uri.Path => Uri.PathUnaryOperator<Uri.Path> function method Rejects all requests whose HTTP method does not match the given one onComplete “Unwraps” a Future[T]CompletionStage<T> and runs the inner route after future completion with the future’s value as an extraction of type Try[T]Try<T> onCompleteWithBreaker “Unwraps” a Future[T]CompletionStage<T> inside a CircuitBreakerCircuitBreaker and runs the inner route after future completion with the future’s value as an extraction of type Try[T]Try<T> onSuccess “Unwraps” a Future[T]CompletionStage<T> and runs the inner route after future completion with the future’s value as an extraction of type T optionalAttribute Extracts the value of an optional request attribute with a given key optionalCookie Extracts the HttpCookiePairHttpCookiePair with the given name as an Option[HttpCookiePair]Optional<HttpCookiePair> optionalHeaderValue Extracts an optional HTTP header value using a given HttpHeader => Option[T]Function<HttpHeader, Optional<T>> function optionalHeaderValueByName Extracts the value of the first optional HTTP request header with a given name optionalHeaderValueByType Extracts the first optional HTTP request header of the given type optionalHeaderValuePF Extracts an optional HTTP header value using a given PartialFunction[HttpHeader, T]PartialFunction<HttpHeader, T> options Rejects all non-OPTIONS requests overrideMethodWithParameter Changes the request method to the value of the specified query parameter parameter Extracts a query parameter value from the request parameterMap Extracts the request’s query parameters as a Map[String, String]Map<String, String> parameterMultiMap Extracts the request’s query parameters as a Map[String, List[String]]Map<String, List<String>> parameters Extracts a number of query parameter values from the request parameterSeq Extracts the request’s query parameters as a Seq[(String, String)]List<Map.Entry<String, String>> pass Always simply passes the request on to its inner route, i.e. doesn’t do anything, neither with the request nor the response patch Rejects all non-PATCH requests path Applies the given PathMatcher to the remaining unmatched path after consuming a leading slash pathEnd Only passes on the request to its inner route if the request path has been matched completely pathEndOrSingleSlash Only passes on the request to its inner route if the request path has been matched completely or only consists of exactly one remaining slash pathPrefix Applies the given PathMatcher to a prefix of the remaining unmatched path after consuming a leading slash pathPrefixTest Checks whether the unmatchedPath has a prefix matched by the given PathMatcher after implicitly consuming a leading slash pathSingleSlash Only passes on the request to its inner route if the request path consists of exactly one remaining slash pathSuffix Applies the given PathMatcher to a suffix of the remaining unmatched path (Caution: check scaladocjava!) pathSuffixTest Checks whether the unmatched path has a suffix matched by the given PathMatcher (Caution: check scaladocjava!) post Rejects all non-POST requests provide Injects a given value into a directive put Rejects all non-PUT requests rawPathPrefix Applies the given matcher directly to a prefix of the unmatched path of the RequestContextRequestContext, without implicitly consuming a leading slash rawPathPrefixTest Checks whether the unmatchedPath has a prefix matched by the given PathMatcher recoverRejections Transforms rejections from the inner route with an immutable.Seq[Rejection] => RouteResultFunction<List<Rejection>, RouteResult> function recoverRejectionsWith Transforms rejections from the inner route with an immutable.Seq[Rejection] => Future[RouteResult]Function<List<Rejection], CompletionStage<RouteResult>> function redirect Completes the request with redirection response of the given type to the given URI redirectToNoTrailingSlashIfPresent If the request path ends with a slash, redirects to the same URI without trailing slash in the path redirectToTrailingSlashIfMissing If the request path doesn’t end with a slash, redirects to the same URI with trailing slash in the path reject Rejects the request with the given rejections rejectEmptyResponse Converts responses with an empty entity into (empty) rejections requestEncodedWith Rejects the request with an UnsupportedRequestEncodingRejectionUnsupportedRequestEncodingRejection if its encoding doesn’t match the given one requestEntityEmpty Rejects if the request entity is non-empty requestEntityPresent Rejects with a RequestEntityExpectedRejectionRequestEntityExpectedRejection if the request entity is empty respondWithDefaultHeader Adds a given response header if the response doesn’t already contain a header with the same name respondWithDefaultHeaders Adds the subset of the given headers to the response which doesn’t already have a header with the respective name present in the response respondWithHeader Unconditionally adds a given header to the outgoing response respondWithHeaders Unconditionally adds the given headers to the outgoing response responseEncodingAccepted Rejects the request with an UnacceptedResponseEncodingRejectionUnacceptedResponseEncodingRejection if the given response encoding is not accepted by the client scheme Rejects all requests whose URI scheme doesn’t match the given one selectPreferredLanguage Inspects the request’s Accept-Language header and determines, which of a given set of language alternatives is preferred by the client setCookie Adds a Set-Cookie response header with the given cookies storeUploadedFile Streams one uploaded file from a multipart request to a file on disk storeUploadedFiles Streams all uploaded files from a multipart request to files on disk textract Extracts a number of values using a RequestContext => Tuple function tprovide Injects a given tuple of values into a directive validate Checks a given condition before running its inner route withoutRequestTimeout Disables request timeouts for a given route. withoutSizeLimit Skips request entity size check withExecutionContext Runs its inner route with the given alternative ExecutionContext withLog Runs its inner route with the given alternative LoggingAdapterLoggingAdapter withMaterializer Runs its inner route with the given alternative MaterializerMaterializer withPrecompressedMediaTypeSupport Adds a Content-Encoding: gzip response header if the entity’s media-type is precompressed with gzip header withRangeSupport Adds Accept-Ranges: bytes to responses to GET requests, produces partial responses if the initial request contained a valid Range header withRequestTimeout Configures the request timeouts for a given route. withRequestTimeoutResponse Prepares the HttpResponseHttpResponse that is emitted if a request timeout is triggered. RequestContext => RequestContext function withSettings Runs its inner route with the given alternative RoutingSettingsRoutingSettings withSizeLimit Applies request entity size check","title":"Predefined Directives (alphabetically)"},{"location":"/routing-dsl/directives/by-trait.html","text":"","title":"Predefined Directives (by trait)"},{"location":"/routing-dsl/directives/by-trait.html#predefined-directives-by-trait-","text":"All predefined directives are organized into traits that form one part of the overarching DirectivesDirectives trait.","title":"Predefined Directives (by trait)"},{"location":"/routing-dsl/directives/by-trait.html#directives-filtering-or-extracting-from-the-request","text":"MethodDirectives Filter and extract based on the request method. HeaderDirectives Filter and extract based on request headers. AttributeDirectives Filter and extract based on request attributes. PathDirectives Filter and extract from the request URI path. HostDirectives Filter and extract based on the target host. ParameterDirectives, FormFieldDirectives Filter and extract based on query parameters or form fields (of Content-Type application/x-www-form-urlencoded or multipart/form-data). CodingDirectives Filter and decode compressed request content. Marshalling Directives Extract the request entity. SchemeDirectives Filter and extract based on the request scheme. SecurityDirectives Handle authentication data from the request. CookieDirectives Filter and extract cookies. BasicDirectives and MiscDirectives Directives handling request properties. FileUploadDirectives Handle file uploads.","title":"Directives filtering or extracting from the request"},{"location":"/routing-dsl/directives/by-trait.html#directives-creating-or-transforming-the-response","text":"CacheConditionDirectives Support for conditional requests (304 Not Modified responses). CachingDirectives Support for caching expensive operations. CookieDirectives Set, modify, or delete cookies. CodingDirectives Compress responses. FileAndResourceDirectives Deliver responses from files and resources. RangeDirectives Support for range requests (206 Partial Content responses). RespondWithDirectives Change response properties. RouteDirectives Complete or reject a request with a response. BasicDirectives and MiscDirectives Directives handling or transforming response properties. TimeoutDirectives Configure request timeouts and automatic timeout responses.","title":"Directives creating or transforming the response"},{"location":"/routing-dsl/directives/by-trait.html#list-of-predefined-directives-by-trait","text":"AttributeDirectives BasicDirectives CacheConditionDirectives CachingDirectives CodingDirectives CookieDirectives DebuggingDirectives ExecutionDirectives FileAndResourceDirectives FileUploadDirectives FormFieldDirectives FuturesDirectives HeaderDirectives HostDirectives Marshalling Directives MethodDirectives MiscDirectives ParameterDirectives PathDirectives RangeDirectives RespondWithDirectives RouteDirectives SchemeDirectives SecurityDirectives WebSocketDirectives TimeoutDirectives","title":"List of predefined directives by trait"},{"location":"/routing-dsl/directives/attribute-directives/index.html","text":"","title":"AttributeDirectives"},{"location":"/routing-dsl/directives/attribute-directives/index.html#attributedirectives","text":"Attribute directives can be used to extract attribute values from the request.\nattribute optionalAttribute","title":"AttributeDirectives"},{"location":"/routing-dsl/directives/attribute-directives/attribute.html","text":"","title":"attribute"},{"location":"/routing-dsl/directives/attribute-directives/attribute.html#attribute","text":"Signature def attribute[T](key: AttributeKey[T]): Directive1[T]","title":"attribute"},{"location":"/routing-dsl/directives/attribute-directives/attribute.html#description","text":"Extracts the value of the request attribute with the given key.\nIf no attribute is found for the given key the request is rejected with a MissingAttributeRejectionMissingAttributeRejection.\nIf the attribute is expected to be missing in some cases or to customize handling when the header is missing use the optionalAttribute directive instead.","title":"Description"},{"location":"/routing-dsl/directives/attribute-directives/attribute.html#example","text":"Scala copysourceval userId = AttributeKey[String](\"user-id\")\n\nval route =\n  attribute(userId) { userId =>\n    complete(s\"The user is $userId\")\n  }\n\n// tests:\nGet(\"/\") ~> addAttribute(userId, \"Joe42\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The user is Joe42\"\n}\n\nGet(\"/\") ~> Route.seal(route) ~> check {\n  status shouldEqual InternalServerError\n} Java copysourceAttributeKey<String> userId = AttributeKey.create(\"user-id\", String.class);\n\nfinal Route route = attribute(userId, id ->\n  complete(\"The user is \" + id)\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/\").addAttribute(userId, \"Joe42\"))\n  .assertEntity(\"The user is Joe42\");\n\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertStatusCode(StatusCodes.INTERNAL_SERVER_ERROR);","title":"Example"},{"location":"/routing-dsl/directives/attribute-directives/optionalAttribute.html","text":"","title":"optionalAttribute"},{"location":"/routing-dsl/directives/attribute-directives/optionalAttribute.html#optionalattribute","text":"Signature def optionalAttribute[T](key: AttributeKey[T]): Directive1[Option[T]]","title":"optionalAttribute"},{"location":"/routing-dsl/directives/attribute-directives/optionalAttribute.html#description","text":"Optionally extracts the value of the request attribute with the given key.\nThe optionalAttribute directive is similar to the attribute directive but always extracts an OptionOptional value instead of rejecting the request if no matching attribute could be found.","title":"Description"},{"location":"/routing-dsl/directives/attribute-directives/optionalAttribute.html#example","text":"Scala copysourceval userId = AttributeKey[String](\"user-id\")\n\nval route =\n  optionalAttribute(userId) {\n    case Some(userId) => complete(s\"The user is $userId\")\n    case None         => complete(s\"No user was provided\")\n  } ~ // can also be written as:\n  optionalAttribute(userId) { userId =>\n    complete {\n      userId match {\n        case Some(u) => s\"The user is $u\"\n        case _       => \"No user was provided\"\n      }\n    }\n  }\n\n// tests:\nGet(\"/\") ~> addAttribute(userId, \"Joe42\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The user is Joe42\"\n}\nGet(\"/\") ~> Route.seal(route) ~> check {\n  responseAs[String] shouldEqual \"No user was provided\"\n} Java copysourceAttributeKey<String> userId = AttributeKey.create(\"user-id\", String.class);\n\nfinal Route route = optionalAttribute(userId, id -> {\n  if (id.isPresent()) {\n    return complete(\"The user is \" + id.get());\n  } else {\n    return complete(\"No user was provided\");\n  }\n});\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/\").addAttribute(userId, \"Joe42\"))\n  .assertEntity(\"The user is Joe42\");\n\ntestRoute(route).run(HttpRequest.GET(\"/\")).assertEntity(\"No user was provided\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/index.html","text":"","title":"BasicDirectives"},{"location":"/routing-dsl/directives/basic-directives/index.html#basicdirectives","text":"Basic directives are building blocks for building Custom Directives. As such they usually aren’t used in a route directly but rather in the definition of new directives.","title":"BasicDirectives"},{"location":"/routing-dsl/directives/basic-directives/index.html#providing-values-to-inner-routes","text":"These directives provide values to the inner routes with extractions. They can be distinguished on two axes: a) provide a constant value or extract a value from the RequestContextRequestContext b) provide a single value or a tuple of values.\nextract extractActorSystem extractDataBytes extractExecutionContext extractLog extractMatchedPath extractMaterializer extractParserSettings extractRequestContext extractRequestEntity extractRequest extractSettings extractStrictEntity extractUnmatchedPath extractUri textract provide tprovide","title":"Providing Values to Inner Routes"},{"location":"/routing-dsl/directives/basic-directives/index.html#transforming-the-request-context-","text":"mapRequest mapRequestContext mapSettings mapUnmatchedPath withExecutionContext withLog withMaterializer withSettings toStrictEntity","title":"Transforming the Request(Context)"},{"location":"/routing-dsl/directives/basic-directives/index.html#transforming-the-response","text":"These directives allow to hook into the response path and transform the complete response or the parts of a response or the list of rejections:\nmapResponse mapResponseEntity mapResponseHeaders","title":"Transforming the Response"},{"location":"/routing-dsl/directives/basic-directives/index.html#transforming-the-routeresult","text":"These directives allow to transform the RouteResult of the inner route.\ncancelRejection cancelRejections mapRejections mapRouteResult mapRouteResultFuture mapRouteResultPF mapRouteResultWith mapRouteResultWithPF recoverRejections recoverRejectionsWith","title":"Transforming the RouteResult"},{"location":"/routing-dsl/directives/basic-directives/index.html#other","text":"mapInnerRoute pass","title":"Other"},{"location":"/routing-dsl/directives/basic-directives/index.html#alphabetically","text":"cancelRejection cancelRejections extract extractActorSystem extractDataBytes extractExecutionContext extractLog extractMatchedPath extractMaterializer extractParserSettings extractRequest extractRequestContext extractRequestEntity extractSettings extractStrictEntity extractUnmatchedPath extractUri mapInnerRoute mapRejections mapRequest mapRequestContext mapResponse mapResponseEntity mapResponseHeaders mapRouteResult mapRouteResultFuture mapRouteResultPF mapRouteResultWithPF mapRouteResultWith mapSettings mapUnmatchedPath pass provide recoverRejections recoverRejectionsWith textract toStrictEntity tprovide withExecutionContext withLog withMaterializer withSettings","title":"Alphabetically"},{"location":"/routing-dsl/directives/basic-directives/cancelRejection.html","text":"","title":"cancelRejection"},{"location":"/routing-dsl/directives/basic-directives/cancelRejection.html#cancelrejection","text":"Signature def cancelRejection(rejection: Rejection): Directive0","title":"cancelRejection"},{"location":"/routing-dsl/directives/basic-directives/cancelRejection.html#description","text":"Adds a TransformationRejectionTransformationRejection cancelling all rejections equal to the given one to the rejections potentially coming back from the inner route.\nRead Rejections to learn more about rejections.\nFor more advanced handling of rejections refer to the handleRejections directive which provides a nicer DSL for building rejection handlers.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/cancelRejection.html#example","text":"Scala copysourceval route =\n  cancelRejection(MethodRejection(HttpMethods.POST)) {\n    post {\n      complete(\"Result\")\n    }\n  }\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  rejections shouldEqual Nil\n  handled shouldEqual false\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.cancelRejection;\n\nfinal Route route = cancelRejection(Rejections.method(HttpMethods.POST), () ->\n  post(() ->  complete(\"Result\"))\n);\n\n// tests:\nrunRouteUnSealed(route, HttpRequest.GET(\"/\"))\n  .assertRejections();","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/cancelRejections.html","text":"","title":"cancelRejections"},{"location":"/routing-dsl/directives/basic-directives/cancelRejections.html#cancelrejections","text":"Signature def cancelRejections(classes: Class[_]*): Directive0 \ndef cancelRejections(cancelFilter: Rejection","title":"cancelRejections"},{"location":"/routing-dsl/directives/basic-directives/cancelRejections.html#description","text":"Adds a TransformationRejectionTransformationRejection cancelling all rejections created by the inner route for which the condition argument function returns true.\nSee also cancelRejection, for canceling a specific rejection.\nRead Rejections to learn more about rejections.\nFor more advanced handling of rejections refer to the handleRejections directive which provides a nicer DSL for building rejection handlers.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/cancelRejections.html#example","text":"Scala copysourcedef isMethodRejection: Rejection => Boolean = {\n  case MethodRejection(_) => true\n  case _                  => false\n}\n\nval route =\n  cancelRejections(isMethodRejection) {\n    post {\n      complete(\"Result\")\n    }\n  }\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  rejections shouldEqual Nil\n  handled shouldEqual false\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.cancelRejections;\n\nfinal Predicate<Rejection> isMethodRejection = p -> p instanceof MethodRejection;\nfinal Route route = cancelRejections(\n  isMethodRejection, () -> post(() -> complete(\"Result\"))\n);\n\n// tests:\nrunRouteUnSealed(route, HttpRequest.GET(\"/\"))\n  .assertRejections();","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/extract.html","text":"","title":"extract"},{"location":"/routing-dsl/directives/basic-directives/extract.html#extract","text":"Signature def extract[T](f: RequestContext","title":"extract"},{"location":"/routing-dsl/directives/basic-directives/extract.html#description","text":"The extract directive is used as a building block for Custom Directives to extract data from the RequestContextRequestContext and provide it to the inner route. It is a special case for extracting one value of the more general textract directive that can be used to extract more than one value.\nSee Providing Values to Inner Routes for an overview of similar directives.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/extract.html#example","text":"Scala copysourceval uriLength = extract(_.request.uri.toString.length)\nval route =\n  uriLength { len =>\n    complete(s\"The length of the request URI is $len\")\n  }\n\n// tests:\nGet(\"/abcdef\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The length of the request URI is 25\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.extract;\n\nfinal Route route = extract(\n  ctx -> ctx.getRequest().getUri().toString().length(),\n  len -> complete(\"The length of the request URI is \" + len)\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/abcdef\"))\n  .assertEntity(\"The length of the request URI is 25\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/extractActorSystem.html","text":"","title":"extractActorSystem"},{"location":"/routing-dsl/directives/basic-directives/extractActorSystem.html#extractactorsystem","text":"Signature def extractActorSystem: Directive1[ActorSystem]","title":"extractActorSystem"},{"location":"/routing-dsl/directives/basic-directives/extractActorSystem.html#description","text":"Extracts the ActorSystemActorSystem from the RequestContextRequestContext, which can be useful when the external API in your route needs one.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/extractActorSystem.html#example","text":"Scala copysourceval route = extractActorSystem { actorSystem =>\n  complete(s\"Actor System extracted, hash=${actorSystem.hashCode()}\")\n}\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual s\"Actor System extracted, hash=${system.hashCode()}\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.extractActorSystem;\n\nfinal Route route = extractActorSystem(actorSystem ->\n  complete(\"Actor System extracted, hash=\" + actorSystem.hashCode())\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertEntity(\"Actor System extracted, hash=\" + system().hashCode());","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/extractDataBytes.html","text":"","title":"extractDataBytes"},{"location":"/routing-dsl/directives/basic-directives/extractDataBytes.html#extractdatabytes","text":"Signature def extractDataBytes: Directive1[Source[ByteString, Any]]","title":"extractDataBytes"},{"location":"/routing-dsl/directives/basic-directives/extractDataBytes.html#description","text":"Extracts the entities data bytes as Source<ByteString, ?>Source[ByteString, _] from the RequestContextRequestContext.\nThe directive returns a stream containing the request data bytes.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/extractDataBytes.html#example","text":"Scala copysourceval route =\n  extractDataBytes { data =>\n    val sum = data.runFold(0) { (acc, i) => acc + i.utf8String.toInt }\n    onSuccess(sum) { s =>\n      complete(HttpResponse(entity = HttpEntity(s.toString)))\n    }\n  }\n\n// tests:\nval dataBytes = Source.fromIterator(() => Iterator.range(1, 10).map(x => ByteString(x.toString)))\nPost(\"/abc\", HttpEntity(ContentTypes.`text/plain(UTF-8)`, data = dataBytes)) ~> route ~> check {\n  responseAs[String] shouldEqual \"45\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.extractDataBytes;\n\nfinal Route route = extractDataBytes(data -> {\n  final CompletionStage<Integer> sum = data.runFold(0, (acc, i) ->\n    acc + Integer.valueOf(i.utf8String()), materializer());\n  return onSuccess(sum, s ->\n    complete(HttpResponse.create().withEntity(HttpEntities.create(s.toString()))));\n});\n\n// tests:\nfinal Iterator iterator = Arrays.asList(\n  ByteString.fromString(\"1\"),\n  ByteString.fromString(\"2\"),\n  ByteString.fromString(\"3\")).iterator();\nfinal Source<ByteString, NotUsed> dataBytes = Source.fromIterator(() -> iterator);\n\ntestRoute(route).run(\n  HttpRequest.POST(\"abc\")\n    .withEntity(HttpEntities.create(ContentTypes.TEXT_PLAIN_UTF8, dataBytes))\n).assertEntity(\"6\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/extractExecutionContext.html","text":"","title":"extractExecutionContext"},{"location":"/routing-dsl/directives/basic-directives/extractExecutionContext.html#extractexecutioncontext","text":"Signature def extractExecutionContext: Directive1[ExecutionContextExecutor]","title":"extractExecutionContext"},{"location":"/routing-dsl/directives/basic-directives/extractExecutionContext.html#description","text":"Extracts the ExecutionContext from the RequestContextRequestContext.\nSee withExecutionContext to see how to customise the execution context provided for an inner route.\nSee extract to learn more about how extractions work.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/extractExecutionContext.html#example","text":"Scala copysourcedef sample() =\n  path(\"sample\") {\n    extractExecutionContext { implicit executor =>\n      complete {\n        Future(s\"Run on ${executor.##}!\") // uses the `executor` ExecutionContext\n      }\n    }\n  }\n\nval route =\n  pathPrefix(\"special\") {\n    sample() // default execution context will be used\n  }\n\n// tests:\nGet(\"/sample\") ~> route ~> check {\n  responseAs[String] shouldEqual s\"Run on ${system.dispatcher.##}!\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.extractExecutionContext;\n\nfinal Route route = path(\"sample\", () ->\n  extractExecutionContext(executor ->\n    onSuccess(\n      CompletableFuture.supplyAsync(\n        // uses the `executor` ExecutionContext\n        () -> \"Run on \" + executor.hashCode() + \"!\", executor\n      ), str -> complete(str)\n    )\n  )\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/sample\"))\n  .assertEntity(\"Run on \" + system().dispatcher().hashCode() + \"!\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/extractLog.html","text":"","title":"extractLog"},{"location":"/routing-dsl/directives/basic-directives/extractLog.html#extractlog","text":"Signature def extractLog: Directive1[LoggingAdapter]","title":"extractLog"},{"location":"/routing-dsl/directives/basic-directives/extractLog.html#description","text":"Extracts a LoggingAdapterLoggingAdapter from the request context which can be used for logging inside the route.\nThe extractLog directive is used for providing logging to routes, such that they don’t have to depend on closing over a logger provided in the class body.\nSee extract and Providing Values to Inner Routes for an overview of similar directives.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/extractLog.html#example","text":"Scala copysourceval route =\n  extractLog { log =>\n    log.debug(\"I'm logging things in much detail..!\")\n    complete(\"It's amazing!\")\n  }\n\n// tests:\nGet(\"/abcdef\") ~> route ~> check {\n  responseAs[String] shouldEqual \"It's amazing!\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.extractLog;\n\nfinal Route route = extractLog(log -> {\n  log.debug(\"I'm logging things in much detail..!\");\n  return complete(\"It's amazing!\");\n});\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/abcdef\"))\n  .assertEntity(\"It's amazing!\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/extractMatchedPath.html","text":"","title":"extractMatchedPath"},{"location":"/routing-dsl/directives/basic-directives/extractMatchedPath.html#extractmatchedpath","text":"Signature def extractMatchedPath: Directive1[Uri.Path]","title":"extractMatchedPath"},{"location":"/routing-dsl/directives/basic-directives/extractMatchedPath.html#description","text":"Extracts the matched path from the request context.\nThe extractMatchedPath directive extracts the path that was already matched by any of the PathDirectives (or any custom ones that change the unmatched path field of the request context). You can use it for building directives that use already matched part in their logic.\nSee also extractUnmatchedPath to see similar directive for unmatched path.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/extractMatchedPath.html#example","text":"Scala copysourceval route =\n  pathPrefix(\"abc\") {\n    extractMatchedPath { matched =>\n      complete(matched.toString)\n    }\n  }\n\n// tests:\nGet(\"/abc\") ~> route ~> check {\n  responseAs[String] shouldEqual \"/abc\"\n}\nGet(\"/abc/xyz\") ~> route ~> check {\n  responseAs[String] shouldEqual \"/abc\"\n}\n Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.extractMatchedPath;\n\nfinal Route route = pathPrefix(\"abc\", () -> extractMatchedPath(Directives::complete));\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/abc\")).assertEntity(\"/abc\");\ntestRoute(route).run(HttpRequest.GET(\"/abc/xyz\")).assertEntity(\"/abc\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/extractMaterializer.html","text":"","title":"extractMaterializer"},{"location":"/routing-dsl/directives/basic-directives/extractMaterializer.html#extractmaterializer","text":"Signature def extractMaterializer: Directive1[Materializer]","title":"extractMaterializer"},{"location":"/routing-dsl/directives/basic-directives/extractMaterializer.html#description","text":"Extracts the MaterializerMaterializer from the RequestContextRequestContext, which can be useful when you want to run an Apache Pekko Stream directly in your route.\nSee also withMaterializer to see how to customise the used materializer for specific inner routes.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/extractMaterializer.html#example","text":"Scala copysourceval route =\n  path(\"sample\") {\n    extractMaterializer { materializer =>\n      complete {\n        // explicitly use the `materializer`:\n        Source.single(s\"Materialized by ${SystemMaterializer(system).materializer.##}!\")\n          .runWith(Sink.head)(materializer)\n      }\n    }\n  } // default materializer will be used\n\n// tests:\nGet(\"/sample\") ~> route ~> check {\n  responseAs[String] shouldEqual s\"Materialized by ${SystemMaterializer(system).materializer.##}!\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.extractMaterializer;\n\nfinal Route route = path(\"sample\", () ->\n  extractMaterializer(mat ->\n    onSuccess(() ->\n      // explicitly use the materializer:\n      Source.single(\"Materialized by \" + mat.hashCode() + \"!\")\n        .runWith(Sink.head(), mat), Directives::complete\n    )\n  )\n); // default materializer will be used\n\ntestRoute(route).run(HttpRequest.GET(\"/sample\"))\n  .assertEntity(\"Materialized by \" + materializer().hashCode()+ \"!\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/extractParserSettings.html","text":"","title":"extractParserSettings"},{"location":"/routing-dsl/directives/basic-directives/extractParserSettings.html#extractparsersettings","text":"Signature def extractParserSettings: Directive1[ParserSettings]","title":"extractParserSettings"},{"location":"/routing-dsl/directives/basic-directives/extractParserSettings.html#description","text":"Extracts the request’s underlying ParserSettingsParserSettings, which can be useful when you want to access custom status codes and media types.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/extractParserSettings.html#example","text":"Scala copysourceval route =\n  extractParserSettings { parserSettings =>\n    complete(s\"URI parsing mode is ${parserSettings.uriParsingMode}\")\n  }\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"URI parsing mode is Strict\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.extractParserSettings;\n\nfinal Route route = extractParserSettings(parserSettings ->\n  complete(\"URI parsing mode is \" + parserSettings.getUriParsingMode())\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertEntity(\"URI parsing mode is Strict\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/extractRequest.html","text":"","title":"extractRequest"},{"location":"/routing-dsl/directives/basic-directives/extractRequest.html#extractrequest","text":"Signature def extractRequest: Directive1[HttpRequest]","title":"extractRequest"},{"location":"/routing-dsl/directives/basic-directives/extractRequest.html#description","text":"Extracts the complete HttpRequestHttpRequest instance.\nUse extractRequest to extract just the complete URI of the request. Usually there’s little use of extracting the complete request because extracting of most of the aspects of HttpRequests is handled by specialized directives. See Request Directives.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/extractRequest.html#example","text":"Scala copysourceval route =\n  extractRequest { request =>\n    complete(s\"Request method is ${request.method.name} and content-type is ${request.entity.contentType}\")\n  }\n\n// tests:\nPost(\"/\", \"text\") ~> route ~> check {\n  responseAs[String] shouldEqual \"Request method is POST and content-type is text/plain; charset=UTF-8\"\n}\nGet(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"Request method is GET and content-type is none/none\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.extractRequest;\n\nfinal Route route = extractRequest(request ->\n  complete(\"Request method is \" + request.method().name() +\n             \" and content-type is \" + request.entity().getContentType())\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.POST(\"/\").withEntity(\"text\"))\n  .assertEntity(\"Request method is POST and content-type is text/plain; charset=UTF-8\");\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertEntity(\"Request method is GET and content-type is none/none\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/extractRequestContext.html","text":"","title":"extractRequestContext"},{"location":"/routing-dsl/directives/basic-directives/extractRequestContext.html#extractrequestcontext","text":"Signature def extractRequestContext: Directive1[RequestContext]","title":"extractRequestContext"},{"location":"/routing-dsl/directives/basic-directives/extractRequestContext.html#description","text":"Extracts the request’s underlying RequestContextRequestContext.\nThis directive is used as a building block for most of the other directives, which extract the context and by inspecting some of it’s values can decide what to do with the request - for example provide a value, or reject the request.\nSee also extractRequest if only interested in the HttpRequestHttpRequest instance itself.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/extractRequestContext.html#example","text":"Scala copysourceval route =\n  extractRequestContext { ctx =>\n    ctx.log.debug(\"Using access to additional context available, like the logger.\")\n    val request = ctx.request\n    complete(s\"Request method is ${request.method.name} and content-type is ${request.entity.contentType}\")\n  }\n\n// tests:\nPost(\"/\", \"text\") ~> route ~> check {\n  responseAs[String] shouldEqual \"Request method is POST and content-type is text/plain; charset=UTF-8\"\n}\nGet(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"Request method is GET and content-type is none/none\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.extractRequestContext;\n\nfinal Route route = extractRequestContext(ctx -> {\n  ctx.getLog().debug(\"Using access to additional context available, like the logger.\");\n  final HttpRequest request = ctx.getRequest();\n  return complete(\"Request method is \" + request.method().name() +\n                    \" and content-type is \" + request.entity().getContentType());\n});\n\n// tests:\ntestRoute(route).run(HttpRequest.POST(\"/\").withEntity(\"text\"))\n  .assertEntity(\"Request method is POST and content-type is text/plain; charset=UTF-8\");\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertEntity(\"Request method is GET and content-type is none/none\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/extractRequestEntity.html","text":"","title":"extractRequestEntity"},{"location":"/routing-dsl/directives/basic-directives/extractRequestEntity.html#extractrequestentity","text":"Signature def extractRequestEntity: Directive1[RequestEntity]","title":"extractRequestEntity"},{"location":"/routing-dsl/directives/basic-directives/extractRequestEntity.html#description","text":"Extracts the RequestEntityRequestEntity from the RequestContextRequestContext.\nThe directive returns a RequestEntityRequestEntity without unmarshalling the request. To extract domain entity, entity should be used.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/extractRequestEntity.html#example","text":"Scala copysourceval route =\n  extractRequestEntity { entity =>\n    complete(s\"Request entity content-type is ${entity.contentType}\")\n  }\n\n// tests:\nval httpEntity = HttpEntity(ContentTypes.`text/plain(UTF-8)`, \"req\")\nPost(\"/abc\", httpEntity) ~> route ~> check {\n  responseAs[String] shouldEqual \"Request entity content-type is text/plain; charset=UTF-8\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.extractRequestEntity;\n\nfinal Route route = extractRequestEntity(entity ->\n  complete(\"Request entity content-type is \" + entity.getContentType())\n);\n\n// tests:\ntestRoute(route).run(\n  HttpRequest.POST(\"/abc\")\n    .withEntity(HttpEntities.create(ContentTypes.TEXT_PLAIN_UTF8, \"req\"))\n).assertEntity(\"Request entity content-type is text/plain; charset=UTF-8\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/extractSettings.html","text":"","title":"extractSettings"},{"location":"/routing-dsl/directives/basic-directives/extractSettings.html#extractsettings","text":"Signature def extractSettings: Directive1[RoutingSettings]","title":"extractSettings"},{"location":"/routing-dsl/directives/basic-directives/extractSettings.html#description","text":"Extracts the RoutingSettingsRoutingSettings from the RequestContextRequestContext.\nBy default the settings of the Http() extension running the route will be returned. It is possible to override the settings for specific sub-routes by using the withSettings directive.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/extractSettings.html#example","text":"Scala copysourceval route =\n  extractSettings { settings: RoutingSettings =>\n    complete(s\"RoutingSettings.renderVanityFooter = ${settings.renderVanityFooter}\")\n  }\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"RoutingSettings.renderVanityFooter = true\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.extractRequestContext;\n\nfinal Route route = extractRequestContext(ctx -> {\n  ctx.getLog().debug(\"Using access to additional context available, like the logger.\");\n  final HttpRequest request = ctx.getRequest();\n  return complete(\"Request method is \" + request.method().name() +\n                    \" and content-type is \" + request.entity().getContentType());\n});\n\n// tests:\ntestRoute(route).run(HttpRequest.POST(\"/\").withEntity(\"text\"))\n  .assertEntity(\"Request method is POST and content-type is text/plain; charset=UTF-8\");\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertEntity(\"Request method is GET and content-type is none/none\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/extractStrictEntity.html","text":"","title":"extractStrictEntity"},{"location":"/routing-dsl/directives/basic-directives/extractStrictEntity.html#extractstrictentity","text":"Signature def extractStrictEntity(timeout: FiniteDuration): Directive1[HttpEntity.Strict] \ndef extractStrictEntity(timeout: FiniteDuration, maxBytes: Long): Directive1[HttpEntity.Strict]","title":"extractStrictEntity"},{"location":"/routing-dsl/directives/basic-directives/extractStrictEntity.html#description","text":"Extracts the strict http entity as HttpEntity.Strict from the RequestContextRequestContext.\nA timeout parameter is given and if the stream isn’t completed after the timeout, the directive will be failed.\nWarning The directive will read the request entity into memory within the size limit(8M by default) and effectively disable streaming. The size limit can be configured globally with pekko.http.parsing.max-content-length or overridden by wrapping with withSizeLimit or withoutSizeLimit directive.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/extractStrictEntity.html#example","text":"Scala copysourceimport scala.concurrent.duration._\n\nval route = extractStrictEntity(3.seconds) { entity =>\n  complete(entity.data.utf8String)\n}\n\n// tests:\nval dataBytes = Source.fromIterator(() => Iterator.range(1, 10).map(x => ByteString(x.toString)))\nPost(\"/\", HttpEntity(ContentTypes.`text/plain(UTF-8)`, data = dataBytes)) ~> route ~> check {\n  responseAs[String] shouldEqual \"123456789\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.extractStrictEntity;\n\nfinal FiniteDuration timeout = FiniteDuration.create(3, TimeUnit.SECONDS);\nfinal Route route = extractStrictEntity(timeout, strict ->\n  complete(strict.getData().utf8String())\n);\n\n// tests:\nfinal Iterator iterator = Arrays.asList(\n  ByteString.fromString(\"1\"),\n  ByteString.fromString(\"2\"),\n  ByteString.fromString(\"3\")).iterator();\nfinal Source<ByteString, NotUsed> dataBytes = Source.fromIterator(() -> iterator);\ntestRoute(route).run(\n  HttpRequest.POST(\"/\")\n    .withEntity(HttpEntities.create(ContentTypes.TEXT_PLAIN_UTF8, dataBytes))\n).assertEntity(\"123\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/extractUnmatchedPath.html","text":"","title":"extractUnmatchedPath"},{"location":"/routing-dsl/directives/basic-directives/extractUnmatchedPath.html#extractunmatchedpath","text":"Signature def extractUnmatchedPath: Directive1[Uri.Path]","title":"extractUnmatchedPath"},{"location":"/routing-dsl/directives/basic-directives/extractUnmatchedPath.html#description","text":"Extracts the unmatched path from the request context.\nThe extractUnmatchedPath directive extracts the remaining path that was not yet matched by any of the PathDirectives (or any custom ones that change the unmatched path field of the request context). You can use it for building directives that handle complete suffixes of paths (like the getFromDirectory directives and similar ones).\nUse mapUnmatchedPath to change the value of the unmatched path.\nSee also extractMatchedPath to see similar directive for matched path.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/extractUnmatchedPath.html#example","text":"Scala copysourceval route =\n  pathPrefix(\"abc\") {\n    extractUnmatchedPath { remaining =>\n      complete(s\"Unmatched: '$remaining'\")\n    }\n  }\n\n// tests:\nGet(\"/abc\") ~> route ~> check {\n  responseAs[String] shouldEqual \"Unmatched: ''\"\n}\nGet(\"/abc/456\") ~> route ~> check {\n  responseAs[String] shouldEqual \"Unmatched: '/456'\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.extractUnmatchedPath;\n\nfinal Route route = pathPrefix(\"abc\", () ->\n  extractUnmatchedPath(remaining ->\n    complete(\"Unmatched: '\" + remaining + \"'\")\n  )\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/abc\"))\n  .assertEntity(\"Unmatched: ''\");\ntestRoute(route).run(HttpRequest.GET(\"/abc/456\"))\n  .assertEntity(\"Unmatched: '/456'\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/extractUri.html","text":"","title":"extractUri"},{"location":"/routing-dsl/directives/basic-directives/extractUri.html#extracturi","text":"Signature def extractUri: Directive1[Uri]","title":"extractUri"},{"location":"/routing-dsl/directives/basic-directives/extractUri.html#description","text":"Access the full URI of the request.\nUse SchemeDirectives, HostDirectives, PathDirectives, and ParameterDirectives for more targeted access to parts of the URI.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/extractUri.html#example","text":"Scala copysourceval route =\n  extractUri { uri =>\n    complete(s\"Full URI: $uri\")\n  }\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  // tests are executed with the host assumed to be \"example.com\"\n  responseAs[String] shouldEqual \"Full URI: http://example.com/\"\n}\nGet(\"/test\") ~> route ~> check {\n  responseAs[String] shouldEqual \"Full URI: http://example.com/test\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.extractUri;\n\nfinal Route route = extractUri(uri ->\n  complete(\"Full URI: \" + uri)\n);\n\n// tests:\n// tests are executed with the host assumed to be \"example.com\"\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertEntity(\"Full URI: http://example.com/\");\ntestRoute(route).run(HttpRequest.GET(\"/test\"))\n  .assertEntity(\"Full URI: http://example.com/test\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/mapInnerRoute.html","text":"","title":"mapInnerRoute"},{"location":"/routing-dsl/directives/basic-directives/mapInnerRoute.html#mapinnerroute","text":"Signature def mapInnerRoute(f: Route","title":"mapInnerRoute"},{"location":"/routing-dsl/directives/basic-directives/mapInnerRoute.html#description","text":"Changes the execution model of the inner route by wrapping it with arbitrary logic.\nThe mapInnerRoute directive is used as a building block for Custom Directives to replace the inner route with any other route. Usually, the returned route wraps the original one with custom execution logic.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/mapInnerRoute.html#example","text":"Scala copysourceval completeWithInnerException =\n  mapInnerRoute { route => ctx =>\n    try {\n      route(ctx)\n    } catch {\n      case NonFatal(e) => ctx.complete(s\"Got ${e.getClass.getSimpleName} '${e.getMessage}'\")\n    }\n  }\n\nval route =\n  completeWithInnerException {\n    complete(throw new IllegalArgumentException(\"BLIP! BLOP! Everything broke\"))\n  }\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"Got IllegalArgumentException 'BLIP! BLOP! Everything broke'\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.mapInnerRoute;\n\n// TODO: implement mapInnerRoute","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/mapRejections.html","text":"","title":"mapRejections"},{"location":"/routing-dsl/directives/basic-directives/mapRejections.html#maprejections","text":"Signature def mapRejections(f: immutable.Seq[Rejection]","title":"mapRejections"},{"location":"/routing-dsl/directives/basic-directives/mapRejections.html#description","text":"Low level directive – unless you’re sure you need to be working on this low-level you might instead want to try the handleRejections directive which provides a nicer DSL for building rejection handlers.\nThe mapRejections directive is used as a building block for Custom Directives to transform a list of rejections from the inner route to a new list of rejections.\nSee Response Transforming Directives for similar directives.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/mapRejections.html#example","text":"Scala copysource// ignore any rejections and replace them by AuthorizationFailedRejection\nval replaceByAuthorizationFailed = mapRejections(_ => List(AuthorizationFailedRejection))\nval route =\n  replaceByAuthorizationFailed {\n    path(\"abc\")(complete(\"abc\"))\n  }\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  rejection shouldEqual AuthorizationFailedRejection\n}\n\nGet(\"/abc\") ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.mapRejections;\n\n// ignore any rejections and replace them by AuthorizationFailedRejection\nfinal Route route = mapRejections(\n  rejections -> Collections.singletonList((Rejection) Rejections.authorizationFailed()),\n  () -> path(\"abc\", () -> complete(\"abc\"))\n);\n\n// tests:\nrunRouteUnSealed(route, HttpRequest.GET(\"/\"))\n  .assertRejections(Rejections.authorizationFailed());\ntestRoute(route).run(HttpRequest.GET(\"/abc\"))\n  .assertStatusCode(StatusCodes.OK);","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/mapRequest.html","text":"","title":"mapRequest"},{"location":"/routing-dsl/directives/basic-directives/mapRequest.html#maprequest","text":"Signature def mapRequest(f: HttpRequest","title":"mapRequest"},{"location":"/routing-dsl/directives/basic-directives/mapRequest.html#description","text":"Transforms the request before it is handled by the inner route.\nThe mapRequest directive is used as a building block for Custom Directives to transform a request before it is handled by the inner route. Changing the request.uri parameter has no effect on path matching in the inner route because the unmatched path is a separate field of the RequestContextRequestContext value which is passed into routes. To change the unmatched path or other fields of the RequestContextRequestContext use the mapRequestContext directive.\nSee Request Transforming Directives for an overview of similar directives.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/mapRequest.html#example","text":"Scala copysourcedef transformToPostRequest(req: HttpRequest): HttpRequest = req.withMethod(HttpMethods.POST)\nval route =\n  mapRequest(transformToPostRequest) {\n    extractRequest { req =>\n      complete(s\"The request method was ${req.method.name}\")\n    }\n  }\n\nGet(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The request method was POST\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.mapRequest;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.extractRequest;\nimport static org.apache.pekko.http.javadsl.server.Directives.mapRequest;\n\nfinal Route route = mapRequest(req ->\n  req.withMethod(HttpMethods.POST), () ->\n  extractRequest(req -> complete(\"The request method was \" + req.method().name()))\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertEntity(\"The request method was POST\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/mapRequestContext.html","text":"","title":"mapRequestContext"},{"location":"/routing-dsl/directives/basic-directives/mapRequestContext.html#maprequestcontext","text":"Signature def mapRequestContext(f: RequestContext","title":"mapRequestContext"},{"location":"/routing-dsl/directives/basic-directives/mapRequestContext.html#description","text":"Transforms the RequestContextRequestContext before it is passed to the inner route.\nThe mapRequestContext directive is used as a building block for Custom Directives to transform the request context before it is passed to the inner route. To change only the request value itself the mapRequest directive can be used instead.\nSee Request Transforming Directives for an overview of similar directives.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/mapRequestContext.html#example","text":"Scala copysourceval replaceRequest =\n  mapRequestContext(_.withRequest(HttpRequest(HttpMethods.POST)))\n\nval route =\n  replaceRequest {\n    extractRequest { req =>\n      complete(req.method.value)\n    }\n  }\n\n// tests:\nGet(\"/abc/def/ghi\") ~> route ~> check {\n  responseAs[String] shouldEqual \"POST\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.extractRequest;\nimport static org.apache.pekko.http.javadsl.server.Directives.mapRequestContext;\n\nfinal Route route = mapRequestContext(ctx ->\n  ctx.withRequest(HttpRequest.create().withMethod(HttpMethods.POST)), () ->\n  extractRequest(req -> complete(req.method().value()))\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/abc/def/ghi\"))\n  .assertEntity(\"POST\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/mapResponse.html","text":"","title":"mapResponse"},{"location":"/routing-dsl/directives/basic-directives/mapResponse.html#mapresponse","text":"Signature def mapResponse(f: HttpResponse","title":"mapResponse"},{"location":"/routing-dsl/directives/basic-directives/mapResponse.html#description","text":"The mapResponse directive is used as a building block for Custom Directives to transform a response that was generated by the inner route. This directive transforms complete responses.\nSee also mapResponseHeaders or mapResponseEntity for more specialized variants and Response Transforming Directives for similar directives.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/mapResponse.html#example-override-status","text":"Scala copysourcedef overwriteResultStatus(response: HttpResponse): HttpResponse =\n  response.withStatus(StatusCodes.BadGateway)\nval route = mapResponse(overwriteResultStatus)(complete(\"abc\"))\n\n// tests:\nGet(\"/abcdef?ghi=12\") ~> route ~> check {\n  status shouldEqual StatusCodes.BadGateway\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.mapResponse;\n\nfinal Route route = mapResponse(\n  response -> response.withStatus(StatusCodes.BAD_GATEWAY),\n  () -> complete(\"abc\")\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/abcdef?ghi=12\"))\n  .assertStatusCode(StatusCodes.BAD_GATEWAY);","title":"Example: Override status"},{"location":"/routing-dsl/directives/basic-directives/mapResponse.html#example-default-to-empty-json-response-on-errors","text":"Scala copysourcetrait ApiRoutes {\n  protected def system: ActorSystem\n\n  private val log = Logging(system, \"ApiRoutes\")\n\n  private val NullJsonEntity = HttpEntity(ContentTypes.`application/json`, \"{}\")\n\n  private def nonSuccessToEmptyJsonEntity(response: HttpResponse): HttpResponse =\n    response.status match {\n      case code if code.isSuccess => response\n      case code =>\n        log.warning(\"Dropping response entity since response status code was: {}\", code)\n        response.withEntity(NullJsonEntity)\n    }\n\n  /** Wrapper for all of our JSON API routes */\n  def apiRoute(innerRoutes: => Route): Route =\n    mapResponse(nonSuccessToEmptyJsonEntity)(innerRoutes)\n}\nval route: Route =\n  apiRoute {\n    get {\n      complete(InternalServerError)\n    }\n  }\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"{}\"\n} Java copysourceclass ApiRoute {\n\n  private final ActorSystem system;\n\n  private final LoggingAdapter log;\n\n  private final HttpEntity nullJsonEntity =\n    HttpEntities.create(ContentTypes.APPLICATION_JSON, \"{}\");\n\n  public ApiRoute(ActorSystem system) {\n    this.system = system;\n    this.log = Logging.getLogger(system, \"ApiRoutes\");\n  }\n\n  private HttpResponse nonSuccessToEmptyJsonEntity(HttpResponse response) {\n    if (response.status().isSuccess()) {\n      return response;\n    } else {\n      log.warning(\n        \"Dropping response entity since response status code was: \" + response.status());\n      return response.withEntity((ResponseEntity) nullJsonEntity);\n    }\n  }\n\n  /** Wrapper for all of our JSON API routes */\n  private Route apiRoute(Supplier<Route> innerRoutes) {\n    return mapResponse(this::nonSuccessToEmptyJsonEntity, innerRoutes);\n  }\n}\n\nfinal ApiRoute api = new ApiRoute(system());\n\nfinal Route route = api.apiRoute(() ->\n  get(() -> complete(StatusCodes.INTERNAL_SERVER_ERROR))\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertEntity(\"{}\");","title":"Example: Default to empty JSON response on errors"},{"location":"/routing-dsl/directives/basic-directives/mapResponseEntity.html","text":"","title":"mapResponseEntity"},{"location":"/routing-dsl/directives/basic-directives/mapResponseEntity.html#mapresponseentity","text":"Signature def mapResponseEntity(f: ResponseEntity","title":"mapResponseEntity"},{"location":"/routing-dsl/directives/basic-directives/mapResponseEntity.html#description","text":"The mapResponseEntity directive is used as a building block for Custom Directives to transform a response entity that was generated by the inner route.\nSee Response Transforming Directives for similar directives.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/mapResponseEntity.html#example","text":"Scala copysourcedef prefixEntity(entity: ResponseEntity): ResponseEntity = entity match {\n  case HttpEntity.Strict(contentType, data) =>\n    HttpEntity.Strict(contentType, ByteString(\"test\") ++ data)\n  case _ => throw new IllegalStateException(\"Unexpected entity type\")\n}\n\nval prefixWithTest: Directive0 = mapResponseEntity(prefixEntity)\nval route = prefixWithTest(complete(\"abc\"))\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"testabc\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.mapResponseEntity;\n\nfinal Function<ResponseEntity, ResponseEntity> prefixEntity = entity -> {\n  if (entity instanceof HttpEntity.Strict) {\n    final HttpEntity.Strict strict = (HttpEntity.Strict) entity;\n    return HttpEntities.create(\n      strict.getContentType(),\n      ByteString.fromString(\"test\").concat(strict.getData()));\n  } else {\n    throw new IllegalStateException(\"Unexpected entity type\");\n  }\n};\n\nfinal Route route = mapResponseEntity(prefixEntity, () -> complete(\"abc\"));\n\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertEntity(\"testabc\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/mapResponseHeaders.html","text":"","title":"mapResponseHeaders"},{"location":"/routing-dsl/directives/basic-directives/mapResponseHeaders.html#mapresponseheaders","text":"Signature def mapResponseHeaders(f: immutable.Seq[HttpHeader]","title":"mapResponseHeaders"},{"location":"/routing-dsl/directives/basic-directives/mapResponseHeaders.html#description","text":"Changes the list of response headers that was generated by the inner route.\nThe mapResponseHeaders directive is used as a building block for Custom Directives to transform the list of response headers that was generated by the inner route.\nSee Response Transforming Directives for similar directives.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/mapResponseHeaders.html#example","text":"Scala copysource// adds all request headers to the response\nval echoRequestHeaders = extract(_.request.headers).flatMap(respondWithHeaders)\n\nval removeIdHeader = mapResponseHeaders(_.filterNot(_.lowercaseName == \"id\"))\nval route =\n  removeIdHeader {\n    echoRequestHeaders {\n      complete(\"test\")\n    }\n  }\n\n// tests:\nGet(\"/\") ~> RawHeader(\"id\", \"12345\") ~> RawHeader(\"id2\", \"67890\") ~> route ~> check {\n  header(\"id\") shouldEqual None\n  header(\"id2\").get.value shouldEqual \"67890\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.mapResponseHeaders;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.respondWithHeaders;\nimport static org.apache.pekko.http.javadsl.server.Directives.mapResponseHeaders;\n\n// adds all request headers to the response\nfinal Route echoRequestHeaders = extract(\n  ctx -> ctx.getRequest().getHeaders(),\n  headers -> respondWithHeaders(headers, () -> complete(\"test\"))\n);\n\nfinal Route route = mapResponseHeaders(headers -> {\n  headers.removeIf(header -> header.lowercaseName().equals(\"id\"));\n  return headers;\n}, () -> echoRequestHeaders);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/\").withHeaders(\n  Arrays.asList(RawHeader.create(\"id\", \"12345\"),RawHeader.create(\"id2\", \"67890\"))))\n  .assertHeaderKindNotExists(\"id\")\n  .assertHeaderExists(\"id2\", \"67890\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/mapRouteResult.html","text":"","title":"mapRouteResult"},{"location":"/routing-dsl/directives/basic-directives/mapRouteResult.html#maprouteresult","text":"Signature def mapRouteResult(f: RouteResult","title":"mapRouteResult"},{"location":"/routing-dsl/directives/basic-directives/mapRouteResult.html#description","text":"Changes the message the inner route sends to the responder.\nThe mapRouteResult directive is used as a building block for Custom Directives to transform the RouteResult coming back from the inner route.\nSee Result Transformation Directives for similar directives.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/mapRouteResult.html#example","text":"Scala copysourceval rejectAll = // not particularly useful directive\n  mapRouteResult {\n    case _ => Rejected(List(AuthorizationFailedRejection))\n  }\nval route =\n  rejectAll {\n    complete(\"abc\")\n  }\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  rejections.nonEmpty shouldEqual true\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.mapRouteResult;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.mapRouteResult;\n\n// this directive is a joke, don't do that :-)\nfinal Route route = mapRouteResult(r -> {\n  if (r instanceof Complete) {\n    final HttpResponse response = ((Complete) r).getResponse();\n    return RouteResults.complete(response.withStatus(200));\n  } else {\n    return r;\n  }\n}, () -> complete(StatusCodes.ACCEPTED));\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertStatusCode(StatusCodes.OK);\nfinal Route route = mapRouteResult(rr -> {\n  final Iterable<Rejection> rejections = Collections.singletonList(Rejections.authorizationFailed());\n  return RouteResults.rejected(rejections);\n}, () -> complete(\"abc\"));\n\n// tests:\nrunRouteUnSealed(route, HttpRequest.GET(\"/\"))\n  .assertRejections(Rejections.authorizationFailed());","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/mapRouteResultFuture.html","text":"","title":"mapRouteResultFuture"},{"location":"/routing-dsl/directives/basic-directives/mapRouteResultFuture.html#maprouteresultfuture","text":"Signature def mapRouteResultFuture(f: Future[RouteResult]","title":"mapRouteResultFuture"},{"location":"/routing-dsl/directives/basic-directives/mapRouteResultFuture.html#description","text":"Asynchronous version of mapRouteResult.\nIt’s similar to mapRouteResultWith, however it’s Future[RouteResult] => Future[RouteResult]Function<CompletionStage<RouteResult>, CompletionStage<RouteResult>> instead of RouteResult => Future[RouteResult]Function<RouteResult, CompletionStage<RouteResult>> which may be useful when combining multiple transformations and / or wanting to recover from a failed route result.\nSee Result Transformation Directives for similar directives.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/mapRouteResultFuture.html#example","text":"Scala copysourceval tryRecoverAddServer = mapRouteResultFuture { fr =>\n  fr.recover {\n    case ex: IllegalArgumentException =>\n      Complete(HttpResponse(StatusCodes.InternalServerError))\n  }.map {\n    case Complete(res) => Complete(res.addHeader(Server(\"MyServer 1.0\")))\n    case rest          => rest\n  }\n}\n\nval route =\n  tryRecoverAddServer {\n    complete(\"Hello world!\")\n  }\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n  header[Server] shouldEqual Some(Server(\"MyServer 1.0\"))\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.mapRouteResultFuture;\n\nfinal Route route = mapRouteResultFuture(cr ->\n  cr.exceptionally(t -> {\n    if (t instanceof IllegalArgumentException) {\n      return RouteResults.complete(\n        HttpResponse.create().withStatus(StatusCodes.INTERNAL_SERVER_ERROR));\n    } else {\n      return null;\n    }\n  }).thenApply(rr -> {\n    if (rr instanceof Complete) {\n      final HttpResponse res = ((Complete) rr).getResponse();\n      return RouteResults.complete(\n        res.addHeader(Server.create(ProductVersion.create(\"MyServer\", \"1.0\"))));\n    } else {\n      return rr;\n    }\n  }), () -> complete(\"Hello world!\"));\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertStatusCode(StatusCodes.OK)\n  .assertHeaderExists(Server.create(ProductVersion.create(\"MyServer\", \"1.0\")));","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/mapRouteResultPF.html","text":"","title":"mapRouteResultPF"},{"location":"/routing-dsl/directives/basic-directives/mapRouteResultPF.html#maprouteresultpf","text":"Signature def mapRouteResultPF(f: PartialFunction[RouteResult, RouteResult]): Directive0","title":"mapRouteResultPF"},{"location":"/routing-dsl/directives/basic-directives/mapRouteResultPF.html#description","text":"Partial Function version of mapRouteResult.\nChanges the message the inner route sends to the responder.\nThe mapRouteResult directive is used as a building block for Custom Directives to transform the RouteResult coming back from the inner route. It’s similar to the mapRouteResult directive but allows to specify a partial function that doesn’t have to handle all potential RouteResultRouteResult instances.\nSee Result Transformation Directives for similar directives.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/mapRouteResultPF.html#example","text":"Scala copysourcecase object MyCustomRejection extends Rejection\nval rejectRejections = // not particularly useful directive\n  mapRouteResultPF {\n    case Rejected(_) => Rejected(List(AuthorizationFailedRejection))\n  }\nval route =\n  rejectRejections {\n    reject(MyCustomRejection)\n  }\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  rejection shouldEqual AuthorizationFailedRejection\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.mapRouteResultPF;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.mapRouteResultPF;\nimport static org.apache.pekko.http.javadsl.server.Directives.reject;\n\nfinal Route route = mapRouteResultPF(\n  new PFBuilder<RouteResult, RouteResult>()\n    .match(Rejected.class, rejected -> {\n      final Iterable<Rejection> rejections =\n        Collections.singletonList(Rejections.authorizationFailed());\n      return RouteResults.rejected(rejections);\n    }).build(), () -> reject(new MyCustomRejection()));\n\n// tests:\nrunRouteUnSealed(route, HttpRequest.GET(\"/\"))\n  .assertRejections(Rejections.authorizationFailed());","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/mapRouteResultWithPF.html","text":"","title":"mapRouteResultWithPF"},{"location":"/routing-dsl/directives/basic-directives/mapRouteResultWithPF.html#maprouteresultwithpf","text":"Signature def mapRouteResultWithPF(f: PartialFunction[RouteResult, Future[RouteResult]]): Directive0","title":"mapRouteResultWithPF"},{"location":"/routing-dsl/directives/basic-directives/mapRouteResultWithPF.html#description","text":"Asynchronous variant of mapRouteResultPF.\nChanges the message the inner route sends to the responder.\nThe mapRouteResult directive is used as a building block for Custom Directives to transform the RouteResult coming back from the inner route.\nSee Result Transformation Directives for similar directives.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/mapRouteResultWithPF.html#example","text":"Scala copysourcecase object MyCustomRejection extends Rejection\nval rejectRejections = // not particularly useful directive\n  mapRouteResultWithPF {\n    case Rejected(_) => Future(Rejected(List(AuthorizationFailedRejection)))\n  }\nval route =\n  rejectRejections {\n    reject(MyCustomRejection)\n  }\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  rejection shouldEqual AuthorizationFailedRejection\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.mapRouteResultWithPF;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.mapRouteResultWithPF;\nimport static org.apache.pekko.http.javadsl.server.Directives.reject;\n\nfinal Route route = mapRouteResultWithPF(\n  new PFBuilder<RouteResult, CompletionStage<RouteResult>>()\n  .match(Rejected.class, rejected -> CompletableFuture.supplyAsync(() -> {\n    final Iterable<Rejection> rejections =\n      Collections.singletonList(Rejections.authorizationFailed());\n    return RouteResults.rejected(rejections);\n  })\n).build(), () -> reject(new MyCustomRejection()));\n\n// tests:\nrunRouteUnSealed(route, HttpRequest.GET(\"/\"))\n  .assertRejections(Rejections.authorizationFailed());","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/mapRouteResultWith.html","text":"","title":"mapRouteResultWith"},{"location":"/routing-dsl/directives/basic-directives/mapRouteResultWith.html#maprouteresultwith","text":"Signature def mapRouteResultWith(f: RouteResult","title":"mapRouteResultWith"},{"location":"/routing-dsl/directives/basic-directives/mapRouteResultWith.html#description","text":"Changes the message the inner route sends to the responder.\nThe mapRouteResult directive is used as a building block for Custom Directives to transform the RouteResult coming back from the inner route. It’s similar to the mapRouteResult directive but returning a FutureCompletionStage instead of a result immediately, which may be useful for longer running transformations.\nSee Result Transformation Directives for similar directives.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/mapRouteResultWith.html#example","text":"Scala copysourcecase object MyCustomRejection extends Rejection\nval rejectRejections = // not particularly useful directive\n  mapRouteResultWith {\n    case Rejected(_) => Future(Rejected(List(AuthorizationFailedRejection)))\n    case res         => Future(res)\n  }\nval route =\n  rejectRejections {\n    reject(MyCustomRejection)\n  }\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  rejection shouldEqual AuthorizationFailedRejection\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.mapRouteResultWith;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.mapRouteResultWith;\nimport static org.apache.pekko.http.javadsl.server.Directives.reject;\n\nfinal Route route = mapRouteResultWith(rr -> CompletableFuture.supplyAsync(() -> {\n  if (rr instanceof Rejected) {\n    final Iterable<Rejection> rejections =\n      Collections.singletonList(Rejections.authorizationFailed());\n    return RouteResults.rejected(rejections);\n  } else {\n    return rr;\n  }\n}), () -> reject(new MyCustomRejection()));\n\n// tests:\nrunRouteUnSealed(route, HttpRequest.GET(\"/\"))\n  .assertRejections(Rejections.authorizationFailed());","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/mapSettings.html","text":"","title":"mapSettings"},{"location":"/routing-dsl/directives/basic-directives/mapSettings.html#mapsettings","text":"Signature def mapSettings(f: RoutingSettings","title":"mapSettings"},{"location":"/routing-dsl/directives/basic-directives/mapSettings.html#description","text":"Transforms the RoutingSettingsRoutingSettings with a RoutingSettings => RoutingSettings functionFunction<RoutingSettings, RoutingSettings>.\nSee also withSettings or extractSettings.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/mapSettings.html#example","text":"Scala copysourceval tunedSettings = mapSettings { settings =>\n  settings.withFileGetConditional(false)\n}\n\nval route =\n  tunedSettings {\n    extractSettings { settings: RoutingSettings =>\n      complete(s\"RoutingSettings.fileGetConditional = ${settings.fileGetConditional}\")\n    }\n  }\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual s\"RoutingSettings.fileGetConditional = false\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.mapSettings;\n\nfinal Route route = mapSettings(settings ->\n  settings.withFileGetConditional(false), () ->\n  extractSettings(settings ->\n    complete(\"RoutingSettings.fileGetConditional = \" + settings.getFileGetConditional())\n  )\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertEntity(\"RoutingSettings.fileGetConditional = false\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/mapUnmatchedPath.html","text":"","title":"mapUnmatchedPath"},{"location":"/routing-dsl/directives/basic-directives/mapUnmatchedPath.html#mapunmatchedpath","text":"Signature def mapUnmatchedPath(f: Uri.Path","title":"mapUnmatchedPath"},{"location":"/routing-dsl/directives/basic-directives/mapUnmatchedPath.html#description","text":"Transforms the unmatchedPath field of the request context for inner routes.\nThe mapUnmatchedPath directive is used as a building block for writing Custom Directives. You can use it for implementing custom path matching directives.\nUse extractUnmatchedPath for extracting the current value of the unmatched path.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/mapUnmatchedPath.html#example","text":"Scala copysourcedef ignore456(path: Uri.Path) = path match {\n  case s @ Uri.Path.Segment(head, tail) if head.startsWith(\"456\") =>\n    val newHead = head.drop(3)\n    if (newHead.isEmpty) tail\n    else s.copy(head = head.drop(3))\n  case _ => path\n}\nval ignoring456 = mapUnmatchedPath(ignore456)\n\nval route =\n  pathPrefix(\"123\") {\n    ignoring456 {\n      path(\"abc\") {\n        complete(\"Content\")\n      }\n    }\n  }\n\n// tests:\nGet(\"/123/abc\") ~> route ~> check {\n  responseAs[String] shouldEqual \"Content\"\n}\nGet(\"/123456/abc\") ~> route ~> check {\n  responseAs[String] shouldEqual \"Content\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.mapUnmatchedPath;\n\nfinal Function<String, String> ignore456 = path -> {\n  int slashPos = path.indexOf(\"/\");\n  if (slashPos != -1) {\n    String head = path.substring(0, slashPos);\n    String tail = path.substring(slashPos);\n    if (head.length() <= 3) {\n      return tail;\n    } else {\n      return path.substring(3);\n    }\n  } else {\n    return path;\n  }\n};\n\nfinal Route route = pathPrefix(\"123\", () ->\n  mapUnmatchedPath(ignore456, () ->\n    path(\"abc\", () ->\n      complete(\"Content\")\n    )\n  )\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/123/abc\"))\n  .assertEntity(\"Content\");\ntestRoute(route).run(HttpRequest.GET(\"/123456/abc\"))\n  .assertEntity(\"Content\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/pass.html","text":"","title":"pass"},{"location":"/routing-dsl/directives/basic-directives/pass.html#pass","text":"Signature def pass: Directive0","title":"pass"},{"location":"/routing-dsl/directives/basic-directives/pass.html#description","text":"A directive that passes the request unchanged to its inner route.\nIt is usually used as a “neutral element” when combining directives generically.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/pass.html#example","text":"Scala copysourceval route = pass(complete(\"abc\"))\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"abc\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.pass;\n\nfinal Route route = pass(() -> complete(\"abc\"));\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertEntity(\"abc\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/provide.html","text":"","title":"provide"},{"location":"/routing-dsl/directives/basic-directives/provide.html#provide","text":"Signature def provide[T](value: T): Directive1[T]","title":"provide"},{"location":"/routing-dsl/directives/basic-directives/provide.html#description","text":"Provides a constant value to the inner route.\nThe provide directive is used as a building block for Custom Directives to provide a single value to the inner route. To provide several values use the tprovide directive.\nSee Providing Values to Inner Routes for an overview of similar directives.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/provide.html#example","text":"Scala copysourcedef providePrefixedString(value: String): Directive1[String] = provide(\"prefix:\" + value)\nval route =\n  providePrefixedString(\"test\") { value =>\n    complete(value)\n  }\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"prefix:test\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.provide;\n\nfinal Route route = providePrefixedStringRoute(\"test\");\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertEntity(\"prefix:test\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/recoverRejections.html","text":"","title":"recoverRejections"},{"location":"/routing-dsl/directives/basic-directives/recoverRejections.html#recoverrejections","text":"Signature def recoverRejections(f: immutable.Seq[Rejection]","title":"recoverRejections"},{"location":"/routing-dsl/directives/basic-directives/recoverRejections.html#description","text":"Low level directive – unless you’re sure you need to be working on this low-level you might instead want to try the handleRejections directive which provides a nicer DSL for building rejection handlers.\nTransforms rejections from the inner route with an immutable.Seq[Rejection] => RouteResult function. a Function<Iterable<Rejection>, RouteResult>. A RouteResultRouteResult is either a Complete(HttpResponse(...)) Complete containing the HttpResponseHttpResponse or a Rejected(rejections). Rejected containing the rejections.\nNote To learn more about how and why rejections work read the Rejections section of the documentation.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/recoverRejections.html#example","text":"Scala copysourceval authRejectionsToNothingToSeeHere = recoverRejections { rejections =>\n  if (rejections.exists(_.isInstanceOf[AuthenticationFailedRejection]))\n    Complete(HttpResponse(entity = \"Nothing to see here, move along.\"))\n  else if (rejections == Nil) // see \"Empty Rejections\" for more details\n    Complete(HttpResponse(StatusCodes.NotFound, entity = \"Literally nothing to see here.\"))\n  else\n    Rejected(rejections)\n}\nval neverAuth: Authenticator[String] = creds => None\nval alwaysAuth: Authenticator[String] = creds => Some(\"id\")\n\nval route =\n  authRejectionsToNothingToSeeHere {\n    pathPrefix(\"auth\") {\n      concat(\n        path(\"never\") {\n          authenticateBasic(\"my-realm\", neverAuth) { user =>\n            complete(\"Welcome to the bat-cave!\")\n          }\n        },\n        path(\"always\") {\n          authenticateBasic(\"my-realm\", alwaysAuth) { user =>\n            complete(\"Welcome to the secret place!\")\n          }\n        })\n    }\n  }\n\n// tests:\nGet(\"/auth/never\") ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n  responseAs[String] shouldEqual \"Nothing to see here, move along.\"\n}\nGet(\"/auth/always\") ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n  responseAs[String] shouldEqual \"Welcome to the secret place!\"\n}\nGet(\"/auth/does_not_exist\") ~> route ~> check {\n  status shouldEqual StatusCodes.NotFound\n  responseAs[String] shouldEqual \"Literally nothing to see here.\"\n} Java copysourceimport org.apache.pekko.http.javadsl.server.directives.SecurityDirectives.ProvidedCredentials;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.authenticateBasic;\nimport static org.apache.pekko.http.javadsl.server.Directives.recoverRejections;\n\nfinal Function<Optional<ProvidedCredentials>, Optional<Object>> neverAuth =\n  creds -> Optional.empty();\nfinal Function<Optional<ProvidedCredentials>, Optional<Object>> alwaysAuth =\n  creds -> Optional.of(\"id\");\n\nfinal Route originalRoute = pathPrefix(\"auth\", () ->\n  Directives.concat(\n    path(\"never\", () ->\n      authenticateBasic(\"my-realm\", neverAuth, obj ->  complete(\"Welcome to the bat-cave!\"))\n    ),\n    path(\"always\", () ->\n      authenticateBasic(\"my-realm\", alwaysAuth, obj -> complete(\"Welcome to the secret place!\"))\n    )\n  )\n);\n\nfinal Function<Iterable<Rejection>, Boolean> existsAuthenticationFailedRejection =\n  rejections ->\n    StreamSupport.stream(rejections.spliterator(), false)\n      .anyMatch(r -> r instanceof AuthenticationFailedRejection);\n\nfinal Route route = recoverRejections(rejections -> {\n  if (existsAuthenticationFailedRejection.apply(rejections)) {\n    return RouteResults.complete(\n      HttpResponse.create().withEntity(\"Nothing to see here, move along.\"));\n  } else if (!rejections.iterator().hasNext()) { // see \"Empty Rejections\" for more details\n    return RouteResults.complete(\n        HttpResponse.create().withStatus(StatusCodes.NOT_FOUND)\n          .withEntity(\"Literally nothing to see here.\"));\n  } else {\n    return RouteResults.rejected(rejections);\n  }\n}, () -> originalRoute);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/auth/never\"))\n  .assertStatusCode(StatusCodes.OK)\n  .assertEntity(\"Nothing to see here, move along.\");\ntestRoute(route).run(HttpRequest.GET(\"/auth/always\"))\n  .assertStatusCode(StatusCodes.OK)\n  .assertEntity(\"Welcome to the secret place!\");\ntestRoute(route).run(HttpRequest.GET(\"/auth/does_not_exist\"))\n  .assertStatusCode(StatusCodes.NOT_FOUND)\n  .assertEntity(\"Literally nothing to see here.\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/recoverRejectionsWith.html","text":"","title":"recoverRejectionsWith"},{"location":"/routing-dsl/directives/basic-directives/recoverRejectionsWith.html#recoverrejectionswith","text":"Signature def recoverRejectionsWith(f: immutable.Seq[Rejection]","title":"recoverRejectionsWith"},{"location":"/routing-dsl/directives/basic-directives/recoverRejectionsWith.html#description","text":"Low level directive – unless you’re sure you need to be working on this low-level you might instead want to try the handleRejections directive which provides a nicer DSL for building rejection handlers.\nTransforms rejections from the inner route with an immutable.Seq[Rejection] => Future[RouteResult] functiona Function<Iterable<Rejection>, CompletionStage<RouteResult>>.\nAsynchronous version of recoverRejections.\nSee recoverRejections (the synchronous equivalent of this directive) for a detailed description.\nNote To learn more about how and why rejections work read the Rejections section of the documentation.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/recoverRejectionsWith.html#example","text":"Scala copysourceval authRejectionsToNothingToSeeHere = recoverRejectionsWith { rejections =>\n  Future {\n    // imagine checking rejections takes a longer time:\n    if (rejections.exists(_.isInstanceOf[AuthenticationFailedRejection]))\n      Complete(HttpResponse(entity = \"Nothing to see here, move along.\"))\n    else\n      Rejected(rejections)\n  }\n}\nval neverAuth: Authenticator[String] = creds => None\n\nval route =\n  authRejectionsToNothingToSeeHere {\n    pathPrefix(\"auth\") {\n      path(\"never\") {\n        authenticateBasic(\"my-realm\", neverAuth) { user =>\n          complete(\"Welcome to the bat-cave!\")\n        }\n      }\n    }\n  }\n\n// tests:\nGet(\"/auth/never\") ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n  responseAs[String] shouldEqual \"Nothing to see here, move along.\"\n} Java copysourceimport org.apache.pekko.http.javadsl.server.directives.SecurityDirectives.ProvidedCredentials;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.authenticateBasic;\nimport static org.apache.pekko.http.javadsl.server.Directives.recoverRejectionsWith;\n\nfinal Function<Optional<ProvidedCredentials>, Optional<Object>> neverAuth =\n  creds -> Optional.empty();\n\nfinal Route originalRoute = pathPrefix(\"auth\", () ->\n  path(\"never\", () ->\n    authenticateBasic(\"my-realm\", neverAuth, obj ->  complete(\"Welcome to the bat-cave!\"))\n  )\n);\n\nfinal Function<Iterable<Rejection>, Boolean> existsAuthenticationFailedRejection =\n  rejections ->\n    StreamSupport.stream(rejections.spliterator(), false)\n      .anyMatch(r -> r instanceof AuthenticationFailedRejection);\n\nfinal Route route = recoverRejectionsWith(\n  rejections -> CompletableFuture.supplyAsync(() -> {\n    if (existsAuthenticationFailedRejection.apply(rejections)) {\n      return RouteResults.complete(\n          HttpResponse.create().withEntity(\"Nothing to see here, move along.\"));\n    } else {\n      return RouteResults.rejected(rejections);\n    }\n}), () -> originalRoute);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/auth/never\"))\n  .assertStatusCode(StatusCodes.OK)\n  .assertEntity(\"Nothing to see here, move along.\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/textract.html","text":"The textract directive is not available in the Java API.\ntextract Signature def textract[L: Tuple](f: RequestContext Description Extracts a tuple of values from the request context and provides them to the inner route. The textract directive is used as a building block for Custom Directives to extract data from the RequestContextRequestContext and provide it to the inner route. To extract just one value use the extract directive. To provide a constant value independent of the RequestContextRequestContext use the tprovide directive instead. See Providing Values to Inner Routes for an overview of similar directives. See also extract for extracting a single value. Example copysourceval pathAndQuery = textract { ctx =>\n  val uri = ctx.request.uri\n  (uri.path, uri.query())\n}\nval route =\n  pathAndQuery { (p, query) =>\n    complete(s\"The path is $p and the query is $query\")\n  }\n\n// tests:\nGet(\"/abcdef?ghi=12\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The path is /abcdef and the query is ghi=12\"\n}","title":"textract"},{"location":"/routing-dsl/directives/basic-directives/toStrictEntity.html","text":"","title":"toStrictEntity"},{"location":"/routing-dsl/directives/basic-directives/toStrictEntity.html#tostrictentity","text":"Signature def toStrictEntity(timeout: FiniteDuration): Directive0 \ndef toStrictEntity(timeout: FiniteDuration, maxBytes: Long): Directive0","title":"toStrictEntity"},{"location":"/routing-dsl/directives/basic-directives/toStrictEntity.html#description","text":"Transforms the request entity to strict entity before it is handled by the inner route.\nA timeout parameter is given and if the stream isn’t completed after the timeout, the directive will be failed.\nWarning The directive will read the request entity into memory within the size limit(8M by default) and effectively disable streaming. The size limit can be configured globally with pekko.http.parsing.max-content-length or overridden by wrapping with withSizeLimit or withoutSizeLimit directive.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/toStrictEntity.html#example","text":"Scala copysourceimport scala.concurrent.duration._\n\nval route = toStrictEntity(3.seconds) {\n  extractRequest { req =>\n    req.entity match {\n      case strict: HttpEntity.Strict =>\n        complete(s\"Request entity is strict, data=${strict.data.utf8String}\")\n      case _ =>\n        complete(\"Ooops, request entity is not strict!\")\n    }\n  }\n}\n\n// tests:\nval dataBytes = Source.fromIterator(() => Iterator.range(1, 10).map(x => ByteString(x.toString)))\nPost(\"/\", HttpEntity(ContentTypes.`text/plain(UTF-8)`, data = dataBytes)) ~> route ~> check {\n  responseAs[String] shouldEqual \"Request entity is strict, data=123456789\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.toStrictEntity;\n\nfinal FiniteDuration timeout = FiniteDuration.create(3, TimeUnit.SECONDS);\nfinal Route route = toStrictEntity(timeout, () ->\n  extractRequest(req -> {\n    if (req.entity() instanceof HttpEntity.Strict) {\n      final HttpEntity.Strict strict = (HttpEntity.Strict)req.entity();\n      return complete(\"Request entity is strict, data=\" + strict.getData().utf8String());\n    } else {\n      return complete(\"Ooops, request entity is not strict!\");\n    }\n  })\n);\n\n// tests:\nfinal Iterator iterator = Arrays.asList(\n  ByteString.fromString(\"1\"),\n  ByteString.fromString(\"2\"),\n  ByteString.fromString(\"3\")).iterator();\nfinal Source<ByteString, NotUsed> dataBytes = Source.fromIterator(() -> iterator);\ntestRoute(route).run(\n  HttpRequest.POST(\"/\")\n    .withEntity(HttpEntities.create(ContentTypes.TEXT_PLAIN_UTF8, dataBytes))\n).assertEntity(\"Request entity is strict, data=123\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/tprovide.html","text":"The tprovide directive is not available in the Java API.\ntprovide Signature def tprovide[L: Tuple](values: L): Directive[L] Description Provides a tuple of values to the inner route. The tprovide directive is used as a building block for Custom Directives to provide data to the inner route. To provide just one value use the provide directive. If you want to provide values calculated from the RequestContextRequestContext use the textract directive instead. See Providing Values to Inner Routes for an overview of similar directives. See also provide for providing a single value. Example copysourcedef provideStringAndLength(value: String) = tprovide((value, value.length))\nval route =\n  provideStringAndLength(\"test\") { (value, len) =>\n    complete(s\"Value is $value and its length is $len\")\n  }\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"Value is test and its length is 4\"\n}","title":"tprovide"},{"location":"/routing-dsl/directives/basic-directives/withExecutionContext.html","text":"","title":"withExecutionContext"},{"location":"/routing-dsl/directives/basic-directives/withExecutionContext.html#withexecutioncontext","text":"Signature def withExecutionContext(ec: ExecutionContextExecutor): Directive0","title":"withExecutionContext"},{"location":"/routing-dsl/directives/basic-directives/withExecutionContext.html#description","text":"Allows running an inner route using an alternative ExecutionContextExecutor in place of the default one.\nThe execution context can be extracted in an inner route using extractExecutionContext directly, or used by directives which internally extract the materializer without surfacing this fact in the API.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/withExecutionContext.html#example","text":"Scala copysourceval special = system.dispatchers.lookup(\"special\")\n\ndef sample() =\n  path(\"sample\") {\n    extractExecutionContext { implicit executor =>\n      complete {\n        Future(s\"Run on ${executor.##}!\") // uses the `executor` ExecutionContext\n      }\n    }\n  }\n\nval route =\n  pathPrefix(\"special\") {\n    withExecutionContext(special) {\n      sample() // `special` execution context will be used\n    }\n  } ~ sample() // default execution context will be used\n\n// tests:\nGet(\"/sample\") ~> route ~> check {\n  responseAs[String] shouldEqual s\"Run on ${system.dispatcher.##}!\"\n}\nGet(\"/special/sample\") ~> route ~> check {\n  responseAs[String] shouldEqual s\"Run on ${special.##}!\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.withExecutionContext;\n\n\nfinal ExecutionContextExecutor special =\n  ExecutionContexts.fromExecutor(Executors.newFixedThreadPool(1));\n\nfinal Route sample = path(\"sample\", () ->\n  extractExecutionContext(executor ->\n    onSuccess(() ->\n      CompletableFuture.supplyAsync(() ->\n        \"Run on \" + executor.hashCode() + \"!\", executor\n      ), Directives::complete\n    )\n  )\n);\n\nfinal Route route = Directives.concat(\n  pathPrefix(\"special\", () ->\n    // `special` execution context will be used\n    withExecutionContext(special, () -> sample)\n  ),\n  sample // default execution context will be used\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/sample\"))\n  .assertEntity(\"Run on \" + system().dispatcher().hashCode() + \"!\");\ntestRoute(route).run(HttpRequest.GET(\"/special/sample\"))\n  .assertEntity(\"Run on \" + special.hashCode() + \"!\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/withLog.html","text":"","title":"withLog"},{"location":"/routing-dsl/directives/basic-directives/withLog.html#withlog","text":"Signature def withLog(log: LoggingAdapter): Directive0","title":"withLog"},{"location":"/routing-dsl/directives/basic-directives/withLog.html#description","text":"Allows running an inner route using an alternative LoggingAdapterLoggingAdapter in place of the default one.\nThe logging adapter can be extracted in an inner route using extractLog directly, or used by directives which internally extract the materializer without surfacing this fact in the API.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/withLog.html#example","text":"Scala copysourceval special = Logging(system, \"SpecialRoutes\")\n\ndef sample() =\n  path(\"sample\") {\n    extractLog { implicit log =>\n      complete {\n        val msg = s\"Logging using $log!\"\n        log.debug(msg)\n        msg\n      }\n    }\n  }\n\nval route =\n  pathPrefix(\"special\") {\n    withLog(special) {\n      sample() // `special` logging adapter will be used\n    }\n  } ~ sample() // default logging adapter will be used\n\n// tests:\nGet(\"/sample\") ~> route ~> check {\n  responseAs[String] shouldEqual s\"Logging using ${system.log}!\"\n}\nGet(\"/special/sample\") ~> route ~> check {\n  responseAs[String] shouldEqual s\"Logging using $special!\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.withLog;\n\nfinal LoggingAdapter special = Logging.getLogger(system(), \"SpecialRoutes\");\n\nfinal Route sample = path(\"sample\", () ->\n  extractLog(log -> {\n    final String msg = \"Logging using \" + log + \"!\";\n    log.debug(msg);\n    return complete(msg);\n  }\n  )\n);\n\nfinal Route route = Directives.concat(\n  pathPrefix(\"special\", () ->\n    withLog(special, () -> sample)\n  ),\n  sample\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/sample\"))\n  .assertEntity(\"Logging using \" + system().log() + \"!\");\n\ntestRoute(route).run(HttpRequest.GET(\"/special/sample\"))\n  .assertEntity(\"Logging using \" + special + \"!\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/withMaterializer.html","text":"","title":"withMaterializer"},{"location":"/routing-dsl/directives/basic-directives/withMaterializer.html#withmaterializer","text":"Signature def withMaterializer(materializer: Materializer): Directive0","title":"withMaterializer"},{"location":"/routing-dsl/directives/basic-directives/withMaterializer.html#description","text":"Allows running an inner route using an alternative MaterializerMaterializer in place of the default one.\nThe materializer can be extracted in an inner route using extractMaterializer directly, or used by directives which internally extract the materializer without surfacing this fact in the API (e.g. responding with a Chunked entity).","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/withMaterializer.html#example","text":"Scala copysourceval special = Materializer(system).withNamePrefix(\"special\")\n\ndef sample() =\n  path(\"sample\") {\n    extractMaterializer { mat =>\n      complete {\n        // explicitly use the materializer:\n        Source.single(s\"Materialized by ${mat.##}!\")\n          .runWith(Sink.head)(mat)\n      }\n    }\n  }\n\nval route =\n  pathPrefix(\"special\") {\n    withMaterializer(special) {\n      sample() // `special` materializer will be used\n    }\n  } ~ sample() // default materializer will be used\n\n// tests:\nGet(\"/sample\") ~> route ~> check {\n  responseAs[String] shouldEqual s\"Materialized by ${SystemMaterializer(system).materializer.##}!\"\n}\nGet(\"/special/sample\") ~> route ~> check {\n  responseAs[String] shouldEqual s\"Materialized by ${special.##}!\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.withMaterializer;\n\nfinal ActorMaterializerSettings settings = ActorMaterializerSettings.create(system());\nfinal ActorMaterializer special = ActorMaterializer.create(settings, system(), \"special\");\n\nfinal Route sample = path(\"sample\", () ->\n  extractMaterializer(mat ->\n    onSuccess(() ->\n      // explicitly use the materializer:\n      Source.single(\"Materialized by \" + mat.hashCode() + \"!\")\n        .runWith(Sink.head(), mat), Directives::complete\n    )\n  )\n);\n\nfinal Route route = Directives.concat(\n  pathPrefix(\"special\", () ->\n    withMaterializer(special, () -> sample) // `special` materializer will be used\n  ),\n  sample // default materializer will be used\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/sample\"))\n  .assertEntity(\"Materialized by \" + materializer().hashCode()+ \"!\");\ntestRoute(route).run(HttpRequest.GET(\"/special/sample\"))\n  .assertEntity(\"Materialized by \" + special.hashCode()+ \"!\");","title":"Example"},{"location":"/routing-dsl/directives/basic-directives/withSettings.html","text":"","title":"withSettings"},{"location":"/routing-dsl/directives/basic-directives/withSettings.html#withsettings","text":"Signature def withSettings(settings: RoutingSettings): Directive0","title":"withSettings"},{"location":"/routing-dsl/directives/basic-directives/withSettings.html#description","text":"Allows running an inner route using an alternative RoutingSettingsRoutingSettings in place of the default one.\nThe execution context can be extracted in an inner route using extractSettings directly, or used by directives which internally extract the materializer without surfacing this fact in the API.","title":"Description"},{"location":"/routing-dsl/directives/basic-directives/withSettings.html#example","text":"Scala copysourceval special = RoutingSettings(system).withFileGetConditional(false)\n\ndef sample() =\n  path(\"sample\") {\n    // internally uses fileGetConditional setting\n    getFromFile(\"example.json\")\n  }\n\nval route =\n  get {\n    pathPrefix(\"special\") {\n      withSettings(special) {\n        sample() // ETag/`If-Modified-Since` disabled\n      }\n    } ~ sample() // ETag/`If-Modified-Since` enabled\n  }\n\n// tests:\nPost(\"/special/sample\") ~> route ~> check {\n  responseAs[String] shouldEqual s\"{}\"\n}\nGet(\"/sample\") ~> route ~> check {\n  responseAs[String] shouldEqual \"{}\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.withSettings;\n\nfinal RoutingSettings special =\n  RoutingSettings\n    .create(system().settings().config())\n    .withFileGetConditional(false);\n\n// internally uses fileGetConditional setting\nfinal Route sample = path(\"sample\", () -> getFromFile(\"example.json\"));\n\nfinal Route route = get(() ->\n  Directives.concat(\n    pathPrefix(\"special\", () ->\n      // ETag/`If-Modified-Since` disabled\n      withSettings(special, () -> sample)\n    ),\n    sample // ETag/`If-Modified-Since` enabled\n  )\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/special/sample\"))\n  .assertEntity(\"{}\");\ntestRoute(route).run(HttpRequest.GET(\"/sample\"))\n  .assertEntity(\"{}\");","title":"Example"},{"location":"/routing-dsl/directives/cache-condition-directives/index.html","text":"","title":"CacheConditionDirectives"},{"location":"/routing-dsl/directives/cache-condition-directives/index.html#cacheconditiondirectives","text":"conditional","title":"CacheConditionDirectives"},{"location":"/routing-dsl/directives/cache-condition-directives/conditional.html","text":"","title":"conditional"},{"location":"/routing-dsl/directives/cache-condition-directives/conditional.html#conditional","text":"Signature def conditional(eTag: EntityTag): Directive0 \ndef conditional(lastModified: DateTime): Directive0 \ndef conditional(eTag: EntityTag, lastModified: DateTime): Directive0 \ndef conditional(eTag: Option[EntityTag], lastModified: Option[DateTime]): Directive0","title":"conditional"},{"location":"/routing-dsl/directives/cache-condition-directives/conditional.html#description","text":"Wraps its inner route with support for Conditional Requests as defined by https://tools.ietf.org/html/draft-ietf-httpbis-p4-conditional-26.\nDepending on the given eTag and lastModified values this directive immediately responds with 304 Not Modified or 412 Precondition Failed (without calling its inner route) if the request comes with the respective conditional headers. Otherwise the request is simply passed on to its inner route.\nThe algorithm implemented by this directive closely follows what is defined in this section of the HTTPbis spec.\nAll responses (the ones produces by this directive itself as well as the ones coming back from the inner route) are augmented with respective ETagETag and Last-Modified response headers.\nSince this directive requires the EntityTagEntityTag and lastModified time stamp for the resource as concrete arguments it is usually used quite deep down in the route structure (i.e. close to the leaf-level), where the exact resource targeted by the request has already been established and the respective ETag/Last-Modified values can be determined.\nThe FileAndResourceDirectives internally use the conditional directive for ETag and Last-Modified support (if the pekko.http.routing.file-get-conditional setting is enabled).","title":"Description"},{"location":"/routing-dsl/directives/caching-directives/index.html","text":"","title":"CachingDirectives"},{"location":"/routing-dsl/directives/caching-directives/index.html#cachingdirectives","text":"Use these directives to “wrap” expensive operations with a caching layer that runs the wrapped operation only once and returns the cached value for all future accesses for the same key (as long as the respective entry has not expired). See caching for an introduction to how the caching support works.","title":"CachingDirectives"},{"location":"/routing-dsl/directives/caching-directives/index.html#dependency","text":"To use Apache Pekko HTTP Caching, add the module to your project:\nsbt val PekkoHttpVersion = \"0.0.0+4308-98f0ff9c-SNAPSHOT\"\nlibraryDependencies += \"org.apache.pekko\" %% \"pekko-http-caching\" % PekkoHttpVersion Gradle def versions = [\n  ScalaBinary: \"2.13\"\n]\ndependencies {\n  implementation platform(\"org.apache.pekko:pekko-http-bom_${versions.ScalaBinary}:0.0.0+4308-98f0ff9c-SNAPSHOT\")\n\n  implementation \"org.apache.pekko:pekko-http-caching_${versions.ScalaBinary}\"\n} Maven <properties>\n  <scala.binary.version>2.13</scala.binary.version>\n</properties>\n<dependencyManagement>\n  <dependencies>\n    <dependency>\n      <groupId>org.apache.pekko</groupId>\n      <artifactId>pekko-http-bom_${scala.binary.version}</artifactId>\n      <version>0.0.0+4308-98f0ff9c-SNAPSHOT</version>\n      <type>pom</type>\n      <scope>import</scope>\n    </dependency>\n  </dependencies>\n</dependencyManagement>\n<dependencies>\n  <dependency>\n    <groupId>org.apache.pekko</groupId>\n    <artifactId>pekko-http-caching_${scala.binary.version}</artifactId>\n  </dependency>\n</dependencies>","title":"Dependency"},{"location":"/routing-dsl/directives/caching-directives/index.html#imports","text":"Directives are available by importing:\nScala copysourceimport org.apache.pekko\nimport pekko.http.scaladsl.server.directives.CachingDirectives._ Java copysourceimport static org.apache.pekko.http.javadsl.server.directives.CachingDirectives.*;\ncache alwaysCache cachingProhibited","title":"Imports"},{"location":"/routing-dsl/directives/caching-directives/cache.html","text":"","title":"cache"},{"location":"/routing-dsl/directives/caching-directives/cache.html#cache","text":"Signature def cache[K](cache: Cache[K, RouteResult], keyer: PartialFunction[RequestContext, K]): Directive0","title":"cache"},{"location":"/routing-dsl/directives/caching-directives/cache.html#description","text":"Wraps its inner Route with caching support using the given CacheCache implementation and the provided keyer function.\nThe directive tries to serve the request from the given cache and only if not found runs the inner route to generate a new response. A simple cache can be constructed using routeCache constructor.\nThe directive is implemented in terms of cachingProhibited and alwaysCache. This means that clients can circumvent the cache using a Cache-Control request header. This behavior may not be adequate depending on your backend implementation (i.e how expensive a call circumventing the cache into the backend is). If you want to force all requests to be handled by the cache use the alwaysCache directive instead. In complexer cases, e.g. when the backend can validate that a cached request is still acceptable according to the request Cache-Control header the predefined caching directives may not be sufficient and a custom solution is necessary.","title":"Description"},{"location":"/routing-dsl/directives/caching-directives/cache.html#example","text":"Scala copysourceimport org.apache.pekko\nimport pekko.http.scaladsl.server.directives.CachingDirectives._\nimport pekko.http.scaladsl.server.RequestContext\nimport pekko.http.scaladsl.model.Uri\nimport pekko.http.scaladsl.model.headers.{ Authorization, `Cache-Control` }\nimport pekko.http.scaladsl.model.headers.CacheDirectives.`no-cache`\n\n// Example keyer for non-authenticated GET requests\nval simpleKeyer: PartialFunction[RequestContext, Uri] = {\n  val isGet: RequestContext => Boolean = _.request.method == GET\n  val isAuthorized: RequestContext => Boolean =\n    _.request.headers.exists(_.is(Authorization.lowercaseName))\n  val result: PartialFunction[RequestContext, Uri] = {\n    case r: RequestContext if isGet(r) && !isAuthorized(r) => r.request.uri\n  }\n  result\n}\n\n// Created outside the route to allow using\n// the same cache across multiple calls\nval myCache = routeCache[Uri]\n\nvar i = 0\nval route =\n  path(\"cached\") {\n    cache(myCache, simpleKeyer) {\n      complete {\n        i += 1\n        i.toString\n      }\n    }\n  }\n\nGet(\"/cached\") ~> route ~> check {\n  responseAs[String] shouldEqual \"1\"\n}\n// now cached\nGet(\"/cached\") ~> route ~> check {\n  responseAs[String] shouldEqual \"1\"\n}\n// caching prevented\nGet(\"/cached\") ~> `Cache-Control`(`no-cache`) ~> route ~> check {\n  responseAs[String] shouldEqual \"2\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.extractUri;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\nimport static org.apache.pekko.http.javadsl.server.PathMatchers.segment;\nfinal CachingSettings cachingSettings = CachingSettings.create(system());\nfinal JavaPartialFunction<RequestContext, Uri> simpleKeyer = new JavaPartialFunction<RequestContext, Uri>() {\n  public Uri apply(RequestContext in, boolean isCheck) {\n    final HttpRequest request = in.getRequest();\n    final boolean isGet = request.method() == HttpMethods.GET;\n    final boolean isAuthorized = request.getHeader(Authorization.class).isPresent();\n\n    if (isGet && !isAuthorized)\n      return request.getUri();\n    else\n      throw noMatch();\n  }\n};\n\n// Created outside the route to allow using\n// the same cache across multiple calls\nfinal Cache<Uri, RouteResult> myCache = routeCache(cachingSettings);\n\nfinal AtomicInteger count = new AtomicInteger(0);\nfinal Route route = path(segment(\"cached\"), () ->\n  cache(myCache, simpleKeyer, () ->\n    extractUri(uri ->\n      complete(String.format(\"Request for %s @ count %d\", uri, count.incrementAndGet()))\n    )\n  )\n);\n\n// tests:\ntestRoute(route)\n  .run(HttpRequest.GET(\"/cached\"))\n  .assertEntity(\"Request for http://example.com/cached @ count 1\");\n\n// now cached\ntestRoute(route)\n  .run(HttpRequest.GET(\"/cached\"))\n  .assertEntity(\"Request for http://example.com/cached @ count 1\");\n\n// caching prevented\nfinal CacheControl noCache = CacheControl.create(CacheDirectives.NO_CACHE);\ntestRoute(route).run(HttpRequest.GET(\"/cached\").addHeader(noCache))\n  .assertEntity(\"Request for http://example.com/cached @ count 2\");","title":"Example"},{"location":"/routing-dsl/directives/caching-directives/alwaysCache.html","text":"","title":"alwaysCache"},{"location":"/routing-dsl/directives/caching-directives/alwaysCache.html#alwayscache","text":"Signature def alwaysCache[K](cache: Cache[K, RouteResult], keyer: PartialFunction[RequestContext, K]): Directive0","title":"alwaysCache"},{"location":"/routing-dsl/directives/caching-directives/alwaysCache.html#description","text":"Like cache but disregards a Cache-Control request header.","title":"Description"},{"location":"/routing-dsl/directives/caching-directives/alwaysCache.html#example","text":"Scala copysourceimport org.apache.pekko\nimport pekko.http.scaladsl.server.directives.CachingDirectives._\nimport pekko.http.scaladsl.server.RequestContext\nimport pekko.http.scaladsl.model.Uri\nimport pekko.http.scaladsl.model.headers.{ Authorization, `Cache-Control` }\nimport pekko.http.scaladsl.model.headers.CacheDirectives.`no-cache`\n\n// Example keyer for non-authenticated GET requests\nval simpleKeyer: PartialFunction[RequestContext, Uri] = {\n  val isGet: RequestContext => Boolean = _.request.method == GET\n  val isAuthorized: RequestContext => Boolean =\n    _.request.headers.exists(_.is(Authorization.lowercaseName))\n  val result: PartialFunction[RequestContext, Uri] = {\n    case r: RequestContext if isGet(r) && !isAuthorized(r) => r.request.uri\n  }\n  result\n}\n\n// Created outside the route to allow using\n// the same cache across multiple calls\nval myCache = routeCache[Uri]\n\nvar i = 0\nval route =\n  path(\"cached\") {\n    alwaysCache(myCache, simpleKeyer) {\n      complete {\n        i += 1\n        i.toString\n      }\n    }\n  }\n\nGet(\"/cached\") ~> route ~> check {\n  responseAs[String] shouldEqual \"1\"\n}\n// now cached\nGet(\"/cached\") ~> route ~> check {\n  responseAs[String] shouldEqual \"1\"\n}\nGet(\"/cached\") ~> `Cache-Control`(`no-cache`) ~> route ~> check {\n  responseAs[String] shouldEqual \"1\"\n} Java copysourcefinal CachingSettings cachingSettings = CachingSettings.create(system());\n// Example keyer for non-authenticated GET requests\nfinal JavaPartialFunction<RequestContext, Uri> simpleKeyer = new JavaPartialFunction<RequestContext, Uri>() {\n  public Uri apply(RequestContext in, boolean isCheck) {\n    final HttpRequest request = in.getRequest();\n    final boolean isGet = request.method() == HttpMethods.GET;\n    final boolean isAuthorized = request.getHeader(Authorization.class).isPresent();\n\n    if (isGet && !isAuthorized)\n      return request.getUri();\n    else\n      throw noMatch();\n  }\n};\n\n// Created outside the route to allow using\n// the same cache across multiple calls\nfinal Cache<Uri, RouteResult> myCache = routeCache(cachingSettings);\n\nfinal AtomicInteger count = new AtomicInteger(0);\nfinal Route route = path(\"cached\", () ->\n    alwaysCache(myCache, simpleKeyer, () ->\n    extractUri(uri ->\n      complete(String.format(\"Request for %s @ count %d\", uri, count.incrementAndGet()))\n    )\n  )\n);\n\n// tests:\ntestRoute(route)\n  .run(HttpRequest.GET(\"/cached\"))\n  .assertEntity(\"Request for http://example.com/cached @ count 1\");\n\n// now cached\ntestRoute(route)\n  .run(HttpRequest.GET(\"/cached\"))\n  .assertEntity(\"Request for http://example.com/cached @ count 1\");\n\nfinal CacheControl noCache = CacheControl.create(CacheDirectives.NO_CACHE);\ntestRoute(route)\n  .run(HttpRequest.GET(\"/cached\").addHeader(noCache))\n  .assertEntity(\"Request for http://example.com/cached @ count 1\");","title":"Example"},{"location":"/routing-dsl/directives/caching-directives/cachingProhibited.html","text":"","title":"cachingProhibited"},{"location":"/routing-dsl/directives/caching-directives/cachingProhibited.html#cachingprohibited","text":"Signature def cachingProhibited: Directive0","title":"cachingProhibited"},{"location":"/routing-dsl/directives/caching-directives/cachingProhibited.html#description","text":"This directive is used to filter out requests that forbid caching. It is used as a building block of the cache directive to prevent caching if the client requests so.","title":"Description"},{"location":"/routing-dsl/directives/caching-directives/cachingProhibited.html#example","text":"Scala copysourceimport org.apache.pekko\nimport pekko.http.scaladsl.model.headers.`Cache-Control`\nimport pekko.http.scaladsl.model.headers.CacheDirectives.`no-cache`\n\nval route =\n  cachingProhibited {\n    complete(\"abc\")\n  }\n\nGet(\"/\") ~> route ~> check {\n  handled shouldEqual false\n}\nGet(\"/\") ~> `Cache-Control`(`no-cache`) ~> route ~> check {\n  responseAs[String] shouldEqual \"abc\"\n} Java copysourcefinal Route route = cachingProhibited(() ->\n  complete(\"abc\")\n);\n\n// tests:\ntestRoute(route)\n  .run(HttpRequest.GET(\"/\"))\n  .assertStatusCode(StatusCodes.NOT_FOUND);\n\nfinal CacheControl noCache = CacheControl.create(CacheDirectives.NO_CACHE);\ntestRoute(route)\n  .run(HttpRequest.GET(\"/\").addHeader(noCache))\n  .assertEntity(\"abc\");","title":"Example"},{"location":"/routing-dsl/directives/coding-directives/index.html","text":"","title":"CodingDirectives"},{"location":"/routing-dsl/directives/coding-directives/index.html#codingdirectives","text":"decodeRequest decodeRequestWith encodeResponse encodeResponseWith requestEncodedWith responseEncodingAccepted withPrecompressedMediaTypeSupport","title":"CodingDirectives"},{"location":"/routing-dsl/directives/coding-directives/decodeRequest.html","text":"","title":"decodeRequest"},{"location":"/routing-dsl/directives/coding-directives/decodeRequest.html#decoderequest","text":"Signature def decodeRequest: Directive0","title":"decodeRequest"},{"location":"/routing-dsl/directives/coding-directives/decodeRequest.html#description","text":"Decompresses the incoming request if it is gzip or deflate compressed. Uncompressed requests are passed through untouched. If the request encoded with another encoding the request is rejected with an UnsupportedRequestEncodingRejectionUnsupportedRequestEncodingRejection. If the request entity after decoding exceeds pekko.http.routing.decode-max-size the stream fails with an EntityStreamSizeExceptionEntityStreamSizeException.","title":"Description"},{"location":"/routing-dsl/directives/coding-directives/decodeRequest.html#example","text":"Scala copysourceval route =\n  decodeRequest {\n    entity(as[String]) { content: String =>\n      complete(s\"Request content: '$content'\")\n    }\n  }\n\n// tests:\nPost(\"/\", helloGzipped) ~> `Content-Encoding`(gzip) ~> route ~> check {\n  responseAs[String] shouldEqual \"Request content: 'Hello'\"\n}\nPost(\"/\", helloDeflated) ~> `Content-Encoding`(deflate) ~> route ~> check {\n  responseAs[String] shouldEqual \"Request content: 'Hello'\"\n}\nPost(\"/\", \"hello uncompressed\") ~> `Content-Encoding`(identity) ~> route ~> check {\n  responseAs[String] shouldEqual \"Request content: 'hello uncompressed'\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.decodeRequest;\nimport static org.apache.pekko.http.javadsl.server.Directives.entity;\n\nfinal ByteString helloGzipped = Coder.Gzip.encode(ByteString.fromString(\"Hello\"));\nfinal ByteString helloDeflated = Coder.Deflate.encode(ByteString.fromString(\"Hello\"));\n\nfinal Route route = decodeRequest(() ->\n  entity(entityToString(), content ->\n    complete(\"Request content: '\" + content + \"'\")\n  )\n);\n\n// tests:\ntestRoute(route).run(\n  HttpRequest.POST(\"/\").withEntity(helloGzipped)\n    .addHeader(ContentEncoding.create(HttpEncodings.GZIP)))\n  .assertEntity(\"Request content: 'Hello'\");\n\ntestRoute(route).run(\n  HttpRequest.POST(\"/\").withEntity(helloDeflated)\n    .addHeader(ContentEncoding.create(HttpEncodings.DEFLATE)))\n  .assertEntity(\"Request content: 'Hello'\");\n\ntestRoute(route).run(\n  HttpRequest.POST(\"/\").withEntity(\"hello uncompressed\")\n    .addHeader(ContentEncoding.create(HttpEncodings.IDENTITY)))\n  .assertEntity( \"Request content: 'hello uncompressed'\");","title":"Example"},{"location":"/routing-dsl/directives/coding-directives/decodeRequestWith.html","text":"","title":"decodeRequestWith"},{"location":"/routing-dsl/directives/coding-directives/decodeRequestWith.html#decoderequestwith","text":"Signature def decodeRequestWith(decoder: Decoder): Directive0 \ndef decodeRequestWith(decoders: Decoder*): Directive0","title":"decodeRequestWith"},{"location":"/routing-dsl/directives/coding-directives/decodeRequestWith.html#description","text":"Decodes the incoming request if it is encoded with one of the given encoders. If the request encoding doesn’t match one of the given encoders the request is rejected with an UnsupportedRequestEncodingRejectionUnsupportedRequestEncodingRejection. If no decoders are given the default encoders (Gzip, Deflate, NoCoding) are used. If the request entity after decoding exceeds pekko.http.routing.decode-max-size the stream fails with an EntityStreamSizeExceptionEntityStreamSizeException.","title":"Description"},{"location":"/routing-dsl/directives/coding-directives/decodeRequestWith.html#example","text":"Scala copysourceval route =\n  decodeRequestWith(Coders.Gzip) {\n    entity(as[String]) { content: String =>\n      complete(s\"Request content: '$content'\")\n    }\n  }\n\n// tests:\nPost(\"/\", helloGzipped) ~> `Content-Encoding`(gzip) ~> route ~> check {\n  responseAs[String] shouldEqual \"Request content: 'Hello'\"\n}\nPost(\"/\", helloDeflated) ~> `Content-Encoding`(deflate) ~> route ~> check {\n  rejection shouldEqual UnsupportedRequestEncodingRejection(gzip)\n}\nPost(\"/\", \"hello\") ~> `Content-Encoding`(identity) ~> route ~> check {\n  rejection shouldEqual UnsupportedRequestEncodingRejection(gzip)\n}\nval route =\n  decodeRequestWith(Coders.Gzip, Coders.NoCoding) {\n    entity(as[String]) { content: String =>\n      complete(s\"Request content: '$content'\")\n    }\n  }\n\n// tests:\nPost(\"/\", helloGzipped) ~> `Content-Encoding`(gzip) ~> route ~> check {\n  responseAs[String] shouldEqual \"Request content: 'Hello'\"\n}\nPost(\"/\", helloDeflated) ~> `Content-Encoding`(deflate) ~> route ~> check {\n  rejections shouldEqual List(UnsupportedRequestEncodingRejection(gzip),\n    UnsupportedRequestEncodingRejection(identity))\n}\nPost(\"/\", \"hello uncompressed\") ~> `Content-Encoding`(identity) ~> route ~> check {\n  responseAs[String] shouldEqual \"Request content: 'hello uncompressed'\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.decodeRequestWith;\nimport static org.apache.pekko.http.javadsl.server.Directives.entity;\n\nfinal ByteString helloGzipped = Coder.Gzip.encode(ByteString.fromString(\"Hello\"));\nfinal ByteString helloDeflated = Coder.Deflate.encode(ByteString.fromString(\"Hello\"));\n\nfinal Route route = decodeRequestWith(Coder.Gzip, () ->\n  entity(entityToString(), content ->\n    complete(\"Request content: '\" + content + \"'\")\n  )\n);\n\n// tests:\ntestRoute(route).run(\n  HttpRequest.POST(\"/\").withEntity(helloGzipped)\n    .addHeader(ContentEncoding.create(HttpEncodings.GZIP)))\n  .assertEntity(\"Request content: 'Hello'\");\n\nrunRouteUnSealed(route,\n  HttpRequest.POST(\"/\").withEntity(helloDeflated)\n    .addHeader(ContentEncoding.create(HttpEncodings.DEFLATE)))\n  .assertRejections(Rejections.unsupportedRequestEncoding(HttpEncodings.GZIP));\n\nrunRouteUnSealed(route,\n  HttpRequest.POST(\"/\").withEntity(\"hello\")\n    .addHeader(ContentEncoding.create(HttpEncodings.IDENTITY)))\n  .assertRejections(Rejections.unsupportedRequestEncoding(HttpEncodings.GZIP));","title":"Example"},{"location":"/routing-dsl/directives/coding-directives/encodeResponse.html","text":"","title":"encodeResponse"},{"location":"/routing-dsl/directives/coding-directives/encodeResponse.html#encoderesponse","text":"Signature def encodeResponse: Directive0","title":"encodeResponse"},{"location":"/routing-dsl/directives/coding-directives/encodeResponse.html#description","text":"Encodes the response with the encoding that is requested by the client via the Accept-Encoding header or rejects the request with an UnacceptedResponseEncodingRejection(supportedEncodings).\nThe response encoding is determined by the rules specified in RFC7231.\nIf the Accept-Encoding header is missing or empty or specifies an encoding other than identity, gzip or deflate then no encoding is used.","title":"Description"},{"location":"/routing-dsl/directives/coding-directives/encodeResponse.html#example","text":"Scala copysourceval route = encodeResponse { complete(\"content\") }\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  response should haveContentEncoding(identity)\n}\nGet(\"/\") ~> `Accept-Encoding`(gzip, deflate) ~> route ~> check {\n  response should haveContentEncoding(gzip)\n}\nGet(\"/\") ~> `Accept-Encoding`(deflate) ~> route ~> check {\n  response should haveContentEncoding(deflate)\n}\nGet(\"/\") ~> `Accept-Encoding`(identity) ~> route ~> check {\n  response should haveContentEncoding(identity)\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.encodeResponse;\n\n    final Route route = encodeResponse(() -> complete(\"content\"));\n\n    // tests:\n    testRoute(route).run(\n      HttpRequest.GET(\"/\")\n        .addHeader(AcceptEncoding.create(HttpEncodings.GZIP))\n        .addHeader(AcceptEncoding.create(HttpEncodings.DEFLATE))\n    ).assertHeaderExists(ContentEncoding.create(HttpEncodings.GZIP));\n\n    testRoute(route).run(\n      HttpRequest.GET(\"/\")\n        .addHeader(AcceptEncoding.create(HttpEncodings.DEFLATE))\n    ).assertHeaderExists(ContentEncoding.create(HttpEncodings.DEFLATE));\n\n    // This case failed!\n//    testRoute(route).run(\n//      HttpRequest.GET(\"/\")\n//        .addHeader(AcceptEncoding.create(HttpEncodings.IDENTITY))\n//    ).assertHeaderExists(ContentEncoding.create(HttpEncodings.IDENTITY));","title":"Example"},{"location":"/routing-dsl/directives/coding-directives/encodeResponseWith.html","text":"","title":"encodeResponseWith"},{"location":"/routing-dsl/directives/coding-directives/encodeResponseWith.html#encoderesponsewith","text":"Signature def encodeResponseWith(first: Encoder, more: Encoder*): Directive0","title":"encodeResponseWith"},{"location":"/routing-dsl/directives/coding-directives/encodeResponseWith.html#description","text":"Encodes the response with the encoding that is requested by the client via the Accept-Encoding if it is among the provided encoders or rejects the request with an UnacceptedResponseEncodingRejection(supportedEncodings).\nThe response encoding is determined by the rules specified in RFC7231.\nIf the Accept-Encoding header is missing then the response is encoded using the first encoder.\nIf the Accept-Encoding header is empty and NoCoding is part of the encoders then no response encoding is used. Otherwise the request is rejected.","title":"Description"},{"location":"/routing-dsl/directives/coding-directives/encodeResponseWith.html#example","text":"Scala copysourceval route = encodeResponseWith(Coders.Gzip) { complete(\"content\") }\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  response should haveContentEncoding(gzip)\n}\nGet(\"/\") ~> `Accept-Encoding`(gzip, deflate) ~> route ~> check {\n  response should haveContentEncoding(gzip)\n}\nGet(\"/\") ~> `Accept-Encoding`(deflate) ~> route ~> check {\n  rejection shouldEqual UnacceptedResponseEncodingRejection(gzip)\n}\nGet(\"/\") ~> `Accept-Encoding`(identity) ~> route ~> check {\n  rejection shouldEqual UnacceptedResponseEncodingRejection(gzip)\n}\n\n// with custom compression level:\nval routeWithLevel9 = encodeResponseWith(Coders.Gzip(compressionLevel = 9)) { complete(\"content\") }\nGet(\"/\") ~> routeWithLevel9 ~> check {\n  response should haveContentEncoding(gzip)\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.encodeResponseWith;\n\nfinal Route route = encodeResponseWith(\n  Collections.singletonList(Coder.Gzip),\n  () -> complete(\"content\")\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertHeaderExists(ContentEncoding.create(HttpEncodings.GZIP));\n\ntestRoute(route).run(\n  HttpRequest.GET(\"/\")\n    .addHeader(AcceptEncoding.create(HttpEncodings.GZIP))\n    .addHeader(AcceptEncoding.create(HttpEncodings.DEFLATE))\n).assertHeaderExists(ContentEncoding.create(HttpEncodings.GZIP));\n\nrunRouteUnSealed(route,\n  HttpRequest.GET(\"/\")\n    .addHeader(AcceptEncoding.create(HttpEncodings.DEFLATE))\n).assertRejections(Rejections.unacceptedResponseEncoding(HttpEncodings.GZIP));\n\nrunRouteUnSealed(route,\n  HttpRequest.GET(\"/\")\n    .addHeader(AcceptEncoding.create(HttpEncodings.IDENTITY))\n).assertRejections(Rejections.unacceptedResponseEncoding(HttpEncodings.GZIP));\n\nfinal Route routeWithLevel9 = encodeResponseWith(\n        Collections.singletonList(Coder.GzipLevel9),\n        () -> complete(\"content\")\n);\n\ntestRoute(routeWithLevel9).run(HttpRequest.GET(\"/\"))\n  .assertHeaderExists(ContentEncoding.create(HttpEncodings.GZIP));","title":"Example"},{"location":"/routing-dsl/directives/coding-directives/requestEncodedWith.html","text":"","title":"requestEncodedWith"},{"location":"/routing-dsl/directives/coding-directives/requestEncodedWith.html#requestencodedwith","text":"Signature def requestEncodedWith(encoding: HttpEncoding): Directive0","title":"requestEncodedWith"},{"location":"/routing-dsl/directives/coding-directives/requestEncodedWith.html#description","text":"Passes the request to the inner route if the request is encoded with the argument encoding. Otherwise, rejects the request with an UnacceptedRequestEncodingRejection(encoding).\nThis directive is the building block for decodeRequest to reject unsupported encodings.","title":"Description"},{"location":"/routing-dsl/directives/coding-directives/responseEncodingAccepted.html","text":"","title":"responseEncodingAccepted"},{"location":"/routing-dsl/directives/coding-directives/responseEncodingAccepted.html#responseencodingaccepted","text":"Signature def responseEncodingAccepted(encoding: HttpEncoding): Directive0","title":"responseEncodingAccepted"},{"location":"/routing-dsl/directives/coding-directives/responseEncodingAccepted.html#description","text":"Passes the request to the inner route if the request accepts the argument encoding. Otherwise, rejects the request with an UnacceptedResponseEncodingRejection(encoding).","title":"Description"},{"location":"/routing-dsl/directives/coding-directives/responseEncodingAccepted.html#example","text":"Scala copysourceval route = responseEncodingAccepted(gzip) { complete(\"content\") }\n\nGet(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"content\"\n}\nGet(\"/\") ~> `Accept-Encoding`(deflate) ~> route ~> check {\n  rejection shouldEqual UnacceptedResponseEncodingRejection(gzip)\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.responseEncodingAccepted;\n\nfinal Route route = responseEncodingAccepted(HttpEncodings.GZIP, () ->\n  complete(\"content\")\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertEntity(\"content\");\nrunRouteUnSealed(route,\n                 HttpRequest.GET(\"/\")\n                   .addHeader(AcceptEncoding.create(HttpEncodings.DEFLATE)))\n  .assertRejections(Rejections.unacceptedResponseEncoding(HttpEncodings.GZIP));","title":"Example"},{"location":"/routing-dsl/directives/coding-directives/withPrecompressedMediaTypeSupport.html","text":"","title":"withPrecompressedMediaTypeSupport"},{"location":"/routing-dsl/directives/coding-directives/withPrecompressedMediaTypeSupport.html#withprecompressedmediatypesupport","text":"Signature def withPrecompressedMediaTypeSupport: Directive0","title":"withPrecompressedMediaTypeSupport"},{"location":"/routing-dsl/directives/coding-directives/withPrecompressedMediaTypeSupport.html#description","text":"Inspects the response entity and adds a Content-Encoding: gzip response header if the entity’s media-type is precompressed with gzip and no Content-Encoding header is present yet.","title":"Description"},{"location":"/routing-dsl/directives/coding-directives/withPrecompressedMediaTypeSupport.html#example","text":"Scala copysourceval svgz = compress(\"<svg/>\", Coders.Gzip)\nval route =\n  withPrecompressedMediaTypeSupport {\n    complete(HttpResponse(entity = HttpEntity(`image/svgz`, svgz)))\n  }\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  header[`Content-Encoding`] shouldEqual Some(`Content-Encoding`(gzip))\n  mediaType shouldEqual `image/svg+xml`\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.withPrecompressedMediaTypeSupport;\n\nfinal ByteString svgz = Coder.Gzip.encode(ByteString.fromString(\"<svg/>\"));\n\nfinal Route route = withPrecompressedMediaTypeSupport(() ->\n  complete(\n    HttpResponse.create().withEntity(\n      HttpEntities.create(MediaTypes.IMAGE_SVGZ.toContentType(), svgz))\n  )\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertMediaType(MediaTypes.IMAGE_SVG_XML)\n  .assertHeaderExists(ContentEncoding.create(HttpEncodings.GZIP));","title":"Example"},{"location":"/routing-dsl/directives/cookie-directives/index.html","text":"","title":"CookieDirectives"},{"location":"/routing-dsl/directives/cookie-directives/index.html#cookiedirectives","text":"cookie deleteCookie optionalCookie setCookie","title":"CookieDirectives"},{"location":"/routing-dsl/directives/cookie-directives/cookie.html","text":"","title":"cookie"},{"location":"/routing-dsl/directives/cookie-directives/cookie.html#cookie","text":"Signature def cookie(name: String): Directive1[HttpCookiePair]","title":"cookie"},{"location":"/routing-dsl/directives/cookie-directives/cookie.html#description","text":"Extracts a cookie with a given name from a request or otherwise rejects the request with a MissingCookieRejectionMissingCookieRejection if the cookie is missing.\nUse the optionalCookie directive instead if you want to support missing cookies in your inner route.","title":"Description"},{"location":"/routing-dsl/directives/cookie-directives/cookie.html#example","text":"Scala copysourceval route =\n  cookie(\"userName\") { nameCookie =>\n    complete(s\"The logged in user is '${nameCookie.value}'\")\n  }\n\n// tests:\nGet(\"/\") ~> Cookie(\"userName\" -> \"paul\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The logged in user is 'paul'\"\n}\n// missing cookie\nGet(\"/\") ~> route ~> check {\n  rejection shouldEqual MissingCookieRejection(\"userName\")\n}\nGet(\"/\") ~> Route.seal(route) ~> check {\n  responseAs[String] shouldEqual \"Request is missing required cookie 'userName'\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.cookie;\n\nfinal Route route = cookie(\"userName\", nameCookie ->\n  complete(\"The logged in user is '\" + nameCookie.value() + \"'\")\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/\").addHeader(Cookie.create(\"userName\", \"paul\")))\n  .assertEntity(\"The logged in user is 'paul'\");\n// missing cookie\nrunRouteUnSealed(route, HttpRequest.GET(\"/\"))\n  .assertRejections(Rejections.missingCookie(\"userName\"));\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertEntity(\"Request is missing required cookie 'userName'\");","title":"Example"},{"location":"/routing-dsl/directives/cookie-directives/deleteCookie.html","text":"","title":"deleteCookie"},{"location":"/routing-dsl/directives/cookie-directives/deleteCookie.html#deletecookie","text":"Signature def deleteCookie(first: HttpCookie, more: HttpCookie*): Directive0 \ndef deleteCookie(name: String, domain: String","title":"deleteCookie"},{"location":"/routing-dsl/directives/cookie-directives/deleteCookie.html#description","text":"Adds a header to the response to request the removal of the cookie with the given name on the client.\nUse the setCookie directive to update a cookie.","title":"Description"},{"location":"/routing-dsl/directives/cookie-directives/deleteCookie.html#example","text":"Scala copysourceval route =\n  deleteCookie(\"userName\") {\n    complete(\"The user was logged out\")\n  }\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The user was logged out\"\n  header[`Set-Cookie`] shouldEqual Some(`Set-Cookie`(HttpCookie(\"userName\", value = \"deleted\",\n    expires = Some(DateTime.MinValue))))\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.deleteCookie;\n\nfinal Route route = deleteCookie(\"userName\", () ->\n  complete(\"The user was logged out\")\n);\n\n// tests:\nfinal HttpHeader expected = SetCookie.create(\n  HttpCookie.create(\n    \"userName\",\n    \"deleted\",\n    Optional.of(DateTime.MinValue()),\n    OptionalLong.empty(),\n    Optional.empty(),\n    Optional.empty(),\n    false,\n    false,\n    Optional.empty()));\n\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertEntity(\"The user was logged out\")\n  .assertHeaderExists(expected);","title":"Example"},{"location":"/routing-dsl/directives/cookie-directives/optionalCookie.html","text":"","title":"optionalCookie"},{"location":"/routing-dsl/directives/cookie-directives/optionalCookie.html#optionalcookie","text":"Signature def optionalCookie(name: String): Directive1[Option[HttpCookiePair]]","title":"optionalCookie"},{"location":"/routing-dsl/directives/cookie-directives/optionalCookie.html#description","text":"Extracts an optional cookie with a given name from a request.\nUse the cookie directive instead if the inner route does not handle a missing cookie.","title":"Description"},{"location":"/routing-dsl/directives/cookie-directives/optionalCookie.html#example","text":"Scala copysourceval route =\n  optionalCookie(\"userName\") {\n    case Some(nameCookie) => complete(s\"The logged in user is '${nameCookie.value}'\")\n    case None             => complete(\"No user logged in\")\n  }\n\n// tests:\nGet(\"/\") ~> Cookie(\"userName\" -> \"paul\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The logged in user is 'paul'\"\n}\nGet(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"No user logged in\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.optionalCookie;\n\nfinal Route route = optionalCookie(\"userName\", optNameCookie -> {\n  if (optNameCookie.isPresent()) {\n    return complete(\"The logged in user is '\" + optNameCookie.get().value() + \"'\");\n  } else {\n    return complete(\"No user logged in\");\n  }\n}\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/\").addHeader(Cookie.create(\"userName\", \"paul\")))\n  .assertEntity(\"The logged in user is 'paul'\");\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertEntity(\"No user logged in\");","title":"Example"},{"location":"/routing-dsl/directives/cookie-directives/setCookie.html","text":"","title":"setCookie"},{"location":"/routing-dsl/directives/cookie-directives/setCookie.html#setcookie","text":"Signature def setCookie(first: HttpCookie, more: HttpCookie*): Directive0","title":"setCookie"},{"location":"/routing-dsl/directives/cookie-directives/setCookie.html#description","text":"Adds a header to the response to request the update of the cookie with the given name on the client.\nUse the deleteCookie directive to delete a cookie.","title":"Description"},{"location":"/routing-dsl/directives/cookie-directives/setCookie.html#example","text":"Scala copysourceval route =\n  setCookie(HttpCookie(\"userName\", value = \"paul\")) {\n    complete(\"The user was logged in\")\n  }\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The user was logged in\"\n  header[`Set-Cookie`] shouldEqual Some(`Set-Cookie`(HttpCookie(\"userName\", value = \"paul\")))\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.setCookie;\n\nfinal Route route = setCookie(HttpCookie.create(\"userName\", \"paul\"), () ->\n  complete(\"The user was logged in\")\n);\n\n// tests:\nfinal HttpHeader expected = SetCookie.create(HttpCookie.create(\"userName\", \"paul\"));\n\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertEntity(\"The user was logged in\")\n  .assertHeaderExists(expected);","title":"Example"},{"location":"/routing-dsl/directives/debugging-directives/index.html","text":"","title":"DebuggingDirectives"},{"location":"/routing-dsl/directives/debugging-directives/index.html#debuggingdirectives","text":"logRequest logRequestResult logResult","title":"DebuggingDirectives"},{"location":"/routing-dsl/directives/debugging-directives/logRequest.html","text":"","title":"logRequest"},{"location":"/routing-dsl/directives/debugging-directives/logRequest.html#logrequest","text":"Signature def logRequest(marker: String): Directive0\ndef logRequest(marker: String, level: LogLevel): Directive0\ndef logRequest(show: HttpRequest => String): Directive0\ndef logRequest(show: HttpRequest => LogEntry): Directive0\ndef logRequest(magnet: LoggingMagnet[HttpRequest => Unit]): Directive0\n The signature shown is simplified, the real signature uses magnets. [1] [1] See The Magnet Pattern for an explanation of magnet-based overloading.","title":"logRequest"},{"location":"/routing-dsl/directives/debugging-directives/logRequest.html#description","text":"Logs the request using the supplied LoggingMagnet[HttpRequest => Unit] using the LoggingAdapterLoggingAdapter of the RequestContextRequestContext. The LoggingMagnet is a wrapped function HttpRequest => Unit that can be implicitly created from the different constructors shown above. These constructors build a LoggingMagnet from these components: Logs the request. The directive is available with the following parameters:\nA marker to prefix each log message with. A log level. A show function that calculates a string representation for a request. A function that creates a LogEntryLogEntry which is a combination of the elements above.\nA marker to prefix each log message with. A log level. A function that creates a LogEntryLogEntry which is a combination of the elements above.\nIt is also possible to use any other function HttpRequest => Unit for logging by wrapping it with LoggingMagnet. See the examples for ways to use the logRequest directive.\nUse logResult for logging the response, or logRequestResult for logging both.\nTo change the logger, wrap this directive by withLog.","title":"Description"},{"location":"/routing-dsl/directives/debugging-directives/logRequest.html#example","text":"Scala copysource// different possibilities of using logRequest\n\n// The first alternatives use an implicitly available LoggingContext for logging\n// marks with \"get-user\", log with debug level, HttpRequest.toString\nDebuggingDirectives.logRequest(\"get-user\")\n\n// marks with \"get-user\", log with info level, HttpRequest.toString\nDebuggingDirectives.logRequest((\"get-user\", Logging.InfoLevel))\n\n// logs just the request method at debug level\ndef requestMethod(req: HttpRequest): String = req.method.name\nDebuggingDirectives.logRequest(requestMethod _)\n\n// logs just the request method at info level\ndef requestMethodAsInfo(req: HttpRequest): LogEntry = LogEntry(req.method.name, Logging.InfoLevel)\nDebuggingDirectives.logRequest(requestMethodAsInfo _)\n\n// This one doesn't use the implicit LoggingContext but uses `println` for logging\ndef printRequestMethod(req: HttpRequest): Unit = println(req.method.name)\nval logRequestPrintln = DebuggingDirectives.logRequest(LoggingMagnet(_ => printRequestMethod))\n\n// tests:\nGet(\"/\") ~> logRequestPrintln(complete(\"logged\")) ~> check {\n  responseAs[String] shouldEqual \"logged\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.get;\nimport static org.apache.pekko.http.javadsl.server.Directives.logRequest;\n\n// logs request with \"get-user\"\nfinal Route routeBasicLogRequest = get(() ->\n  logRequest(\"get-user\", () -> complete(\"logged\")));\n\n// logs request with \"get-user\" as Info\nfinal Route routeBasicLogRequestAsInfo = get(() ->\n  logRequest(\"get-user\", InfoLevel(), () -> complete(\"logged\")));\n\n// logs just the request method at info level\nFunction<HttpRequest, LogEntry> requestMethodAsInfo = (request) ->\n  LogEntry.create(request.method().name(), InfoLevel());\n\nfinal Route routeUsingFunction = get(() ->\n  logRequest(requestMethodAsInfo, () -> complete(\"logged\")));\n\n// tests:\ntestRoute(routeBasicLogRequest).run(HttpRequest.GET(\"/\"))\n  .assertEntity(\"logged\");","title":"Example"},{"location":"/routing-dsl/directives/debugging-directives/logRequestResult.html","text":"","title":"logRequestResult"},{"location":"/routing-dsl/directives/debugging-directives/logRequestResult.html#logrequestresult","text":"Signature def logRequestResult(marker: String)(implicit log: LoggingContext): Directive0\ndef logRequestResult(marker: String, level: LogLevel)(implicit log: LoggingContext): Directive0\ndef logRequestResult(show: HttpRequest => RouteResult => Option[LogEntry])(implicit log: LoggingContext): Directive0\n The signature shown is simplified, the real signature uses magnets. [1] [1] See The Magnet Pattern for an explanation of magnet-based overloading.","title":"logRequestResult"},{"location":"/routing-dsl/directives/debugging-directives/logRequestResult.html#description","text":"Logs both the request and the response using the LoggingAdapterLoggingAdapter of the RequestContextRequestContext.\nThis directive is a combination of logRequest and logResult.\nSee logRequest for the general description how these directives work.","title":"Description"},{"location":"/routing-dsl/directives/debugging-directives/logRequestResult.html#example","text":"Scala copysource// different possibilities of using logRequestResult\n\n// The first alternatives use an implicitly available LoggingContext for logging\n// marks with \"get-user\", log with debug level, HttpRequest.toString, HttpResponse.toString\nDebuggingDirectives.logRequestResult(\"get-user\")\n\n// marks with \"get-user\", log with info level, HttpRequest.toString, HttpResponse.toString\nDebuggingDirectives.logRequestResult((\"get-user\", Logging.InfoLevel))\n\n// logs just the request method and response status at info level\ndef requestMethodAndResponseStatusAsInfo(req: HttpRequest): RouteResult => Option[LogEntry] = {\n  case RouteResult.Complete(res) => Some(LogEntry(req.method.name + \": \" + res.status, Logging.InfoLevel))\n  case _                         => None // no log entries for rejections\n}\nDebuggingDirectives.logRequestResult(requestMethodAndResponseStatusAsInfo _)\n\n// This one will only log rejections\nval rejectionLogger: HttpRequest => RouteResult => Option[LogEntry] = req => {\n  case Rejected(rejections) =>\n    Some(LogEntry(s\"Request: $req\\nwas rejected with rejections:\\n$rejections\", Logging.DebugLevel))\n  case _ => None\n}\nDebuggingDirectives.logRequestResult(rejectionLogger)\n\n// This one doesn't use the implicit LoggingContext but uses `println` for logging\ndef printRequestMethodAndResponseStatus(req: HttpRequest)(res: RouteResult): Unit =\n  println(requestMethodAndResponseStatusAsInfo(req)(res).map(_.obj.toString).getOrElse(\"\"))\nval logRequestResultPrintln =\n  DebuggingDirectives.logRequestResult(LoggingMagnet(_ => printRequestMethodAndResponseStatus))\n\n// tests:\nGet(\"/\") ~> logRequestResultPrintln(complete(\"logged\")) ~> check {\n  responseAs[String] shouldEqual \"logged\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.logRequestResultOptional;\n\n// using logRequestResult\n// handle request to optionally generate a log entry\nBiFunction<HttpRequest, HttpResponse, Optional<LogEntry>> requestMethodAsInfo =\n  (request, response) ->\n    (response.status().isSuccess()) ?\n      Optional.of(\n        LogEntry.create(\n          request.method().name() + \":\" + response.status().intValue(),\n          InfoLevel()))\n      : Optional.empty(); // not a successful response\n\n// handle rejections to optionally generate a log entry\nBiFunction<HttpRequest, List<Rejection>, Optional<LogEntry>> rejectionsAsInfo =\n  (request, rejections) ->\n    (!rejections.isEmpty()) ?\n      Optional.of(\n        LogEntry.create(\n          rejections\n            .stream()\n            .map(Rejection::toString)\n            .collect(Collectors.joining(\", \")),\n          InfoLevel()))\n      : Optional.empty(); // no rejections\n\nfinal Route route = get(() -> logRequestResultOptional(\n  requestMethodAsInfo,\n  rejectionsAsInfo,\n  () -> complete(\"logged\")));\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/\")).assertEntity(\"logged\");","title":"Example"},{"location":"/routing-dsl/directives/debugging-directives/logRequestResult.html#building-advanced-directives","text":"This example will showcase the advanced logging using the DebuggingDirectivesDebuggingDirectives. The built logResponseTime directive will log the request time (or rejection reason):\nScala copysource def pekkoResponseTimeLoggingFunction(\n    loggingAdapter: LoggingAdapter,\n    requestTimestamp: Long,\n    level: LogLevel = Logging.InfoLevel)(req: HttpRequest)(res: RouteResult): Unit = {\n  val entry = res match {\n    case Complete(resp) =>\n      val responseTimestamp: Long = System.nanoTime\n      val elapsedTime: Long = (responseTimestamp - requestTimestamp) / 1000000\n      val loggingString = s\"\"\"Logged Request:${req.method}:${req.uri}:${resp.status}:$elapsedTime\"\"\"\n      LogEntry(loggingString, level)\n    case Rejected(reason) =>\n      LogEntry(s\"Rejected Reason: ${reason.mkString(\",\")}\", level)\n  }\n  entry.logTo(loggingAdapter)\n}\ndef printResponseTime(log: LoggingAdapter) = {\n  val requestTimestamp = System.nanoTime\n  pekkoResponseTimeLoggingFunction(log, requestTimestamp) _\n}\n\nval logResponseTime = DebuggingDirectives.logRequestResult(LoggingMagnet(printResponseTime))\n\nGet(\"/\") ~> logResponseTime(complete(\"logged\")) ~> check {\n  responseAs[String] shouldEqual \"logged\"\n} Java copysource// using logRequestResultOptional for generating Response Time\n// handle request to optionally generate a log entry\nBiFunction<HttpRequest, HttpResponse, Optional<LogEntry>> requestMethodAsInfo() {\n  Long requestTime = System.nanoTime();\n  return new BiFunction<HttpRequest, HttpResponse, Optional<LogEntry>>() {\n    @Override\n    public Optional<LogEntry> apply(HttpRequest request, HttpResponse response) {\n      return printResponseTime(request, response, requestTime);\n    }\n  };\n}\n\n@Test\npublic void testLogRequestResultWithResponseTime() {\n  // handle rejections to optionally generate a log entry\n  BiFunction<HttpRequest, List<Rejection>, Optional<LogEntry>> rejectionsAsInfo =\n    (request, rejections) ->\n      (!rejections.isEmpty()) ?\n        Optional.of(\n          LogEntry.create(\n            rejections\n              .stream()\n              .map(Rejection::toString)\n              .collect(Collectors.joining(\", \")),\n            InfoLevel()))\n        : Optional.empty(); // no rejections\n\n  final Route route = get(() -> logRequestResultOptional(\n    requestMethodAsInfo(),\n    rejectionsAsInfo,\n    () -> complete(\"logged\")));\n  // tests:\n  testRoute(route).run(HttpRequest.GET(\"/\")).assertEntity(\"logged\");","title":"Building Advanced Directives"},{"location":"/routing-dsl/directives/debugging-directives/logResult.html","text":"","title":"logResult"},{"location":"/routing-dsl/directives/debugging-directives/logResult.html#logresult","text":"Signature def logResult(marker: String): Directive0\ndef logResult(marker: String, level: LogLevel): Directive0\ndef logResult(show: RouteResult => String): Directive0\ndef logResult(show: RouteResult => LogEntry): Directive0\ndef logResult(magnet: LoggingMagnet[RouteResult => Unit]): Directive0\n The signature shown is simplified, the real signature uses magnets. [1] [1] See The Magnet Pattern for an explanation of magnet-based overloading.","title":"logResult"},{"location":"/routing-dsl/directives/debugging-directives/logResult.html#description","text":"Logs the response using the LoggingAdapterLoggingAdapter of the RequestContextRequestContext.\nSee logRequest for the general description how these directives work. This directive is different as it requires a LoggingMagnet[RouteResult => Unit]. Instead of just logging HttpResponses, logResult is able to log any RouteResult coming back from the inner route.\nUse logRequest for logging the request, or logRequestResult for logging both.","title":"Description"},{"location":"/routing-dsl/directives/debugging-directives/logResult.html#example","text":"Scala copysource// different possibilities of using logResponse\n\n// The first alternatives use an implicitly available LoggingContext for logging\n// marks with \"get-user\", log with debug level, HttpResponse.toString\nDebuggingDirectives.logResult(\"get-user\")\n\n// marks with \"get-user\", log with info level, HttpResponse.toString\nDebuggingDirectives.logResult((\"get-user\", Logging.InfoLevel))\n\n// logs just the response status at debug level\ndef responseStatus(res: RouteResult): String = res match {\n  case RouteResult.Complete(x)          => x.status.toString\n  case RouteResult.Rejected(rejections) => \"Rejected: \" + rejections.mkString(\", \")\n}\nDebuggingDirectives.logResult(responseStatus _)\n\n// logs just the response status at info level\ndef responseStatusAsInfo(res: RouteResult): LogEntry = LogEntry(responseStatus(res), Logging.InfoLevel)\nDebuggingDirectives.logResult(responseStatusAsInfo _)\n\n// This one doesn't use the implicit LoggingContext but uses `println` for logging\ndef printResponseStatus(res: RouteResult): Unit = println(responseStatus(res))\nval logResultPrintln = DebuggingDirectives.logResult(LoggingMagnet(_ => printResponseStatus))\n\n// tests:\nGet(\"/\") ~> logResultPrintln(complete(\"logged\")) ~> check {\n  responseAs[String] shouldEqual \"logged\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.logResult;\n\n// logs result with \"get-user\"\nfinal Route routeBasicLogResult = get(() ->\n  logResult(\"get-user\", () -> complete(\"logged\")));\n\n// logs result with \"get-user\" as Info\nfinal Route routeBasicLogResultAsInfo = get(() ->\n  logResult(\"get-user\", InfoLevel(), () -> complete(\"logged\")));\n\n// logs the result and the rejections as LogEntry\nFunction<HttpResponse, LogEntry> showSuccessAsInfo = (response) ->\n  LogEntry.create(String.format(\"Response code '%d'\", response.status().intValue()),\n    InfoLevel());\n\nFunction<List<Rejection>, LogEntry> showRejectionAsInfo = (rejections) ->\n  LogEntry.create(\n    rejections\n      .stream()\n      .map(rejection -> rejection.toString())\n      .collect(Collectors.joining(\", \")),\n    InfoLevel());\n\nfinal Route routeUsingFunction = get(() ->\n  logResult(showSuccessAsInfo, showRejectionAsInfo, () -> complete(\"logged\")));\n// tests:\ntestRoute(routeBasicLogResult).run(HttpRequest.GET(\"/\"))\n  .assertEntity(\"logged\");","title":"Example"},{"location":"/routing-dsl/directives/execution-directives/index.html","text":"","title":"ExecutionDirectives"},{"location":"/routing-dsl/directives/execution-directives/index.html#executiondirectives","text":"handleExceptions handleRejections","title":"ExecutionDirectives"},{"location":"/routing-dsl/directives/execution-directives/handleExceptions.html","text":"","title":"handleExceptions"},{"location":"/routing-dsl/directives/execution-directives/handleExceptions.html#handleexceptions","text":"Signature def handleExceptions(handler: ExceptionHandler): Directive0","title":"handleExceptions"},{"location":"/routing-dsl/directives/execution-directives/handleExceptions.html#description","text":"Catches exceptions thrown by the inner route and handles them using the specified ExceptionHandlerExceptionHandler.\nUsing this directive is an alternative to using a global implicitly defined ExceptionHandlerExceptionHandler that applies to the complete route.\nSee Exception Handling for general information about options for handling exceptions.","title":"Description"},{"location":"/routing-dsl/directives/execution-directives/handleExceptions.html#example","text":"Scala copysourceval divByZeroHandler = ExceptionHandler {\n  case _: ArithmeticException => complete(StatusCodes.BadRequest, \"You've got your arithmetic wrong, fool!\")\n}\nval route =\n  path(\"divide\" / IntNumber / IntNumber) { (a, b) =>\n    handleExceptions(divByZeroHandler) {\n      complete(s\"The result is ${a / b}\")\n    }\n  }\n\n// tests:\nGet(\"/divide/10/5\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The result is 2\"\n}\nGet(\"/divide/10/0\") ~> route ~> check {\n  status shouldEqual StatusCodes.BadRequest\n  responseAs[String] shouldEqual \"You've got your arithmetic wrong, fool!\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.handleExceptions;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\n\nfinal ExceptionHandler divByZeroHandler = ExceptionHandler.newBuilder()\n  .match(ArithmeticException.class, x ->\n    complete(StatusCodes.BAD_REQUEST, \"You've got your arithmetic wrong, fool!\"))\n  .build();\n\nfinal Route route =\n  path(PathMatchers.segment(\"divide\").slash(integerSegment()).slash(integerSegment()), (a, b) ->\n    handleExceptions(divByZeroHandler, () -> complete(\"The result is \" + (a / b)))\n  );\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/divide/10/5\"))\n  .assertEntity(\"The result is 2\");\ntestRoute(route).run(HttpRequest.GET(\"/divide/10/0\"))\n  .assertStatusCode(StatusCodes.BAD_REQUEST)\n  .assertEntity(\"You've got your arithmetic wrong, fool!\");","title":"Example"},{"location":"/routing-dsl/directives/execution-directives/handleRejections.html","text":"","title":"handleRejections"},{"location":"/routing-dsl/directives/execution-directives/handleRejections.html#handlerejections","text":"Signature def handleRejections(handler: RejectionHandler): Directive0","title":"handleRejections"},{"location":"/routing-dsl/directives/execution-directives/handleRejections.html#description","text":"Using this directive is an alternative to using a global implicitly defined RejectionHandler that applies to the complete route.\nSee Rejections for general information about options for handling rejections.","title":"Description"},{"location":"/routing-dsl/directives/execution-directives/handleRejections.html#example","text":"Scala copysourceval totallyMissingHandler = RejectionHandler.newBuilder()\n  .handleNotFound { complete(StatusCodes.NotFound, \"Oh man, what you are looking for is long gone.\") }\n  .handle { case ValidationRejection(msg, _) => complete(StatusCodes.InternalServerError, msg) }\n  .result()\nval route =\n  pathPrefix(\"handled\") {\n    handleRejections(totallyMissingHandler) {\n      path(\"existing\")(complete(\"This path exists\")) ~\n      path(\"boom\")(reject(new ValidationRejection(\"This didn't work.\")))\n    }\n  }\n\n// tests:\nGet(\"/handled/existing\") ~> route ~> check {\n  responseAs[String] shouldEqual \"This path exists\"\n}\nGet(\"/missing\") ~> Route.seal(route) /* applies default handler */ ~> check {\n  status shouldEqual StatusCodes.NotFound\n  responseAs[String] shouldEqual \"The requested resource could not be found.\"\n}\nGet(\"/handled/missing\") ~> route ~> check {\n  status shouldEqual StatusCodes.NotFound\n  responseAs[String] shouldEqual \"Oh man, what you are looking for is long gone.\"\n}\nGet(\"/handled/boom\") ~> route ~> check {\n  status shouldEqual StatusCodes.InternalServerError\n  responseAs[String] shouldEqual \"This didn't work.\"\n} Java copysourceimport org.apache.pekko.http.javadsl.server.Directives;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.handleRejections;\nimport static org.apache.pekko.http.javadsl.server.Directives.pathPrefix;\nimport static org.apache.pekko.http.javadsl.server.Directives.reject;\n\nfinal RejectionHandler totallyMissingHandler = RejectionHandler.newBuilder()\n  .handleNotFound(complete(StatusCodes.NOT_FOUND, \"Oh man, what you are looking for is long gone.\"))\n  .handle(ValidationRejection.class, r -> complete(StatusCodes.INTERNAL_SERVER_ERROR, r.message()))\n  .build();\n\nfinal Route route = pathPrefix(\"handled\", () ->\n  handleRejections(totallyMissingHandler, () ->\n    Directives.concat(\n      path(\"existing\", () -> complete(\"This path exists\")),\n      path(\"boom\", () -> reject(Rejections.validationRejection(\"This didn't work.\")))\n    )\n  )\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/handled/existing\"))\n  .assertEntity(\"This path exists\");\n// applies default handler\ntestRoute(route).run(HttpRequest.GET(\"/missing\"))\n  .assertStatusCode(StatusCodes.NOT_FOUND)\n  .assertEntity(\"The requested resource could not be found.\");\ntestRoute(route).run(HttpRequest.GET(\"/handled/missing\"))\n  .assertStatusCode(StatusCodes.NOT_FOUND)\n  .assertEntity(\"Oh man, what you are looking for is long gone.\");\ntestRoute(route).run(HttpRequest.GET(\"/handled/boom\"))\n  .assertStatusCode(StatusCodes.INTERNAL_SERVER_ERROR)\n  .assertEntity(\"This didn't work.\");","title":"Example"},{"location":"/routing-dsl/directives/file-and-resource-directives/index.html","text":"","title":"FileAndResourceDirectives"},{"location":"/routing-dsl/directives/file-and-resource-directives/index.html#fileandresourcedirectives","text":"Like the RouteDirectives the FileAndResourceDirectivesFileAndResourceDirectives are somewhat special in pekko-http’s routing DSL. Most other directives wrap an inner route and are therefore used as inner nodes of the route tree. These directives, instead, are indeed instance of RouteRoute, i.e. leaves of the route tree that handle a request themselves without passing it on to an inner route.\nSo in most cases the inner-most element of a route structure branch is one of the RouteDirectives or FileAndResourceDirectivesFileAndResourceDirectives.\ngetFromBrowseableDirectories getFromBrowseableDirectory getFromDirectory getFromFile getFromResource getFromResourceDirectory listDirectoryContents","title":"FileAndResourceDirectives"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectories.html","text":"","title":"getFromBrowseableDirectories"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectories.html#getfrombrowseabledirectories","text":"Signature def getFromBrowseableDirectories(directories: String*)(implicit renderer: DirectoryRenderer, resolver: ContentTypeResolver): Route","title":"getFromBrowseableDirectories"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectories.html#description","text":"The getFromBrowseableDirectories is a combination of serving files from the specified directories (like getFromDirectory) and listing a browseable directory with listDirectoryContents.\nNesting this directive beneath get is not necessary as this directive will only respond to GET requests.\nUse getFromBrowseableDirectory to serve only one directory.\nUse getFromDirectory if directory browsing isn’t required.\nFor more details refer to getFromBrowseableDirectory.","title":"Description"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectories.html#example","text":"Scala copysourceval route =\n  path(\"tmp\") {\n    getFromBrowseableDirectories(\"/main\", \"/backups\")\n  }\n\n// tests:\nGet(\"/tmp\") ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.getFromBrowseableDirectories;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\n\nfinal Route route = path(\"tmp\", () ->\n  getFromBrowseableDirectories(\"/main\", \"/backups\")\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/tmp\"))\n  .assertStatusCode(StatusCodes.OK);","title":"Example"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectory.html","text":"","title":"getFromBrowseableDirectory"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectory.html#getfrombrowseabledirectory","text":"Signature def getFromBrowseableDirectory(directory: String)( implicit renderer: DirectoryRenderer, resolver: ContentTypeResolver): Route","title":"getFromBrowseableDirectory"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectory.html#description","text":"The getFromBrowseableDirectories is a combination of serving files from the specified directories (like getFromDirectory) and listing a browseable directory with listDirectoryContents.\nNesting this directive beneath get is not necessary as this directive will only respond to GET requests.\nUse getFromBrowseableDirectory to serve only one directory.\nUse getFromDirectory if directory browsing isn’t required.","title":"Description"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectory.html#example","text":"Scala copysourceval route =\n  path(\"tmp\") {\n    getFromBrowseableDirectory(\"/tmp\")\n  }\n\n// tests:\nGet(\"/tmp\") ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.getFromBrowseableDirectory;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\n\nfinal Route route = path(\"tmp\", () ->\n  getFromBrowseableDirectory(\"/tmp\")\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/tmp\"))\n  .assertStatusCode(StatusCodes.OK);","title":"Example"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromBrowseableDirectory.html#default-file-listing-page-example","text":"Directives which list directories (e.g. getFromBrowsableDirectory) use an implicit DirectoryRenderer instance to perform the actual rendering of the file listing. This rendered can be easily overridden by simply providing one in-scope for the directives to use, so you can build your custom directory listings.\nThe default renderer is org.apache.pekko.http.scaladsl.server.directives.FileAndResourceDirectives.defaultDirectoryRenderer, and renders a listing which looks like this:\nExample page rendered by the defaultDirectoryRenderer.\nIt’s possible to turn off rendering the footer stating which version of Apache Pekko HTTP is rendering this page by configuring the pekko.http.routing.render-vanity-footer configuration option to off.","title":"Default file listing page example"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromDirectory.html","text":"","title":"getFromDirectory"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromDirectory.html#getfromdirectory","text":"Signature def getFromDirectory(directoryName: String)(implicit resolver: ContentTypeResolver): Route","title":"getFromDirectory"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromDirectory.html#description","text":"Allows exposing a directory’s files for GET requests for its contents.\nThe unmatchedPath (see extractUnmatchedPath) of the RequestContextRequestContext is first transformed by the given pathRewriter function, before being appended to the given directory name to build the final file name.\nTo serve a single file use getFromFile. To serve browsable directory listings use getFromBrowseableDirectories. To serve files from a classpath directory use getFromResourceDirectory instead.\nNote that it’s not required to wrap this directive with get as this directive will only respond to GET requests.\nNote The file’s contents will be read using an Apache Pekko Streams Source which automatically uses a pre-configured dedicated blocking io dispatcher, which separates the blocking file operations from the rest of the stream. Note also that thanks to using Apache Pekko Streams internally, the file will be served at the highest speed reachable by the client, and not faster – i.e. the file will not end up being loaded in full into memory before writing it to the client.","title":"Description"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromDirectory.html#example","text":"Scala copysourceval route =\n  pathPrefix(\"tmp\") {\n    getFromDirectory(\"/tmp\")\n  }\n\n// tests:\nGet(\"/tmp/example\") ~> route ~> check {\n  responseAs[String] shouldEqual \"example file contents\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.getFromDirectory;\nimport static org.apache.pekko.http.javadsl.server.Directives.pathPrefix;\n\nfinal Route route = pathPrefix(\"tmp\", () ->\n  getFromDirectory(\"/tmp\")\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/tmp/example\"))\n  .assertEntity(\"example file contents\");","title":"Example"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromFile.html","text":"","title":"getFromFile"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromFile.html#getfromfile","text":"Signature def getFromFile(fileName: String)(implicit resolver: ContentTypeResolver): Route \ndef getFromFile(file: File)(implicit resolver: ContentTypeResolver): Route \ndef getFromFile(file: File, contentType: ContentType): Route","title":"getFromFile"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromFile.html#description","text":"Allows exposing a file to be streamed to the client issuing the request.\nThe unmatchedPath (see extractUnmatchedPath) of the RequestContextRequestContext is first transformed by the given pathRewriter function, before being appended to the given directory name to build the final file name.\nTo files from a given directory use getFromDirectory. To serve browsable directory listings use getFromBrowseableDirectories. To serve files from a classpath directory use getFromResourceDirectory instead.\nNote that it’s not required to wrap this directive with get as this directive will only respond to GET requests.\nNote The file’s contents will be read using an Apache Pekko Streams Source which automatically uses a pre-configured dedicated blocking io dispatcher, which separates the blocking file operations from the rest of the stream. Note also that thanks to using Apache Pekko Streams internally, the file will be served at the highest speed reachable by the client, and not faster – i.e. the file will not end up being loaded in full into memory before writing it to the client.","title":"Description"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromFile.html#example","text":"Scala copysourceimport org.apache.pekko.http.scaladsl.server.directives._\nimport ContentTypeResolver.Default\n\nval route =\n  path(\"logs\" / Segment) { name =>\n    getFromFile(s\"$name.log\") // uses implicit ContentTypeResolver\n  }\n\n// tests:\nGet(\"/logs/example\") ~> route ~> check {\n  responseAs[String] shouldEqual \"example file contents\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.getFromFile;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\n\nfinal Route route = path(PathMatchers.segment(\"logs\").slash(segment()), name ->\n  getFromFile(name + \".log\")\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/logs/example\"))\n  .assertEntity(\"example file contents\");","title":"Example"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromResource.html","text":"","title":"getFromResource"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromResource.html#getfromresource","text":"Signature def getFromResource(resourceName: String)(implicit resolver: ContentTypeResolver): Route \ndef getFromResource( resourceName: String, contentType: ContentType, classLoader: ClassLoader","title":"getFromResource"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromResource.html#description","text":"Completes GET requests with the content of the given classpath resource.\nFor details refer to getFromFile which works the same way but obtaining the file from the filesystem instead of the applications classpath.\nNote that it’s not required to wrap this directive with get as this directive will only respond to GET requests.","title":"Description"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromResource.html#example","text":"Scala copysourceimport org.apache.pekko.http.scaladsl.server.directives._\nimport ContentTypeResolver.Default\n\nval route =\n  path(\"logs\" / Segment) { name =>\n    getFromResource(s\"$name.log\") // uses implicit ContentTypeResolver\n  }\n\n// tests:\nGet(\"/logs/example\") ~> route ~> check {\n  responseAs[String] shouldEqual \"example file contents\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.getFromResource;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\n\nfinal Route route = path(PathMatchers.segment(\"logs\").slash(segment()), name ->\n  getFromResource(name + \".log\")\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/logs/example\"))\n  .assertEntity(\"example file contents\");","title":"Example"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromResourceDirectory.html","text":"","title":"getFromResourceDirectory"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromResourceDirectory.html#getfromresourcedirectory","text":"Signature def getFromResourceDirectory(directoryName: String, classLoader: ClassLoader","title":"getFromResourceDirectory"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromResourceDirectory.html#description","text":"Completes GET requests with the content of the given classpath resource directory.\nFor details refer to getFromDirectory which works the same way but obtaining the file from the filesystem instead of the applications classpath.\nNote that it’s not required to wrap this directive with get as this directive will only respond to GET requests.","title":"Description"},{"location":"/routing-dsl/directives/file-and-resource-directives/getFromResourceDirectory.html#example","text":"Scala copysourceval route =\n  pathPrefix(\"examples\") {\n    getFromResourceDirectory(\"examples\")\n  }\n\n// tests:\nGet(\"/examples/example-1\") ~> route ~> check {\n  responseAs[String] shouldEqual \"example file contents\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.getFromResourceDirectory;\nimport static org.apache.pekko.http.javadsl.server.Directives.pathPrefix;\n\nfinal Route route = pathPrefix(\"examples\", () ->\n  getFromResourceDirectory(\"/examples\")\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/examples/example-1\"))\n  .assertEntity(\"example file contents\");","title":"Example"},{"location":"/routing-dsl/directives/file-and-resource-directives/listDirectoryContents.html","text":"","title":"listDirectoryContents"},{"location":"/routing-dsl/directives/file-and-resource-directives/listDirectoryContents.html#listdirectorycontents","text":"Signature def listDirectoryContents(directories: String*)(implicit renderer: DirectoryRenderer): Route","title":"listDirectoryContents"},{"location":"/routing-dsl/directives/file-and-resource-directives/listDirectoryContents.html#description","text":"Completes GET requests with a unified listing of the contents of all given directories. The actual rendering of the directory contents is performed by the in-scope Marshaller<DirectoryListing>Marshaller[DirectoryListing].\nTo just serve files use getFromDirectory.\nTo serve files and provide a browseable directory listing use getFromBrowseableDirectories instead.\nThe rendering can be overridden by providing a custom Marshaller<DirectoryListing>Marshaller[DirectoryListing]DirectoryRenderer implementation, you can read more about it in getFromDirectory ’s documentation.\nNote that it’s not required to wrap this directive with get as this directive will only respond to GET requests.","title":"Description"},{"location":"/routing-dsl/directives/file-and-resource-directives/listDirectoryContents.html#example","text":"Scala copysourceval route =\n  concat(\n    path(\"tmp\") {\n      listDirectoryContents(\"/tmp\")\n    },\n    path(\"custom\") {\n      // implement your custom renderer here\n      val renderer = new DirectoryRenderer {\n        override def marshaller(renderVanityFooter: Boolean): ToEntityMarshaller[DirectoryListing] = ???\n      }\n      listDirectoryContents(\"/tmp\")(renderer)\n    })\n\n// tests:\nGet(\"/logs/example\") ~> route ~> check {\n  responseAs[String] shouldEqual \"example file contents\"\n} Java copysourceimport org.apache.pekko.http.javadsl.server.Directives;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.listDirectoryContents;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\n\nfinal Route route = Directives.concat(\n  path(\"tmp\", () -> listDirectoryContents(\"/tmp\")),\n  path(\"custom\", () -> {\n    // implement your custom renderer here\n    final DirectoryRenderer renderer = renderVanityFooter -> {\n      throw new NotImplementedError();\n    };\n    return listDirectoryContents(renderer, \"/tmp\");\n  })\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/logs/example\"))\n  .assertEntity(\"example file contents\");","title":"Example"},{"location":"/routing-dsl/directives/file-upload-directives/index.html","text":"","title":"FileUploadDirectives"},{"location":"/routing-dsl/directives/file-upload-directives/index.html#fileuploaddirectives","text":"fileUpload fileUploadAll storeUploadedFile storeUploadedFiles","title":"FileUploadDirectives"},{"location":"/routing-dsl/directives/file-upload-directives/fileUpload.html","text":"","title":"fileUpload"},{"location":"/routing-dsl/directives/file-upload-directives/fileUpload.html#fileupload","text":"Signature def fileUpload(fieldName: String): Directive1[(FileInfo, Source[ByteString, Any])]","title":"fileUpload"},{"location":"/routing-dsl/directives/file-upload-directives/fileUpload.html#description","text":"Simple access to the stream of bytes for a file uploaded as a multipart form together with metadata about the upload.\nIf there is no field with the given name the request will be rejected. If there are multiple file parts with the same name, the first one will be used and the subsequent ones ignored.\nNote This directive will only upload one file with a given name. To upload multiple files with the same name you should use the fileUploadAll directive, though all files will be buffered to disk, even if there is only one.","title":"Description"},{"location":"/routing-dsl/directives/file-upload-directives/fileUpload.html#example","text":"Scala copysource // adding integers as a service\nval route =\n  extractRequestContext { ctx =>\n    implicit val materializer = ctx.materializer\n\n    fileUpload(\"csv\") {\n      case (metadata, byteSource) =>\n        val sumF: Future[Int] =\n          // sum the numbers as they arrive so that we can\n          // accept any size of file\n          byteSource.via(Framing.delimiter(ByteString(\"\\n\"), 1024))\n            .mapConcat(_.utf8String.split(\",\").toVector)\n            .map(_.toInt)\n            .runFold(0) { (acc, n) => acc + n }\n\n        onSuccess(sumF) { sum => complete(s\"Sum: $sum\") }\n    }\n  }\n\n// tests:\nval multipartForm =\n  Multipart.FormData(Multipart.FormData.BodyPart.Strict(\n    \"csv\",\n    HttpEntity(ContentTypes.`text/plain(UTF-8)`, \"2,3,5\\n7,11,13,17,23\\n29,31,37\\n\"),\n    Map(\"filename\" -> \"primes.csv\")))\n\nPost(\"/\", multipartForm) ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n  responseAs[String] shouldEqual \"Sum: 178\"\n}\n Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.extractRequestContext;\nimport static org.apache.pekko.http.javadsl.server.Directives.fileUpload;\nimport static org.apache.pekko.http.javadsl.server.Directives.onSuccess;\n\nfinal Route route = extractRequestContext(ctx -> {\n  return fileUpload(\"csv\", (metadata, byteSource) -> {\n    // sum the numbers as they arrive\n    CompletionStage<Integer> sumF = byteSource.via(Framing.delimiter(\n      ByteString.fromString(\"\\n\"), 1024))\n        .mapConcat(bs -> Arrays.asList(bs.utf8String().split(\",\")))\n        .map(s -> Integer.parseInt(s))\n        .runFold(0, (acc, n) -> acc + n, ctx.getMaterializer());\n    return onSuccess(sumF, sum -> complete(\"Sum: \" + sum));\n  });\n});\n\nMap<String, String> filenameMapping = new HashMap<>();\nfilenameMapping.put(\"filename\", \"primes.csv\");\n\norg.apache.pekko.http.javadsl.model.Multipart.FormData multipartForm =\n  Multiparts.createStrictFormDataFromParts(\n    Multiparts.createFormDataBodyPartStrict(\"csv\",\n      HttpEntities.create(ContentTypes.TEXT_PLAIN_UTF8,\n        \"2,3,5\\n7,11,13,17,23\\n29,31,37\\n\"), filenameMapping));\n\n// test:\ntestRoute(route).run(HttpRequest.POST(\"/\").withEntity(\n  multipartForm.toEntity(BodyPartRenderer.randomBoundaryWithDefaults())))\n  .assertStatusCode(StatusCodes.OK)\n  .assertEntityAs(Unmarshaller.entityToString(), \"Sum: 178\");","title":"Example"},{"location":"/routing-dsl/directives/file-upload-directives/fileUploadAll.html","text":"","title":"fileUploadAll"},{"location":"/routing-dsl/directives/file-upload-directives/fileUploadAll.html#fileuploadall","text":"Signature def fileUploadAll(fieldName: String): Directive1[immutable.Seq[(FileInfo, Source[ByteString, Any])]]","title":"fileUploadAll"},{"location":"/routing-dsl/directives/file-upload-directives/fileUploadAll.html#description","text":"Simple access to streams of bytes for all files uploaded in a multipart form together with metadata about each upload.\nIf there is no field with the given name the request will be rejected.\nNote This directive buffers all files to temporary files on disk in files prefixed pekko-http-upload. This is to work around limitations of the HTTP multipart format. To upload only one file it may be preferred to use the fileUpload directive, as it streams the file directly without buffering.","title":"Description"},{"location":"/routing-dsl/directives/file-upload-directives/fileUploadAll.html#example","text":"Scala copysource // adding integers as a service\nval route =\n  extractRequestContext { ctx =>\n    implicit val materializer = ctx.materializer\n\n    fileUploadAll(\"csv\") {\n      case byteSources =>\n        // accumulate the sum of each file\n        val sumF: Future[Int] = byteSources.foldLeft(Future.successful(0)) {\n          case (accF, (metadata, byteSource)) =>\n            // sum the numbers as they arrive\n            val intF = byteSource.via(Framing.delimiter(ByteString(\"\\n\"), 1024))\n              .mapConcat(_.utf8String.split(\",\").toVector)\n              .map(_.toInt)\n              .runFold(0) { (acc, n) => acc + n }\n\n            accF.flatMap(acc => intF.map(acc + _))\n        }\n\n        onSuccess(sumF) { sum => complete(s\"Sum: $sum\") }\n    }\n  }\n\n// tests:\nval multipartForm =\n  Multipart.FormData(\n    Multipart.FormData.BodyPart.Strict(\n      \"csv\",\n      HttpEntity(ContentTypes.`text/plain(UTF-8)`, \"2,3,5\\n7,11,13,17,23\\n29,31,37\\n\"),\n      Map(\"filename\" -> \"primesA.csv\")),\n    Multipart.FormData.BodyPart.Strict(\n      \"csv\",\n      HttpEntity(ContentTypes.`text/plain(UTF-8)`, \"41,43,47\\n53,59,61,67,71\\n73,79,83\\n\"),\n      Map(\"filename\" -> \"primesB.csv\")))\n\nPost(\"/\", multipartForm) ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n  responseAs[String] shouldEqual \"Sum: 855\"\n}\n Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.extractRequestContext;\nimport static org.apache.pekko.http.javadsl.server.Directives.fileUploadAll;\nimport static org.apache.pekko.http.javadsl.server.Directives.onSuccess;\n\nfinal Route route = extractRequestContext(ctx -> {\n  return fileUploadAll(\"csv\", byteSources -> {\n    // accumulate the sum of each file\n    CompletionStage<Integer> sumF = byteSources.stream()\n      .map(item -> {\n        // sum the numbers as they arrive\n        return item.getValue().via(Framing.delimiter(\n          ByteString.fromString(\"\\n\"), 1024))\n            .mapConcat(bs -> Arrays.asList(bs.utf8String().split(\",\")))\n            .map(s -> Integer.parseInt(s))\n            .runFold(0, (acc, n) -> acc + n, ctx.getMaterializer());\n      })\n      .reduce(CompletableFuture.completedFuture(0), (accF, intF) -> {\n        return accF.thenCombine(intF, (a, b) -> a + b);\n      });\n\n    return onSuccess(sumF, sum -> complete(\"Sum: \" + sum));\n  });\n});\n\nMap<String, String> filenameMappingA = new HashMap<>();\nMap<String, String> filenameMappingB = new HashMap<>();\nfilenameMappingA.put(\"filename\", \"primesA.csv\");\nfilenameMappingB.put(\"filename\", \"primesB.csv\");\n\norg.apache.pekko.http.javadsl.model.Multipart.FormData multipartForm =\n  Multiparts.createStrictFormDataFromParts(\n    Multiparts.createFormDataBodyPartStrict(\"csv\",\n      HttpEntities.create(ContentTypes.TEXT_PLAIN_UTF8,\n        \"2,3,5\\n7,11,13,17,23\\n29,31,37\\n\"), filenameMappingA),\n    Multiparts.createFormDataBodyPartStrict(\"csv\",\n      HttpEntities.create(ContentTypes.TEXT_PLAIN_UTF8,\n        \"41,43,47\\n53,59,61,67,71\\n73,79,83\\n\"), filenameMappingB));\n\n// test:\ntestRoute(route).run(HttpRequest.POST(\"/\").withEntity(\n  multipartForm.toEntity(BodyPartRenderer.randomBoundaryWithDefaults())))\n  .assertStatusCode(StatusCodes.OK)\n  .assertEntityAs(Unmarshaller.entityToString(), \"Sum: 855\");","title":"Example"},{"location":"/routing-dsl/directives/file-upload-directives/storeUploadedFile.html","text":"","title":"storeUploadedFile"},{"location":"/routing-dsl/directives/file-upload-directives/storeUploadedFile.html#storeuploadedfile","text":"Signature def storeUploadedFile(fieldName: String, destFn: FileInfo","title":"storeUploadedFile"},{"location":"/routing-dsl/directives/file-upload-directives/storeUploadedFile.html#description","text":"Streams the contents of a file uploaded as a multipart form into a file on disk and provides the file and metadata about the upload.\nIf there is an error writing to disk the request will be failed with the thrown exception. If there is no field with the given name the request will be rejected. If there are multiple file parts with the same name, the first one will be used and the subsequent ones ignored.\nNote This directive will stream contents of the request into a file, however one can not start processing these until the file has been written completely. For streaming APIs it is preferred to use the fileUpload directive, as it allows for streaming handling of the incoming data bytes.","title":"Description"},{"location":"/routing-dsl/directives/file-upload-directives/storeUploadedFile.html#example","text":"Scala copysource def tempDestination(fileInfo: FileInfo): File =\n  File.createTempFile(fileInfo.fileName, \".tmp\")\n\nval route =\n  storeUploadedFile(\"csv\", tempDestination) {\n    case (metadata, file) =>\n      // do something with the file and file metadata ...\n      file.delete()\n      complete(StatusCodes.OK)\n  }\n\n// tests:\nval multipartForm =\n  Multipart.FormData(\n    Multipart.FormData.BodyPart.Strict(\n      \"csv\",\n      HttpEntity(ContentTypes.`text/plain(UTF-8)`, \"2,3,5\\n7,11,13,17,23\\n29,31,37\\n\"),\n      Map(\"filename\" -> \"primes.csv\")))\n\nPost(\"/\", multipartForm) ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n}\n Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.storeUploadedFile;\n\n    final Function<FileInfo, File> temporaryDestination = (info) -> {\n      try {\n        return File.createTempFile(info.getFileName(), \".tmp\");\n      } catch (Exception e) {\n        return null;\n      }\n    };\n\n    final Route route = storeUploadedFile(\"csv\", temporaryDestination, (info, file) -> {\n      // do something with the file and file metadata ...\n      file.delete();\n      return complete(StatusCodes.OK);\n    });\n\n    Map<String, String> filenameMapping = new HashMap<>();\n    filenameMapping.put(\"filename\", \"primes.csv\");\n\n    org.apache.pekko.http.javadsl.model.Multipart.FormData multipartForm =\n      Multiparts.createStrictFormDataFromParts(Multiparts.createFormDataBodyPartStrict(\"csv\",\n        HttpEntities.create(ContentTypes.TEXT_PLAIN_UTF8,\n          \"2,3,5\\n7,11,13,17,23\\n29,31,37\\n\"), filenameMapping));\n\n    // test:\n    testRoute(route).run(HttpRequest.POST(\"/\")\n      .withEntity(\n        multipartForm.toEntity(BodyPartRenderer\n\t\t  .randomBoundaryWithDefaults())))\n      .assertStatusCode(StatusCodes.OK);","title":"Example"},{"location":"/routing-dsl/directives/file-upload-directives/storeUploadedFiles.html","text":"","title":"storeUploadedFiles"},{"location":"/routing-dsl/directives/file-upload-directives/storeUploadedFiles.html#storeuploadedfiles","text":"Signature def storeUploadedFiles(fieldName: String, destFn: FileInfo","title":"storeUploadedFiles"},{"location":"/routing-dsl/directives/file-upload-directives/storeUploadedFiles.html#description","text":"Streams the contents of all files uploaded in a multipart form into files on disk and provides a list of each file and metadata about the upload.\nIf there is an error writing to disk the request will be failed with the thrown exception. If there is no field with the given name the request will be rejected.","title":"Description"},{"location":"/routing-dsl/directives/file-upload-directives/storeUploadedFiles.html#example","text":"Scala copysource def tempDestination(fileInfo: FileInfo): File =\n  File.createTempFile(fileInfo.fileName, \".tmp\")\n\nval route =\n  storeUploadedFiles(\"csv\", tempDestination) { files =>\n    val finalStatus = files.foldLeft(StatusCodes.OK) {\n      case (status, (metadata, file)) =>\n        // do something with the file and file metadata ...\n        file.delete()\n        status\n    }\n\n    complete(finalStatus)\n  }\n\n// tests:\nval multipartForm =\n  Multipart.FormData(\n    Multipart.FormData.BodyPart.Strict(\n      \"csv\",\n      HttpEntity(ContentTypes.`text/plain(UTF-8)`, \"2,3,5\\n7,11,13,17,23\\n29,31,37\\n\"),\n      Map(\"filename\" -> \"primesA.csv\")),\n    Multipart.FormData.BodyPart.Strict(\n      \"csv\",\n      HttpEntity(ContentTypes.`text/plain(UTF-8)`, \"41,43,47\\n53,59,6167,71\\n73,79,83\\n\"),\n      Map(\"filename\" -> \"primesB.csv\")))\n\nPost(\"/\", multipartForm) ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n}\n Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.storeUploadedFiles;\n\n    final Function<FileInfo, File> temporaryDestination = info -> {\n      try {\n        return File.createTempFile(info.getFileName(), \".tmp\");\n      } catch (Exception e) {\n        return null;\n      }\n    };\n\n    final Route route = storeUploadedFiles(\"csv\", temporaryDestination, files -> {\n      files.forEach(item -> {\n        // do something with the file and file metadata ...\n        FileInfo info = item.getKey();\n        File file = item.getValue();\n        file.delete();\n      });\n      return complete(StatusCodes.OK);\n    });\n\n    Map<String, String> filenameMappingA = new HashMap<>();\n    Map<String, String> filenameMappingB = new HashMap<>();\n    filenameMappingA.put(\"filename\", \"primesA.csv\");\n    filenameMappingB.put(\"filename\", \"primesB.csv\");\n\n    org.apache.pekko.http.javadsl.model.Multipart.FormData multipartForm =\n      Multiparts.createStrictFormDataFromParts(\n        Multiparts.createFormDataBodyPartStrict(\"csv\",\n          HttpEntities.create(ContentTypes.TEXT_PLAIN_UTF8,\n            \"2,3,5\\n7,11,13,17,23\\n29,31,37\\n\"), filenameMappingA),\n        Multiparts.createFormDataBodyPartStrict(\"csv\",\n          HttpEntities.create(ContentTypes.TEXT_PLAIN_UTF8,\n            \"41,43,47\\n53,59,61,67,71\\n73,79,83\\n\"), filenameMappingB));\n\n    // test:\n    testRoute(route).run(HttpRequest.POST(\"/\")\n      .withEntity(\n        multipartForm.toEntity(BodyPartRenderer\n\t\t  .randomBoundaryWithDefaults())))\n      .assertStatusCode(StatusCodes.OK);","title":"Example"},{"location":"/routing-dsl/directives/form-field-directives/index.html","text":"","title":"FormFieldDirectives"},{"location":"/routing-dsl/directives/form-field-directives/index.html#formfielddirectives","text":"formField formFields formFieldSeqformFieldList formFieldMap formFieldMultiMap","title":"FormFieldDirectives"},{"location":"/routing-dsl/directives/form-field-directives/formField.html","text":"","title":"formField"},{"location":"/routing-dsl/directives/form-field-directives/formField.html#formfield","text":"","title":"formField"},{"location":"/routing-dsl/directives/form-field-directives/formField.html#description","text":"Allows extracting a single Form field sent in the request. Data posted from HTML Forms is either of type application/x-www-form-urlencoded or of type multipart/form-data.\nSee formFields for an in-depth description.","title":"Description"},{"location":"/routing-dsl/directives/form-field-directives/formField.html#example","text":"Scala copysourceval route =\n  concat(\n    formField(\"color\") { color =>\n      complete(s\"The color is '$color'\")\n    },\n    formField(\"id\".as[Int]) { id =>\n      complete(s\"The id is '$id'\")\n    })\n\n// tests:\nPost(\"/\", FormData(\"color\" -> \"blue\")) ~> route ~> check {\n  responseAs[String] shouldEqual \"The color is 'blue'\"\n}\n\nGet(\"/\") ~> Route.seal(route) ~> check {\n  status shouldEqual StatusCodes.BadRequest\n  responseAs[String] shouldEqual \"Request is missing required form field 'color'\"\n} Java copysourceimport org.apache.pekko.http.javadsl.server.Directives;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.formField;\n\nfinal Route route = Directives.concat(\n  formField(\"color\", color ->\n    complete(\"The color is '\" + color + \"'\")\n  ),\n  formField(StringUnmarshallers.INTEGER, \"id\", id ->\n    complete(\"The id is '\" + id + \"'\")\n  )\n);\n\n// tests:\nfinal FormData formData = FormData.create(Pair.create(\"color\", \"blue\"));\ntestRoute(route).run(HttpRequest.POST(\"/\").withEntity(formData.toEntity()))\n  .assertEntity(\"The color is 'blue'\");\n\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertStatusCode(StatusCodes.BAD_REQUEST)\n  .assertEntity(\"Request is missing required form field 'color'\");","title":"Example"},{"location":"/routing-dsl/directives/form-field-directives/formFields.html","text":"The formFields directive is not available for Java, see formField and formFieldList.\nformFields Signature def formFields(field: <FieldDef[T]>): Directive1[T]\ndef formFields(fields: <FieldDef[T_i]>*): Directive[T_0 :: ... T_i ... :: HNil]\ndef formFields(fields: <FieldDef[T_0]> :: ... <FieldDef[T_i]> ... :: HNil): Directive[T_0 :: ... T_i ... :: HNil]\n The signature shown is simplified and written in pseudo-syntax, the real signature uses magnets. [1] The type <FieldDef> doesn’t really exist but consists of the syntactic variants as shown in the description and the examples. [1] See The Magnet Pattern for an explanation of magnet-based overloading. Description Extracts fields from requests generated by HTML forms (independently of HttpMethodHttpMethod used). Form fields can be either extracted as a String or can be converted to another type. The parameter name can be supplied either as a String or as a Symbol. Form field extraction can be modified to mark a field as required, optional, or repeated, or to filter requests where a form field has a certain value: \"color\" extract the value of field “color” as String reject if the field is missing \"color\".optional (symbolic notation \"color\".?) extract the optional value of field “color” as Option[String] \"color\".withDefault(\"red\") (symbolic notation \"color\" ? \"red\") extract the optional value of field “color” as String with default value \"red\" \"color\".requiredValue(\"blue\") (symbolic notation \"color\" ! \"blue\") require the value of field “color” to be \"blue\" and extract nothing reject if the field is missing or can’t be unmarshalled to the given type \"amount\".as[Int] extract the value of field “amount” as Int, you need a matching implicit UnmarshallerUnmarshaller in scope for that to work (see also Unmarshalling) reject if the field is missing or can’t be unmarshalled to the given type \"amount\".as(unmarshaller) extract the value of field “amount” with an explicit UnmarshallerUnmarshaller reject if the field is missing or can’t be unmarshalled to the given type \"distance\".repeated extract multiple occurrences of field “distance” as Iterable[String] \"distance\".as[Int].repeated extract multiple occurrences of field “distance” as Iterable[Int], you need a matching implicit UnmarshallerUnmarshaller in scope for that to work (see also Unmarshalling) \"distance\".as(unmarshaller).repeated extract multiple occurrences of field “distance” with an explicit UnmarshallerUnmarshaller You can use Case Class Extraction to group several extracted values together into a case-class instance. Requests missing a required field or field value will be rejected with an appropriate rejection. There’s also a singular version, formField. Query parameters can be handled in a similar way, see parameters. Unmarshalling Data POSTed from HTML forms is either of type application/x-www-form-urlencoded or of type multipart/form-data. The value of an url-encoded field is a String while the value of a multipart/form-data-encoded field is a “body part” containing an entity. This means that different kind of unmarshallers are needed depending on what the Content-Type of the request is: A application/x-www-form-urlencoded encoded field needs an implicit Unmarshaller<Option<String>, T>Unmarshaller[Option[String], T] A multipart/form-data encoded field needs an implicit FromStrictFormFieldUnmarshaller[T] For common data-types, these implicits are predefined so that you usually don’t need to care. For custom data-types it should usually suffice to create a FromStringUnmarshaller[T] if the value will be encoded as a String. This should be valid for all values generated by HTML forms apart from file uploads. Details It should only be necessary to read and understand this paragraph if you have very special needs and need to process arbitrary forms, especially ones not generated by HTML forms. The formFields directive contains this logic to find and decide how to deserialize a POSTed form field: It tries to find implicits of both types at the definition site if possible or otherwise at least one of both. If none is available compilation will fail with an “implicit not found” error. Depending on the Content-Type of the incoming request it first tries the matching (see above) one if available. If only a Unmarshaller<Option<String>, T>Unmarshaller[Option[String], T] is available when a request of type multipart/form-data is received, this unmarshaller will be tried to deserialize the body part for a field if the entity is of type text/plain or unspecified. If only a FromStrictFormFieldUnmarshaller[T] is available when a request of type application/x-www-form-urlencoded is received, this unmarshaller will be tried to deserialize the field value by packing the field value into a body part with an entity of type text/plain. Deserializing will only succeed if the unmarshaller accepts entities of type text/plain. If you need to handle encoded fields of a multipart/form-data-encoded request for a custom type, you therefore need to provide a FromStrictFormFieldUnmarshaller[T]. Example copysourceval route =\n  formFields(\"color\", \"age\".as[Int], \"direction\" ! \"up\") { (color, age, _) =>\n    complete(s\"The color is '$color' and the age ten years ago was ${age - 10}\")\n  }\n\n// tests:\nPost(\"/\", FormData(\"direction\" -> \"up\", \"color\" -> \"blue\", \"age\" -> \"68\")) ~> route ~> check {\n  responseAs[String] shouldEqual \"The color is 'blue' and the age ten years ago was 58\"\n}\n\nGet(\"/\") ~> Route.seal(route) ~> check {\n  status shouldEqual StatusCodes.BadRequest\n  responseAs[String] shouldEqual \"Request is missing required form field 'color'\"\n} For more examples about the way how fields can specified see the examples for the parameters directive.","title":"formFields"},{"location":"/routing-dsl/directives/form-field-directives/formFieldSeq.html","text":"","title":"formFieldSeqformFieldList"},{"location":"/routing-dsl/directives/form-field-directives/formFieldSeq.html#","text":"Signature def formFieldSeq: Directive1[immutable.Seq[(String, String)]]","title":"formFieldSeqformFieldList"},{"location":"/routing-dsl/directives/form-field-directives/formFieldSeq.html#description","text":"Extracts all HTTP form fields at once in the original order as (name, value) tuples of type (String, String)Map.Entry<String, String>. Data posted from HTML Forms is either of type application/x-www-form-urlencoded or of type multipart/form-data.\nThis directive can be used if the exact order of form fields is important or if parameters can occur several times.\nSee formFields for an in-depth description.","title":"Description"},{"location":"/routing-dsl/directives/form-field-directives/formFieldSeq.html#warning","text":"The directive reads all incoming HTTP form fields without any configured upper bound. It means, that requests with form fields holding significant amount of data (ie. during a file upload) can cause performance issues or even an OutOfMemoryError s.","title":"Warning"},{"location":"/routing-dsl/directives/form-field-directives/formFieldSeq.html#example","text":"Scala copysourceval route =\n  formFieldSeq { fields =>\n    def formFieldString(formField: (String, String)): String =\n      s\"\"\"${formField._1} = '${formField._2}'\"\"\"\n    complete(s\"The form fields are ${fields.map(formFieldString).mkString(\", \")}\")\n  }\n\n// tests:\nPost(\"/\", FormData(\"color\" -> \"blue\", \"count\" -> \"42\")) ~> route ~> check {\n  responseAs[String] shouldEqual \"The form fields are color = 'blue', count = '42'\"\n}\nPost(\"/\", FormData(\"x\" -> \"23\", \"x\" -> \"4\", \"x\" -> \"89\")) ~> route ~> check {\n  responseAs[String] shouldEqual \"The form fields are x = '23', x = '4', x = '89'\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.formFieldList;\n\nfinal Function<List<Entry<String, String>>, String> listToString = list ->\n  list.stream()\n    .map(e -> e.getKey() + \" = '\" + e.getValue() +\"'\")\n    .collect(Collectors.joining(\", \"));\n\nfinal Route route = formFieldList(fields ->\n  complete(\"The form fields are \" + listToString.apply(fields))\n);\n\n// tests:\nfinal FormData formDataDiffKey =\n  FormData.create(\n    Pair.create(\"color\", \"blue\"),\n    Pair.create(\"count\", \"42\"));\ntestRoute(route).run(HttpRequest.POST(\"/\").withEntity(formDataDiffKey.toEntity()))\n  .assertEntity(\"The form fields are color = 'blue', count = '42'\");\n\nfinal FormData formDataSameKey =\n  FormData.create(\n    Pair.create(\"x\", \"23\"),\n    Pair.create(\"x\", \"4\"),\n    Pair.create(\"x\", \"89\"));\ntestRoute(route).run(HttpRequest.POST(\"/\").withEntity(formDataSameKey.toEntity()))\n  .assertEntity(\"The form fields are x = '23', x = '4', x = '89'\");","title":"Example"},{"location":"/routing-dsl/directives/form-field-directives/formFieldMap.html","text":"","title":"formFieldMap"},{"location":"/routing-dsl/directives/form-field-directives/formFieldMap.html#formfieldmap","text":"Signature def formFieldMap: Directive1[Map[String, String]]","title":"formFieldMap"},{"location":"/routing-dsl/directives/form-field-directives/formFieldMap.html#description","text":"Extracts all HTTP form fields at once as a Map[String, String]Map<String, String> mapping form field names to form field values. Data posted from HTML Forms is either of type application/x-www-form-urlencoded or of type multipart/form-data.\nIf form data contain a field value several times, the map will contain the last one.\nSee formFields for an in-depth description.","title":"Description"},{"location":"/routing-dsl/directives/form-field-directives/formFieldMap.html#warning","text":"Use of this directive can result in performance degradation or even in OutOfMemoryError s. See formFieldSeqformFieldList for details.","title":"Warning"},{"location":"/routing-dsl/directives/form-field-directives/formFieldMap.html#example","text":"Scala copysourceval route =\n  formFieldMap { fields =>\n    def formFieldString(formField: (String, String)): String =\n      s\"\"\"${formField._1} = '${formField._2}'\"\"\"\n    complete(s\"The form fields are ${fields.map(formFieldString).mkString(\", \")}\")\n  }\n\n// tests:\nPost(\"/\", FormData(\"color\" -> \"blue\", \"count\" -> \"42\")) ~> route ~> check {\n  responseAs[String] shouldEqual \"The form fields are color = 'blue', count = '42'\"\n}\nPost(\"/\", FormData(\"x\" -> \"1\", \"x\" -> \"5\")) ~> route ~> check {\n  responseAs[String] shouldEqual \"The form fields are x = '5'\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.formFieldMap;\n\nfinal Function<Map<String, String>, String> mapToString = map ->\n  map.entrySet()\n    .stream()\n    .map(e -> e.getKey() + \" = '\" + e.getValue() +\"'\")\n    .collect(Collectors.joining(\", \"));\n\n\nfinal Route route = formFieldMap(fields ->\n  complete(\"The form fields are \" + mapToString.apply(fields))\n);\n\n// tests:\nfinal FormData formDataDiffKey =\n  FormData.create(\n    Pair.create(\"color\", \"blue\"),\n    Pair.create(\"count\", \"42\"));\ntestRoute(route).run(HttpRequest.POST(\"/\").withEntity(formDataDiffKey.toEntity()))\n  .assertEntity(\"The form fields are color = 'blue', count = '42'\");\n\nfinal FormData formDataSameKey =\n  FormData.create(\n    Pair.create(\"x\", \"1\"),\n    Pair.create(\"x\", \"5\"));\ntestRoute(route).run(HttpRequest.POST(\"/\").withEntity(formDataSameKey.toEntity()))\n  .assertEntity( \"The form fields are x = '5'\");","title":"Example"},{"location":"/routing-dsl/directives/form-field-directives/formFieldMultiMap.html","text":"","title":"formFieldMultiMap"},{"location":"/routing-dsl/directives/form-field-directives/formFieldMultiMap.html#formfieldmultimap","text":"Signature def formFieldMultiMap: Directive1[Map[String, List[String]]]","title":"formFieldMultiMap"},{"location":"/routing-dsl/directives/form-field-directives/formFieldMultiMap.html#description","text":"Extracts all HTTP form fields at once as a multi-map of type Map[String, List[String]]Map<String, List<String>> mapping a form name to a list of all its values. Data posted from HTML Forms is either of type application/x-www-form-urlencoded or of type multipart/form-data.\nThis directive can be used if form fields can occur several times.\nThe order of values is not specified.\nSee formFields for an in-depth description.","title":"Description"},{"location":"/routing-dsl/directives/form-field-directives/formFieldMultiMap.html#warning","text":"Use of this directive can result in performance degradation or even in OutOfMemoryError s. See formFieldSeqformFieldList for details.","title":"Warning"},{"location":"/routing-dsl/directives/form-field-directives/formFieldMultiMap.html#example","text":"Scala copysourceval route =\n  formFieldMultiMap { fields =>\n    complete(\"There are \" +\n      s\"form fields ${fields.map(x => x._1 + \" -> \" + x._2.size).mkString(\", \")}\")\n  }\n\n// tests:\nPost(\"/\", FormData(\"color\" -> \"blue\", \"count\" -> \"42\")) ~> route ~> check {\n  responseAs[String] shouldEqual \"There are form fields color -> 1, count -> 1\"\n}\nPost(\"/\", FormData(\"x\" -> \"23\", \"x\" -> \"4\", \"x\" -> \"89\")) ~> route ~> check {\n  responseAs[String] shouldEqual \"There are form fields x -> 3\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.formFieldMultiMap;\n\nfinal Function<Map<String, List<String>>, String> mapToString = map ->\n  map.entrySet()\n    .stream()\n    .map(e -> e.getKey() + \" -> \" + e.getValue().size())\n    .collect(Collectors.joining(\", \"));\n\nfinal Route route = formFieldMultiMap(fields ->\n  complete(\"There are form fields \" + mapToString.apply(fields))\n);\n\n// test:\nfinal FormData formDataDiffKey =\n  FormData.create(\n    Pair.create(\"color\", \"blue\"),\n    Pair.create(\"count\", \"42\"));\ntestRoute(route).run(HttpRequest.POST(\"/\").withEntity(formDataDiffKey.toEntity()))\n  .assertEntity(\"There are form fields color -> 1, count -> 1\");\n\nfinal FormData formDataSameKey =\n  FormData.create(\n    Pair.create(\"x\", \"23\"),\n    Pair.create(\"x\", \"4\"),\n    Pair.create(\"x\", \"89\"));\ntestRoute(route).run(HttpRequest.POST(\"/\").withEntity(formDataSameKey.toEntity()))\n  .assertEntity(\"There are form fields x -> 3\");","title":"Example"},{"location":"/routing-dsl/directives/future-directives/index.html","text":"","title":"FuturesDirectives"},{"location":"/routing-dsl/directives/future-directives/index.html#futuresdirectives","text":"Future directives can be used to run inner routes once the provided Future[T]CompletionStage<T> has been completed.\nonComplete onCompleteWithBreaker onSuccess completeOrRecoverWith","title":"FuturesDirectives"},{"location":"/routing-dsl/directives/future-directives/onComplete.html","text":"","title":"onComplete"},{"location":"/routing-dsl/directives/future-directives/onComplete.html#oncomplete","text":"Signature def onComplete[T](future:","title":"onComplete"},{"location":"/routing-dsl/directives/future-directives/onComplete.html#description","text":"Evaluates its parameter of type Future[T]CompletionStage<T>, and once it has been completed, extracts its result as a value of type Try[T]Try<T> and passes it to the inner route. A Try<T> can either be a Success containing the T value or a Failure containing the Throwable.\nTo handle the Failure case automatically and only work with the result value, use onSuccess.\nTo complete with a successful result automatically and just handle the failure result, use completeOrRecoverWith, instead.","title":"Description"},{"location":"/routing-dsl/directives/future-directives/onComplete.html#example","text":"Scala copysourcedef divide(a: Int, b: Int): Future[Int] = Future {\n  a / b\n}\n\nval route =\n  path(\"divide\" / IntNumber / IntNumber) { (a, b) =>\n    onComplete(divide(a, b)) {\n      case Success(value) => complete(s\"The result was $value\")\n      case Failure(ex)    => complete(InternalServerError, s\"An error occurred: ${ex.getMessage}\")\n    }\n  }\n\n// tests:\nGet(\"/divide/10/2\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The result was 5\"\n}\n\nGet(\"/divide/10/0\") ~> Route.seal(route) ~> check {\n  status shouldEqual InternalServerError\n  responseAs[String] shouldEqual \"An error occurred: / by zero\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.onComplete;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\n\n// import static scala.compat.java8.JFunction.func;\n// import static org.apache.pekko.http.javadsl.server.PathMatchers.*;\n\nfinal Route route = path(segment(\"divide\").slash(integerSegment()).slash(integerSegment()),\n        (a, b) -> onComplete(\n                () -> CompletableFuture.supplyAsync(() -> a / b),\n                maybeResult -> maybeResult\n                        .map(func(result -> complete(\"The result was \" + result)))\n                        .recover(new PFBuilder<Throwable, Route>()\n                                .matchAny(ex -> complete(StatusCodes.InternalServerError(),\n                                        \"An error occurred: \" + ex.getMessage())\n                                )\n                                .build())\n                        .get()\n        )\n);\n\ntestRoute(route).run(HttpRequest.GET(\"/divide/10/2\"))\n        .assertEntity(\"The result was 5\");\n\ntestRoute(route).run(HttpRequest.GET(\"/divide/10/0\"))\n        .assertStatusCode(StatusCodes.InternalServerError())\n        .assertEntity(\"An error occurred: / by zero\");\nNote Using the onComplete directive means that you’ll have to explicitly and manually handle failure cases. Doing this for every route in your app will result in a lot of boilerplate code. Most of the time you want to use the Exception Handling mechanism instead.\nNote The identically named onComplete method of Scala’s Future (from the standard library) does not work at all in this context since it’s just a method that returns Unit - whereas Apache Pekko HTTP’s onComplete is a Directive that creates a Route.","title":"Example"},{"location":"/routing-dsl/directives/future-directives/onCompleteWithBreaker.html","text":"","title":"onCompleteWithBreaker"},{"location":"/routing-dsl/directives/future-directives/onCompleteWithBreaker.html#oncompletewithbreaker","text":"Signature def onCompleteWithBreaker[T](breaker: CircuitBreaker)(future:","title":"onCompleteWithBreaker"},{"location":"/routing-dsl/directives/future-directives/onCompleteWithBreaker.html#description","text":"Evaluates its parameter of type Future[T]CompletionStage<T> protecting it with the specified CircuitBreakerCircuitBreaker. Refer to Circuit Breaker for a detailed description of this pattern.\nIf the CircuitBreakerCircuitBreaker is open, the request is rejected with a CircuitBreakerOpenRejectionCircuitBreakerOpenRejection. Note that in this case the request’s entity databytes stream is cancelled, and the connection is closed as a consequence.\nOtherwise, the same behaviour provided by onComplete is to be expected.","title":"Description"},{"location":"/routing-dsl/directives/future-directives/onCompleteWithBreaker.html#example","text":"Scala copysourcedef divide(a: Int, b: Int): Future[Int] = Future {\n  a / b\n}\n\nval resetTimeout = 1.second\nval breaker = new CircuitBreaker(\n  system.scheduler,\n  maxFailures = 1,\n  callTimeout = 5.seconds,\n  resetTimeout)\n\nval route =\n  path(\"divide\" / IntNumber / IntNumber) { (a, b) =>\n    onCompleteWithBreaker(breaker)(divide(a, b)) {\n      case Success(value) => complete(s\"The result was $value\")\n      case Failure(ex)    => complete(InternalServerError, s\"An error occurred: ${ex.getMessage}\")\n    }\n  }\n\n// tests:\nGet(\"/divide/10/2\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The result was 5\"\n}\n\nGet(\"/divide/10/0\") ~> Route.seal(route) ~> check {\n  status shouldEqual InternalServerError\n  responseAs[String] shouldEqual \"An error occurred: / by zero\"\n} // opens the circuit breaker\n\nGet(\"/divide/10/2\") ~> route ~> check {\n  rejection shouldBe a[CircuitBreakerOpenRejection]\n}\n\nThread.sleep(resetTimeout.toMillis + 200)\n\nGet(\"/divide/10/2\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The result was 5\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.onCompleteWithBreaker;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\n\n// import static scala.compat.java8.JFunction.func;\n// import static org.apache.pekko.http.javadsl.server.PathMatchers.*;\n\nfinal int maxFailures = 1;\nfinal FiniteDuration callTimeout = FiniteDuration.create(5, TimeUnit.SECONDS);\nfinal FiniteDuration resetTimeout = FiniteDuration.create(1, TimeUnit.SECONDS);\nfinal CircuitBreaker breaker = CircuitBreaker.create(system().scheduler(), maxFailures, callTimeout, resetTimeout);\n\nfinal Route route = path(segment(\"divide\").slash(integerSegment()).slash(integerSegment()),\n        (a, b) -> onCompleteWithBreaker(breaker,\n                () -> CompletableFuture.supplyAsync(() -> a / b),\n                maybeResult -> maybeResult\n                        .map(func(result -> complete(\"The result was \" + result)))\n                        .recover(new PFBuilder<Throwable, Route>()\n                                .matchAny(ex -> complete(StatusCodes.InternalServerError(),\n                                        \"An error occurred: \" + ex.toString())\n                                )\n                                .build())\n                        .get()\n        )\n);\n\ntestRoute(route).run(HttpRequest.GET(\"/divide/10/2\"))\n        .assertEntity(\"The result was 5\");\n\ntestRoute(route).run(HttpRequest.GET(\"/divide/10/0\"))\n        .assertStatusCode(StatusCodes.InternalServerError())\n        .assertEntity(\"An error occurred: java.lang.ArithmeticException: / by zero\");\n\n// The circuit-breaker will eventually be opened\nnew TestKit(system()) {\n    {\n        awaitAssert(\n                Duration.ofSeconds(500),\n                () -> {\n                    testRoute(route).run(HttpRequest.GET(\"/divide/10/0\"))\n                            .assertEntity(\"The server is currently unavailable (because it is overloaded or down for maintenance).\")\n                            .assertStatusCode(StatusCodes.ServiceUnavailable());\n                    return null;\n                });\n\n        Thread.sleep(resetTimeout.toMillis());\n\n        // circuit breaker resets after this time, but observing it\n        // is timing sensitive so retry a few times within a timeout\n        awaitAssert(\n                Duration.ofSeconds(500),\n                () -> {\n                    testRoute(route).run(HttpRequest.GET(\"/divide/8/2\"))\n                            .assertEntity(\"The result was 4\");\n                    return null;\n                });\n    }\n};","title":"Example"},{"location":"/routing-dsl/directives/future-directives/onSuccess.html","text":"","title":"onSuccess"},{"location":"/routing-dsl/directives/future-directives/onSuccess.html#onsuccess","text":"Signature def onSuccess(unitFuture: Future[Unit]): Directive0\ndef onSuccess(simpleTypeFuture: Future[T]): Directive1[T]\ndef onSuccess(hlistFuture: Future[T_0 :: ... T_i ... :: HNil]): Directive[T_0 :: ... T_i ... :: HNil]\n The signature shown is simplified and written in pseudo-syntax, the real signature uses magnets. [1]. [1] See The Magnet Pattern for an explanation of magnet-based overloading.","title":"onSuccess"},{"location":"/routing-dsl/directives/future-directives/onSuccess.html#description","text":"Evaluates its parameter of type Future[T]CompletionStage<T>, and once it has been completed successfully, extracts its result as a value of type T and passes it to the inner route.\nIf the future fails its failure throwable is bubbled up to the nearest ExceptionHandlerExceptionHandler.\nTo handle the Failure case manually as well, use onComplete, instead.","title":"Description"},{"location":"/routing-dsl/directives/future-directives/onSuccess.html#example","text":"Scala copysourceval route =\n  concat(\n    path(\"success\") {\n      onSuccess(Future { \"Ok\" }) { extraction =>\n        complete(extraction)\n      }\n    },\n    path(\"failure\") {\n      onSuccess(Future.failed[String](TestException)) { extraction =>\n        complete(extraction)\n      }\n    })\n\n// tests:\nGet(\"/success\") ~> route ~> check {\n  responseAs[String] shouldEqual \"Ok\"\n}\n\nGet(\"/failure\") ~> Route.seal(route) ~> check {\n  status shouldEqual InternalServerError\n  responseAs[String] shouldEqual \"Unsuccessful future!\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.onSuccess;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\n\nfinal Route route = path(\"success\", () ->\n        onSuccess(CompletableFuture.supplyAsync(() -> \"Ok\"),\n                extraction -> complete(extraction)\n        )\n).orElse(path(\"failure\", () ->\n        onSuccess(CompletableFuture.supplyAsync(() -> {\n                    throw new RuntimeException();\n                }),\n                extraction -> complete(\"never reaches here\"))\n));\n\ntestRoute(route).run(HttpRequest.GET(\"/success\"))\n        .assertEntity(\"Ok\");\n\ntestRoute(route).run(HttpRequest.GET(\"/failure\"))\n        .assertStatusCode(StatusCodes.InternalServerError())\n        .assertEntity(\"There was an internal server error.\");","title":"Example"},{"location":"/routing-dsl/directives/future-directives/completeOrRecoverWith.html","text":"","title":"completeOrRecoverWith"},{"location":"/routing-dsl/directives/future-directives/completeOrRecoverWith.html#completeorrecoverwith","text":"Signature def completeOrRecoverWith(magnet: CompleteOrRecoverWithMagnet): Directive1[Throwable]","title":"completeOrRecoverWith"},{"location":"/routing-dsl/directives/future-directives/completeOrRecoverWith.html#description","text":"If the Future[T]CompletionStage<T> succeeds the request is completed using the value’s marshaller (this directive therefore requires a marshaller for the future’s parametercompletion stage value type to be implicitly availableprovided). The execution of the inner route passed to this directive is only executed if the given futurecompletion stage completed with a failure, exposing the reason of failure as an extraction of type Throwable.\nTo handle the successful case manually as well, use the onComplete directive, instead.","title":"Description"},{"location":"/routing-dsl/directives/future-directives/completeOrRecoverWith.html#example","text":"Scala copysourceval route =\n  concat(\n    path(\"success\") {\n      completeOrRecoverWith(Future { \"Ok\" }) { extraction =>\n        failWith(extraction) // not executed.\n      }\n    },\n    path(\"failure\") {\n      completeOrRecoverWith(Future.failed[String](TestException)) { extraction =>\n        failWith(extraction)\n      }\n    })\n\n// tests:\nGet(\"/success\") ~> route ~> check {\n  responseAs[String] shouldEqual \"Ok\"\n}\n\nGet(\"/failure\") ~> Route.seal(route) ~> check {\n  status shouldEqual InternalServerError\n  responseAs[String] shouldEqual \"Unsuccessful future!\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.completeOrRecoverWith;\nimport static org.apache.pekko.http.javadsl.server.Directives.failWith;\n\nfinal Route route = path(\"success\", () ->\n        completeOrRecoverWith(\n                () -> CompletableFuture.supplyAsync(() -> \"Ok\"),\n                Marshaller.stringToEntity(),\n                extraction -> failWith(extraction) // not executed\n        )\n).orElse(path(\"failure\", () ->\n        completeOrRecoverWith(\n                () -> CompletableFuture.supplyAsync(() -> {\n                    throw new RuntimeException();\n                }),\n                Marshaller.stringToEntity(),\n                extraction -> failWith(extraction))\n));\n\ntestRoute(route).run(HttpRequest.GET(\"/success\"))\n        .assertEntity(\"Ok\");\n\ntestRoute(route).run(HttpRequest.GET(\"/failure\"))\n        .assertStatusCode(StatusCodes.InternalServerError())\n        .assertEntity(\"There was an internal server error.\");","title":"Example"},{"location":"/routing-dsl/directives/header-directives/index.html","text":"","title":"HeaderDirectives"},{"location":"/routing-dsl/directives/header-directives/index.html#headerdirectives","text":"Header directives can be used to extract header values from the request. To change response headers use one of the RespondWithDirectives.\nheaderValue headerValueByName headerValueByType headerValuePF optionalHeaderValue optionalHeaderValueByName optionalHeaderValueByType optionalHeaderValuePF checkSameOrigin","title":"HeaderDirectives"},{"location":"/routing-dsl/directives/header-directives/headerValue.html","text":"","title":"headerValue"},{"location":"/routing-dsl/directives/header-directives/headerValue.html#headervalue","text":"Signature def headerValue[T](f: HttpHeader","title":"headerValue"},{"location":"/routing-dsl/directives/header-directives/headerValue.html#description","text":"Traverses the list of request headers with the specified function and extracts the first value the function returns as Some(value)a non empty Optional<T>.\nThe headerValue directive is a mixture of map and find on the list of request headers. The specified function is called once for each header until the function returns Some(value)a non empty Optional<T>. This value is extracted and presented to the inner route. If the function throws an exception the request is rejected with a MalformedHeaderRejectionMalformedHeaderRejection. If the function returns NoneOptional.empty() for every header the request is rejected as “NotFound”.\nThis directive is the basis for building other request header related directives.\nSee also headerValuePF for a nicer syntactic alternative.","title":"Description"},{"location":"/routing-dsl/directives/header-directives/headerValue.html#example","text":"Scala copysourcedef extractHostPort: HttpHeader => Option[Int] = {\n  case h: `Host` => Some(h.port)\n  case x         => None\n}\n\nval route =\n  headerValue(extractHostPort) { port =>\n    complete(s\"The port was $port\")\n  }\n\n// tests:\nGet(\"/\") ~> Host(\"example.com\", 5043) ~> route ~> check {\n  responseAs[String] shouldEqual \"The port was 5043\"\n}\nGet(\"/\") ~> Route.seal(route) ~> check {\n  status shouldEqual NotFound\n  responseAs[String] shouldEqual \"The requested resource could not be found.\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.headerValue;\n\nfinal Function<HttpHeader, Optional<Host>> extractHostPort = header -> {\n  if (header instanceof Host) {\n    return Optional.of((Host) header);\n  } else {\n    return Optional.empty();\n  }\n};\n\nfinal Route route = headerValue(extractHostPort, host ->\n  complete(\"The port was \" + host.port())\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/\").addHeader(Host.create(\"example.com\", 5043)))\n  .assertEntity(\"The port was 5043\");\n\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertStatusCode(StatusCodes.NOT_FOUND)\n  .assertEntity(\"The requested resource could not be found.\");","title":"Example"},{"location":"/routing-dsl/directives/header-directives/headerValue.html#get-headervalue-or-return-a-default-value","text":"Using provide and composing directives one can build a pattern where a headerValue is extracted if available or a default is returned.\nScala copysourceval exampleHeaderValue = \"exampleHeaderValue\".toLowerCase\ndef extractExampleHeader: HttpHeader => Option[String] = {\n  case HttpHeader(`exampleHeaderValue`, value) => Some(value)\n  case _                                       => None\n}\n\nval route =\n  (headerValue(extractExampleHeader) | provide(\"newValue\")) { value =>\n    complete(s\"headerValue $value\")\n  }\n\n// tests:\nGet(\"/\") ~> RawHeader(\"exampleHeaderValue\", \"theHeaderValue\") ~> route ~> check {\n  responseAs[String] shouldEqual \"headerValue theHeaderValue\"\n}\n\nGet(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"headerValue newValue\"\n} Java copysourceimport org.apache.pekko.http.javadsl.server.Directives;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.anyOf;\nfinal Function<HttpHeader, Optional<String>> extractExampleHeader = header -> {\n  if (header.is(\"x-example-header\")) {\n    return Optional.of(header.value());\n  } else {\n    return Optional.empty();\n  }\n};\n\nfinal Route route = anyOf(\n  bindParameter(Directives::headerValue, extractExampleHeader),\n  bindParameter(Directives::provide, \"newValue\"),\n  (String value) -> complete(\"header is \" + value));\n\n// tests:\nfinal RawHeader exampleHeader = RawHeader.create(\"X-Example-Header\", \"theHeaderValue\");\ntestRoute(route).run(HttpRequest.GET(\"/\").addHeader(exampleHeader))\n  .assertEntity(\"header is theHeaderValue\");\n\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertEntity(\"header is newValue\");","title":"Get headerValue or return a default value"},{"location":"/routing-dsl/directives/header-directives/headerValueByName.html","text":"","title":"headerValueByName"},{"location":"/routing-dsl/directives/header-directives/headerValueByName.html#headervaluebyname","text":"Signature def headerValueByName(headerName: Symbol): Directive1[String] \ndef headerValueByName(headerName: String): Directive1[String]","title":"headerValueByName"},{"location":"/routing-dsl/directives/header-directives/headerValueByName.html#description","text":"Extracts the value of the HTTP request header with the given name.\nIf no header with a matching name is found the request is rejected with a MissingHeaderRejectionMissingHeaderRejection.\nIf the header is expected to be missing in some cases or to customize handling when the header is missing use the optionalHeaderValueByName directive instead.","title":"Description"},{"location":"/routing-dsl/directives/header-directives/headerValueByName.html#example","text":"Scala copysourceval route =\n  headerValueByName(\"X-User-Id\") { userId =>\n    complete(s\"The user is $userId\")\n  }\n\n// tests:\nGet(\"/\") ~> RawHeader(\"X-User-Id\", \"Joe42\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The user is Joe42\"\n}\n\nGet(\"/\") ~> Route.seal(route) ~> check {\n  status shouldEqual BadRequest\n  responseAs[String] shouldEqual \"Request is missing required HTTP header 'X-User-Id'\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.headerValueByName;\n\nfinal Route route = headerValueByName(\"X-User-Id\", userId ->\n  complete(\"The user is \" + userId)\n);\n\n// tests:\nfinal RawHeader header = RawHeader.create(\"X-User-Id\", \"Joe42\");\ntestRoute(route).run(HttpRequest.GET(\"/\").addHeader(header))\n  .assertEntity(\"The user is Joe42\");\n\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertStatusCode(StatusCodes.BAD_REQUEST)\n  .assertEntity(\"Request is missing required HTTP header 'X-User-Id'\");","title":"Example"},{"location":"/routing-dsl/directives/header-directives/headerValueByType.html","text":"","title":"headerValueByType"},{"location":"/routing-dsl/directives/header-directives/headerValueByType.html#headervaluebytype","text":"Signature def headerValueByType[T <: HttpHeader: ClassTag](): Directive1[T]\n The signature shown is simplified, the real signature uses magnets. [1] [1] See The Magnet Pattern for an explanation of magnet-based overloading.","title":"headerValueByType"},{"location":"/routing-dsl/directives/header-directives/headerValueByType.html#description","text":"Traverses the list of request headers and extracts the first header of the given type.\nThe headerValueByType directive finds a header of the given type in the list of request header. If no header of the given type is found the request is rejected with a MissingHeaderRejectionMissingHeaderRejection.\nIf the header is expected to be missing in some cases or to customize handling when the header is missing use the optionalHeaderValueByType directive instead.\nNote Custom headers will only be matched by this directive if they extend ModeledCustomHeaderModeledCustomHeader and provide a companion extending ModeledCustomHeaderCompanion, otherwise the routing infrastructure does now know where to search for the needed companion and header name. from the Scala DSL and there is currently no API for the Java DSL (Issue 219) To learn more about defining custom headers, read: Custom Headers.","title":"Description"},{"location":"/routing-dsl/directives/header-directives/headerValueByType.html#example","text":"Scala copysourceval route =\n  headerValueByType(Origin) { origin =>\n    complete(s\"The first origin was ${origin.origins.head}\")\n  }\n\nval originHeader = Origin(HttpOrigin(\"http://localhost:8080\"))\n\n// tests:\n// extract a header if the type is matching\nGet(\"abc\") ~> originHeader ~> route ~> check {\n  responseAs[String] shouldEqual \"The first origin was http://localhost:8080\"\n}\n\n// reject a request if no header of the given type is present\nGet(\"abc\") ~> route ~> check {\n  inside(rejection) { case MissingHeaderRejection(\"Origin\") => }\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.headerValueByType;\n\nfinal Route route = headerValueByType(Origin.class, origin ->\n  complete(\"The first origin was \" + origin.getOrigins().iterator().next())\n);\n\n// tests:\nfinal Host host = Host.create(\"localhost\", 8080);\nfinal Origin originHeader = Origin.create(HttpOrigin.create(\"http\", host));\n\ntestRoute(route).run(HttpRequest.GET(\"abc\").addHeader(originHeader))\n  .assertEntity(\"The first origin was http://localhost:8080\");\n\ntestRoute(route).run(HttpRequest.GET(\"abc\"))\n  .assertStatusCode(StatusCodes.BAD_REQUEST)\n  .assertEntity(\"Request is missing required HTTP header 'Origin'\");","title":"Example"},{"location":"/routing-dsl/directives/header-directives/headerValuePF.html","text":"","title":"headerValuePF"},{"location":"/routing-dsl/directives/header-directives/headerValuePF.html#headervaluepf","text":"Signature def headerValuePF[T](pf: PartialFunction[HttpHeader, T]): Directive1[T]","title":"headerValuePF"},{"location":"/routing-dsl/directives/header-directives/headerValuePF.html#description","text":"Calls the specified partial function with the first request header the function is isDefinedAt and extracts the result of calling the function.\nThe headerValuePF directive is an alternative syntax version of headerValue.\nIf the function throws an exception the request is rejected with a MalformedHeaderRejectionMalformedHeaderRejection.\nIf the function is not defined for any header the request is rejected as “NotFound”.","title":"Description"},{"location":"/routing-dsl/directives/header-directives/headerValuePF.html#example","text":"Scala copysourcedef extractHostPort: PartialFunction[HttpHeader, Int] = {\n  case h: `Host` => h.port\n}\n\nval route =\n  headerValuePF(extractHostPort) { port =>\n    complete(s\"The port was $port\")\n  }\n\n// tests:\nGet(\"/\") ~> Host(\"example.com\", 5043) ~> route ~> check {\n  responseAs[String] shouldEqual \"The port was 5043\"\n}\nGet(\"/\") ~> Route.seal(route) ~> check {\n  status shouldEqual NotFound\n  responseAs[String] shouldEqual \"The requested resource could not be found.\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.headerValuePF;\n\nfinal PartialFunction<HttpHeader, Integer> extractHostPort =\n  new JavaPartialFunction<HttpHeader, Integer>() {\n    @Override\n    public Integer apply(HttpHeader x, boolean isCheck) throws Exception {\n      if (x instanceof Host) {\n        if (isCheck) {\n          return null;\n        } else {\n          return ((Host) x).port();\n        }\n      } else {\n        throw noMatch();\n      }\n    }\n  };\n\nfinal Route route = headerValuePF(extractHostPort, port ->\n  complete(\"The port was \" + port)\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/\").addHeader(Host.create(\"example.com\", 5043)))\n  .assertEntity(\"The port was 5043\");\n\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertStatusCode(StatusCodes.NOT_FOUND)\n  .assertEntity(\"The requested resource could not be found.\");","title":"Example"},{"location":"/routing-dsl/directives/header-directives/optionalHeaderValue.html","text":"","title":"optionalHeaderValue"},{"location":"/routing-dsl/directives/header-directives/optionalHeaderValue.html#optionalheadervalue","text":"Signature def optionalHeaderValue[T](f: HttpHeader","title":"optionalHeaderValue"},{"location":"/routing-dsl/directives/header-directives/optionalHeaderValue.html#description","text":"Traverses the list of request headers with the specified function and extracts the first value the function returns as Some(value)a non empty Optional<T>.\nThe optionalHeaderValue directive is similar to the headerValue directive but always extracts an OptionOptional value instead of rejecting the request if no matching header could be found.","title":"Description"},{"location":"/routing-dsl/directives/header-directives/optionalHeaderValue.html#example","text":"Scala copysourcedef extractHostPort: HttpHeader => Option[Int] = {\n  case h: `Host` => Some(h.port)\n  case x         => None\n}\n\nval route =\n  optionalHeaderValue(extractHostPort) {\n    case Some(port) => complete(s\"The port was $port\")\n    case None       => complete(s\"The port was not provided explicitly\")\n  } ~ // can also be written as:\n  optionalHeaderValue(extractHostPort) { port =>\n    complete {\n      port match {\n        case Some(p) => s\"The port was $p\"\n        case _       => \"The port was not provided explicitly\"\n      }\n    }\n  }\n\n// tests:\nGet(\"/\") ~> Host(\"example.com\", 5043) ~> route ~> check {\n  responseAs[String] shouldEqual \"The port was 5043\"\n}\nGet(\"/\") ~> Route.seal(route) ~> check {\n  responseAs[String] shouldEqual \"The port was not provided explicitly\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.optionalHeaderValue;\n\nfinal Function<HttpHeader, Optional<Integer>> extractHostPort = header -> {\n  if (header instanceof Host) {\n    return Optional.of(((Host) header).port());\n  } else {\n    return Optional.empty();\n  }\n};\n\nfinal Route route = optionalHeaderValue(extractHostPort, port -> {\n  if (port.isPresent()) {\n    return complete(\"The port was \" + port.get());\n  } else {\n    return complete(\"The port was not provided explicitly\");\n  }\n});\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/\").addHeader(Host.create(\"example.com\", 5043)))\n  .assertEntity(\"The port was 5043\");\n\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertEntity(\"The port was not provided explicitly\");","title":"Example"},{"location":"/routing-dsl/directives/header-directives/optionalHeaderValueByName.html","text":"","title":"optionalHeaderValueByName"},{"location":"/routing-dsl/directives/header-directives/optionalHeaderValueByName.html#optionalheadervaluebyname","text":"Signature def optionalHeaderValueByName(headerName: Symbol): Directive1[Option[String]] \ndef optionalHeaderValueByName(headerName: String): Directive1[Option[String]]","title":"optionalHeaderValueByName"},{"location":"/routing-dsl/directives/header-directives/optionalHeaderValueByName.html#description","text":"Optionally extracts the value of the HTTP request header with the given name.\nThe optionalHeaderValueByName directive is similar to the headerValueByName directive but always extracts an OptionOptional value instead of rejecting the request if no matching header could be found.","title":"Description"},{"location":"/routing-dsl/directives/header-directives/optionalHeaderValueByName.html#example","text":"Scala copysourceval route =\n  optionalHeaderValueByName(\"X-User-Id\") {\n    case Some(userId) => complete(s\"The user is $userId\")\n    case None         => complete(s\"No user was provided\")\n  } ~ // can also be written as:\n  optionalHeaderValueByName(\"X-User-Id\") { userId =>\n    complete {\n      userId match {\n        case Some(u) => s\"The user is $u\"\n        case _       => \"No user was provided\"\n      }\n    }\n  }\n\n// tests:\nGet(\"/\") ~> RawHeader(\"X-User-Id\", \"Joe42\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The user is Joe42\"\n}\nGet(\"/\") ~> Route.seal(route) ~> check {\n  responseAs[String] shouldEqual \"No user was provided\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.optionalHeaderValueByName;\n\nfinal Route route = optionalHeaderValueByName(\"X-User-Id\", userId -> {\n  if (userId.isPresent()) {\n    return complete(\"The user is \" + userId.get());\n  } else {\n    return complete(\"No user was provided\");\n  }\n});\n\n// tests:\nfinal RawHeader header = RawHeader.create(\"X-User-Id\", \"Joe42\");\ntestRoute(route).run(HttpRequest.GET(\"/\").addHeader(header))\n  .assertEntity(\"The user is Joe42\");\n\ntestRoute(route).run(HttpRequest.GET(\"/\")).assertEntity(\"No user was provided\");","title":"Example"},{"location":"/routing-dsl/directives/header-directives/optionalHeaderValueByType.html","text":"","title":"optionalHeaderValueByType"},{"location":"/routing-dsl/directives/header-directives/optionalHeaderValueByType.html#optionalheadervaluebytype","text":"Signature def optionalHeaderValueByType[T <: HttpHeader: ClassTag](): Directive1[Option[T]]\n The signature shown is simplified, the real signature uses magnets. [1] [1] See The Magnet Pattern for an explanation of magnet-based overloading.","title":"optionalHeaderValueByType"},{"location":"/routing-dsl/directives/header-directives/optionalHeaderValueByType.html#description","text":"Optionally extracts the value of the HTTP request header of the given type.\nThe optionalHeaderValueByType directive is similar to the headerValueByType directive but always extracts an OptionOptional value instead of rejecting the request if no matching header could be found.\nNote Custom headers will only be matched by this directive if they extend ModeledCustomHeaderModeledCustomHeader and provide a companion extending ModeledCustomHeaderCompanion, otherwise the routing infrastructure does now know where to search for the needed companion and header name. from the Scala DSL and there is currently no API for the Java DSL (Issue 219) To learn more about defining custom headers, read: Custom Headers.","title":"Description"},{"location":"/routing-dsl/directives/header-directives/optionalHeaderValueByType.html#example","text":"Scala copysourceval route =\n  optionalHeaderValueByType(Origin) {\n    case Some(origin) => complete(s\"The first origin was ${origin.origins.head}\")\n    case None         => complete(\"No Origin header found.\")\n  }\n\nval originHeader = Origin(HttpOrigin(\"http://localhost:8080\"))\n\n// tests:\n// extract Some(header) if the type is matching\nGet(\"abc\") ~> originHeader ~> route ~> check {\n  responseAs[String] shouldEqual \"The first origin was http://localhost:8080\"\n}\n\n// extract None if no header of the given type is present\nGet(\"abc\") ~> route ~> check {\n  responseAs[String] shouldEqual \"No Origin header found.\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.optionalHeaderValueByType;\n\nfinal Route route = optionalHeaderValueByType(Origin.class, origin -> {\n  if (origin.isPresent()) {\n    return complete(\"The first origin was \" + origin.get().getOrigins().iterator().next());\n  } else {\n    return complete(\"No Origin header found.\");\n  }\n});\n\n// tests:\n\n// extract Some(header) if the type is matching\nHost host = Host.create(\"localhost\", 8080);\nOrigin originHeader = Origin.create(HttpOrigin.create(\"http\", host));\ntestRoute(route).run(HttpRequest.GET(\"abc\").addHeader(originHeader))\n  .assertEntity(\"The first origin was http://localhost:8080\");\n\n// extract None if no header of the given type is present\ntestRoute(route).run(HttpRequest.GET(\"abc\")).assertEntity(\"No Origin header found.\");","title":"Example"},{"location":"/routing-dsl/directives/header-directives/optionalHeaderValuePF.html","text":"","title":"optionalHeaderValuePF"},{"location":"/routing-dsl/directives/header-directives/optionalHeaderValuePF.html#optionalheadervaluepf","text":"Signature def optionalHeaderValuePF[T](pf: PartialFunction[HttpHeader, T]): Directive1[Option[T]]","title":"optionalHeaderValuePF"},{"location":"/routing-dsl/directives/header-directives/optionalHeaderValuePF.html#description","text":"Calls the specified partial function with the first request header the function is isDefinedAt and extracts the result of calling the function.\nThe optionalHeaderValuePF directive is similar to the headerValuePF directive but always extracts an OptionOptional value instead of rejecting the request if no matching header could be found.","title":"Description"},{"location":"/routing-dsl/directives/header-directives/optionalHeaderValuePF.html#example","text":"Scala copysourcedef extractHostPort: PartialFunction[HttpHeader, Int] = {\n  case h: `Host` => h.port\n}\n\nval route =\n  optionalHeaderValuePF(extractHostPort) {\n    case Some(port) => complete(s\"The port was $port\")\n    case None       => complete(s\"The port was not provided explicitly\")\n  } ~ // can also be written as:\n  optionalHeaderValuePF(extractHostPort) { port =>\n    complete {\n      port match {\n        case Some(p) => s\"The port was $p\"\n        case _       => \"The port was not provided explicitly\"\n      }\n    }\n  }\n\n// tests:\nGet(\"/\") ~> Host(\"example.com\", 5043) ~> route ~> check {\n  responseAs[String] shouldEqual \"The port was 5043\"\n}\nGet(\"/\") ~> Route.seal(route) ~> check {\n  responseAs[String] shouldEqual \"The port was not provided explicitly\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.optionalHeaderValuePF;\n\nfinal PartialFunction<HttpHeader, Integer> extractHostPort =\n  new JavaPartialFunction<HttpHeader, Integer>() {\n    @Override\n    public Integer apply(HttpHeader x, boolean isCheck) throws Exception {\n      if (x instanceof Host) {\n        if (isCheck) {\n          return null;\n        } else {\n          return ((Host) x).port();\n        }\n      } else {\n        throw noMatch();\n      }\n    }\n  };\n\nfinal Route route = optionalHeaderValuePF(extractHostPort, port -> {\n  if (port.isPresent()) {\n    return complete(\"The port was \" + port.get());\n  } else {\n    return complete(\"The port was not provided explicitly\");\n  }\n});\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/\").addHeader(Host.create(\"example.com\", 5043)))\n  .assertEntity(\"The port was 5043\");\n\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertEntity(\"The port was not provided explicitly\");","title":"Example"},{"location":"/routing-dsl/directives/header-directives/checkSameOrigin.html","text":"","title":"checkSameOrigin"},{"location":"/routing-dsl/directives/header-directives/checkSameOrigin.html#checksameorigin","text":"Signature def checkSameOrigin(allowed: HttpOriginRange.Default): Directive0","title":"checkSameOrigin"},{"location":"/routing-dsl/directives/header-directives/checkSameOrigin.html#description","text":"Checks that request comes from the same origin. Extracts the OriginOrigin header value and verifies that allowed range contains the obtained value. In the case of absent of the OriginOrigin header rejects with a MissingHeaderRejectionMissingHeaderRejection. If the origin value is not in the allowed range rejects with an InvalidOriginHeaderRejection and StatusCodes.ForbiddenStatusCodes.FORBIDDEN status.","title":"Description"},{"location":"/routing-dsl/directives/header-directives/checkSameOrigin.html#example","text":"Checking the OriginOrigin header:\nScala copysourceval correctOrigin = HttpOrigin(\"http://localhost:8080\")\nval route = checkSameOrigin(HttpOriginRange(correctOrigin)) {\n  complete(\"Result\")\n}\n\n// tests:\n// handle request with correct origin headers\nGet(\"abc\") ~> Origin(correctOrigin) ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n  responseAs[String] shouldEqual \"Result\"\n}\n\n// reject request with missed origin header\nGet(\"abc\") ~> route ~> check {\n  inside(rejection) {\n    case MissingHeaderRejection(headerName) => headerName shouldEqual Origin.name\n  }\n}\n\n// rejects request with invalid origin headers\nval invalidHttpOrigin = HttpOrigin(\"http://invalid.com\")\nval invalidOriginHeader = Origin(invalidHttpOrigin)\nGet(\"abc\") ~> invalidOriginHeader ~> route ~> check {\n  inside(rejection) {\n    case InvalidOriginRejection(allowedOrigins) =>\n      allowedOrigins shouldEqual Seq(correctOrigin)\n  }\n}\nGet(\"abc\") ~> invalidOriginHeader ~> Route.seal(route) ~> check {\n  status shouldEqual StatusCodes.Forbidden\n  responseAs[String] should include(s\"${correctOrigin.value}\")\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.checkSameOrigin;\n\nfinal HttpOrigin validOriginHeader =\n  HttpOrigin.create(\"http://localhost\", Host.create(\"8080\"));\n\nfinal HttpOriginRange validOriginRange = HttpOriginRange.create(validOriginHeader);\n\nfinal TestRoute route = testRoute(\n  checkSameOrigin(validOriginRange,\n    () -> complete(\"Result\")));\n\nroute\n  .run(HttpRequest.create().addHeader(Origin.create(validOriginHeader)))\n  .assertStatusCode(StatusCodes.OK)\n  .assertEntity(\"Result\");\n\nroute\n  .run(HttpRequest.create())\n  .assertStatusCode(StatusCodes.BAD_REQUEST);\n\nfinal HttpOrigin invalidOriginHeader =\n  HttpOrigin.create(\"http://invalid.com\", Host.create(\"8080\"));\n\nroute\n  .run(HttpRequest.create().addHeader(Origin.create(invalidOriginHeader)))\n  .assertStatusCode(StatusCodes.FORBIDDEN);","title":"Example"},{"location":"/routing-dsl/directives/host-directives/index.html","text":"","title":"HostDirectives"},{"location":"/routing-dsl/directives/host-directives/index.html#hostdirectives","text":"HostDirectives allow you to filter requests based on the hostname part of the Host header contained in incoming requests as well as extracting its value for usage in inner routes.\nhost extractHost","title":"HostDirectives"},{"location":"/routing-dsl/directives/host-directives/host.html","text":"","title":"host"},{"location":"/routing-dsl/directives/host-directives/host.html#host","text":"Filter requests matching conditions against the hostname part of the Host header value in the request.\nSignature def host(hostNames: String*): Directive0 \ndef host(predicate: String \ndef host(regex: Regex): Directive1[String]","title":"host"},{"location":"/routing-dsl/directives/host-directives/host.html#description","text":"The def host(hostNames: String*) overload rejects all requests with a hostname different from the given ones. The def host(predicate: String => Boolean) overload rejects all requests for which the hostname does not satisfy the given predicate.\nThere are a few variants: reject all requests with a hostname different from the given ones reject all requests for which the hostname does not satisfy the given predicate reject all requests for which the hostname does not satisfy the given regular expression\nThe def host(regex: Regex) overloadregular expression matching works a little bit different: it rejects all requests with a hostname that doesn’t have a prefix matching the given regular expression and also extracts a String to its inner route following this rules:\nFor all matching requests the prefix string matching the regex is extracted and passed to the inner route. If the regex contains a capturing group only the string matched by this group is extracted. If the regex contains more than one capturing group an IllegalArgumentException is thrown.","title":"Description"},{"location":"/routing-dsl/directives/host-directives/host.html#example","text":"Matching a list of hosts:\nScala copysourceval route =\n  host(\"api.company.com\", \"rest.company.com\") {\n    complete(\"Ok\")\n  }\n\n// tests:\nGet() ~> Host(\"rest.company.com\") ~> route ~> check {\n  status shouldEqual OK\n  responseAs[String] shouldEqual \"Ok\"\n}\n\nGet() ~> Host(\"notallowed.company.com\") ~> route ~> check {\n  handled shouldBe false\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.host;\n\nfinal Route matchListOfHosts = host(\n    Arrays.asList(\"api.company.com\", \"rest.company.com\"),\n    () -> complete(StatusCodes.OK));\n\ntestRoute(matchListOfHosts).run(HttpRequest.GET(\"/\").addHeader(Host.create(\"api.company.com\")))\n    .assertStatusCode(StatusCodes.OK);\nMaking sure the host satisfies the given predicate\nScala copysourceval shortOnly: String => Boolean = hostname => hostname.length < 10\n\nval route =\n  host(shortOnly) {\n    complete(\"Ok\")\n  }\n\n// tests:\nGet() ~> Host(\"short.com\") ~> route ~> check {\n  status shouldEqual OK\n  responseAs[String] shouldEqual \"Ok\"\n}\n\nGet() ~> Host(\"verylonghostname.com\") ~> route ~> check {\n  handled shouldBe false\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.host;\n\nfinal Route shortOnly = host(hostname -> hostname.length() < 10,\n    () -> complete(StatusCodes.OK));\n\ntestRoute(shortOnly).run(HttpRequest.GET(\"/\").addHeader(Host.create(\"short.com\")))\n    .assertStatusCode(StatusCodes.OK);\n\ntestRoute(shortOnly).run(HttpRequest.GET(\"/\").addHeader(Host.create(\"verylonghostname.com\")))\n    .assertStatusCode(StatusCodes.NOT_FOUND);\nUsing a regular expressions:\nScala copysourceval route =\n  concat(\n    host(\"api|rest\".r) { prefix =>\n      complete(s\"Extracted prefix: $prefix\")\n    },\n    host(\"public.(my|your)company.com\".r) { captured =>\n      complete(s\"You came through $captured company\")\n    })\n\n// tests:\nGet() ~> Host(\"api.company.com\") ~> route ~> check {\n  status shouldEqual OK\n  responseAs[String] shouldEqual \"Extracted prefix: api\"\n}\n\nGet() ~> Host(\"public.mycompany.com\") ~> route ~> check {\n  status shouldEqual OK\n  responseAs[String] shouldEqual \"You came through my company\"\n} Java copysourceimport org.apache.pekko.http.javadsl.server.Directives;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.host;\n\n\nfinal Route hostPrefixRoute = host(Pattern.compile(\"api|rest\"), prefix -> \n    complete(\"Extracted prefix: \" + prefix));\n\nfinal Route hostPartRoute = host(Pattern.compile(\"public.(my|your)company.com\"), captured ->\n    complete(\"You came through \" + captured\n        + \" company\"));\n\nfinal Route route = Directives.concat(hostPrefixRoute, hostPartRoute);\n\ntestRoute(route).run(HttpRequest.GET(\"/\").addHeader(Host.create(\"api.company.com\")))\n    .assertStatusCode(StatusCodes.OK).assertEntity(\"Extracted prefix: api\");\n\ntestRoute(route).run(HttpRequest.GET(\"/\").addHeader(Host.create(\"public.mycompany.com\")))\n    .assertStatusCode(StatusCodes.OK)\n    .assertEntity(\"You came through my company\");\nBeware that in the case of introducing multiple capturing groups in the regex such as in the case bellow, the directive will fail at runtime, at the moment the route tree is evaluated for the first time. This might cause your http handler actor to enter in a fail/restart loop depending on your supervision strategy.\nScala copysourcean[IllegalArgumentException] should be thrownBy {\n  host(\"server-([0-9]).company.(com|net|org)\".r) { target =>\n    complete(\"Will never complete :'(\")\n  }\n} Java copysource// this will throw IllegalArgumentException\nfinal Route hostRegex = host(Pattern.compile(\"server-([0-9]).company.(com|net|org)\"), s ->\n    // will not reach here\n    complete(s)\n);","title":"Example"},{"location":"/routing-dsl/directives/host-directives/extractHost.html","text":"","title":"extractHost"},{"location":"/routing-dsl/directives/host-directives/extractHost.html#extracthost","text":"Extract the hostname part of the Host request header and expose it as a String extraction to its inner route.\nSignature def extractHost: Directive1[String]","title":"extractHost"},{"location":"/routing-dsl/directives/host-directives/extractHost.html#example","text":"Scala copysourceval route =\n  extractHost { hn =>\n    complete(s\"Hostname: $hn\")\n  }\n\n// tests:\nGet() ~> Host(\"company.com\", 9090) ~> route ~> check {\n  status shouldEqual OK\n  responseAs[String] shouldEqual \"Hostname: company.com\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.extractHost;\n\n\nfinal Route route = extractHost(hn -> \n    complete(\"Hostname: \" + hn));\n\ntestRoute(route).run(HttpRequest.GET(\"/\").addHeader(Host.create(\"company.com\", 9090)))\n    .assertEntity(\"Hostname: company.com\");","title":"Example"},{"location":"/routing-dsl/directives/marshalling-directives/index.html","text":"","title":"Marshalling Directives"},{"location":"/routing-dsl/directives/marshalling-directives/index.html#marshalling-directives","text":"Marshalling directives work in conjunction with org.apache.pekko.http.scaladsl.marshalling and org.apache.pekko.http.scaladsl.unmarshalling to convert a request entity to a specific type or a type to a response.\nSee marshalling and unmarshalling for specific serialization (also known as pickling) guidance.\nMarshalling directives usually rely on an in-scope implicit marshaller to handle conversion.\nUnderstanding Specific Marshalling Directives completeWith entity handleWith","title":"Marshalling Directives"},{"location":"/routing-dsl/directives/marshalling-directives/index.html#understanding-specific-marshalling-directives","text":"directive behavior completeWith Uses a marshaller for a given type to produce a completion function for an inner route. Used in conjunction with instanceOf to format responses. entity Unmarshalls the request entity to the given type and passes it to its inner route. Used in conjunction with as to convert requests to objects. handleWith Completes a request with a given function, using an in-scope unmarshaller for an input and in-scope marshaller for the output.","title":"Understanding Specific Marshalling Directives"},{"location":"/routing-dsl/directives/marshalling-directives/completeWith.html","text":"","title":"completeWith"},{"location":"/routing-dsl/directives/marshalling-directives/completeWith.html#completewith","text":"Signature def completeWith[T](marshaller: ToResponseMarshaller[T])(inner: (T","title":"completeWith"},{"location":"/routing-dsl/directives/marshalling-directives/completeWith.html#description","text":"Uses the marshaller for a given type to produce a completion function that is passed to its inner route. You can use it to decouple marshaller resolution from request completion.\nThe completeWith directive works in conjunction with the instanceOf directive to convert higher-level (object) structure into some lower-level serialized “wire format”. The marshalling documentation explains this process in detail. This directive simplifies exposing types to clients via a route while providing some form of access to the current context.\ncompleteWith is similar to handleWith. The main difference is with completeWith you must eventually call the completion function generated by completeWith. handleWith will automatically call complete when the handleWith function returns.","title":"Description"},{"location":"/routing-dsl/directives/marshalling-directives/completeWith.html#examples","text":"The following example uses spray-jsonJson Support via Jackson to marshall a simple Person class to a json response. It utilizes SprayJsonSupport via the PersonJsonSupport object as the in-scope unmarshaller.\nScala copysourceobject PersonJsonSupport extends DefaultJsonProtocol with SprayJsonSupport {\n  implicit val PortofolioFormats = jsonFormat2(Person)\n}\ncase class Person(name: String, favoriteNumber: Int) Java copysourcestatic public class Person {\n  private final String name;\n  private final int favoriteNumber;\n\n  //default constructor required for Jackson\n  public Person() {\n    this.name = \"\";\n    this.favoriteNumber = 0;\n  }\n\n  public Person(String name, int favoriteNumber) {\n    this.name = name;\n    this.favoriteNumber = favoriteNumber;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public int getFavoriteNumber() {\n    return favoriteNumber;\n  }\n}\nThe findPerson takes an argument of type Person => UnitConsumer<Consumer<Person>> which is generated by the completeWith call. We can handle any logic we want in findPerson and call our completion function to complete the request.\nScala copysourceimport PersonJsonSupport._\n\nval findPerson = (f: Person => Unit) => {\n\n  // ... some processing logic...\n\n  // complete the request\n  f(Person(\"Jane\", 42))\n}\n\nval route = get {\n  completeWith(instanceOf[Person]) { completionFunction => findPerson(completionFunction) }\n}\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  mediaType shouldEqual `application/json`\n  responseAs[String] should include(\"\"\"\"name\":\"Jane\"\"\"\")\n  responseAs[String] should include(\"\"\"\"favoriteNumber\":42\"\"\")\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.completeWith;\n\nfinal Marshaller<Person, HttpResponse> marshaller = Marshaller.entityToOKResponse(Jackson.<Person>marshaller());\n\n//Please note that you can also pass completionFunction to another thread and use it there to complete the request.\n//For example:\n//final Consumer<Consumer<Person>> findPerson = completionFunction -> {\n//  CompletableFuture.runAsync(() ->\n//   /* ... some processing logic... */\n//   completionFunction.accept(new Person(\"Jane\", 42)));\n//};\nfinal Consumer<Consumer<Person>> findPerson = completionFunction -> {\n\n  //... some processing logic...\n\n  //complete the request\n  completionFunction.accept(new Person(\"Jane\", 42));\n};\n\nfinal Route route = completeWith(marshaller, findPerson);\n\n// tests:\nfinal TestRouteResult routeResult = testRoute(route).run(\n        HttpRequest.GET(\"/\")\n);\nrouteResult.assertMediaType(MediaTypes.APPLICATION_JSON);\nrouteResult.assertEntity(\"{\\\"favoriteNumber\\\":42,\\\"name\\\":\\\"Jane\\\"}\");","title":"Examples"},{"location":"/routing-dsl/directives/marshalling-directives/entity.html","text":"","title":"entity"},{"location":"/routing-dsl/directives/marshalling-directives/entity.html#entity","text":"Signature def entity[T](um: FromRequestUnmarshaller[T]): Directive1[T]","title":"entity"},{"location":"/routing-dsl/directives/marshalling-directives/entity.html#description","text":"Unmarshalls the request entity to the given type and passes it to its inner Route. An unmarshaller returns an Either with Right(value) if successful or Left(exception) for a failure. The entity method will either pass the value to the inner route or map the exception to a RejectionRejection.\nThe entity directive works in conjunction with as and org.apache.pekko.http.scaladsl.unmarshalling to convert some serialized “wire format” value into a higher-level object structure. The unmarshalling documentation explains this process in detail. This directive simplifies extraction and error handling to the specified type from the request.\nAn unmarshaller will return a Left(exception) in the case of an error. This is converted to a RejectionRejection within the entity directive. The following table lists how exceptions are mapped to rejections:\nLeft(exception) Rejection ContentExpected RequestEntityExpectedRejectionRequestEntityExpectedRejection UnsupportedContentType UnsupportedRequestContentTypeRejectionUnsupportedRequestContentTypeRejection, which lists the supported types MalformedContent MalformedRequestContentRejectionMalformedRequestContentRejection, with an error message and cause","title":"Description"},{"location":"/routing-dsl/directives/marshalling-directives/entity.html#examples","text":"The following example uses spray-jsonJson Support via Jackson to unmarshall a json request into a simple Person class. It utilizes SprayJsonSupport via the PersonJsonSupport object as the in-scope unmarshaller.\nScala copysourcecase class Person(name: String, favoriteNumber: Int)\nobject PersonJsonSupport extends DefaultJsonProtocol with SprayJsonSupport {\n  implicit val PortofolioFormats = jsonFormat2(Person)\n} Java copysourcestatic public class Person {\n  private final String name;\n  private final int favoriteNumber;\n\n  //default constructor required for Jackson\n  public Person() {\n    this.name = \"\";\n    this.favoriteNumber = 0;\n  }\n\n  public Person(String name, int favoriteNumber) {\n    this.name = name;\n    this.favoriteNumber = favoriteNumber;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public int getFavoriteNumber() {\n    return favoriteNumber;\n  }\n}\nScala copysourceimport PersonJsonSupport._\n\nval route = post {\n  entity(as[Person]) { person =>\n    complete(s\"Person: ${person.name} - favorite number: ${person.favoriteNumber}\")\n  }\n}\n\n// tests:\nPost(\"/\", HttpEntity(`application/json`, \"\"\"{ \"name\": \"Jane\", \"favoriteNumber\" : 42 }\"\"\")) ~>\nroute ~> check {\n  responseAs[String] shouldEqual \"Person: Jane - favorite number: 42\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.entity;\n\nfinal Unmarshaller<HttpEntity, Person> unmarshaller = Jackson.unmarshaller(Person.class);\n\nfinal Route route = entity(unmarshaller, person ->\n  complete( \"Person:\" +  person.getName() + \" - favoriteNumber:\" + person.getFavoriteNumber() )\n);\n\ntestRoute(route).run(\n  HttpRequest.POST(\"/\")\n    .withEntity(\n      HttpEntities.create(\n        ContentTypes.APPLICATION_JSON, \"{\\\"name\\\":\\\"Jane\\\",\\\"favoriteNumber\\\":42}\"\n      )\n    )\n).assertEntity(\"Person:Jane - favoriteNumber:42\");\nIt is also possible to use the entity directive to obtain raw JsValue ( spray-json ) objects, by simply using as[JsValue], or any other JSON type for which you have marshallers in-scope. copysourceimport PersonJsonSupport._\n\nval route = post {\n  entity(as[JsValue]) { json =>\n    complete(\n      s\"Person: ${json.asJsObject.fields(\"name\")} - favorite number: ${json.asJsObject.fields(\"favoriteNumber\")}\")\n  }\n}\n\n// tests:\nPost(\"/\", HttpEntity(`application/json`, \"\"\"{ \"name\": \"Jane\", \"favoriteNumber\" : 42 }\"\"\")) ~>\nroute ~> check {\n  responseAs[String] shouldEqual \"\"\"Person: \"Jane\" - favorite number: 42\"\"\"\n}","title":"Examples"},{"location":"/routing-dsl/directives/marshalling-directives/handleWith.html","text":"","title":"handleWith"},{"location":"/routing-dsl/directives/marshalling-directives/handleWith.html#handlewith","text":"Signature def handleWith[A, B](f: A","title":"handleWith"},{"location":"/routing-dsl/directives/marshalling-directives/handleWith.html#description","text":"Completes the request using the given function. The input to the function is produced with the in-scope entity unmarshaller and the result value of the function is marshalled with the in-scope marshaller. handleWith can be a convenient method combining entity with complete.\nThe handleWith directive is used when you want to handle a route with a given function of type A => BFunction<A,B>. handleWith will use both an in-scope unmarshaller to convert a request into type A and an in-scope marshaller to convert type B into a response. This is helpful when your core business logic resides in some other class or you want your business logic to be independent of the REST interface written with pekko-http. You can use handleWith to “hand off” processing to a given function without requiring any pekko-http-specific functionality.\nhandleWith is similar to produce. The main difference is handleWith automatically calls complete when the function passed to handleWith returns. Using produce you must explicitly call the completion function passed from the produce function.\nSee marshalling and unmarshalling for guidance on marshalling entities with pekko-http.","title":"Description"},{"location":"/routing-dsl/directives/marshalling-directives/handleWith.html#examples","text":"The following example uses an updatePerson function with a Person case class as an input and output. We plug this function into our route using handleWith.\nScala copysourcecase class Person(name: String, favoriteNumber: Int) Java copysourcestatic public class Person {\n  private final String name;\n  private final int favoriteNumber;\n\n  //default constructor required for Jackson\n  public Person() {\n    this.name = \"\";\n    this.favoriteNumber = 0;\n  }\n\n  public Person(String name, int favoriteNumber) {\n    this.name = name;\n    this.favoriteNumber = favoriteNumber;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public int getFavoriteNumber() {\n    return favoriteNumber;\n  }\n}\nScala copysourceimport PersonJsonSupport._\n\nval updatePerson = (person: Person) => {\n\n  // ... some processing logic...\n\n  // return the person\n  person\n}\n\nval route = post {\n  handleWith(updatePerson)\n}\n\n// tests:\nPost(\"/\", HttpEntity(`application/json`, \"\"\"{ \"name\": \"Jane\", \"favoriteNumber\" : 42 }\"\"\")) ~>\nroute ~> check {\n  mediaType shouldEqual `application/json`\n  responseAs[String] should include(\"\"\"\"name\":\"Jane\"\"\"\")\n  responseAs[String] should include(\"\"\"\"favoriteNumber\":42\"\"\")\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.handleWith;\n\nfinal Unmarshaller<HttpEntity, Person> unmarshaller = Jackson.unmarshaller(Person.class);\nfinal Marshaller<Person, HttpResponse> marshaller = Marshaller.entityToOKResponse(Jackson.<Person>marshaller());\n\nfinal Function<Person, Person> updatePerson = person -> {\n\n  //... some processing logic...\n\n  //return the person\n  return person;\n};\n\nfinal Route route = handleWith(unmarshaller, marshaller, updatePerson);\n\n// tests:\nfinal TestRouteResult routeResult = testRoute(route).run(\n  HttpRequest.POST(\"/\")\n    .withEntity(\n      HttpEntities.create(\n        ContentTypes.APPLICATION_JSON, \"{\\\"name\\\":\\\"Jane\\\",\\\"favoriteNumber\\\":42}\"\n      )\n    )\n);\nrouteResult.assertMediaType(MediaTypes.APPLICATION_JSON);\nrouteResult.assertEntity(\"{\\\"favoriteNumber\\\":42,\\\"name\\\":\\\"Jane\\\"}\");\nThe PersonJsonSupport object handlesprevious example uses also Json Support via Jackson to handle both marshalling and unmarshalling of the Person case class.\ncopysourceobject PersonJsonSupport extends DefaultJsonProtocol with SprayJsonSupport {\n  implicit val PortofolioFormats = jsonFormat2(Person)\n}","title":"Examples"},{"location":"/routing-dsl/directives/method-directives/index.html","text":"","title":"MethodDirectives"},{"location":"/routing-dsl/directives/method-directives/index.html#methoddirectives","text":"delete extractMethod get head method options overrideMethodWithParameter patch post put","title":"MethodDirectives"},{"location":"/routing-dsl/directives/method-directives/delete.html","text":"","title":"delete"},{"location":"/routing-dsl/directives/method-directives/delete.html#delete","text":"Matches requests with HTTP method DELETE.\nSignature def delete: Directive0","title":"delete"},{"location":"/routing-dsl/directives/method-directives/delete.html#description","text":"This directive filters an incoming request by its HTTP method. Only requests with method DELETE are passed on to the inner route. All others are rejected with a MethodRejectionMethodRejection, which is translated into a 405 Method Not Allowed response by the default RejectionHandler.","title":"Description"},{"location":"/routing-dsl/directives/method-directives/delete.html#example","text":"Scala copysourceval route = delete { complete(\"This is a DELETE request.\") }\n\n// tests:\nDelete(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"This is a DELETE request.\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.delete;\n\nfinal Route route = delete(() -> complete(\"This is a DELETE request.\"));\n\ntestRoute(route).run(HttpRequest.DELETE(\"/\")).assertEntity(\n    \"This is a DELETE request.\");","title":"Example"},{"location":"/routing-dsl/directives/method-directives/extractMethod.html","text":"","title":"extractMethod"},{"location":"/routing-dsl/directives/method-directives/extractMethod.html#extractmethod","text":"Signature def extractMethod: Directive1[HttpMethod]","title":"extractMethod"},{"location":"/routing-dsl/directives/method-directives/extractMethod.html#description","text":"Extracts the HttpMethodHttpMethod from the request context and provides it for use for other directives explicitly.","title":"Description"},{"location":"/routing-dsl/directives/method-directives/extractMethod.html#example","text":"In the below example our route first matches all GET requests, and if an incoming request wasn’t a GET, the matching continues and the extractMethod route will be applied which we can use to programatically print what type of request it was - independent of what actual HttpMethod it was:\nScala copysourceval route =\n  concat(\n    get {\n      complete(\"This is a GET request.\")\n    },\n    extractMethod { method =>\n      complete(s\"This ${method.name} request, clearly is not a GET!\")\n    })\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"This is a GET request.\"\n}\n\nPut(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"This PUT request, clearly is not a GET!\"\n}\nHead(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"This HEAD request, clearly is not a GET!\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.get;\nimport static org.apache.pekko.http.javadsl.server.Directives.extractMethod;\n\n\nfinal Route route = concat(\n    get(() ->\n        complete(\"This is a GET request.\")\n    ),\n    extractMethod(method ->\n        complete(\"This \" + method.value() + \" request, clearly is not a GET!\")\n    )\n);\n\ntestRoute(route).run(HttpRequest.GET(\"/\")).assertEntity(\n    \"This is a GET request.\");\n\ntestRoute(route).run(HttpRequest.PUT(\"/\").withEntity(\"put content\"))\n    .assertEntity(\"This PUT request, clearly is not a GET!\");\n\ntestRoute(route).run(HttpRequest.HEAD(\"/\")).assertEntity(\n    \"This HEAD request, clearly is not a GET!\");","title":"Example"},{"location":"/routing-dsl/directives/method-directives/extractMethod.html#custom-http-method","text":"When you define a custom HttpMethod, you can define a route using extractMethod.\nScala copysourceimport org.apache.pekko.http.scaladsl.settings.{ ParserSettings, ServerSettings }\n\n// define custom method type:\nval BOLT = HttpMethod.custom(\"BOLT\", safe = false,\n  idempotent = true, requestEntityAcceptance = Expected)\n\n// add custom method to parser settings:\nval parserSettings = ParserSettings.forServer(system).withCustomMethods(BOLT)\nval serverSettings = ServerSettings(system).withParserSettings(parserSettings)\n\nval routes = extractMethod { method =>\n  complete(s\"This is a ${method.name} method request.\")\n}\nval binding = Http().newServerAt(host, port).withSettings(serverSettings).bind(routes)\n\nval request = HttpRequest(BOLT, s\"http://$host:$port/\", protocol = `HTTP/1.1`) Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.extractMethod;\n\n\n// define custom method type:\nHttpMethod BOLT =\n  HttpMethods.custom(\"BOLT\", false, true, Expected);\n\n// add custom method to parser settings:\nfinal ParserSettings parserSettings =\n  ParserSettings.forServer(system).withCustomMethods(BOLT);\nfinal ServerSettings serverSettings =\n  ServerSettings.create(system).withParserSettings(parserSettings);\n\nfinal Route routes = concat(\n  extractMethod( method ->\n    complete( \"This is a \" + method.name() + \" request.\")\n  )\n);\nfinal Http http = Http.get(system);\nfinal CompletionStage<ServerBinding> binding =\n  http.newServerAt(host, port)\n      .withSettings(serverSettings)\n      .logTo(loggingAdapter)\n      .bind(routes);\n\nHttpRequest request = HttpRequest.create()\n  .withUri(\"http://\" + host + \":\" + Integer.toString(port))\n  .withMethod(BOLT)\n  .withProtocol(HTTP_1_1);\n\nCompletionStage<HttpResponse> response = http.singleRequest(request);","title":"Custom Http Method"},{"location":"/routing-dsl/directives/method-directives/get.html","text":"","title":"get"},{"location":"/routing-dsl/directives/method-directives/get.html#get","text":"Matches requests with HTTP method GET.\nSignature def get: Directive0","title":"get"},{"location":"/routing-dsl/directives/method-directives/get.html#description","text":"This directive filters the incoming request by its HTTP method. Only requests with method GET are passed on to the inner route. All others are rejected with a MethodRejectionMethodRejection, which is translated into a 405 Method Not Allowed response by the default RejectionHandler.","title":"Description"},{"location":"/routing-dsl/directives/method-directives/get.html#example","text":"Scala copysourceval route = get { complete(\"This is a GET request.\") }\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"This is a GET request.\"\n} Java copysourcefinal Route route = get(() -> complete(\"This is a GET request.\"));\n\ntestRoute(route).run(HttpRequest.GET(\"/\")).assertEntity(\n    \"This is a GET request.\");","title":"Example"},{"location":"/routing-dsl/directives/method-directives/head.html","text":"","title":"head"},{"location":"/routing-dsl/directives/method-directives/head.html#head","text":"Matches requests with HTTP method HEAD.\nSignature def head: Directive0","title":"head"},{"location":"/routing-dsl/directives/method-directives/head.html#description","text":"This directive filters the incoming request by its HTTP method. Only requests with method HEAD are passed on to the inner route. All others are rejected with a MethodRejectionMethodRejection, which is translated into a 405 Method Not Allowed response by the default RejectionHandler.\nNote Apache Pekko HTTP can handle HEAD requests transparently by dispatching a GET request to the handler and stripping off the result body. See the pekko.http.server.transparent-head-requests setting for how to enable this behavior.","title":"Description"},{"location":"/routing-dsl/directives/method-directives/head.html#example","text":"Scala copysourceval route = head { complete(\"This is a HEAD request.\") }\n\n// tests:\nHead(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"This is a HEAD request.\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.head;\n\nfinal Route route = head(() -> complete(\"This is a HEAD request.\"));\n\ntestRoute(route).run(HttpRequest.HEAD(\"/\")).assertEntity(\n    \"This is a HEAD request.\");","title":"Example"},{"location":"/routing-dsl/directives/method-directives/method.html","text":"","title":"method"},{"location":"/routing-dsl/directives/method-directives/method.html#method","text":"Matches HTTP requests based on their method.\nSignature def method(httpMethod: HttpMethod): Directive0","title":"method"},{"location":"/routing-dsl/directives/method-directives/method.html#description","text":"This directive filters the incoming request by its HTTP method. Only requests with the specified method are passed on to the inner route. All others are rejected with a MethodRejectionMethodRejection, which is translated into a 405 Method Not Allowed response by the default RejectionHandler.","title":"Description"},{"location":"/routing-dsl/directives/method-directives/method.html#example","text":"Scala copysourceval route = method(HttpMethods.PUT) { complete(\"This is a PUT request.\") }\n\n// tests:\nPut(\"/\", \"put content\") ~> route ~> check {\n  responseAs[String] shouldEqual \"This is a PUT request.\"\n}\n\nGet(\"/\") ~> Route.seal(route) ~> check {\n  status shouldEqual StatusCodes.MethodNotAllowed\n  responseAs[String] shouldEqual \"HTTP method not allowed, supported methods: PUT\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.method;\n\nfinal Route route = method(HttpMethods.PUT,\n    () -> complete(\"This is a PUT request.\"));\n\ntestRoute(route).run(HttpRequest.PUT(\"/\").withEntity(\"put content\"))\n    .assertEntity(\"This is a PUT request.\");\n\ntestRoute(route).run(HttpRequest.GET(\"/\")).assertStatusCode(\n    StatusCodes.METHOD_NOT_ALLOWED);","title":"Example"},{"location":"/routing-dsl/directives/method-directives/options.html","text":"","title":"options"},{"location":"/routing-dsl/directives/method-directives/options.html#options","text":"Matches requests with HTTP method OPTIONS.\nSignature def options: Directive0","title":"options"},{"location":"/routing-dsl/directives/method-directives/options.html#description","text":"This directive filters the incoming request by its HTTP method. Only requests with method OPTIONS are passed on to the inner route. All others are rejected with a MethodRejectionMethodRejection, which is translated into a 405 Method Not Allowed response by the default RejectionHandler.","title":"Description"},{"location":"/routing-dsl/directives/method-directives/options.html#example","text":"Scala copysourceval route = options { complete(\"This is an OPTIONS request.\") }\n\n// tests:\nOptions(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"This is an OPTIONS request.\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.options;\n\nfinal Route route = options(() -> complete(\"This is a OPTIONS request.\"));\n\ntestRoute(route).run(HttpRequest.OPTIONS(\"/\")).assertEntity(\n    \"This is a OPTIONS request.\");","title":"Example"},{"location":"/routing-dsl/directives/method-directives/overrideMethodWithParameter.html","text":"","title":"overrideMethodWithParameter"},{"location":"/routing-dsl/directives/method-directives/overrideMethodWithParameter.html#overridemethodwithparameter","text":"Signature def overrideMethodWithParameter(paramName: String): Directive0","title":"overrideMethodWithParameter"},{"location":"/routing-dsl/directives/method-directives/overrideMethodWithParameter.html#description","text":"Changes the request method to the value of the specified query parameter.\nChanges the HTTP method of the request to the value of the specified query string parameter. If the query string parameter is not specified this directive has no effect.\nIf the query string is specified as something that is not an HTTP method, then this directive completes the request with a 501 Not Implemented response.\nThis directive is useful for:\nUse in combination with JSONP (JSONP only supports GET) Supporting older browsers that lack support for certain HTTP methods. E.g. IE8 does not support PATCH","title":"Description"},{"location":"/routing-dsl/directives/method-directives/overrideMethodWithParameter.html#example","text":"Scala copysourceval route =\n  overrideMethodWithParameter(\"method\") {\n    concat(\n      get {\n        complete(\"This looks like a GET request.\")\n      },\n      post {\n        complete(\"This looks like a POST request.\")\n      })\n  }\n\n// tests:\nGet(\"/?method=POST\") ~> route ~> check {\n  responseAs[String] shouldEqual \"This looks like a POST request.\"\n}\nPost(\"/?method=get\") ~> route ~> check {\n  responseAs[String] shouldEqual \"This looks like a GET request.\"\n}\n\nGet(\"/?method=hallo\") ~> route ~> check {\n  status shouldEqual StatusCodes.NotImplemented\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.get;\nimport static org.apache.pekko.http.javadsl.server.Directives.post;\nimport static org.apache.pekko.http.javadsl.server.Directives.overrideMethodWithParameter;\n\n\nfinal Route route = concat(\n    overrideMethodWithParameter(\"method\", () ->\n      concat(\n        get(() -> complete(\"This looks like a GET request.\")),\n        post(() -> complete(\"This looks like a POST request.\"))\n      )\n    )\n);\n\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/?method=POST\")).assertEntity(\n    \"This looks like a POST request.\");\n\ntestRoute(route).run(HttpRequest.POST(\"/?method=get\"))\n    .assertEntity(\"This looks like a GET request.\");\n\ntestRoute(route).run(HttpRequest.GET(\"/?method=hallo\")).assertEntity(\n    \"The server either does not recognize the request method, or it lacks the ability to fulfill the request.\");","title":"Example"},{"location":"/routing-dsl/directives/method-directives/patch.html","text":"","title":"patch"},{"location":"/routing-dsl/directives/method-directives/patch.html#patch","text":"Matches requests with HTTP method PATCH.\nSignature def patch: Directive0","title":"patch"},{"location":"/routing-dsl/directives/method-directives/patch.html#description","text":"This directive filters the incoming request by its HTTP method. Only requests with method PATCH are passed on to the inner route. All others are rejected with a MethodRejectionMethodRejection, which is translated into a 405 Method Not Allowed response by the default RejectionHandler.","title":"Description"},{"location":"/routing-dsl/directives/method-directives/patch.html#example","text":"Scala copysourceval route = patch { complete(\"This is a PATCH request.\") }\n\n// tests:\nPatch(\"/\", \"patch content\") ~> route ~> check {\n  responseAs[String] shouldEqual \"This is a PATCH request.\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.patch;\n\nfinal Route route = patch(() -> complete(\"This is a PATCH request.\"));\n\ntestRoute(route).run(HttpRequest.PATCH(\"/\").withEntity(\"patch content\"))\n    .assertEntity(\"This is a PATCH request.\");","title":"Example"},{"location":"/routing-dsl/directives/method-directives/post.html","text":"","title":"post"},{"location":"/routing-dsl/directives/method-directives/post.html#post","text":"Matches requests with HTTP method POST.\nSignature def post: Directive0","title":"post"},{"location":"/routing-dsl/directives/method-directives/post.html#description","text":"This directive filters the incoming request by its HTTP method. Only requests with method POST are passed on to the inner route. All others are rejected with a MethodRejectionMethodRejection, which is translated into a 405 Method Not Allowed response by the default RejectionHandler.","title":"Description"},{"location":"/routing-dsl/directives/method-directives/post.html#example","text":"Scala copysourceval route = post { complete(\"This is a POST request.\") }\n\n// tests:\nPost(\"/\", \"post content\") ~> route ~> check {\n  responseAs[String] shouldEqual \"This is a POST request.\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.post;\n\nfinal Route route = post(() -> complete(\"This is a POST request.\"));\n\ntestRoute(route).run(HttpRequest.POST(\"/\").withEntity(\"post content\"))\n    .assertEntity(\"This is a POST request.\");","title":"Example"},{"location":"/routing-dsl/directives/method-directives/put.html","text":"","title":"put"},{"location":"/routing-dsl/directives/method-directives/put.html#put","text":"Matches requests with HTTP method PUT.\nSignature def put: Directive0","title":"put"},{"location":"/routing-dsl/directives/method-directives/put.html#description","text":"This directive filters the incoming request by its HTTP method. Only requests with method PUT are passed on to the inner route. All others are rejected with a MethodRejectionMethodRejection, which is translated into a 405 Method Not Allowed response by the default RejectionHandler.","title":"Description"},{"location":"/routing-dsl/directives/method-directives/put.html#example","text":"Scala copysourceval route = put { complete(\"This is a PUT request.\") }\n\n// tests:\nPut(\"/\", \"put content\") ~> route ~> check {\n  responseAs[String] shouldEqual \"This is a PUT request.\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.put;\n\nfinal Route route = put(() -> complete(\"This is a PUT request.\"));\n\ntestRoute(route).run(HttpRequest.PUT(\"/\").withEntity(\"put content\"))\n    .assertEntity(\"This is a PUT request.\");","title":"Example"},{"location":"/routing-dsl/directives/misc-directives/index.html","text":"","title":"MiscDirectives"},{"location":"/routing-dsl/directives/misc-directives/index.html#miscdirectives","text":"extractClientIP rejectEmptyResponse requestEntityEmpty requestEntityPresent selectPreferredLanguage validate withoutSizeLimit withSizeLimit","title":"MiscDirectives"},{"location":"/routing-dsl/directives/misc-directives/extractClientIP.html","text":"","title":"extractClientIP"},{"location":"/routing-dsl/directives/misc-directives/extractClientIP.html#extractclientip","text":"Signature def extractClientIP: Directive1[RemoteAddress]","title":"extractClientIP"},{"location":"/routing-dsl/directives/misc-directives/extractClientIP.html#description","text":"Provides the value of the X-Forwarded-For or X-Real-IP header. If neither of those is found it will fall back to the value of the synthetic RemoteAddress header (pekko.http.server.remote-address-header setting is on) or the value of the AttributeKeys.remoteAddressAttributeKeys.remoteAddress attribute (if the pekko.http.server.remote-address-attribute setting is on)\nIf no valid IP address is encountered, this extractor will return RemoteAddress.Unknown`.\nWarning Clients can send any values in these headers. If the client is not a trusted upstream, the IP address can be malicious. For sensitive operations use the AttributeKeys.remoteAddressAttributeKeys.remoteAddress attribute, or use the specific headers which are known to be set correctly by the infrastructure you do trust.","title":"Description"},{"location":"/routing-dsl/directives/misc-directives/extractClientIP.html#example","text":"Scala copysourceval route = extractClientIP { ip =>\n  complete(\"Client's ip is \" + ip.toOption.map(_.getHostAddress).getOrElse(\"unknown\"))\n}\n\n// tests:\nGet(\"/\").withHeaders(`X-Forwarded-For`(RemoteAddress(InetAddress.getByName(\"192.168.3.12\")))) ~> route ~> check {\n  responseAs[String] shouldEqual \"Client's ip is 192.168.3.12\"\n} Java copysourcefinal Route route = extractClientIP(remoteAddr ->\n  complete(\"Client's IP is \" + remoteAddr.getAddress().map(InetAddress::getHostAddress)\n    .orElseGet(() -> \"unknown\"))\n);\n\n// tests:\nfinal String ip = \"192.168.1.2\";\nfinal org.apache.pekko.http.javadsl.model.RemoteAddress remoteAddress =\n  org.apache.pekko.http.javadsl.model.RemoteAddress.create(InetAddress.getByName(ip));\n\nfinal HttpRequest request = HttpRequest.GET(\"/\")\n  .addHeader(XForwardedFor.create(remoteAddress)); //\n\ntestRoute(route).run(request)\n  .assertEntity(\"Client's IP is \" + ip);\n\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertEntity(\"Client's IP is unknown\");","title":"Example"},{"location":"/routing-dsl/directives/misc-directives/rejectEmptyResponse.html","text":"","title":"rejectEmptyResponse"},{"location":"/routing-dsl/directives/misc-directives/rejectEmptyResponse.html#rejectemptyresponse","text":"Signature def rejectEmptyResponse: Directive0","title":"rejectEmptyResponse"},{"location":"/routing-dsl/directives/misc-directives/rejectEmptyResponse.html#description","text":"Replaces a response with no content with an empty rejection.\nThe rejectEmptyResponse directive is mostly used together with marshallers that serialize to an empty response under certain circumstances. For example serialization of None. In many cases this empty serialization should instead be handled as 404 Not Found which is the effect of using rejectEmptyResponse.","title":"Description"},{"location":"/routing-dsl/directives/misc-directives/rejectEmptyResponse.html#example","text":"Scala copysourceval route = rejectEmptyResponse {\n  path(\"even\" / IntNumber) { i =>\n    complete {\n      // returns Some(evenNumberDescription) or None\n      Option(i).filter(_ % 2 == 0).map { num =>\n        s\"Number $num is even.\"\n      }\n    }\n  }\n}\n\n// tests:\nGet(\"/even/23\") ~> Route.seal(route) ~> check {\n  status shouldEqual StatusCodes.NotFound\n}\nGet(\"/even/28\") ~> route ~> check {\n  responseAs[String] shouldEqual \"Number 28 is even.\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\nimport static org.apache.pekko.http.javadsl.server.Directives.rejectEmptyResponse;\n\nfinal Route route = rejectEmptyResponse(() ->\n        path(PathMatchers.segment(\"even\").slash(PathMatchers.integerSegment()), (value) -> {\n                  String response = \"\";\n                  if (value % 2 == 0) {\n                    response = \"Number \" + value + \" is even\";\n                  }\n                  return complete(response);\n                }\n        ));\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/even/24\"))\n  .assertEntity(\"Number 24 is even\");\ntestRoute(route).run(HttpRequest.GET(\"/even/23\"))\n  .assertStatusCode(StatusCodes.NOT_FOUND);","title":"Example"},{"location":"/routing-dsl/directives/misc-directives/requestEntityEmpty.html","text":"","title":"requestEntityEmpty"},{"location":"/routing-dsl/directives/misc-directives/requestEntityEmpty.html#requestentityempty","text":"Signature def requestEntityEmpty: Directive0","title":"requestEntityEmpty"},{"location":"/routing-dsl/directives/misc-directives/requestEntityEmpty.html#description","text":"A filter that checks if the request entity is empty and only then passes processing to the inner route. Otherwise, the request is rejected.\nSee also requestEntityPresent for the opposite effect.","title":"Description"},{"location":"/routing-dsl/directives/misc-directives/requestEntityEmpty.html#example","text":"Scala copysourceval route =\n  concat(\n    requestEntityEmpty {\n      complete(\"request entity empty\")\n    },\n    requestEntityPresent {\n      complete(\"request entity present\")\n    })\n\n// tests:\nPost(\"/\", \"text\") ~> Route.seal(route) ~> check {\n  responseAs[String] shouldEqual \"request entity present\"\n}\nPost(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"request entity empty\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.requestEntityEmpty;\nimport static org.apache.pekko.http.javadsl.server.Directives.requestEntityPresent;\n\nfinal Route route = requestEntityEmpty(() ->\n  complete(\"request entity empty\")\n).orElse(requestEntityPresent(() ->\n  complete(\"request entity present\")\n));\n\n// tests:\ntestRoute(route).run(HttpRequest.POST(\"/\"))\n  .assertEntity(\"request entity empty\");\ntestRoute(route).run(HttpRequest.POST(\"/\").withEntity(\"foo\"))\n  .assertEntity(\"request entity present\");","title":"Example"},{"location":"/routing-dsl/directives/misc-directives/requestEntityPresent.html","text":"","title":"requestEntityPresent"},{"location":"/routing-dsl/directives/misc-directives/requestEntityPresent.html#requestentitypresent","text":"Signature def requestEntityPresent: Directive0","title":"requestEntityPresent"},{"location":"/routing-dsl/directives/misc-directives/requestEntityPresent.html#description","text":"A simple filter that checks if the request entity is present and only then passes processing to the inner route. Otherwise, the request is rejected with RequestEntityExpectedRejectionRequestEntityExpectedRejection.\nSee also requestEntityEmpty for the opposite effect.","title":"Description"},{"location":"/routing-dsl/directives/misc-directives/requestEntityPresent.html#example","text":"Scala copysourceval route =\n  concat(\n    requestEntityEmpty {\n      complete(\"request entity empty\")\n    },\n    requestEntityPresent {\n      complete(\"request entity present\")\n    })\n\n// tests:\nPost(\"/\", \"text\") ~> Route.seal(route) ~> check {\n  responseAs[String] shouldEqual \"request entity present\"\n}\nPost(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"request entity empty\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.requestEntityEmpty;\nimport static org.apache.pekko.http.javadsl.server.Directives.requestEntityPresent;\n\nfinal Route route = requestEntityEmpty(() ->\n  complete(\"request entity empty\")\n).orElse(requestEntityPresent(() ->\n  complete(\"request entity present\")\n));\n\n// tests:\ntestRoute(route).run(HttpRequest.POST(\"/\"))\n  .assertEntity(\"request entity empty\");\ntestRoute(route).run(HttpRequest.POST(\"/\").withEntity(\"foo\"))\n  .assertEntity(\"request entity present\");","title":"Example"},{"location":"/routing-dsl/directives/misc-directives/selectPreferredLanguage.html","text":"","title":"selectPreferredLanguage"},{"location":"/routing-dsl/directives/misc-directives/selectPreferredLanguage.html#selectpreferredlanguage","text":"Signature def selectPreferredLanguage(first: Language, more: Language*): Directive1[Language]","title":"selectPreferredLanguage"},{"location":"/routing-dsl/directives/misc-directives/selectPreferredLanguage.html#description","text":"Inspects the request’s Accept-Language header and determines, which of a given set of language alternatives is preferred by the client according to content negotiation rules defined by RFC 7231 in section 5.3.5.\nIf there are several best language alternatives that the client has equal preference for (even if this preference is zero!) the order of the arguments is used as a tie breaker (first one wins).","title":"Description"},{"location":"/routing-dsl/directives/misc-directives/selectPreferredLanguage.html#example","text":"Scala copysourceval request = Get() ~> `Accept-Language`(\n  Language(\"en-US\"),\n  Language(\"en\").withQValue(0.7f),\n  LanguageRange.`*`.withQValue(0.1f),\n  Language(\"de\").withQValue(0.5f))\n\nrequest ~> {\n  selectPreferredLanguage(\"en\", \"en-US\") { lang =>\n    complete(lang.toString)\n  }\n} ~> check { responseAs[String] shouldEqual \"en-US\" }\n\nrequest ~> {\n  selectPreferredLanguage(\"de-DE\", \"hu\") { lang =>\n    complete(lang.toString)\n  }\n} ~> check { responseAs[String] shouldEqual \"de-DE\" } Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.selectPreferredLanguage;\n\nfinal Route enRoute = selectPreferredLanguage(\n  Arrays.asList(Language.create(\"en\"), Language.create(\"en-US\")), lang ->\n    complete(lang.toString())\n);\nfinal Route deHuRoute = selectPreferredLanguage(\n  Arrays.asList(Language.create(\"de-DE\"), Language.create(\"hu\")), lang ->\n    complete(lang.toString())\n);\n\n\n// tests:\nfinal HttpRequest request = HttpRequest.GET(\"/\").addHeader(AcceptLanguage.create(\n  Language.create(\"en-US\").withQValue(1f),\n  Language.create(\"en\").withQValue(0.7f),\n  LanguageRanges.ALL.withQValue(0.1f),\n  Language.create(\"de-DE\").withQValue(0.5f)\n));\n\ntestRoute(enRoute).run(request).assertEntity(\"en-US\");\ntestRoute(deHuRoute).run(request).assertEntity(\"de-DE\");","title":"Example"},{"location":"/routing-dsl/directives/misc-directives/validate.html","text":"","title":"validate"},{"location":"/routing-dsl/directives/misc-directives/validate.html#validate","text":"Allows validating a precondition before handling a route.\nSignature def validate(check:","title":"validate"},{"location":"/routing-dsl/directives/misc-directives/validate.html#description","text":"Checks an arbitrary condition and passes control to the inner route if it returns true. Otherwise, rejects the request with a ValidationRejectionValidationRejection containing the given error message.","title":"Description"},{"location":"/routing-dsl/directives/misc-directives/validate.html#example","text":"Scala copysourceval route =\n  extractUri { uri =>\n    validate(uri.path.toString.size < 5, s\"Path too long: '${uri.path.toString}'\") {\n      complete(s\"Full URI: $uri\")\n    }\n  }\n\n// tests:\nGet(\"/234\") ~> route ~> check {\n  responseAs[String] shouldEqual \"Full URI: http://example.com/234\"\n}\nGet(\"/abcdefghijkl\") ~> route ~> check {\n  rejection shouldEqual ValidationRejection(\"Path too long: '/abcdefghijkl'\", None)\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.extractUri;\nimport static org.apache.pekko.http.javadsl.server.Directives.validate;\n\nfinal Route route = extractUri(uri ->\n  validate(() -> uri.path().length() < 5,\n    \"Path too long: \" + uri.path(),\n    () -> complete(\"Full URI: \" + uri.toString()))\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/234\"))\n  .assertEntity(\"Full URI: http://example.com/234\");\ntestRoute(route).run(HttpRequest.GET(\"/abcdefghijkl\"))\n  .assertEntity(\"Path too long: /abcdefghijkl\");","title":"Example"},{"location":"/routing-dsl/directives/misc-directives/withoutSizeLimit.html","text":"","title":"withoutSizeLimit"},{"location":"/routing-dsl/directives/misc-directives/withoutSizeLimit.html#withoutsizelimit","text":"Signature def withoutSizeLimit: Directive0","title":"withoutSizeLimit"},{"location":"/routing-dsl/directives/misc-directives/withoutSizeLimit.html#description","text":"Skips request entity size verification.\nThe whole mechanism of entity size checking is intended to prevent certain Denial-of-Service attacks. So suggested setup is to have pekko.http.parsing.max-content-length relatively low and use withoutSizeLimit directive just for endpoints for which size verification should not be performed.\nCaution Usage of withoutSizeLimit is not recommended as it turns off the too large payload protection. Therefore, we highly encourage using withSizeLimit instead, providing it with a value high enough to successfully handle the route in need of big entities.\nSee also withSizeLimit for setting request entity size limit.","title":"Description"},{"location":"/routing-dsl/directives/misc-directives/withoutSizeLimit.html#example","text":"Scala copysourceval route =\n  withoutSizeLimit {\n    entity(as[String]) { _ =>\n      complete(HttpResponse())\n    }\n  }\n\n// tests:\ndef entityOfSize(size: Int) =\n  HttpEntity(ContentTypes.`text/plain(UTF-8)`, \"0\" * size)\n\n// will work even if you have configured pekko.http.parsing.max-content-length = 500\nPost(\"/abc\", entityOfSize(501)) ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.entity;\nimport static org.apache.pekko.http.javadsl.server.Directives.withSizeLimit;\n\nfinal Route route = withSizeLimit(500, () ->\n  entity(Unmarshaller.entityToString(), (entity) ->\n    complete(\"ok\")\n  )\n);\n\nFunction<Integer, HttpRequest> withEntityOfSize = (sizeLimit) -> {\n  char[] charArray = new char[sizeLimit];\n  Arrays.fill(charArray, '0');\n  return HttpRequest.POST(\"/\").withEntity(new String(charArray));\n};\n\n// tests:\ntestRoute(route).run(withEntityOfSize.apply(500))\n  .assertStatusCode(StatusCodes.OK);\n\ntestRoute(route).run(withEntityOfSize.apply(501))\n  .assertStatusCode(StatusCodes.PAYLOAD_TOO_LARGE);","title":"Example"},{"location":"/routing-dsl/directives/misc-directives/withSizeLimit.html","text":"","title":"withSizeLimit"},{"location":"/routing-dsl/directives/misc-directives/withSizeLimit.html#withsizelimit","text":"Signature def withSizeLimit(maxBytes: Long): Directive0","title":"withSizeLimit"},{"location":"/routing-dsl/directives/misc-directives/withSizeLimit.html#description","text":"Fails the stream with EntityStreamSizeException if its request entity size exceeds given limit. Limit given as parameter overrides limit configured with pekko.http.parsing.max-content-length.\nThe whole mechanism of entity size checking is intended to prevent certain Denial-of-Service attacks. So suggested setup is to have pekko.http.parsing.max-content-length relatively low and use withSizeLimit directive for endpoints which expects bigger entities.\nSee also withoutSizeLimit for skipping request entity size check.","title":"Description"},{"location":"/routing-dsl/directives/misc-directives/withSizeLimit.html#examples","text":"Scala copysourceval route = withSizeLimit(500) {\n  entity(as[String]) { _ =>\n    complete(HttpResponse())\n  }\n}\n\n// tests:\ndef entityOfSize(size: Int) =\n  HttpEntity(ContentTypes.`text/plain(UTF-8)`, \"0\" * size)\n\nPost(\"/abc\", entityOfSize(500)) ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n}\n\nPost(\"/abc\", entityOfSize(501)) ~> Route.seal(route) ~> check {\n  status shouldEqual StatusCodes.PayloadTooLarge\n}\n Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.entity;\nimport static org.apache.pekko.http.javadsl.server.Directives.withSizeLimit;\n\nfinal Route route = withSizeLimit(500, () ->\n  entity(Unmarshaller.entityToString(), (entity) ->\n    complete(\"ok\")\n  )\n);\n\nFunction<Integer, HttpRequest> withEntityOfSize = (sizeLimit) -> {\n  char[] charArray = new char[sizeLimit];\n  Arrays.fill(charArray, '0');\n  return HttpRequest.POST(\"/\").withEntity(new String(charArray));\n};\n\n// tests:\ntestRoute(route).run(withEntityOfSize.apply(500))\n  .assertStatusCode(StatusCodes.OK);\n\ntestRoute(route).run(withEntityOfSize.apply(501))\n  .assertStatusCode(StatusCodes.PAYLOAD_TOO_LARGE);\nBeware that request entity size check is executed when entity is consumed. Therefore in the following example even request with entity greater than argument to withSizeLimit will succeed (because this route does not consume entity): copysourceval route = withSizeLimit(500) {\n  complete(HttpResponse())\n}\n\n// tests:\ndef entityOfSize(size: Int) =\n  HttpEntity(ContentTypes.`text/plain(UTF-8)`, \"0\" * size)\n\nPost(\"/abc\", entityOfSize(500)) ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n}\n\nPost(\"/abc\", entityOfSize(501)) ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n}\nDirective withSizeLimit is implemented in terms of HttpEntity.withSizeLimit which means that in case of nested withSizeLimit directives the innermost is applied:\nScala copysourceval route =\n  withSizeLimit(500) {\n    withSizeLimit(800) {\n      entity(as[String]) { _ =>\n        complete(HttpResponse())\n      }\n    }\n  }\n\n// tests:\ndef entityOfSize(size: Int) =\n  HttpEntity(ContentTypes.`text/plain(UTF-8)`, \"0\" * size)\nPost(\"/abc\", entityOfSize(800)) ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n}\n\nPost(\"/abc\", entityOfSize(801)) ~> Route.seal(route) ~> check {\n  status shouldEqual StatusCodes.PayloadTooLarge\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.entity;\nimport static org.apache.pekko.http.javadsl.server.Directives.withSizeLimit;\n\nfinal Route route = withSizeLimit(500, () ->\n        withSizeLimit(800, () ->\n        entity(Unmarshaller.entityToString(), (entity) ->\n                complete(\"ok\")\n        ))\n);\n\nFunction<Integer, HttpRequest> withEntityOfSize = (sizeLimit) -> {\n  char[] charArray = new char[sizeLimit];\n  Arrays.fill(charArray, '0');\n  return HttpRequest.POST(\"/\").withEntity(new String(charArray));\n};\n\n// tests:\ntestRoute(route).run(withEntityOfSize.apply(800))\n        .assertStatusCode(StatusCodes.OK);\n\ntestRoute(route).run(withEntityOfSize.apply(801))\n        .assertStatusCode(StatusCodes.PAYLOAD_TOO_LARGE);","title":"Examples"},{"location":"/routing-dsl/directives/parameter-directives/index.html","text":"","title":"ParameterDirectives"},{"location":"/routing-dsl/directives/parameter-directives/index.html#parameterdirectives","text":"When to use which parameter directive? parameter parameters parameterMap parameterMultiMap parameterSeqparameterList","title":"ParameterDirectives"},{"location":"/routing-dsl/directives/parameter-directives/index.html#when-to-use-which-parameter-directive-","text":"Usually, you want to use the high-level parameters directive. When you need more low-level access you can use the table below to decide which directive to use which shows properties of different parameter directives.\ndirective level ordering multi parameter high no no parameters high no yes parameterMap low no no parameterMultiMap low no yes parameterSeqparameterList low yes yes\nlevel high-level parameter directives extract subset of all parameters by name and allow conversions and automatically report errors if expectations are not met, low-level directives give you all parameters at once, leaving all further processing to you ordering original ordering from request URL is preserved multi multiple values per parameter name are possible\nNote If you need to extract multiple parameters, apply the parameter directive multiple times.","title":"When to use which parameter directive?"},{"location":"/routing-dsl/directives/parameter-directives/parameter.html","text":"","title":"parameter"},{"location":"/routing-dsl/directives/parameter-directives/parameter.html#parameter","text":"","title":"parameter"},{"location":"/routing-dsl/directives/parameter-directives/parameter.html#description","text":"Extracts a query parameter value from the requestrequest and provides it to the inner route as a String.\nIn the Scala API, parameter is an alias for parameters and you can use both directives to extract any number of parameter values. For a detailed description about how to extract one or more parameters see parameters.\nSee When to use which parameter directive? to understand when to use which directive.","title":"Description"},{"location":"/routing-dsl/directives/parameter-directives/parameter.html#example","text":"Scala copysourceval route =\n  parameter(\"color\") { color =>\n    complete(s\"The color is '$color'\")\n  }\n\n// tests:\nGet(\"/?color=blue\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The color is 'blue'\"\n}\n\nGet(\"/\") ~> Route.seal(route) ~> check {\n  status shouldEqual StatusCodes.NotFound\n  responseAs[String] shouldEqual \"Request is missing required query parameter 'color'\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.parameter;\n\nfinal Route route = parameter(\"color\", color ->\n  complete(\"The color is '\" + color + \"'\")\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/?color=blue\"))\n  .assertEntity(\"The color is 'blue'\");\n\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertStatusCode(StatusCodes.NOT_FOUND)\n  .assertEntity(\"Request is missing required query parameter 'color'\");","title":"Example"},{"location":"/routing-dsl/directives/parameter-directives/parameters.html","text":"","title":"parameters"},{"location":"/routing-dsl/directives/parameter-directives/parameters.html#parameters","text":"This page explains how to extract multiple query parameter values from the request, or parameters that might or might not be present.\nSignature def parameters(param: <ParamDef[T]>): Directive1[T]\ndef parameters(params: <ParamDef[T_i]>*): Directive[T_0 :: ... T_i ... :: HNil]\ndef parameters(params: <ParamDef[T_0]> :: ... <ParamDef[T_i]> ... :: HNil): Directive[T_0 :: ... T_i ... :: HNil]\n The signature shown is simplified and written in pseudo-syntax, the real signature uses magnets. [1] The type <ParamDef> doesn’t really exist but consists of the syntactic variants as shown in the description and the examples. [1] See The Magnet Pattern for an explanation of magnet-based overloading.","title":"parameters"},{"location":"/routing-dsl/directives/parameter-directives/parameters.html#description","text":"The parameters directive filters on the existence of several query parameters and extract their values. Query parameters can be either extracted as a String or can be converted to another type. The parameter name is supplied as a String. Parameter extraction can be modified to mark a query parameter as required, optional, or repeated, or to filter requests where a parameter has a certain value: \"color\" extract the value of parameter “color” as String reject if the parameter is missing \"color\".optional (symbolic notation \"color\".?) extract the optional value of parameter “color” as Option[String] \"color\".withDefault(\"red\") (symbolic notation \"color\" ? \"red\") extract the optional value of parameter “color” as String with default value \"red\" \"color\".requiredValue(\"blue\") (symbolic notation \"color\" ! \"blue\") require the value of parameter “color” to be \"blue\" and extract nothing reject if the parameter is missing or has a different value \"amount\".as[Int] extract the value of parameter “amount” as Int, you need a matching UnmarshallerUnmarshaller in scope for that to work (see also Unmarshalling) reject if the parameter is missing or can’t be unmarshalled to the given type \"amount\".as(unmarshaller) extract the value of parameter “amount” with an explicit UnmarshallerUnmarshaller as described in Unmarshalling reject if the parameter is missing or can’t be unmarshalled to the given type \"distance\".repeated extract multiple occurrences of parameter “distance” as Iterable[String] \"distance\".as[Int].repeated extract multiple occurrences of parameter “distance” as Iterable[Int], you need a matching UnmarshallerUnmarshaller in scope for that to work (see also Unmarshalling) \"distance\".as(unmarshaller).repeated extract multiple occurrences of parameter “distance” with an explicit UnmarshallerUnmarshaller as described in Unmarshalling You can use Case Class Extraction to group several extracted values together into a case-class instance.\nIn order to filter on the existence of several query parameters, you need to nest as many parameter directives as desired. Query parameters can be either extracted as a String or can be converted to another type. Different methods must be used when the desired parameter is required, optional or repeated.\nRequests missing a required parameter or parameter value will be rejected with an appropriate rejection.\nIf an unmarshaller throws an exception while extracting the value of a parameter, the request will be rejected with a MissingQueryParameterRejection if the unmarshaller threw an Unmarshaller.NoContentException or a MalformedQueryParamRejectionMalformedQueryParamRejection in all other cases. (see also Rejections)\nThere’s also a singular version, parameter. Form fields can be handled in a similar way, see formFields.\nSee When to use which parameter directive? to understand when to use which directive.","title":"Description"},{"location":"/routing-dsl/directives/parameter-directives/parameters.html#examples","text":"","title":"Examples"},{"location":"/routing-dsl/directives/parameter-directives/parameters.html#required-parameter","text":"Scala copysourceval route =\n  parameters(\"color\", \"backgroundColor\") { (color, backgroundColor) =>\n    complete(s\"The color is '$color' and the background is '$backgroundColor'\")\n  }\n\n// tests:\nGet(\"/?color=blue&backgroundColor=red\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The color is 'blue' and the background is 'red'\"\n}\nGet(\"/?color=blue\") ~> Route.seal(route) ~> check {\n  status shouldEqual StatusCodes.NotFound\n  responseAs[String] shouldEqual \"Request is missing required query parameter 'backgroundColor'\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.parameter;\n\nfinal Route route = parameter(\"color\", color ->\n  parameter(\"backgroundColor\", backgroundColor ->\n    complete(\"The color is '\" + color\n               + \"' and the background is '\" + backgroundColor + \"'\")\n  )\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/?color=blue&backgroundColor=red\"))\n  .assertEntity(\"The color is 'blue' and the background is 'red'\");\n\ntestRoute(route).run(HttpRequest.GET(\"/?color=blue\"))\n  .assertStatusCode(StatusCodes.NOT_FOUND)\n  .assertEntity(\"Request is missing required query parameter 'backgroundColor'\");","title":"Required parameter"},{"location":"/routing-dsl/directives/parameter-directives/parameters.html#optional-parameter","text":"Scala copysourceval route =\n  parameters(\"color\", \"backgroundColor\".optional) { (color, backgroundColor) =>\n    val backgroundStr = backgroundColor.getOrElse(\"<undefined>\")\n    complete(s\"The color is '$color' and the background is '$backgroundStr'\")\n  }\n\n// tests:\nGet(\"/?color=blue&backgroundColor=red\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The color is 'blue' and the background is 'red'\"\n}\nGet(\"/?color=blue\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The color is 'blue' and the background is '<undefined>'\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.parameter;\nimport static org.apache.pekko.http.javadsl.server.Directives.parameterOptional;\n\nfinal Route route = parameter(\"color\", color ->\n  parameterOptional(\"backgroundColor\", backgroundColor ->\n    complete(\"The color is '\" + color + \"' and the background is '\"\n      + backgroundColor.orElse(\"undefined\") + \"'\")\n  )\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/?color=blue&backgroundColor=red\"))\n  .assertEntity(\"The color is 'blue' and the background is 'red'\");\n\ntestRoute(route).run(HttpRequest.GET(\"/?color=blue\"))\n  .assertEntity(\"The color is 'blue' and the background is 'undefined'\");\nOptional parameter with default value copysourceval route =\n  parameters(\"color\", \"backgroundColor\".withDefault(\"white\")) { (color, backgroundColor) =>\n    complete(s\"The color is '$color' and the background is '$backgroundColor'\")\n  }\n\n// tests:\nGet(\"/?color=blue&backgroundColor=red\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The color is 'blue' and the background is 'red'\"\n}\nGet(\"/?color=blue\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The color is 'blue' and the background is 'white'\"\n}","title":"Optional parameter"},{"location":"/routing-dsl/directives/parameter-directives/parameters.html#parameter-with-required-value","text":"The requiredValue decorator makes the route match only if the parameter contains the specified value. The directive parameterRequiredValue makes the route match only if the parameter contains the specified value.\nScala copysourceval route =\n  parameters(\"color\", \"action\".requiredValue(\"true\")) { (color, _) =>\n    complete(s\"The color is '$color'.\")\n  }\n\n// tests:\nGet(\"/?color=blue&action=true\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The color is 'blue'.\"\n}\n\nGet(\"/?color=blue&action=false\") ~> Route.seal(route) ~> check {\n  status shouldEqual StatusCodes.NotFound\n  responseAs[String] shouldEqual \"Request is missing required value 'true' for query parameter 'action'\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.parameterRequiredValue;\n\nfinal Route route = parameter(\"color\", color ->\n  parameterRequiredValue(StringUnmarshallers.BOOLEAN, true, \"action\", () ->\n    complete(\"The color is '\" + color + \"'.\")\n  )\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/?color=blue&action=true\"))\n  .assertStatusCode(StatusCodes.OK)\n  .assertEntity(\"The color is 'blue'.\");\n\ntestRoute(route).run(HttpRequest.GET(\"/?color=blue&action=false\"))\n  .assertStatusCode(StatusCodes.NOT_FOUND)\n  .assertEntity(\"Request is missing required value 'true' for query parameter 'action'\");","title":"Parameter with required value"},{"location":"/routing-dsl/directives/parameter-directives/parameters.html#deserialized-parameter","text":"Scala copysourceval route =\n  parameters(\"color\", \"count\".as[Int]) { (color, count) =>\n    complete(s\"The color is '$color' and you have $count of it.\")\n  }\n\n// tests:\nGet(\"/?color=blue&count=42\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The color is 'blue' and you have 42 of it.\"\n}\n\nGet(\"/?color=blue&count=blub\") ~> Route.seal(route) ~> check {\n  status shouldEqual StatusCodes.BadRequest\n  responseAs[String] shouldEqual \"The query parameter 'count' was malformed:\\n'blub'\" +\n  \" is not a valid 32-bit signed integer value\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.parameter;\n\nfinal Route route = parameter(\"color\", color ->\n  parameter(StringUnmarshallers.INTEGER,\"count\", count ->\n    complete(\"The color is '\" + color + \"' and you have \" + count + \" of it.\")\n  )\n);\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/?color=blue&count=42\"))\n  .assertEntity(\"The color is 'blue' and you have 42 of it.\");\n\ntestRoute(route).run(HttpRequest.GET(\"/?color=blue&count=blub\"))\n  .assertStatusCode(StatusCodes.BAD_REQUEST)\n  .assertEntity(\"The query parameter 'count' was malformed:\\n'blub'\"\n                      +\" is not a valid 32-bit signed integer value\");\nRepeated parameter copysourceval route =\n  parameters(\"color\", \"city\".repeated) { (color, cities) =>\n    cities.toList match {\n      case Nil         => complete(s\"The color is '$color' and there are no cities.\")\n      case city :: Nil => complete(s\"The color is '$color' and the city is $city.\")\n      case multiple    => complete(s\"The color is '$color' and the cities are ${multiple.mkString(\", \")}.\")\n    }\n  }\n\n// tests:\nGet(\"/?color=blue\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The color is 'blue' and there are no cities.\"\n}\n\nGet(\"/?color=blue&city=Chicago\") ~> Route.seal(route) ~> check {\n  responseAs[String] shouldEqual \"The color is 'blue' and the city is Chicago.\"\n}\n\nGet(\"/?color=blue&city=Chicago&city=Boston\") ~> Route.seal(route) ~> check {\n  responseAs[String] shouldEqual \"The color is 'blue' and the cities are Boston, Chicago.\"\n} CSV parameter copysourceval route =\n  parameter(\"names\".as(CsvSeq[String])) { names =>\n    complete(s\"The parameters are ${names.mkString(\", \")}\")\n  }\n\n// tests:\nGet(\"/?names=\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The parameters are \"\n}\nGet(\"/?names=Caplin\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The parameters are Caplin\"\n}\nGet(\"/?names=Caplin,John\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The parameters are Caplin, John\"\n}\nGet(\"/?names=Caplin,John,\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The parameters are Caplin, John, \"\n} Repeated, deserialized parameter copysourceval route =\n  parameters(\"color\", \"distance\".as[Int].repeated) { (color, distances) =>\n    distances.toList match {\n      case Nil             => complete(s\"The color is '$color' and there are no distances.\")\n      case distance :: Nil => complete(s\"The color is '$color' and the distance is $distance.\")\n      case multiple        => complete(s\"The color is '$color' and the distances are ${multiple.mkString(\", \")}.\")\n    }\n  }\n\n// tests:\nGet(\"/?color=blue\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The color is 'blue' and there are no distances.\"\n}\n\nGet(\"/?color=blue&distance=5\") ~> Route.seal(route) ~> check {\n  responseAs[String] shouldEqual \"The color is 'blue' and the distance is 5.\"\n}\n\nGet(\"/?color=blue&distance=5&distance=14\") ~> Route.seal(route) ~> check {\n  responseAs[String] shouldEqual \"The color is 'blue' and the distances are 14, 5.\"\n}","title":"Deserialized parameter"},{"location":"/routing-dsl/directives/parameter-directives/parameterMap.html","text":"","title":"parameterMap"},{"location":"/routing-dsl/directives/parameter-directives/parameterMap.html#parametermap","text":"Signature def parameterMap: Directive1[Map[String, String]]","title":"parameterMap"},{"location":"/routing-dsl/directives/parameter-directives/parameterMap.html#description","text":"Extracts all parameters at once as a Map[String, String]Map<String, String> mapping parameter names to parameter values.\nIf a query contains a parameter value several times, the map will contain the last one.\nSee also When to use which parameter directive? to understand when to use which directive.","title":"Description"},{"location":"/routing-dsl/directives/parameter-directives/parameterMap.html#example","text":"Scala copysourceval route =\n  parameterMap { params =>\n    def paramString(param: (String, String)): String = s\"\"\"${param._1} = '${param._2}'\"\"\"\n    complete(s\"The parameters are ${params.map(paramString).mkString(\", \")}\")\n  }\n\n// tests:\nGet(\"/?color=blue&count=42\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The parameters are color = 'blue', count = '42'\"\n}\nGet(\"/?x=1&x=2\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The parameters are x = '2'\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.parameterMap;\n\nfinal Function<Entry, String> paramString =\n  entry -> entry.getKey() + \" = '\" + entry.getValue() + \"'\";\n\nfinal Route route = parameterMap(params -> {\n  final String pString = params.entrySet()\n    .stream()\n    .map(paramString::apply)\n    .collect(Collectors.joining(\", \"));\n  return complete(\"The parameters are \" + pString);\n});\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/?color=blue&count=42\"))\n  .assertEntity(\"The parameters are color = 'blue', count = '42'\");\n\ntestRoute(route).run(HttpRequest.GET(\"/?x=1&x=2\"))\n  .assertEntity(\"The parameters are x = '2'\");","title":"Example"},{"location":"/routing-dsl/directives/parameter-directives/parameterMultiMap.html","text":"","title":"parameterMultiMap"},{"location":"/routing-dsl/directives/parameter-directives/parameterMultiMap.html#parametermultimap","text":"Signature def parameterMultiMap: Directive1[Map[String, List[String]]]","title":"parameterMultiMap"},{"location":"/routing-dsl/directives/parameter-directives/parameterMultiMap.html#description","text":"Extracts all parameters at once as a multi-map of type Map[String, List[String]]Map<String, List<String>> mapping a parameter name to a list of all its values.\nThis directive can be used if parameters can occur several times.\nThe order of values is not specified.\nSee When to use which parameter directive? to understand when to use which directive.","title":"Description"},{"location":"/routing-dsl/directives/parameter-directives/parameterMultiMap.html#example","text":"Scala copysourceval route =\n  parameterMultiMap { params =>\n    complete(s\"There are parameters ${params.map(x => x._1 + \" -> \" + x._2.size).mkString(\", \")}\")\n  }\n\n// tests:\nGet(\"/?color=blue&count=42\") ~> route ~> check {\n  responseAs[String] shouldEqual \"There are parameters color -> 1, count -> 1\"\n}\nGet(\"/?x=23&x=42\") ~> route ~> check {\n  responseAs[String] shouldEqual \"There are parameters x -> 2\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.parameterMultiMap;\n\nfinal Route route = parameterMultiMap(params -> {\n  final String pString = params.entrySet()\n    .stream()\n    .map(e -> e.getKey() + \" -> \" + e.getValue().size())\n    .collect(Collectors.joining(\", \"));\n  return complete(\"There are parameters \" + pString);\n});\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/?color=blue&count=42\"))\n  .assertEntity(\"There are parameters color -> 1, count -> 1\");\n\ntestRoute(route).run(HttpRequest.GET(\"/?x=23&x=42\"))\n  .assertEntity(\"There are parameters x -> 2\");","title":"Example"},{"location":"/routing-dsl/directives/parameter-directives/parameterSeq.html","text":"","title":"parameterSeqparameterList"},{"location":"/routing-dsl/directives/parameter-directives/parameterSeq.html#","text":"Signature def parameterSeq: Directive1[immutable.Seq[(String, String)]]","title":"parameterSeqparameterList"},{"location":"/routing-dsl/directives/parameter-directives/parameterSeq.html#description","text":"Extracts all parameters at once in the original order as (name, value) tuples of type (String, String)Map.Entry<String, String>.\nThis directive can be used if the exact order of parameters is important or if parameters can occur several times.\nSee When to use which parameter directive? to understand when to use which directive.","title":"Description"},{"location":"/routing-dsl/directives/parameter-directives/parameterSeq.html#example","text":"Scala copysourceval route =\n  parameterSeq { params =>\n    def paramString(param: (String, String)): String = s\"\"\"${param._1} = '${param._2}'\"\"\"\n    complete(s\"The parameters are ${params.map(paramString).mkString(\", \")}\")\n  }\n\n// tests:\nGet(\"/?color=blue&count=42\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The parameters are color = 'blue', count = '42'\"\n}\nGet(\"/?x=1&x=2\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The parameters are x = '1', x = '2'\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.parameterList;\n\nfinal Function<Entry, String> paramString =\n  entry -> entry.getKey() + \" = '\" + entry.getValue() + \"'\";\n\nfinal Route route = parameterList(params -> {\n  final String pString = params.stream()\n    .map(paramString::apply)\n    .collect(Collectors.joining(\", \"));\n\n  return complete(\"The parameters are \" + pString);\n});\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/?color=blue&count=42\"))\n  .assertEntity(\"The parameters are color = 'blue', count = '42'\");\n\ntestRoute(route).run(HttpRequest.GET(\"/?x=1&x=2\"))\n  .assertEntity(\"The parameters are x = '1', x = '2'\");","title":"Example"},{"location":"/routing-dsl/directives/path-directives/index.html","text":"","title":"PathDirectives"},{"location":"/routing-dsl/directives/path-directives/index.html#pathdirectives","text":"Overview of path directives path pathEnd pathEndOrSingleSlash pathPrefix pathPrefixTest pathSingleSlash pathSuffix pathSuffixTest rawPathPrefix rawPathPrefixTest redirectToNoTrailingSlashIfPresent redirectToTrailingSlashIfMissing ignoreTrailingSlash The PathMatcher DSL","title":"PathDirectives"},{"location":"/routing-dsl/directives/path-directives/index.html#overview-of-path-directives","text":"This is a tiny overview for some of the most common path directives:\nrawPathPrefix(x): it matches x and leaves a suffix (if any) unmatched. pathPrefix(x): is equivalent to rawPathPrefix(Slash ~ x)rawPathPrefix(slash().concat(segment(x))). It matches a leading slash followed by x and then leaves a suffix unmatched. path(x): is equivalent to rawPathPrefix(Slash ~ x ~ PathEnd)rawPathPrefix(slash().concat(segment(x)).concat(pathEnd())). It matches a leading slash followed by x and then the end. pathEnd: is equivalent to just rawPathPrefix(PathEnd)rawPathPrefix(pathEnd()). It is matched only when there is nothing left to match from the path. This directive should not be used at the root as the minimal path is the single slash. pathSingleSlash: is equivalent to rawPathPrefix(Slash ~ PathEnd)rawPathPrefix(slash().concat(pathEnd())). It matches when the remaining path is just a single slash. pathEndOrSingleSlash: is equivalent to rawPathPrefix(PathEnd)rawPathPrefix(pathEnd()) or rawPathPrefix(Slash ~ PathEnd)rawPathPrefix(slash().concat(pathEnd())). It matches either when there is no remaining path or is just a single slash.","title":"Overview of path directives"},{"location":"/routing-dsl/directives/path-directives/path.html","text":"","title":"path"},{"location":"/routing-dsl/directives/path-directives/path.html#path","text":"Signature def path[L](pm: PathMatcher[L]): Directive[L]","title":"path"},{"location":"/routing-dsl/directives/path-directives/path.html#description","text":"Matches the complete unmatched path of the RequestContextRequestContext against the given PathMatcher, potentially extracts one or more values (depending on the type of the argument).\nThis directive filters incoming requests based on the part of their URI that hasn’t been matched yet by other potentially existing pathPrefix directives on higher levels of the routing structure. Its one parameter is usually an expression evaluating to a PathMatcher instance (see also: The PathMatcher DSL).\nAs opposed to the rawPathPrefix or rawPathPrefixTest directives path automatically adds a leading slash to its PathMatcher argument, you therefore don’t have to start your matching expression with an explicit slash.\nThe path directive attempts to match the complete remaining path, not just a prefix. If you only want to match a path prefix and then delegate further filtering to a lower level in your routing structure use the pathPrefix directive instead. As a consequence it doesn’t make sense to nest a path or pathPrefix directive underneath another path directive, as there is no way that they will ever match (since the unmatched path underneath a path directive will always be empty). For a comparison between path directives check Overview of path directives.\nDepending on the type of its PathMatcher argument the path directive extracts zero or more values from the URI. If the match fails the request is rejected with an empty rejection set.\nNote The empty string (also called empty word or identity) is a neutral element of string concatenation operation, so it will match everything, but remember that path requires whole remaining path being matched, so (/) will succeed and (/whatever) will fail. The pathPrefix provides more liberal behaviour.","title":"Description"},{"location":"/routing-dsl/directives/path-directives/path.html#example","text":"Scala copysourceval route =\n  concat(\n    path(\"foo\") {\n      complete(\"/foo\")\n    },\n    path(\"foo\" / \"bar\") {\n      complete(\"/foo/bar\")\n    },\n    pathPrefix(\"ball\") {\n      concat(\n        pathEnd {\n          complete(\"/ball\")\n        },\n        path(IntNumber) { int =>\n          complete(if (int % 2 == 0) \"even ball\" else \"odd ball\")\n        })\n    })\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  handled shouldEqual false\n}\n\nGet(\"/foo\") ~> route ~> check {\n  responseAs[String] shouldEqual \"/foo\"\n}\n\nGet(\"/foo/bar\") ~> route ~> check {\n  responseAs[String] shouldEqual \"/foo/bar\"\n}\n\nGet(\"/ball/1337\") ~> route ~> check {\n  responseAs[String] shouldEqual \"odd ball\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.path;\n\n// matches /foo/\npath(segment(\"foo\").slash(), () -> complete(StatusCodes.OK));\n\n// matches /foo/bar\npath(segment(\"foo\").slash(segment(\"boo\")), () -> complete(StatusCodes.OK));\n\n// NOTE: matches /foo%2Fbar and doesn't match /foo/bar\npath(segment(\"foo/bar\"), () -> complete(StatusCodes.OK));\n\n// NOTE: matches /foo/bar\npath(separateOnSlashes(\"foo/bar\"), () -> complete(StatusCodes.OK));\n\n// matches e.g. /foo/123 and extracts \"123\" as a String\npath(segment(\"foo\").slash(segment(compile(\"\\\\d+\"))), (value) ->\n    complete(StatusCodes.OK));\n\n// matches e.g. /foo/bar123 and extracts \"123\" as a String\npath(segment(\"foo\").slash(segment(compile(\"bar(\\\\d+)\"))), (value) ->\n    complete(StatusCodes.OK));\n\n// similar to `path(Segments)`\npath(neutral().repeat(0, 10), () -> complete(StatusCodes.OK));\n\n// identical to path(\"foo\" ~ (PathEnd | Slash))\npath(segment(\"foo\").orElse(slash()), () -> complete(StatusCodes.OK));","title":"Example"},{"location":"/routing-dsl/directives/path-directives/pathEnd.html","text":"","title":"pathEnd"},{"location":"/routing-dsl/directives/path-directives/pathEnd.html#pathend","text":"Signature def pathEnd: Directive0","title":"pathEnd"},{"location":"/routing-dsl/directives/path-directives/pathEnd.html#description","text":"Only passes the request to its inner route if the unmatched path of the RequestContextRequestContext is empty, i.e. the request path has been fully matched by a higher-level path or pathPrefix directive.\nThis directive is a simple alias for rawPathPrefix(PathEnd) and is mostly used on an inner-level to discriminate “path already fully matched” from other alternatives (see the example below). For a comparison between path directives check Overview of path directives.","title":"Description"},{"location":"/routing-dsl/directives/path-directives/pathEnd.html#example","text":"Scala copysourceval route =\n  pathPrefix(\"foo\") {\n    concat(\n      pathEnd {\n        complete(\"/foo\")\n      },\n      path(\"bar\") {\n        complete(\"/foo/bar\")\n      })\n  }\n\n// tests:\nGet(\"/foo\") ~> route ~> check {\n  responseAs[String] shouldEqual \"/foo\"\n}\n\nGet(\"/foo/\") ~> route ~> check {\n  handled shouldEqual false\n}\n\nGet(\"/foo/bar\") ~> route ~> check {\n  responseAs[String] shouldEqual \"/foo/bar\"\n} Java copysourcefinal Route route =\n    concat(\n        pathPrefix(\"foo\", () ->\n            concat(\n                pathEnd(() -> complete(\"/foo\")),\n                path(\"bar\", () -> complete(\"/foo/bar\"))\n            )\n        )\n    );\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/foo\")).assertEntity(\"/foo\");\ntestRoute(route).run(HttpRequest.GET(\"/foo/\")).assertStatusCode(StatusCodes.NOT_FOUND);\ntestRoute(route).run(HttpRequest.GET(\"/foo/bar\")).assertEntity(\"/foo/bar\");","title":"Example"},{"location":"/routing-dsl/directives/path-directives/pathEndOrSingleSlash.html","text":"","title":"pathEndOrSingleSlash"},{"location":"/routing-dsl/directives/path-directives/pathEndOrSingleSlash.html#pathendorsingleslash","text":"Signature def pathEndOrSingleSlash: Directive0","title":"pathEndOrSingleSlash"},{"location":"/routing-dsl/directives/path-directives/pathEndOrSingleSlash.html#description","text":"Only passes the request to its inner route if the unmatched path of the RequestContextRequestContext is either empty or contains only one single slash.\nThis directive is a simple alias for rawPathPrefix(Slash.? ~ PathEnd) and is mostly used on an inner-level to discriminate “path already fully matched” from other alternatives (see the example below). For a comparison between path directives check Overview of path directives.\nIt is equivalent to pathEnd | pathSingleSlash but slightly more efficient.","title":"Description"},{"location":"/routing-dsl/directives/path-directives/pathEndOrSingleSlash.html#example","text":"Scala copysourceval route =\n  pathPrefix(\"foo\") {\n    concat(\n      pathEndOrSingleSlash {\n        complete(\"/foo\")\n      },\n      path(\"bar\") {\n        complete(\"/foo/bar\")\n      })\n  }\n\n// tests:\nGet(\"/foo\") ~> route ~> check {\n  responseAs[String] shouldEqual \"/foo\"\n}\n\nGet(\"/foo/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"/foo\"\n}\n\nGet(\"/foo/bar\") ~> route ~> check {\n  responseAs[String] shouldEqual \"/foo/bar\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\nimport static org.apache.pekko.http.javadsl.server.Directives.pathEndOrSingleSlash;\nfinal Route route =\n    concat(\n        pathPrefix(\"foo\", () ->\n            concat(\n                pathEndOrSingleSlash(() -> complete(\"/foo\")),\n                path(\"bar\", () -> complete(\"/foo/bar\"))\n            )\n        )\n    );\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/foo\")).assertEntity(\"/foo\");\ntestRoute(route).run(HttpRequest.GET(\"/foo/\")).assertEntity(\"/foo\");\ntestRoute(route).run(HttpRequest.GET(\"/foo/bar\")).assertEntity(\"/foo/bar\");","title":"Example"},{"location":"/routing-dsl/directives/path-directives/pathPrefix.html","text":"","title":"pathPrefix"},{"location":"/routing-dsl/directives/path-directives/pathPrefix.html#pathprefix","text":"Signature def pathPrefix[L](pm: PathMatcher[L]): Directive[L]","title":"pathPrefix"},{"location":"/routing-dsl/directives/path-directives/pathPrefix.html#description","text":"Matches and consumes a prefix of the unmatched path of the RequestContextRequestContext against the given PathMatcher, potentially extracts one or more values (depending on the type of the argument).\nThis directive filters incoming requests based on the part of their URI that hasn’t been matched yet by other potentially existing pathPrefix or rawPathPrefix directives on higher levels of the routing structure. Its one parameter is usually an expression evaluating to a PathMatcher instance (see also: The PathMatcher DSL).\nAs opposed to its rawPathPrefix counterpart pathPrefix automatically adds a leading slash to its PathMatcher argument, you therefore don’t have to start your matching expression with an explicit slash. For a comparison between path directives check Overview of path directives.\nDepending on the type of its PathMatcher argument the pathPrefix directive extracts zero or more values from the URI. If the match fails the request is rejected with an empty rejection set.\nNote The empty string (also called empty word or identity) is a neutral element of string concatenation operation, so it will match everything and consume nothing. The path provides more strict behaviour.","title":"Description"},{"location":"/routing-dsl/directives/path-directives/pathPrefix.html#example","text":"Scala copysourceval route =\n  pathPrefix(\"ball\") {\n    concat(\n      pathEnd {\n        complete(\"/ball\")\n      },\n      path(IntNumber) { int =>\n        complete(if (int % 2 == 0) \"even ball\" else \"odd ball\")\n      })\n  }\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  handled shouldEqual false\n}\n\nGet(\"/ball\") ~> route ~> check {\n  responseAs[String] shouldEqual \"/ball\"\n}\n\nGet(\"/ball/1337\") ~> route ~> check {\n  responseAs[String] shouldEqual \"odd ball\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.path;\nimport static org.apache.pekko.http.javadsl.server.Directives.pathEnd;\nimport static org.apache.pekko.http.javadsl.server.Directives.pathPrefix;\nfinal Route route =\n    concat(\n        pathPrefix(\"ball\", () ->\n            concat(\n                pathEnd(() -> complete(\"/ball\")),\n                path(integerSegment(), (i) ->\n                    complete((i % 2 == 0) ? \"even ball\" : \"odd ball\"))\n            )\n        )\n    );\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/\")).assertStatusCode(StatusCodes.NOT_FOUND);\ntestRoute(route).run(HttpRequest.GET(\"/ball\")).assertEntity(\"/ball\");\ntestRoute(route).run(HttpRequest.GET(\"/ball/1337\")).assertEntity(\"odd ball\");","title":"Example"},{"location":"/routing-dsl/directives/path-directives/pathPrefixTest.html","text":"","title":"pathPrefixTest"},{"location":"/routing-dsl/directives/path-directives/pathPrefixTest.html#pathprefixtest","text":"Signature def pathPrefixTest[L](pm: PathMatcher[L]): Directive[L]","title":"pathPrefixTest"},{"location":"/routing-dsl/directives/path-directives/pathPrefixTest.html#description","text":"Checks whether the unmatched path of the RequestContextRequestContext has a prefix matched by the given PathMatcher. Potentially extracts one or more values (depending on the type of the argument) but doesn’t consume its match from the unmatched path.\nThis directive is very similar to the pathPrefix directive with the one difference that the path prefix it matched (if it matched) is not consumed. The unmatched path of the RequestContextRequestContext is therefore left as is even in the case that the directive successfully matched and the request is passed on to its inner route.\nFor more info on how to create a PathMatcher see The PathMatcher DSL.\nAs opposed to its rawPathPrefixTest counterpart pathPrefixTest automatically adds a leading slash to its PathMatcher argument, you therefore don’t have to start your matching expression with an explicit slash.\nDepending on the type of its PathMatcher argument the pathPrefixTest directive extracts zero or more values from the URI. If the match fails the request is rejected with an empty rejection set.","title":"Description"},{"location":"/routing-dsl/directives/path-directives/pathPrefixTest.html#example","text":"Scala copysourceval completeWithUnmatchedPath =\n  extractUnmatchedPath { p =>\n    complete(p.toString)\n  }\n\nval route =\n  pathPrefixTest(\"foo\" | \"bar\") {\n    concat(\n      pathPrefix(\"foo\") { completeWithUnmatchedPath },\n      pathPrefix(\"bar\") { completeWithUnmatchedPath })\n  }\n\n// tests:\nGet(\"/foo/doo\") ~> route ~> check {\n  responseAs[String] shouldEqual \"/doo\"\n}\n\nGet(\"/bar/yes\") ~> route ~> check {\n  responseAs[String] shouldEqual \"/yes\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.path;\nimport static org.apache.pekko.http.javadsl.server.Directives.pathEnd;\nimport static org.apache.pekko.http.javadsl.server.Directives.pathPrefix;\nimport static org.apache.pekko.http.javadsl.server.Directives.pathPrefixTest;\nfinal Route route =\n    concat(\n        pathPrefixTest(segment(\"foo\").orElse(\"bar\"), () ->\n            concat(\n                  pathPrefix(\"foo\", () -> completeWithUnmatchedPath.get()),\n                  pathPrefix(\"bar\", () -> completeWithUnmatchedPath.get())\n            )\n        )\n    );\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/foo/doo\")).assertEntity(\"/doo\");\ntestRoute(route).run(HttpRequest.GET(\"/bar/yes\")).assertEntity(\"/yes\");","title":"Example"},{"location":"/routing-dsl/directives/path-directives/pathSingleSlash.html","text":"","title":"pathSingleSlash"},{"location":"/routing-dsl/directives/path-directives/pathSingleSlash.html#pathsingleslash","text":"Signature def pathSingleSlash: Directive0","title":"pathSingleSlash"},{"location":"/routing-dsl/directives/path-directives/pathSingleSlash.html#description","text":"Only passes the request to its inner route if the unmatched path of the RequestContextRequestContext contains exactly one single slash.\nThis directive is a simple alias for pathPrefix(PathEnd) and is mostly used for matching requests to the root URI (/) on an inner-level to discriminate “all path segments matched” from other alternatives (see the example below). For a comparison between path directives check Overview of path directives.","title":"Description"},{"location":"/routing-dsl/directives/path-directives/pathSingleSlash.html#example","text":"Scala copysourceval route =\n  concat(\n    pathSingleSlash {\n      complete(\"root\")\n    },\n    pathPrefix(\"ball\") {\n      concat(\n        pathSingleSlash {\n          complete(\"/ball/\")\n        },\n        path(IntNumber) { int =>\n          complete(if (int % 2 == 0) \"even ball\" else \"odd ball\")\n        })\n    })\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"root\"\n}\n\nGet(\"/ball\") ~> route ~> check {\n  handled shouldEqual false\n}\n\nGet(\"/ball/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"/ball/\"\n}\n\nGet(\"/ball/1337\") ~> route ~> check {\n  responseAs[String] shouldEqual \"odd ball\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\nimport static org.apache.pekko.http.javadsl.server.Directives.pathPrefix;\nimport static org.apache.pekko.http.javadsl.server.Directives.pathSingleSlash;\nfinal Route route =\n    concat(\n        pathSingleSlash(() -> complete(\"root\")),\n        pathPrefix(\"ball\", () ->\n            concat(\n                pathSingleSlash(() -> complete(\"/ball/\")),\n                path(integerSegment(), (i) -> complete((i % 2 == 0) ? \"even ball\" : \"odd ball\"))\n            )\n        )\n    );\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/\")).assertEntity(\"root\");\ntestRoute(route).run(HttpRequest.GET(\"/ball\")).assertStatusCode(StatusCodes.NOT_FOUND);\ntestRoute(route).run(HttpRequest.GET(\"/ball/\")).assertEntity(\"/ball/\");\ntestRoute(route).run(HttpRequest.GET(\"/ball/1337\")).assertEntity(\"odd ball\");","title":"Example"},{"location":"/routing-dsl/directives/path-directives/pathSuffix.html","text":"","title":"pathSuffix"},{"location":"/routing-dsl/directives/path-directives/pathSuffix.html#pathsuffix","text":"Signature def pathSuffix[L](pm: PathMatcher[L]): Directive[L]","title":"pathSuffix"},{"location":"/routing-dsl/directives/path-directives/pathSuffix.html#description","text":"Matches and consumes a suffix of the unmatched path of the RequestContextRequestContext against the given PathMatcher, potentially extracts one or more values (depending on the type of the argument).\nThis directive filters incoming requests based on the part of their URI that hasn’t been matched yet by other potentially existing path matching directives on higher levels of the routing structure. Its one parameter is usually an expression evaluating to a PathMatcher instance (see also: The PathMatcher DSL).\nAs opposed to pathPrefix this directive matches and consumes the unmatched path from the right, i.e. the end.\nCaution For efficiency reasons, the given PathMatcher must match the desired suffix in reversed-segment order, i.e. pathSuffix(\"baz\" / \"bar\") would match /foo/bar/baz! The order within a segment match is not reversed.\nDepending on the type of its PathMatcher argument the pathPrefix directive extracts zero or more values from the URI. If the match fails the request is rejected with an empty rejection set.","title":"Description"},{"location":"/routing-dsl/directives/path-directives/pathSuffix.html#example","text":"Scala copysourceval completeWithUnmatchedPath =\n  extractUnmatchedPath { p =>\n    complete(p.toString)\n  }\n\nval route =\n  pathPrefix(\"start\") {\n    concat(\n      pathSuffix(\"end\") {\n        completeWithUnmatchedPath\n      },\n      pathSuffix(\"foo\" / \"bar\" ~ \"baz\") {\n        completeWithUnmatchedPath\n      })\n  }\n\n// tests:\nGet(\"/start/middle/end\") ~> route ~> check {\n  responseAs[String] shouldEqual \"/middle/\"\n}\n\nGet(\"/start/something/barbaz/foo\") ~> route ~> check {\n  responseAs[String] shouldEqual \"/something/\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.pathPrefix;\nimport static org.apache.pekko.http.javadsl.server.Directives.pathSuffix;\nfinal Route route =\n    concat(\n        pathPrefix(\"start\", () ->\n            concat(\n                pathSuffix(\"end\", () -> completeWithUnmatchedPath.get()),\n                pathSuffix(segment(\"foo\").slash(\"bar\").concat(\"baz\"), () ->\n                    completeWithUnmatchedPath.get())\n            )\n        )\n    );\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/start/middle/end\")).assertEntity(\"/middle/\");\ntestRoute(route).run(HttpRequest.GET(\"/start/something/barbaz/foo\")).assertEntity(\"/something/\");","title":"Example"},{"location":"/routing-dsl/directives/path-directives/pathSuffixTest.html","text":"","title":"pathSuffixTest"},{"location":"/routing-dsl/directives/path-directives/pathSuffixTest.html#pathsuffixtest","text":"Signature def pathSuffixTest[L](pm: PathMatcher[L]): Directive[L]","title":"pathSuffixTest"},{"location":"/routing-dsl/directives/path-directives/pathSuffixTest.html#description","text":"Checks whether the unmatched path of the RequestContextRequestContext has a suffix matched by the given PathMatcher. Potentially extracts one or more values (depending on the type of the argument) but doesn’t consume its match from the unmatched path.\nThis directive is very similar to the pathSuffix directive with the one difference that the path suffix it matched (if it matched) is not consumed. The unmatched path of the RequestContextRequestContext is therefore left as is even in the case that the directive successfully matched and the request is passed on to its inner route.\nAs opposed to pathPrefixTest this directive matches and consumes the unmatched path from the right, i.e. the end.\nCaution For efficiency reasons, the given PathMatcher must match the desired suffix in reversed-segment order, i.e. pathSuffixTest(\"baz\" / \"bar\") would match /foo/bar/baz! The order within a segment match is not reversed.\nDepending on the type of its PathMatcher argument the pathSuffixTest directive extracts zero or more values from the URI. If the match fails the request is rejected with an empty rejection set.","title":"Description"},{"location":"/routing-dsl/directives/path-directives/pathSuffixTest.html#example","text":"Scala copysourceval completeWithUnmatchedPath =\n  extractUnmatchedPath { p =>\n    complete(p.toString)\n  }\n\nval route =\n  concat(\n    pathSuffixTest(Slash) {\n      complete(\"slashed\")\n    },\n    complete(\"unslashed\"))\n\n// tests:\nGet(\"/foo/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"slashed\"\n}\nGet(\"/foo\") ~> route ~> check {\n  responseAs[String] shouldEqual \"unslashed\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.pathSuffixTest;\nfinal Route route =\n    concat(\n        pathSuffixTest(slash(), () -> complete(\"slashed\")),\n        complete(\"unslashed\")\n    );\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/foo/\")).assertEntity(\"slashed\");\ntestRoute(route).run(HttpRequest.GET(\"/foo\")).assertEntity(\"unslashed\");","title":"Example"},{"location":"/routing-dsl/directives/path-directives/rawPathPrefix.html","text":"","title":"rawPathPrefix"},{"location":"/routing-dsl/directives/path-directives/rawPathPrefix.html#rawpathprefix","text":"Signature def rawPathPrefix[L](pm: PathMatcher[L]): Directive[L]","title":"rawPathPrefix"},{"location":"/routing-dsl/directives/path-directives/rawPathPrefix.html#description","text":"Matches and consumes a prefix of the unmatched path of the RequestContextRequestContext against the given PathMatcher, potentially extracts one or more values (depending on the type of the argument).\nThis directive filters incoming requests based on the part of their URI that hasn’t been matched yet by other potentially existing rawPathPrefix or pathPrefix directives on higher levels of the routing structure. Its one parameter is usually an expression evaluating to a PathMatcher instance (see also: The PathMatcher DSL).\nAs opposed to its pathPrefix counterpart rawPathPrefix does not automatically add a leading slash to its PathMatcher argument. Rather its PathMatcher argument is applied to the unmatched path as is. For a comparison between path directives check Overview of path directives.\nDepending on the type of its PathMatcher argument the rawPathPrefix directive extracts zero or more values from the URI. If the match fails the request is rejected with an empty rejection set.","title":"Description"},{"location":"/routing-dsl/directives/path-directives/rawPathPrefix.html#example","text":"Scala copysourceval completeWithUnmatchedPath =\n  extractUnmatchedPath { p =>\n    complete(p.toString)\n  }\n\nval route =\n  pathPrefix(\"foo\") {\n    concat(\n      rawPathPrefix(\"bar\") { completeWithUnmatchedPath },\n      rawPathPrefix(\"doo\") { completeWithUnmatchedPath })\n  }\n\n// tests:\nGet(\"/foobar/baz\") ~> route ~> check {\n  responseAs[String] shouldEqual \"/baz\"\n}\n\nGet(\"/foodoo/baz\") ~> route ~> check {\n  responseAs[String] shouldEqual \"/baz\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.rawPathPrefixTest;\nfinal Route route =\n    concat(\n        pathPrefix(\"foo\", () ->\n            rawPathPrefixTest(\"bar\", () -> completeWithUnmatchedPath.get())\n        )\n    );\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/foobar\")).assertEntity(\"bar\");\ntestRoute(route).run(HttpRequest.GET(\"/foobaz\")).assertStatusCode(StatusCodes.NOT_FOUND);","title":"Example"},{"location":"/routing-dsl/directives/path-directives/rawPathPrefixTest.html","text":"","title":"rawPathPrefixTest"},{"location":"/routing-dsl/directives/path-directives/rawPathPrefixTest.html#rawpathprefixtest","text":"Signature def rawPathPrefixTest[L](pm: PathMatcher[L]): Directive[L]","title":"rawPathPrefixTest"},{"location":"/routing-dsl/directives/path-directives/rawPathPrefixTest.html#description","text":"Checks whether the unmatched path of the RequestContextRequestContext has a prefix matched by the given PathMatcher. Potentially extracts one or more values (depending on the type of the argument) but doesn’t consume its match from the unmatched path.\nThis directive is very similar to the pathPrefix directive with the one difference that the path prefix it matched (if it matched) is not consumed. The unmatched path of the RequestContextRequestContext is therefore left as is even in the case that the directive successfully matched and the request is passed on to its inner route.\nFor more info on how to create a PathMatcher see The PathMatcher DSL.\nAs opposed to its pathPrefixTest counterpart rawPathPrefixTest does not automatically add a leading slash to its PathMatcher argument. Rather its PathMatcher argument is applied to the unmatched path as is.\nDepending on the type of its PathMatcher argument the rawPathPrefixTest directive extracts zero or more values from the URI. If the match fails the request is rejected with an empty rejection set.","title":"Description"},{"location":"/routing-dsl/directives/path-directives/rawPathPrefixTest.html#example","text":"Scala copysourceval completeWithUnmatchedPath =\n  extractUnmatchedPath { p =>\n    complete(p.toString)\n  }\n\nval route =\n  pathPrefix(\"foo\") {\n    rawPathPrefixTest(\"bar\") {\n      completeWithUnmatchedPath\n    }\n  }\n\n// tests:\nGet(\"/foobar\") ~> route ~> check {\n  responseAs[String] shouldEqual \"bar\"\n}\n\nGet(\"/foobaz\") ~> route ~> check {\n  handled shouldEqual false\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.rawPathPrefixTest;\nfinal Route route =\n    concat(\n        pathPrefix(\"foo\", () ->\n            rawPathPrefixTest(\"bar\", () -> completeWithUnmatchedPath.get())\n        )\n    );\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/foobar\")).assertEntity(\"bar\");\ntestRoute(route).run(HttpRequest.GET(\"/foobaz\")).assertStatusCode(StatusCodes.NOT_FOUND);","title":"Example"},{"location":"/routing-dsl/directives/path-directives/redirectToNoTrailingSlashIfPresent.html","text":"","title":"redirectToNoTrailingSlashIfPresent"},{"location":"/routing-dsl/directives/path-directives/redirectToNoTrailingSlashIfPresent.html#redirecttonotrailingslashifpresent","text":"Signature def redirectToNoTrailingSlashIfPresent(redirectionType: StatusCodes.Redirection): Directive0","title":"redirectToNoTrailingSlashIfPresent"},{"location":"/routing-dsl/directives/path-directives/redirectToNoTrailingSlashIfPresent.html#description","text":"If the requested path does end with a trailing / character, redirects to the same path without that trailing slash..\nRedirects the HTTP Client to the same resource yet without the trailing /, in case the request contained it. When redirecting an HttpResponse with the given redirect response code (i.e. MovedPermanently or TemporaryRedirect etc.) as well as a simple HTML page containing a “click me to follow redirect” link to be used in case the client can not, or refuses to for security reasons, automatically follow redirects.\nPlease note that the inner paths MUST NOT end with an explicit trailing slash (e.g. \"things\"./) for the re-directed-to route to match.\nA good read on the subject of how to deal with trailing slashes is available on Google Webmaster Central - To Slash or not to Slash.\nSee also redirectToTrailingSlashIfMissing which achieves the opposite - redirecting paths in case they do not have a trailing slash.","title":"Description"},{"location":"/routing-dsl/directives/path-directives/redirectToNoTrailingSlashIfPresent.html#example","text":"Scala copysourceimport org.apache.pekko.http.scaladsl.model.StatusCodes\n\nval route =\n  redirectToNoTrailingSlashIfPresent(StatusCodes.MovedPermanently) {\n    concat(\n      path(\"foo\") {\n        // We require to not have a trailing slash in the path\n        complete(\"OK\")\n      },\n      path(\"bad\"./) {\n        // MISTAKE!\n        // Since inside a `redirectToNoTrailingSlashIfPresent` directive\n        // the matched path here will never contain a trailing slash,\n        // thus this path will never match.\n        //\n        // It should be `path(\"bad\")` instead.\n        ???\n      })\n  }\n\n// tests:\n// Redirected:\nGet(\"/foo/\") ~> route ~> check {\n  status shouldEqual StatusCodes.MovedPermanently\n\n  // results in nice human readable message,\n  // in case the redirect can't be followed automatically:\n  responseAs[String] shouldEqual {\n    \"This and all future requests should be directed to \" +\n    \"<a href=\\\"http://example.com/foo\\\">this URI</a>.\"\n  }\n}\n\n// Properly handled:\nGet(\"/foo\") ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n  responseAs[String] shouldEqual \"OK\"\n}\n\n// MISTAKE! will never match - reason explained in routes\nGet(\"/bad\") ~> route ~> check {\n  handled shouldEqual false\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\nimport static org.apache.pekko.http.javadsl.server.Directives.redirectToNoTrailingSlashIfPresent;\nfinal Route route =\n    redirectToNoTrailingSlashIfPresent(\n        StatusCodes.MOVED_PERMANENTLY, () ->\n        concat(\n            path(\"foo\", () -> complete(\"OK\")),\n            path(segment(\"bad\").slash(), () ->\n                // MISTAKE!\n                // Since inside a `redirectToNoTrailingSlashIfPresent` directive\n                // the matched path here will never contain a trailing slash,\n                // thus this path will never match.\n                //\n                // It should be `path(\"bad\")` instead.\n                 complete(StatusCodes.NOT_IMPLEMENTED)\n            )\n        )\n    );\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/foo/\"))\n    .assertStatusCode(StatusCodes.MOVED_PERMANENTLY)\n    .assertEntity(\"This and all future requests should be directed to \" +\n      \"<a href=\\\"http://example.com/foo\\\">this URI</a>.\");\n\ntestRoute(route).run(HttpRequest.GET(\"/foo\"))\n    .assertStatusCode(StatusCodes.OK)\n    .assertEntity(\"OK\");\n\ntestRoute(route).run(HttpRequest.GET(\"/bad\"))\n    .assertStatusCode(StatusCodes.NOT_FOUND);","title":"Example"},{"location":"/routing-dsl/directives/path-directives/redirectToTrailingSlashIfMissing.html","text":"","title":"redirectToTrailingSlashIfMissing"},{"location":"/routing-dsl/directives/path-directives/redirectToTrailingSlashIfMissing.html#redirecttotrailingslashifmissing","text":"Signature def redirectToTrailingSlashIfMissing(redirectionType: StatusCodes.Redirection): Directive0","title":"redirectToTrailingSlashIfMissing"},{"location":"/routing-dsl/directives/path-directives/redirectToTrailingSlashIfMissing.html#description","text":"If the requested path does not end with a trailing / character, redirects to the same path followed by such trailing slash.\nRedirects the HTTP Client to the same resource yet followed by a trailing /, in case the request did not contain it. When redirecting an HttpResponse with the given redirect response code (i.e. MovedPermanently or TemporaryRedirect etc.) as well as a simple HTML page containing a “click me to follow redirect” link to be used in case the client can not, or refuses to for security reasons, automatically follow redirects.\nPlease note that the inner paths MUST end with an explicit trailing slash (e.g. \"things\"./) for the re-directed-to route to match.\nSee also redirectToNoTrailingSlashIfPresent which achieves the opposite - redirecting paths in case they do have a trailing slash.","title":"Description"},{"location":"/routing-dsl/directives/path-directives/redirectToTrailingSlashIfMissing.html#example","text":"Scala copysourceimport org.apache.pekko.http.scaladsl.model.StatusCodes\n\nval route =\n  redirectToTrailingSlashIfMissing(StatusCodes.MovedPermanently) {\n    concat(\n      path(\"foo\"./) {\n        // We require the explicit trailing slash in the path\n        complete(\"OK\")\n      },\n      path(\"bad-1\") {\n        // MISTAKE!\n        // Missing `/` in path, causes this path to never match,\n        // because it is inside a `redirectToTrailingSlashIfMissing`\n        ???\n      },\n      path(\"bad-2/\") {\n        // MISTAKE!\n        // / should be explicit as path element separator and not *in* the path element\n        // So it should be: \"bad-2\" /\n        ???\n      })\n  }\n\n// tests:\n// Redirected:\nGet(\"/foo\") ~> route ~> check {\n  status shouldEqual StatusCodes.MovedPermanently\n\n  // results in nice human readable message,\n  // in case the redirect can't be followed automatically:\n  responseAs[String] shouldEqual {\n    \"This and all future requests should be directed to \" +\n    \"<a href=\\\"http://example.com/foo/\\\">this URI</a>.\"\n  }\n}\n\n// Properly handled:\nGet(\"/foo/\") ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n  responseAs[String] shouldEqual \"OK\"\n}\n\n// MISTAKE! will never match - reason explained in routes\nGet(\"/bad-1/\") ~> route ~> check {\n  handled shouldEqual false\n}\n\n// MISTAKE! will never match - reason explained in routes\nGet(\"/bad-2/\") ~> route ~> check {\n  handled shouldEqual false\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\nimport static org.apache.pekko.http.javadsl.server.Directives.redirectToTrailingSlashIfMissing;\nfinal Route route =\n    redirectToTrailingSlashIfMissing(\n        StatusCodes.MOVED_PERMANENTLY, () ->\n        concat(\n            path(segment(\"foo\").slash(), () -> complete(\"OK\")),\n            path(segment(\"bad-1\"), () ->\n                // MISTAKE!\n                // Missing .slash() in path, causes this path to never match,\n                // because it is inside a `redirectToTrailingSlashIfMissing`\n                complete(StatusCodes.NOT_IMPLEMENTED)\n            ),\n            path(segment(\"bad-2/\"), () ->\n                // MISTAKE!\n                // / should be explicit with `.slash()` and not *in* the path element\n                // So it should be: segment(\"bad-2\").slash()\n                complete(StatusCodes.NOT_IMPLEMENTED)\n            )\n        )\n    );\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/foo\"))\n    .assertStatusCode(StatusCodes.MOVED_PERMANENTLY)\n    .assertEntity(\"This and all future requests should be directed to \" +\n      \"<a href=\\\"http://example.com/foo/\\\">this URI</a>.\");\n\ntestRoute(route).run(HttpRequest.GET(\"/foo/\"))\n    .assertStatusCode(StatusCodes.OK)\n    .assertEntity(\"OK\");\n\ntestRoute(route).run(HttpRequest.GET(\"/bad-1/\"))\n    .assertStatusCode(StatusCodes.NOT_FOUND);","title":"Example"},{"location":"/routing-dsl/directives/path-directives/ignoreTrailingSlash.html","text":"","title":"ignoreTrailingSlash"},{"location":"/routing-dsl/directives/path-directives/ignoreTrailingSlash.html#ignoretrailingslash","text":"Signature def ignoreTrailingSlash: Directive0","title":"ignoreTrailingSlash"},{"location":"/routing-dsl/directives/path-directives/ignoreTrailingSlash.html#description","text":"If the requested path ends with a trailing / character and the inner route is rejected with an empty RejectionRejection list, it retries the inner route it removing the trailing / character. Similarly, it retries adding a trailing / character if the original requested path doesn’t end with a / character.\nThis directive will retry the inner route with a “flipped” trailing slash only if the mentioned inner route is rejected with an empty RejectionRejection list.\nNote Please note that enclosing routes with this directive might cause double evaluation in case of unhandled request paths. This may be expensive when enclosing big route trees. Use with care.\nSee also redirectToNoTrailingSlashIfPresent and redirectToTrailingSlashIfMissing for other ways to accomplish a similar thing.","title":"Description"},{"location":"/routing-dsl/directives/path-directives/ignoreTrailingSlash.html#example","text":"Scala copysourceval route = ignoreTrailingSlash {\n  concat(\n    path(\"foo\") {\n      // Thanks to `ignoreTrailingSlash` it will serve both `/foo` and `/foo/`.\n      complete(\"OK\")\n    },\n    path(\"bar\"./) {\n      // Thanks to `ignoreTrailingSlash` it will serve both `/bar` and `/bar/`.\n      complete(\"OK\")\n    })\n}\n\n// tests:\nGet(\"/foo\") ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n  responseAs[String] shouldEqual \"OK\"\n}\n\nGet(\"/foo/\") ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n  responseAs[String] shouldEqual \"OK\"\n}\n\nGet(\"/bar\") ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n  responseAs[String] shouldEqual \"OK\"\n}\n\nGet(\"/bar/\") ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n  responseAs[String] shouldEqual \"OK\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\nimport static org.apache.pekko.http.javadsl.server.Directives.ignoreTrailingSlash;\nfinal Route route = ignoreTrailingSlash(() ->\n  concat(\n    path(\"foo\", () ->\n      // Thanks to `ignoreTrailingSlash` it will serve both `/foo` and `/foo/`.\n      complete(\"OK\")),\n    path(PathMatchers.segment(\"bar\").slash(), () ->\n      // Thanks to `ignoreTrailingSlash` it will serve both `/bar` and `/bar/`.\n      complete(\"OK\"))\n  )\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/foo\"))\n  .assertStatusCode(StatusCodes.OK)\n  .assertEntity(\"OK\");\ntestRoute(route).run(HttpRequest.GET(\"/foo/\"))\n  .assertStatusCode(StatusCodes.OK)\n  .assertEntity(\"OK\");\n\ntestRoute(route).run(HttpRequest.GET(\"/bar\"))\n  .assertStatusCode(StatusCodes.OK)\n  .assertEntity(\"OK\");\ntestRoute(route).run(HttpRequest.GET(\"/bar/\"))\n  .assertStatusCode(StatusCodes.OK)\n  .assertEntity(\"OK\");","title":"Example"},{"location":"/routing-dsl/path-matchers.html","text":"","title":"The PathMatcher DSL"},{"location":"/routing-dsl/path-matchers.html#the-pathmatcher-dsl","text":"The PathMatcher mini-DSL is used to match incoming URL’s and extract values from them. It is used in the path directive.\nSome simple examples of the DSL in action can be found below.","title":"The PathMatcher DSL"},{"location":"/routing-dsl/path-matchers.html#overview","text":"When a request (or rather the respective RequestContextRequestContext instance) enters the route structure it has an “unmatched path” that is identical to the request.uri.path. As it descends the routing tree and passes through one or more pathPrefix or path directives the “unmatched path” progressively gets “eaten into” from the left until, in most cases, it eventually has been consumed completely.\nWhat exactly gets matched and consumed as well as extracted from the unmatched path in each directive is defined with the path matching DSL, which is built around these types:\nScala trait PathMatcher[L: Tuple]\ntype PathMatcher0 = PathMatcher[Unit]\ntype PathMatcher1[T] = PathMatcher[Tuple1[T]]\ntype PathMatcher2[T,U] = PathMatcher[Tuple2[T,U]]\n// .. etc\n Java package org.apache.pekko.http.javadsl.server;\nclass PathMatcher0\nclass PathMatcher1<T1>\nclass PathMatcher2<T1, T2>\n// .. etc\nThe number and types of the values extracted by a PathMatcher instance is represented by the L type parameter which needs to be one of Scala’s TupleN types or Unit (which is designated by the Tuple context bound). is determined by the class and its type parameters. The convenience alias PathMatcher0 can be used for all matchers which don’t extract anything while PathMatcher1[T] defines a matcher which only extracts a single value of type T.\nHere is an example of a more complex PathMatcher expression:\nScala copysourceval matcher: PathMatcher1[Option[Int]] =\n  \"foo\" / \"bar\" / \"X\" ~ IntNumber.? / (\"edit\" | \"create\")\n\nval route: Route =\n  path(matcher) { i: Option[Int] =>\n    complete(s\"Matched X${i.getOrElse(\"\")}\")\n  } Java copysourceimport org.apache.pekko.http.javadsl.server.PathMatcher1;\nimport static org.apache.pekko.http.javadsl.server.PathMatchers.segment;\nimport static org.apache.pekko.http.javadsl.server.PathMatchers.integerSegment;\n\nPathMatcher1<Integer> matcher =\n  PathMatchers\n    .segment(\"foo\")\n    .slash(\"bar\")\n    .slash(\n      segment(\"X\").concat(integerSegment())\n    )\n    .slash(\n      segment(\"edit\").orElse(segment(\"create\"))\n    );\n\nRoute route = path(matcher, i ->\n  complete(\"Matched X\" + i)\n);\nThis will match paths like foo/bar/X42/edit or foo/bar/X/createfoo/bar/X37/create.\nNote The path matching DSL describes what paths to accept after URL decoding. This is why the path-separating slashes have special status and cannot simply be specified as part of a string! The string “foo/bar” would match the raw URI path “foo%2Fbar”, which is most likely not what you want!","title":"Overview"},{"location":"/routing-dsl/path-matchers.html#basic-pathmatchers","text":"A complex PathMatcher can be constructed by combining or modifying more basic ones. Here are the basic matchers that Apache Pekko HTTP already provides for you: String You can use a String instance as a PathMatcher0. Strings simply match themselves and extract no value. Note that strings are interpreted as the decoded representation of the path, so if they include a ‘/’ character this character will match “%2F” in the encoded raw URI! Regex You can use a Regex instance as a PathMatcher1[String], which matches whatever the regex matches and extracts one String value. A PathMatcher created from a regular expression extracts either the complete match (if the regex doesn’t contain a capture group) or the capture group (if the regex contains exactly one capture group). If the regex contains more than one capture group an IllegalArgumentException will be thrown. Map[String, T] You can use a Map[String, T] instance as a PathMatcher1[T], which matches any of the keys and extracts the respective map value for it. Slash: PathMatcher0 Matches exactly one path-separating slash (/) character and extracts nothing. Segment: PathMatcher1[String] Matches if the unmatched path starts with a path segment (i.e. not a slash). If so the path segment is extracted as a String instance. PathEnd: PathMatcher0 Matches the very end of the path, similar to $ in regular expressions and extracts nothing. Remaining: PathMatcher1[String] Matches and extracts the complete remaining unmatched part of the request’s URI path as an (encoded!) String. If you need access to the remaining decoded elements of the path use RemainingPath instead. RemainingPath: PathMatcher1[Path] Matches and extracts the complete remaining, unmatched part of the request’s URI path. IntNumber: PathMatcher1[Int] Efficiently matches a number of decimal digits (unsigned) and extracts their (non-negative) Int value. The matcher will not match zero digits or a sequence of digits that would represent an Int value larger than Int.MaxValue. LongNumber: PathMatcher1[Long] Efficiently matches a number of decimal digits (unsigned) and extracts their (non-negative) Long value. The matcher will not match zero digits or a sequence of digits that would represent an Long value larger than Long.MaxValue. HexIntNumber: PathMatcher1[Int] Efficiently matches a number of hex digits and extracts their (non-negative) Int value. The matcher will not match zero digits or a sequence of digits that would represent an Int value larger than Int.MaxValue. HexLongNumber: PathMatcher1[Long] Efficiently matches a number of hex digits and extracts their (non-negative) Long value. The matcher will not match zero digits or a sequence of digits that would represent an Long value larger than Long.MaxValue. DoubleNumber: PathMatcher1[Double] Matches and extracts a Double value. The matched string representation is the pure decimal, optionally signed form of a double value, i.e. without exponent. JavaUUID: PathMatcher1[UUID] Matches and extracts a java.util.UUID instance. Neutral: PathMatcher0 A matcher that always matches, doesn’t consume anything and extracts nothing. Serves mainly as a neutral element in PathMatcher composition. Segments: PathMatcher1[List[String]] Matches all remaining segments as a list of strings. Note that this can also be “no segments” resulting in the empty list. If the path has a trailing slash this slash will not be matched, i.e. remain unmatched and to be consumed by potentially nested directives. separateOnSlashes(string: String): PathMatcher0 Converts a path string containing slashes into a PathMatcher0 that interprets slashes as path segment separators. This means that a matcher matching “%2F” cannot be constructed with this helper. provide[L: Tuple](extractions: L): PathMatcher[L] Always matches, consumes nothing and extracts the given TupleX of values. PathMatcher[L: Tuple](prefix: Path, extractions: L): PathMatcher[L] Matches and consumes the given path prefix and extracts the given list of extractions. If the given prefix is empty the returned matcher matches always and consumes nothing.\nA path matcher is a description of a part of a path to match. The simplest path matcher is PathMatcher.segment which matches exactly one path segment against the supplied constant string. Other path matchers defined in PathMatchersPathMatchers match the end of the path (PathMatchers.END), a single slash (PathMatchers.SLASH), or nothing at all (PathMatchers.NEUTRAL). Many path matchers are hybrids that can both match (by using them with one of the PathDirectives) and extract values, Extracting a path matcher value (i.e. using it with handleWithX) is only allowed if it nested inside a path directive that uses that path matcher and so specifies at which position the value should be extracted from the path. Predefined path matchers allow extraction of various types of values: PathMatchers.segment(String) Strings simply match themselves and extract no value. Note that strings are interpreted as the decoded representation of the path, so if they include a ‘/’ character this character will match “%2F” in the encoded raw URI! PathMatchers.segment(java.util.regex.Pattern) You can use a regular expression instance as a path matcher, which matches whatever the regex matches and extracts one String value. A PathMatcher created from a regular expression extracts either the complete match (if the regex doesn’t contain a capture group) or the capture group (if the regex contains exactly one capture group). If the regex contains more than one capture group an IllegalArgumentException will be thrown. PathMatchers.SLASH Matches exactly one path-separating slash (/) character. PathMatchers.END Matches the very end of the path, similar to $ in regular expressions. PathMatchers.Segment Matches if the unmatched path starts with a path segment (i.e. not a slash). If so the path segment is extracted as a String instance. PathMatchers.Remaining Matches and extracts the complete remaining unmatched part of the request’s URI path as an (encoded!) String. If you need access to the remaining decoded elements of the path use RemainingPath instead. PathMatchers.intValue Efficiently matches a number of decimal digits (unsigned) and extracts their (non-negative) Int value. The matcher will not match zero digits or a sequence of digits that would represent an Int value larger than Integer.MAX_VALUE. PathMatchers.longValue Efficiently matches a number of decimal digits (unsigned) and extracts their (non-negative) Long value. The matcher will not match zero digits or a sequence of digits that would represent an Long value larger than Long.MAX_VALUE. PathMatchers.hexIntValue Efficiently matches a number of hex digits and extracts their (non-negative) Int value. The matcher will not match zero digits or a sequence of digits that would represent an Int value larger than Integer.MAX_VALUE. PathMatchers.hexLongValue Efficiently matches a number of hex digits and extracts their (non-negative) Long value. The matcher will not match zero digits or a sequence of digits that would represent an Long value larger than Long.MAX_VALUE. PathMatchers.uuid Matches and extracts a java.util.UUID instance. PathMatchers.NEUTRAL A matcher that always matches, doesn’t consume anything and extracts nothing. Serves mainly as a neutral element in PathMatcher composition. PathMatchers.segments Matches all remaining segments as a list of strings. Note that this can also be “no segments” resulting in the empty list. If the path has a trailing slash this slash will not be matched, i.e. remain unmatched and to be consumed by potentially nested directives.\nCombinators Path matchers can be combined with these combinators to form higher-level constructs: Tilde Operator (~) The tilde is the most basic combinator. It simply concatenates two matchers into one, i.e if the first one matched (and consumed) the second one is tried. The extractions of both matchers are combined type-safely. This is an alias for the append method. For example: \"foo\" ~ \"bar\" yields a matcher that is identical to \"foobar\". Slash Operator (/) This operator concatenates two matchers and inserts a Slash matcher in between them. This is an alias for the slash method. For example: \"foo\" / \"bar\" is identical to \"foo\" ~ Slash ~ \"bar\". Pipe Operator (|) This operator combines two matcher alternatives in that the second one is only tried if the first one did not match. The two sub-matchers must have compatible types. This is an alias for the or method. For example: \"foo\" | \"bar\" will match either “foo” or “bar”. When combining an alternative expressed using this operator with an / operator, make sure to surround the alternative with parentheses, like so: (\"foo\" | \"bar\") / \"bom\". Otherwise, the / operator takes precedence and would only apply to the right-hand side of the alternative. Modifiers Path matcher instances can be transformed with these modifier methods: / The slash operator cannot only be used as combinator for combining two matcher instances, it can also be used as a postfix call. matcher / is identical to matcher ~ Slash but shorter and easier to read. This is an alias for the slash method. ? : By postfixing a matcher with ? you can turn any PathMatcher into one that always matches, optionally consumes and potentially extracts an Option of the underlying matchers extraction. This is an alias for the optional method. The result type depends on the type of the underlying matcher: If a matcher is of type then matcher.? is of type PathMatcher0 PathMatcher0 PathMatcher1[T] PathMatcher1[Option[T]] PathMatcher[L: Tuple] PathMatcher[Option[L]] repeat(separator: PathMatcher0 = PathMatchers.Neutral) : By postfixing a matcher with repeat(separator) you can turn any PathMatcher into one that always matches, consumes zero or more times (with the given separator) and potentially extracts a List of the underlying matcher’s extractions. The result type depends on the type of the underlying matcher: If a matcher is of type then matcher.repeat(...) is of type PathMatcher0 PathMatcher0 PathMatcher1[T] PathMatcher1[List[T]] PathMatcher[L: Tuple] PathMatcher[List[L]] unary_! By prefixing a matcher with ! it can be turned into a PathMatcher0 that only matches if the underlying matcher does not match and vice versa. This is the operator alternative to the not method. transform / (h)flatMap / (h)map These modifiers allow you to append your own “post-application” logic to another matcher in order to form a custom one. You can map over the extraction(s), turn mismatches into matches or vice-versa or do anything else with the results of the underlying matcher. Take a look at the method signatures and implementations for more guidance as to how to use them.","title":"Basic PathMatchers"},{"location":"/routing-dsl/path-matchers.html#examples","text":"Here’s a collection of path matching examples:\nScala copysource// matches /foo/\npath(\"foo\"./)\n\n// matches /foo/bar\npath(\"foo\" / \"bar\")\n\n// NOTE: matches /foo%2Fbar and doesn't match /foo/bar\npath(\"foo/bar\")\n\n// matches /foo/bar\npath(separateOnSlashes(\"foo/bar\"))\n\n// matches e.g. /foo/123 and extracts \"123\" as a String\npath(\"foo\" / \"\"\"\\d+\"\"\".r)\n\n// matches e.g. /foo/bar123 and extracts \"123\" as a String\npath(\"foo\" / \"\"\"bar(\\d+)\"\"\".r)\n\n// similar to `path(Segments)`\npath(Segment.repeat(10, separator = Slash))\n\n// matches e.g. /i42 or /hCAFE and extracts an Int\npath(\"i\" ~ IntNumber | \"h\" ~ HexIntNumber)\n\n// identical to path(\"foo\" ~ (PathEnd | Slash))\npath(\"foo\" ~ Slash.?)\n\n// matches /red or /green or /blue and extracts 1, 2 or 3 respectively\npath(Map(\"red\" -> 1, \"green\" -> 2, \"blue\" -> 3))\n\n// matches anything starting with \"/foo\" except for /foobar\npathPrefix(\"foo\" ~ not(\"bar\")) Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\nimport static org.apache.pekko.http.javadsl.server.Directives.pathEnd;\nimport static org.apache.pekko.http.javadsl.server.Directives.pathPrefix;\nimport static org.apache.pekko.http.javadsl.server.Directives.pathSingleSlash;\n// matches \"/test\"\npath(\"test\", () ->\n  complete(StatusCodes.OK)\n);\n\n// matches \"/test\", as well\npath(PathMatchers.segment(\"test\"), () ->\n  complete(StatusCodes.OK)\n);\n\n// matches \"/admin/user\"\npath(PathMatchers.segment(\"admin\")\n  .slash(\"user\"), () ->\n  complete(StatusCodes.OK)\n);\n\n// matches \"/admin/user\", as well\npathPrefix(\"admin\", () ->\n  path(\"user\", () ->\n    complete(StatusCodes.OK)\n  )\n);\n\n// matches \"/admin/user/<user-id>\"\npath(PathMatchers.segment(\"admin\")\n  .slash(\"user\")\n  .slash(PathMatchers.integerSegment()), userId -> {\n    return complete(\"Hello user \" + userId);\n  }\n);\n\n// matches \"/admin/user/<user-id>\", as well\npathPrefix(\"admin\", () ->\n  path(\"user\", () ->\n    path(PathMatchers.integerSegment(), userId ->\n      complete(\"Hello user \" + userId)\n    )\n  )\n);\n\n// never matches\npath(\"admin\", () -> // oops this only matches \"/admin\", and no sub-paths\n  path(\"user\", () ->\n    complete(StatusCodes.OK)\n  )\n);\n\n// matches \"/user/\" with the first subroute, \"/user\" (without a trailing slash)\n// with the second subroute, and \"/user/<user-id>\" with the last one.\npathPrefix(\"user\", () -> concat(\n  pathSingleSlash(() ->\n    complete(StatusCodes.OK)\n  ),\n  pathEnd(() ->\n    complete(StatusCodes.OK)\n  ),\n  path(PathMatchers.integerSegment(), userId ->\n    complete(\"Hello user \" + userId)\n  )\n));","title":"Examples"},{"location":"/routing-dsl/directives/range-directives/index.html","text":"","title":"RangeDirectives"},{"location":"/routing-dsl/directives/range-directives/index.html#rangedirectives","text":"withRangeSupport","title":"RangeDirectives"},{"location":"/routing-dsl/directives/range-directives/withRangeSupport.html","text":"","title":"withRangeSupport"},{"location":"/routing-dsl/directives/range-directives/withRangeSupport.html#withrangesupport","text":"Signature def withRangeSupport(): Directive0\ndef withRangeSupport(rangeCountLimit: Int, rangeCoalescingThreshold:Long): Directive0\n The signature shown is simplified, the real signature uses magnets. [1] [1] See The Magnet Pattern for an explanation of magnet-based overloading.","title":"withRangeSupport"},{"location":"/routing-dsl/directives/range-directives/withRangeSupport.html#description","text":"Transforms the response from its inner route into a 206 Partial Content response if the client requested only part of the resource with a Range header.\nAugments responses to GET requests with an Accept-Ranges: bytes header and converts them into partial responses if the request contains a valid Range request header. The requested byte-ranges are coalesced (merged) if they lie closer together than the specified rangeCoalescingThreshold argument.\nIn order to prevent the server from becoming overloaded with trying to prepare multipart/byteranges responses for high numbers of potentially very small ranges the directive rejects requests requesting more than rangeCountLimit ranges with a TooManyRangesRejectionTooManyRangesRejection. Requests with unsatisfiable ranges are rejected with an UnsatisfiableRangeRejectionUnsatisfiableRangeRejection.\nThe withRangeSupport() form (without parameters) uses the range-coalescing-threshold and range-count-limit settings from the pekko.http.routing configuration.\nThis directive is transparent to non-GET requests.\nSee also: RFC 7233","title":"Description"},{"location":"/routing-dsl/directives/range-directives/withRangeSupport.html#example","text":"Scala copysourceval route =\n  withRangeSupport {\n    complete(\"ABCDEFGH\")\n  }\n\nGet() ~> addHeader(Range(ByteRange(3, 4))) ~> route ~> check {\n  headers should contain(`Content-Range`(ContentRange(3, 4, 8)))\n  status shouldEqual StatusCodes.PartialContent\n  responseAs[String] shouldEqual \"DE\"\n}\n\n// we set \"pekko.http.routing.range-coalescing-threshold = 2\"\n// above to make sure we get two BodyParts\nGet() ~> addHeader(Range(ByteRange(0, 1), ByteRange(1, 2), ByteRange(6, 7))) ~> route ~> check {\n  headers.collectFirst { case `Content-Range`(_, _) => true } shouldBe None\n  val responseF = responseAs[Multipart.ByteRanges].parts\n    .runFold[List[Multipart.ByteRanges.BodyPart]](Nil)((acc, curr) => curr :: acc)\n\n  val response = Await.result(responseF, 3.seconds).reverse\n\n  (response should have).length(2)\n\n  val part1 = response(0)\n  part1.contentRange shouldEqual ContentRange(0, 2, 8)\n  part1.entity should matchPattern {\n    case HttpEntity.Strict(_, bytes) if bytes.utf8String == \"ABC\" =>\n  }\n\n  val part2 = response(1)\n  part2.contentRange shouldEqual ContentRange(6, 7, 8)\n  part2.entity should matchPattern {\n    case HttpEntity.Strict(_, bytes) if bytes.utf8String == \"GH\" =>\n  }\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.withRangeSupport;\n\nfinal Route route = withRangeSupport(() -> complete(\"ABCDEFGH\"));\n\n// test:\nfinal String bytes348Range = ContentRange.create(RangeUnits.BYTES,\n        org.apache.pekko.http.javadsl.model.ContentRange.create(3, 4, 8)).value();\nfinal org.apache.pekko.http.javadsl.model.ContentRange bytes028Range =\n        org.apache.pekko.http.javadsl.model.ContentRange.create(0, 2, 8);\nfinal org.apache.pekko.http.javadsl.model.ContentRange bytes678Range =\n        org.apache.pekko.http.javadsl.model.ContentRange.create(6, 7, 8);\nfinal Materializer materializer = systemResource().materializer();\n\ntestRoute(route).run(HttpRequest.GET(\"/\")\n        .addHeader(Range.create(RangeUnits.BYTES, ByteRange.createSlice(3, 4))))\n        .assertHeaderKindExists(\"Content-Range\")\n        .assertHeaderExists(\"Content-Range\", bytes348Range)\n        .assertStatusCode(StatusCodes.PARTIAL_CONTENT)\n        .assertEntity(\"DE\");\n\n// we set \"pekko.http.routing.range-coalescing-threshold = 2\"\n// above to make sure we get two BodyParts\nfinal TestRouteResult response = testRoute(route).run(HttpRequest.GET(\"/\")\n        .addHeader(Range.create(RangeUnits.BYTES,\n                ByteRange.createSlice(0, 1), ByteRange.createSlice(1, 2), ByteRange.createSlice(6, 7))));\nresponse.assertHeaderKindNotExists(\"Content-Range\");\n\nfinal CompletionStage<List<Multipart.ByteRanges.BodyPart>> completionStage =\n        response.entity(Unmarshaller.entityToMultipartByteRangesUnmarshaller()).getParts()\n                .runFold(new ArrayList<>(), (acc, n) -> {\n                    acc.add(n);\n                    return acc;\n                }, materializer);\ntry {\n    final List<Multipart.ByteRanges.BodyPart> bodyParts =\n            completionStage.toCompletableFuture().get(3, TimeUnit.SECONDS);\n    assertEquals(2, bodyParts.toArray().length);\n\n    final Multipart.ByteRanges.BodyPart part1 = bodyParts.get(0);\n    assertEquals(bytes028Range, part1.getContentRange());\n    assertEquals(ByteString.fromString(\"ABC\"),\n            part1.toStrict(1000, materializer).toCompletableFuture().get().getEntity().getData());\n\n    final Multipart.ByteRanges.BodyPart part2 = bodyParts.get(1);\n    assertEquals(bytes678Range, part2.getContentRange());\n    assertEquals(ByteString.fromString(\"GH\"),\n            part2.toStrict(1000, materializer).toCompletableFuture().get().getEntity().getData());\n\n} catch (Exception e) {\n    // please handle this in production code\n}","title":"Example"},{"location":"/routing-dsl/directives/respond-with-directives/index.html","text":"","title":"RespondWithDirectives"},{"location":"/routing-dsl/directives/respond-with-directives/index.html#respondwithdirectives","text":"respondWithDefaultHeader respondWithDefaultHeaders respondWithHeader respondWithHeaders","title":"RespondWithDirectives"},{"location":"/routing-dsl/directives/respond-with-directives/respondWithDefaultHeader.html","text":"","title":"respondWithDefaultHeader"},{"location":"/routing-dsl/directives/respond-with-directives/respondWithDefaultHeader.html#respondwithdefaultheader","text":"Signature def respondWithDefaultHeader(responseHeader: HttpHeader): Directive0","title":"respondWithDefaultHeader"},{"location":"/routing-dsl/directives/respond-with-directives/respondWithDefaultHeader.html#description","text":"Adds a given HTTP header to all responses coming back from its inner route only if a header with the same name doesn’t exist yet in the response.\nThis directive transforms HttpResponseHttpResponse and ChunkedResponseStart messages coming back from its inner route by potentially adding the given HttpHeaderHttpHeader instance to the headers list. The header is only added if there is no header instance with the same name (case insensitively) already present in the response.\nSee also respondWithDefaultHeaders if you’d like to add more than one header.","title":"Description"},{"location":"/routing-dsl/directives/respond-with-directives/respondWithDefaultHeader.html#example","text":"Scala copysource// custom headers\nval blippy = RawHeader(\"X-Fish-Name\", \"Blippy\")\nval elTonno = RawHeader(\"X-Fish-Name\", \"El Tonno\")\n\n// format: OFF\n// by default always include the Blippy header,\n// unless a more specific X-Fish-Name is given by the inner route\nval route =\n  respondWithDefaultHeader(blippy) {  //  blippy\n    respondWithHeader(elTonno) {      // /  el tonno\n      path(\"el-tonno\") {              // | /\n        complete(\"¡Ay blippy!\")       // | |- el tonno\n      } ~                             // | |\n      path(\"los-tonnos\") {            // | |\n        complete(\"¡Ay ay blippy!\")    // | |- el tonno\n      }                               // | |\n    } ~                               // | x\n    complete(\"Blip!\")                 // |- blippy\n  } // x\n// format: ON\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  header(\"X-Fish-Name\") shouldEqual Some(RawHeader(\"X-Fish-Name\", \"Blippy\"))\n  responseAs[String] shouldEqual \"Blip!\"\n}\n\nGet(\"/el-tonno\") ~> route ~> check {\n  header(\"X-Fish-Name\") shouldEqual Some(RawHeader(\"X-Fish-Name\", \"El Tonno\"))\n  responseAs[String] shouldEqual \"¡Ay blippy!\"\n}\n\nGet(\"/los-tonnos\") ~> route ~> check {\n  header(\"X-Fish-Name\") shouldEqual Some(RawHeader(\"X-Fish-Name\", \"El Tonno\"))\n  responseAs[String] shouldEqual \"¡Ay ay blippy!\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\nimport static org.apache.pekko.http.javadsl.server.Directives.respondWithDefaultHeader;\nimport static org.apache.pekko.http.javadsl.server.Directives.respondWithHeader;\n\n//custom headers\nfinal RawHeader blippy = RawHeader.create(\"X-Fish-Name\", \"Blippy\");\nfinal RawHeader elTonno = RawHeader.create(\"X-Fish-Name\", \"El Tonno\");\n\n// format: OFF\n// by default always include the Blippy header,\n// unless a more specific X-Fish-Name is given by the inner route\nfinal Route route =\n        respondWithDefaultHeader(blippy, () ->                      // blippy\n                respondWithHeader(elTonno, () ->                    // / el tonno\n                        path(\"el-tonno\", () ->                      // | /\n                                complete(\"¡Ay blippy!\")             // | |- el tonno\n                        ).orElse(                                   // | |\n                                path(\"los-tonnos\", () ->            // | |\n                                        complete(\"¡Ay ay blippy!\")  // | |- el tonno\n                                )                                   // | |\n                        )                                           // | |\n                ).orElse(                                           // | x\n                        complete(\"Blip!\")                           // |- blippy\n                )                                                   // x\n        );\n//format: ON\n\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n        .assertHeaderExists(\"X-Fish-Name\", \"Blippy\")\n        .assertEntity(\"Blip!\");\n\ntestRoute(route).run(HttpRequest.GET(\"/el-tonno\"))\n        .assertHeaderExists(\"X-Fish-Name\", \"El Tonno\")\n        .assertEntity(\"¡Ay blippy!\");\n\ntestRoute(route).run(HttpRequest.GET(\"/los-tonnos\"))\n        .assertHeaderExists(\"X-Fish-Name\", \"El Tonno\")\n        .assertEntity(\"¡Ay ay blippy!\");","title":"Example"},{"location":"/routing-dsl/directives/respond-with-directives/respondWithDefaultHeaders.html","text":"","title":"respondWithDefaultHeaders"},{"location":"/routing-dsl/directives/respond-with-directives/respondWithDefaultHeaders.html#respondwithdefaultheaders","text":"Signature def respondWithDefaultHeaders(responseHeaders: HttpHeader*): Directive0 \ndef respondWithDefaultHeaders(responseHeaders: immutable.Seq[HttpHeader]): Directive0 \ndef respondWithDefaultHeaders(firstHeader: HttpHeader, otherHeaders: HttpHeader*): Directive0","title":"respondWithDefaultHeaders"},{"location":"/routing-dsl/directives/respond-with-directives/respondWithDefaultHeaders.html#description","text":"Adds the given HTTP headers to all responses coming back from its inner route only if a respective header with the same name doesn’t exist yet in the response.\nThis directive transforms HttpResponseHttpResponse and ChunkedResponseStart messages coming back from its inner route by potentially adding the given HttpHeaderHttpHeader instances to the headers list. A header is only added if there is no header instance with the same name (case insensitively) already present in the response.\nSee also respondWithDefaultHeader if you’d like to add only a single header.","title":"Description"},{"location":"/routing-dsl/directives/respond-with-directives/respondWithDefaultHeaders.html#example","text":"The respondWithDefaultHeaders directive is equivalent to the respondWithDefaultHeader directive which is shown in the example below, however it allows including multiple default headers at once in the directive, like so:\nScala copysourcerespondWithDefaultHeaders(\n  Origin(HttpOrigin(\"http://pekko.apache.org\")),\n  RawHeader(\"X-Fish-Name\", \"Blippy\")) { ??? } Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.respondWithDefaultHeaders;\n\nfinal List<HttpHeader> headers = Arrays.asList(\n        Origin.create(HttpOrigin.parse(\"http://pekko.apache.org\")),\n        RawHeader.create(\"X-Fish-Name\", \"Blippy\"));\nrespondWithDefaultHeaders(headers, () ->\n        /*...*/\n        complete(\"Blip!\"));\nThe semantics remain the same however, as explained by the following example:\nScala copysource// custom headers\nval blippy = RawHeader(\"X-Fish-Name\", \"Blippy\")\nval elTonno = RawHeader(\"X-Fish-Name\", \"El Tonno\")\n\n// format: OFF\n// by default always include the Blippy header,\n// unless a more specific X-Fish-Name is given by the inner route\nval route =\n  respondWithDefaultHeader(blippy) {  //  blippy\n    respondWithHeader(elTonno) {      // /  el tonno\n      path(\"el-tonno\") {              // | /\n        complete(\"¡Ay blippy!\")       // | |- el tonno\n      } ~                             // | |\n      path(\"los-tonnos\") {            // | |\n        complete(\"¡Ay ay blippy!\")    // | |- el tonno\n      }                               // | |\n    } ~                               // | x\n    complete(\"Blip!\")                 // |- blippy\n  } // x\n// format: ON\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  header(\"X-Fish-Name\") shouldEqual Some(RawHeader(\"X-Fish-Name\", \"Blippy\"))\n  responseAs[String] shouldEqual \"Blip!\"\n}\n\nGet(\"/el-tonno\") ~> route ~> check {\n  header(\"X-Fish-Name\") shouldEqual Some(RawHeader(\"X-Fish-Name\", \"El Tonno\"))\n  responseAs[String] shouldEqual \"¡Ay blippy!\"\n}\n\nGet(\"/los-tonnos\") ~> route ~> check {\n  header(\"X-Fish-Name\") shouldEqual Some(RawHeader(\"X-Fish-Name\", \"El Tonno\"))\n  responseAs[String] shouldEqual \"¡Ay ay blippy!\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\nimport static org.apache.pekko.http.javadsl.server.Directives.respondWithDefaultHeaders;\nimport static org.apache.pekko.http.javadsl.server.Directives.respondWithHeader;\n\n//custom headers\nfinal RawHeader blippy = RawHeader.create(\"X-Fish-Name\", \"Blippy\");\nfinal HttpHeader akka = Origin.create(HttpOrigin.parse(\"http://pekko.apache.org\"));\nfinal List<HttpHeader> defaultHeaders = Arrays.asList(blippy, akka);\nfinal RawHeader elTonno = RawHeader.create(\"X-Fish-Name\", \"El Tonno\");\n\n// format: OFF\n// by default always include the Blippy and Pekko headers,\n// unless a more specific X-Fish-Name is given by the inner route\nfinal Route route =\n        respondWithDefaultHeaders(defaultHeaders, () ->            // blippy and akka\n                respondWithHeader(elTonno, () ->                   // / el tonno\n                        path(\"el-tonno\", () ->                     // | /\n                                complete(\"¡Ay blippy!\")            // | |- el tonno\n                        ).orElse(                                  // | |\n                                path(\"los-tonnos\", () ->           // | |\n                                        complete(\"¡Ay ay blippy!\") // | |- el tonno\n                                )                                  // | |\n                        )                                          // | |\n                ).orElse(                                          // | x\n                        complete(\"Blip!\")                          // |- blippy and akka\n                )                                                  // x\n        );\n//format: ON\n\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n        .assertHeaderExists(\"X-Fish-Name\", \"Blippy\")\n        .assertHeaderExists(\"Origin\", \"http://pekko.apache.org\")\n        .assertEntity(\"Blip!\");\n\ntestRoute(route).run(HttpRequest.GET(\"/el-tonno\"))\n        .assertHeaderExists(\"X-Fish-Name\", \"El Tonno\")\n        .assertEntity(\"¡Ay blippy!\");\n\ntestRoute(route).run(HttpRequest.GET(\"/los-tonnos\"))\n        .assertHeaderExists(\"X-Fish-Name\", \"El Tonno\")\n        .assertEntity(\"¡Ay ay blippy!\");\nSee the respondWithDefaultHeader directive for an example with only one header.","title":"Example"},{"location":"/routing-dsl/directives/respond-with-directives/respondWithHeader.html","text":"","title":"respondWithHeader"},{"location":"/routing-dsl/directives/respond-with-directives/respondWithHeader.html#respondwithheader","text":"Signature def respondWithHeader(responseHeader: HttpHeader): Directive0","title":"respondWithHeader"},{"location":"/routing-dsl/directives/respond-with-directives/respondWithHeader.html#description","text":"Adds a given HTTP header to all responses coming back from its inner route.\nThis directive transforms HttpResponseHttpResponse and ChunkedResponseStart messages coming back from its inner route by adding the given HttpHeaderHttpHeader instance to the headers list.\nSee also respondWithHeaders if you’d like to add more than one header.","title":"Description"},{"location":"/routing-dsl/directives/respond-with-directives/respondWithHeader.html#example","text":"Scala copysourceval route =\n  path(\"foo\") {\n    respondWithHeader(RawHeader(\"Funky-Muppet\", \"gonzo\")) {\n      complete(\"beep\")\n    }\n  }\n\n// tests:\nGet(\"/foo\") ~> route ~> check {\n  header(\"Funky-Muppet\") shouldEqual Some(RawHeader(\"Funky-Muppet\", \"gonzo\"))\n  responseAs[String] shouldEqual \"beep\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\nimport static org.apache.pekko.http.javadsl.server.Directives.respondWithDefaultHeader;\n\nfinal Route route = path(\"foo\", () ->\n        respondWithHeader(RawHeader.create(\"Funky-Muppet\", \"gonzo\"), () ->\n                complete(\"beep\")));\n\ntestRoute(route).run(HttpRequest.GET(\"/foo\"))\n        .assertHeaderExists(\"Funky-Muppet\", \"gonzo\")\n        .assertEntity(\"beep\");","title":"Example"},{"location":"/routing-dsl/directives/respond-with-directives/respondWithHeaders.html","text":"","title":"respondWithHeaders"},{"location":"/routing-dsl/directives/respond-with-directives/respondWithHeaders.html#respondwithheaders","text":"Signature def respondWithHeaders(responseHeaders: HttpHeader*): Directive0 \ndef respondWithHeaders(responseHeaders: immutable.Seq[HttpHeader]): Directive0 \ndef respondWithHeaders(firstHeader: HttpHeader, otherHeaders: HttpHeader*): Directive0","title":"respondWithHeaders"},{"location":"/routing-dsl/directives/respond-with-directives/respondWithHeaders.html#description","text":"Adds the given HTTP headers to all responses coming back from its inner route.\nThis directive transforms HttpResponseHttpResponse and ChunkedResponseStart messages coming back from its inner route by adding the given HttpHeaderHttpHeader instances to the headers list.\nSee also respondWithHeader if you’d like to add just a single header.","title":"Description"},{"location":"/routing-dsl/directives/respond-with-directives/respondWithHeaders.html#example","text":"Scala copysourceval route =\n  path(\"foo\") {\n    respondWithHeaders(RawHeader(\"Funky-Muppet\", \"gonzo\"), Origin(HttpOrigin(\"http://pekko.apache.org\"))) {\n      complete(\"beep\")\n    }\n  }\n\n// tests:\nGet(\"/foo\") ~> route ~> check {\n  header(\"Funky-Muppet\") shouldEqual Some(RawHeader(\"Funky-Muppet\", \"gonzo\"))\n  header[Origin] shouldEqual Some(Origin(HttpOrigin(\"http://pekko.apache.org\")))\n  responseAs[String] shouldEqual \"beep\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\nimport static org.apache.pekko.http.javadsl.server.Directives.respondWithDefaultHeaders;\nimport static org.apache.pekko.http.javadsl.server.Directives.respondWithHeaders;\n\nfinal HttpHeader gonzo = RawHeader.create(\"Funky-Muppet\", \"gonzo\");\nfinal HttpHeader akka = Origin.create(HttpOrigin.parse(\"http://pekko.apache.org\"));\n\nfinal Route route = path(\"foo\", () ->\n        respondWithHeaders(Arrays.asList(gonzo, akka), () ->\n                complete(\"beep\")\n        )\n);\n\ntestRoute(route).run(HttpRequest.GET(\"/foo\"))\n        .assertHeaderExists(\"Funky-Muppet\", \"gonzo\")\n        .assertHeaderExists(\"Origin\", \"http://pekko.apache.org\")\n        .assertEntity(\"beep\");","title":"Example"},{"location":"/routing-dsl/directives/route-directives/index.html","text":"","title":"RouteDirectives"},{"location":"/routing-dsl/directives/route-directives/index.html#routedirectives","text":"The RouteDirectivesRouteDirectives have a special role in akka-http’s routing DSL. Contrary to all other directives (except most FileAndResourceDirectives) they do not produce instances of type Directive[L <: HList] but rather “plain” routes of type RouteRoute. The reason is that the RouteDirectivesRouteDirectives are not meant for wrapping an inner route (like most other directives, as intermediate-level elements of a route structure, do) but rather form the leaves of the actual route structure leaves.\nSo in most cases the inner-most element of a route structure branch is one of the RouteDirectivesRouteDirectives (or FileAndResourceDirectives):\ncomplete failWith handle handleSync redirect reject","title":"RouteDirectives"},{"location":"/routing-dsl/directives/route-directives/complete.html","text":"","title":"complete"},{"location":"/routing-dsl/directives/route-directives/complete.html#complete","text":"Signature def complete[T :ToResponseMarshaller](value: T): StandardRoute\ndef complete(response: HttpResponse): StandardRoute\ndef complete(status: StatusCode): StandardRoute\ndef complete[T :Marshaller](status: StatusCode, value: T): StandardRoute\ndef complete[T :Marshaller](status: Int, value: T): StandardRoute\ndef complete[T :Marshaller](status: StatusCode, headers: Seq[HttpHeader], value: T): StandardRoute\ndef complete[T :Marshaller](status: Int, headers: Seq[HttpHeader], value: T): StandardRoute\n The signature shown is simplified, the real signature uses magnets. [1] [1] See The Magnet Pattern for an explanation of magnet-based overloading.","title":"complete"},{"location":"/routing-dsl/directives/route-directives/complete.html#description","text":"Completes the request using the given argument(s).\ncomplete uses the given arguments to construct a RouteRoute which simply calls complete on the RequestContextRequestContext with the respective HttpResponseHttpResponse instance. Completing the request will send the response “back up” the route structure where all the logic runs that wrapping directives have potentially chained into the RouteResult future transformation chain.\nPlease note that the complete directive has multiple variants, like the ones shown in the examples.","title":"Description"},{"location":"/routing-dsl/directives/route-directives/complete.html#example","text":"Scala copysourceimport org.apache.pekko\nimport pekko.http.scaladsl.model._\nimport pekko.http.scaladsl.model.ContentTypes._\nimport pekko.http.scaladsl.model.headers.`Content-Type`\n\nval route =\n  concat(\n    path(\"a\") {\n      complete(HttpResponse(entity = \"foo\"))\n    },\n    path(\"b\") {\n      complete(StatusCodes.OK)\n    },\n    path(\"c\") {\n      complete(StatusCodes.Created -> \"bar\")\n    },\n    path(\"d\") {\n      complete(201 -> \"bar\")\n    },\n    path(\"e\") {\n      complete(StatusCodes.Created, List(`Content-Type`(`text/plain(UTF-8)`)), \"bar\")\n    },\n    path(\"f\") {\n      complete(201, List(`Content-Type`(`text/plain(UTF-8)`)), \"bar\")\n    },\n    path(\"g\") {\n      complete(Future { StatusCodes.Created -> \"bar\" })\n    },\n    path(\"h\") & complete(\"baz\") // `&` also works with `complete` as the 2nd argument\n  )\n\n// tests:\nGet(\"/a\") ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n  responseAs[String] shouldEqual \"foo\"\n}\n\nGet(\"/b\") ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n  responseAs[String] shouldEqual \"OK\"\n}\n\nGet(\"/c\") ~> route ~> check {\n  status shouldEqual StatusCodes.Created\n  responseAs[String] shouldEqual \"bar\"\n}\n\nGet(\"/d\") ~> route ~> check {\n  status shouldEqual StatusCodes.Created\n  responseAs[String] shouldEqual \"bar\"\n}\n\nGet(\"/e\") ~> route ~> check {\n  status shouldEqual StatusCodes.Created\n  header[`Content-Type`] shouldEqual Some(`Content-Type`(`text/plain(UTF-8)`))\n  responseAs[String] shouldEqual \"bar\"\n}\n\nGet(\"/f\") ~> route ~> check {\n  status shouldEqual StatusCodes.Created\n  header[`Content-Type`] shouldEqual Some(`Content-Type`(`text/plain(UTF-8)`))\n  responseAs[String] shouldEqual \"bar\"\n}\n\nGet(\"/g\") ~> route ~> check {\n  status shouldEqual StatusCodes.Created\n  responseAs[String] shouldEqual \"bar\"\n}\n\nGet(\"/h\") ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n  responseAs[String] shouldEqual \"baz\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\n\nfinal Route route = concat(\n  path(\"a\", () -> complete(HttpResponse.create().withEntity(\"foo\"))),\n  path(\"b\", () -> complete(StatusCodes.OK)),\n  path(\"c\", () -> complete(StatusCodes.CREATED, \"bar\")),\n  path(\"d\", () -> complete(StatusCodes.get(201), \"bar\")),\n  path(\"e\", () ->\n    complete(StatusCodes.CREATED,\n             Collections.singletonList(ContentType.create(ContentTypes.TEXT_PLAIN_UTF8)),\n             HttpEntities.create(\"bar\"))),\n  path(\"f\", () ->\n    complete(StatusCodes.get(201),\n             Collections.singletonList(ContentType.create(ContentTypes.TEXT_PLAIN_UTF8)),\n             HttpEntities.create(\"bar\"))),\n  path(\"g\", () -> complete(\"baz\"))\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/a\"))\n  .assertStatusCode(StatusCodes.OK)\n  .assertEntity(\"foo\");\n\ntestRoute(route).run(HttpRequest.GET(\"/b\"))\n  .assertStatusCode(StatusCodes.OK)\n  .assertEntity(\"OK\");\n\ntestRoute(route).run(HttpRequest.GET(\"/c\"))\n  .assertStatusCode(StatusCodes.CREATED)\n  .assertEntity(\"bar\");\n\ntestRoute(route).run(HttpRequest.GET(\"/d\"))\n  .assertStatusCode(StatusCodes.CREATED)\n  .assertEntity(\"bar\");\n\ntestRoute(route).run(HttpRequest.GET(\"/e\"))\n  .assertStatusCode(StatusCodes.CREATED)\n  .assertHeaderExists(ContentType.create(ContentTypes.TEXT_PLAIN_UTF8))\n  .assertEntity(\"bar\");\n\ntestRoute(route).run(HttpRequest.GET(\"/f\"))\n  .assertStatusCode(StatusCodes.CREATED)\n  .assertHeaderExists(ContentType.create(ContentTypes.TEXT_PLAIN_UTF8))\n  .assertEntity(\"bar\");\n\ntestRoute(route).run(HttpRequest.GET(\"/g\"))\n  .assertStatusCode(StatusCodes.OK)\n  .assertEntity(\"baz\");","title":"Example"},{"location":"/routing-dsl/directives/route-directives/failWith.html","text":"","title":"failWith"},{"location":"/routing-dsl/directives/route-directives/failWith.html#failwith","text":"Signature def failWith(error: Throwable): StandardRoute","title":"failWith"},{"location":"/routing-dsl/directives/route-directives/failWith.html#description","text":"Bubbles up the given error through the route structure where it is dealt with by the closest handleExceptions directive and its ExceptionHandlerExceptionHandler.\nfailWith explicitly raises an exception that gets bubbled up through the route structure to be picked up by the nearest handleExceptions directive. Using failWith rather than simply throwing an exception enables the route structure’s Exception Handling mechanism to deal with the exception even if the current route is executed asynchronously on another thread (e.g. in a Future or separate actor).\nIf no handleExceptions is present above the respective location in the route structure the top-level routing logic will handle the exception and translate it into a corresponding HttpResponseHttpResponse using the in-scope ExceptionHandlerExceptionHandler. See the Exception Handling chapter for more details.\nThere is one notable special case: If the given exception is a RejectionErrorRejectionError exception it is not bubbled up, but rather the wrapped exception is unpacked and “executed”. This allows the “tunneling” of a rejection via an exception.","title":"Description"},{"location":"/routing-dsl/directives/route-directives/failWith.html#example","text":"Scala copysourceval route =\n  path(\"foo\") {\n    failWith(new RuntimeException(\"Oops.\"))\n  }\n\n// tests:\nGet(\"/foo\") ~> Route.seal(route) ~> check {\n  status shouldEqual StatusCodes.InternalServerError\n  responseAs[String] shouldEqual \"There was an internal server error.\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.failWith;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\n\nfinal Route route = path(\"foo\", () ->\n  failWith(new RuntimeException(\"Oops.\"))\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/foo\"))\n  .assertStatusCode(StatusCodes.INTERNAL_SERVER_ERROR)\n  .assertEntity(\"There was an internal server error.\");","title":"Example"},{"location":"/routing-dsl/directives/route-directives/handle.html","text":"","title":"handle"},{"location":"/routing-dsl/directives/route-directives/handle.html#handle","text":"Signature def handle(handler: HttpRequest \ndef handle(handler: PartialFunction[HttpRequest, Future[HttpResponse]]): StandardRoute \ndef handle( handler: PartialFunction[HttpRequest, Future[HttpResponse]], rejections: Seq[Rejection]): StandardRoute","title":"handle"},{"location":"/routing-dsl/directives/route-directives/handle.html#description","text":"Creates a RouteRoute that handles the request using a function or PartialFunction from HttpRequestHttpRequest to a FutureCompletionStage of HttpResponseHttpResponse.\nThis directive can be used to include external components request processing components defined as a Function or PartialFunction (like those provided by akka-grpc) into a routing tree defined by directives and routes.\nFor the PartialFunction variant, the given list of rejections will be used to reject the request with if the PartialFunction is not defined for a request. By default, an empty list of rejections will be used which is interpreted as “Not Found”.\nThere is also a strict version called handleSync.","title":"Description"},{"location":"/routing-dsl/directives/route-directives/handle.html#example","text":"Scala copysourceval handler: PartialFunction[HttpRequest, Future[HttpResponse]] = {\n  case HttpRequest(HttpMethods.GET, Uri.Path(\"/value\"), _, _, _) =>\n    Future.successful(HttpResponse(entity = \"23\"))\n}\n\nval route =\n  concat(\n    handle(handler),\n    complete(\"fallback\"))\n\n// tests:\nGet(\"/value\") ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n  responseAs[String] shouldEqual \"23\"\n}\n\n// Uri doesn't match so function is never invoked and the request is rejected and the\n// fallback completes the request.\nGet(\"/other\") ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n  responseAs[String] shouldEqual \"fallback\"\n}","title":"Example"},{"location":"/routing-dsl/directives/route-directives/handleSync.html","text":"","title":"handleSync"},{"location":"/routing-dsl/directives/route-directives/handleSync.html#handlesync","text":"Signature def handleSync(handler: HttpRequest \ndef handleSync(handler: PartialFunction[HttpRequest, HttpResponse]): StandardRoute \ndef handleSync( handler: PartialFunction[HttpRequest, HttpResponse], rejections: Seq[Rejection]): StandardRoute","title":"handleSync"},{"location":"/routing-dsl/directives/route-directives/handleSync.html#description","text":"Creates a RouteRoute that handles the request using a function or PartialFunction from HttpRequestHttpRequest to a HttpResponseHttpResponse.\nThis directive can be used to include components into a routing tree that have been defined only in terms of the low-level model classes.\nThis is a strict version of handle.","title":"Description"},{"location":"/routing-dsl/directives/route-directives/handleSync.html#example","text":"Scala copysourceval handler: PartialFunction[HttpRequest, HttpResponse] = {\n  case HttpRequest(HttpMethods.GET, Uri.Path(\"/value\"), _, _, _) => HttpResponse(entity = \"23\")\n}\n\nval route =\n  concat(\n    handleSync(handler),\n    complete(\"fallback\"))\n\n// tests:\nGet(\"/value\") ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n  responseAs[String] shouldEqual \"23\"\n}\n\n// Uri doesn't match so function is never invoked and the request is rejected and the\n// fallback completes the request.\nGet(\"/other\") ~> route ~> check {\n  status shouldEqual StatusCodes.OK\n  responseAs[String] shouldEqual \"fallback\"\n}","title":"Example"},{"location":"/routing-dsl/directives/route-directives/redirect.html","text":"","title":"redirect"},{"location":"/routing-dsl/directives/route-directives/redirect.html#redirect","text":"Signature def redirect(uri: Uri, redirectionType: Redirection): StandardRoute","title":"redirect"},{"location":"/routing-dsl/directives/route-directives/redirect.html#description","text":"Completes the request with a redirection response to a given target URI and of a given redirection type (status code).\nredirect is a convenience helper for completing the request with a redirection response. It is equivalent to this snippet relying on the complete method on RequestContextRequestContext, and a directive is also available:\nScala copysourcecomplete(HttpResponse(\n  status = redirectionType,\n  headers = headers.Location(uri) :: Nil,\n  entity = redirectionType.htmlTemplate match {\n    case \"\"       => HttpEntity.Empty\n    case template => HttpEntity(ContentTypes.`text/html(UTF-8)`, template.format(uri))\n  })) Java copysourcerc.completeWith(HttpResponse.create()\n        .withStatus(redirectionType)\n        .addHeader(Location.create(uri))","title":"Description"},{"location":"/routing-dsl/directives/route-directives/redirect.html#example","text":"Scala copysourceval route =\n  pathPrefix(\"foo\") {\n    concat(\n      pathSingleSlash {\n        complete(\"yes\")\n      },\n      pathEnd {\n        redirect(\"/foo/\", StatusCodes.PermanentRedirect)\n      })\n  }\n\n// tests:\nGet(\"/foo/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"yes\"\n}\n\nGet(\"/foo\") ~> route ~> check {\n  status shouldEqual StatusCodes.PermanentRedirect\n  responseAs[String] shouldEqual \"\"\"The request, and all future requests should be repeated using <a href=\"/foo/\">this URI</a>.\"\"\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.pathEnd;\nimport static org.apache.pekko.http.javadsl.server.Directives.pathPrefix;\nimport static org.apache.pekko.http.javadsl.server.Directives.pathSingleSlash;\nimport static org.apache.pekko.http.javadsl.server.Directives.redirect;\nfinal Route route = pathPrefix(\"foo\", () ->\n  concat(\n    pathSingleSlash(() -> complete(\"yes\")),\n    pathEnd(() -> redirect(Uri.create(\"/foo/\"), StatusCodes.PERMANENT_REDIRECT))\n  )\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/foo/\"))\n  .assertEntity(\"yes\");\n\ntestRoute(route).run(HttpRequest.GET(\"/foo\"))\n  .assertStatusCode(StatusCodes.PERMANENT_REDIRECT)\n  .assertEntity(\"The request, and all future requests should be repeated using <a href=\\\"/foo/\\\">this URI</a>.\");","title":"Example"},{"location":"/routing-dsl/directives/route-directives/reject.html","text":"","title":"reject"},{"location":"/routing-dsl/directives/route-directives/reject.html#reject","text":"Signature def reject: StandardRoute \ndef reject(rejections: Rejection*): StandardRoute","title":"reject"},{"location":"/routing-dsl/directives/route-directives/reject.html#description","text":"Explicitly rejects the request optionally using the given rejection(s).\nreject uses the given rejection instances (which might be the empty Seq) to construct a RouteRoute which simply calls requestContext.reject. See the chapter on Rejections for more information on what this means.\nAfter the request has been rejected at the respective point it will continue to flow through the routing structure in the search for a route that is able to complete it.\nThe explicit reject directive is used mostly when building Custom Directives, e.g. inside of a flatMap modifier for “filtering out” certain cases.","title":"Description"},{"location":"/routing-dsl/directives/route-directives/reject.html#example","text":"Scala copysourceimport org.apache.pekko\nimport pekko.http.scaladsl.model._\nimport pekko.http.scaladsl.server.ValidationRejection\n\nval route =\n  concat(\n    path(\"a\") {\n      reject // don't handle here, continue on\n    },\n    path(\"a\") {\n      complete(\"foo\")\n    },\n    path(\"b\") {\n      // trigger a ValidationRejection explicitly\n      // rather than through the `validate` directive\n      reject(ValidationRejection(\"Restricted!\"))\n    })\n\n// tests:\nGet(\"/a\") ~> route ~> check {\n  responseAs[String] shouldEqual \"foo\"\n}\n\nGet(\"/b\") ~> route ~> check {\n  rejection shouldEqual ValidationRejection(\"Restricted!\")\n} Java copysourceimport org.apache.pekko.http.javadsl.server.Directives;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\nimport static org.apache.pekko.http.javadsl.server.Directives.reject;\nfinal Route route = concat(\n  path(\"a\", Directives::reject), // don't handle here, continue on\n  path(\"a\", () -> complete(\"foo\")),\n  path(\"b\", () -> reject(Rejections.validationRejection(\"Restricted!\")))\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/a\"))\n  .assertEntity(\"foo\");\n\nrunRouteUnSealed(route, HttpRequest.GET(\"/b\"))\n  .assertRejections(Rejections.validationRejection(\"Restricted!\"));","title":"Example"},{"location":"/routing-dsl/directives/scheme-directives/index.html","text":"","title":"SchemeDirectives"},{"location":"/routing-dsl/directives/scheme-directives/index.html#schemedirectives","text":"Scheme directives can be used to extract the Uri scheme (i.e. “http”, “https”, etc.) from requests or to reject any request that does not match a specified scheme name.\nextractScheme scheme","title":"SchemeDirectives"},{"location":"/routing-dsl/directives/scheme-directives/extractScheme.html","text":"","title":"extractScheme"},{"location":"/routing-dsl/directives/scheme-directives/extractScheme.html#extractscheme","text":"Signature def extractScheme: Directive1[String]","title":"extractScheme"},{"location":"/routing-dsl/directives/scheme-directives/extractScheme.html#description","text":"Extracts the Uri scheme (i.e. “http”, “https”, etc.) for an incoming request.\nFor rejecting a request if it doesn’t match a specified scheme name, see the scheme directive.","title":"Description"},{"location":"/routing-dsl/directives/scheme-directives/extractScheme.html#example","text":"Scala copysourceval route =\n  extractScheme { scheme =>\n    complete(s\"The scheme is '${scheme}'\")\n  }\n\n// tests:\nGet(\"https://www.example.com/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"The scheme is 'https'\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.extractScheme;\n\nfinal Route route = extractScheme((scheme) ->\n                                  complete(String.format(\"The scheme is '%s'\", scheme)));\ntestRoute(route).run(HttpRequest.GET(\"https://www.example.com/\"))\n  .assertEntity(\"The scheme is 'https'\");","title":"Example"},{"location":"/routing-dsl/directives/scheme-directives/scheme.html","text":"","title":"scheme"},{"location":"/routing-dsl/directives/scheme-directives/scheme.html#scheme","text":"Signature def scheme(name: String): Directive0","title":"scheme"},{"location":"/routing-dsl/directives/scheme-directives/scheme.html#description","text":"Rejects a request if its Uri scheme does not match a given one.\nThe scheme directive can be used to match requests by their Uri scheme, only passing through requests that match the specified scheme and rejecting all others.\nA typical use case for the scheme directive would be to reject requests coming in over http instead of https, or to redirect such requests to the matching https URI with a MovedPermanently.\nFor simply extracting the scheme name, see the extractScheme directive.","title":"Description"},{"location":"/routing-dsl/directives/scheme-directives/scheme.html#example","text":"Scala copysourceimport org.apache.pekko\nimport pekko.http.scaladsl.model._\nimport pekko.http.scaladsl.model.headers.Location\nimport StatusCodes.MovedPermanently\n\nval route =\n  concat(\n    scheme(\"http\") {\n      extract(_.request.uri) { uri =>\n        redirect(uri.copy(scheme = \"https\"), MovedPermanently)\n      }\n    },\n    scheme(\"https\") {\n      complete(s\"Safe and secure!\")\n    })\n\n// tests:\nGet(\"http://www.example.com/hello\") ~> route ~> check {\n  status shouldEqual MovedPermanently\n  header[Location] shouldEqual Some(Location(Uri(\"https://www.example.com/hello\")))\n}\n\nGet(\"https://www.example.com/hello\") ~> route ~> check {\n  responseAs[String] shouldEqual \"Safe and secure!\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.extract;\nimport static org.apache.pekko.http.javadsl.server.Directives.redirect;\nimport static org.apache.pekko.http.javadsl.server.Directives.scheme;\n\nfinal Route route = concat(\n  scheme(\"http\", ()->\n    extract((ctx) -> ctx.getRequest().getUri(), (uri)->\n      redirect(uri.scheme(\"https\"), StatusCodes.MOVED_PERMANENTLY)\n    )\n  ),\n  scheme(\"https\", ()->\n    complete(\"Safe and secure!\")\n  )\n);\n\ntestRoute(route).run(HttpRequest.GET(\"http://www.example.com/hello\"))\n  .assertStatusCode(StatusCodes.MOVED_PERMANENTLY)\n  .assertHeaderExists(Location.create(\"https://www.example.com/hello\"))\n;\n\ntestRoute(route).run(HttpRequest.GET(\"https://www.example.com/hello\"))\n  .assertEntity(\"Safe and secure!\");","title":"Example"},{"location":"/routing-dsl/directives/security-directives/index.html","text":"","title":"SecurityDirectives"},{"location":"/routing-dsl/directives/security-directives/index.html#securitydirectives","text":"Authentication vs. Authorization Authentication and Authorization in HTTP Low-level OAuth2 “Bearer Token” directives Credentials and password timing attacks authenticateBasic authenticateBasicAsync authenticateBasicPF authenticateBasicPFAsync authenticateOrRejectWithChallenge authenticateOAuth2 authenticateOAuth2Async authenticateOAuth2PF authenticateOAuth2PFAsync authorize authorizeAsync extractCredentials","title":"SecurityDirectives"},{"location":"/routing-dsl/directives/security-directives/index.html#authentication-vs-authorization","text":"Authentication is the process of establishing a known identity for the user, whereby ‘identity’ is defined in the context of the application. This may be done with a username/password combination, a cookie, a pre-defined IP or some other mechanism. After authentication the system believes that it knows who the user is.\nAuthorization is the process of determining, whether a given user is allowed access to a given resource or not. In most cases, in order to be able to authorize a user (i.e. allow access to some part of the system) the users identity must already have been established, i.e. he/she must have been authenticated. Without prior authentication the authorization would have to be very crude, e.g. “allow access for all users” or “allow access for noone”. Only after authentication will it be possible to, e.g., “allow access to the statistics resource for admins, but not for regular members”.\nAuthentication and authorization may happen at the same time, e.g. when everyone who can properly be authenticated is also allowed access (which is often a very simple and somewhat implicit authorization logic). In other cases the system might have one mechanism for authentication (e.g. establishing user identity via an LDAP lookup) and another one for authorization (e.g. a database lookup for retrieving user access rights).","title":"Authentication vs. Authorization"},{"location":"/routing-dsl/directives/security-directives/index.html#authentication-and-authorization-in-http","text":"HTTP provides a general framework for access control and authentication, via an extensible set of challenge-response authentication schemes, which can be used by a server to challenge a client request and by a client to provide authentication information. The general mechanism is defined in RFC 7235.\nThe “HTTP Authentication Scheme Registry” defines the namespace for the authentication schemes in challenges and credentials. You can see the currently registered schemes at IANA HTTP Authentication Scheme Registry.\nAt this point, Apache Pekko HTTP only implements the “‘Basic’ HTTP Authentication Scheme” whose most current specification can be found here: https://datatracker.ietf.org/doc/rfc7617/.","title":"Authentication and Authorization in HTTP"},{"location":"/routing-dsl/directives/security-directives/index.html#low-level-oauth2-directives","text":"The OAuth2 directives currently provided in Apache Pekko HTTP are not a full OAuth2 protocol implementation, they are only a means of extracting the so called Bearer Token from the AuthorizationAuthorization HTTP Header, as defined in RFC 6750, and allow users to validate and complete the protocol.","title":"Low-level OAuth2 “Bearer Token” directives"},{"location":"/routing-dsl/directives/security-directives/index.html#credentials-and-password-timing-attacks","text":"When transforming request Credentials into an application specific user identifier the naive solution for checking the secret (password) would be a regular string comparison, but doing this would open up the application to timing attacks. See for example Timing Attacks Explained for an explanation of the problem.\nTo protect users of the library from that mistake the secret is not available through the API, instead the method Credentials.Provided.verify(String) should be used. It does a constant time comparison rather than returning early upon finding the first non-equal character.","title":"Credentials and password timing attacks"},{"location":"/routing-dsl/directives/security-directives/authenticateBasic.html","text":"","title":"authenticateBasic"},{"location":"/routing-dsl/directives/security-directives/authenticateBasic.html#authenticatebasic","text":"Signature type Authenticator[T] = Credentials => Option[T] def authenticateBasic[T](realm: String, authenticator: Authenticator[T]): AuthenticationDirective[T]","title":"authenticateBasic"},{"location":"/routing-dsl/directives/security-directives/authenticateBasic.html#description","text":"Wraps the inner route with Http Basic authentication support using a given Authenticator[T]Authenticator<T> - function from Optional<ProvidedCredentials> to Optional<T>.\nProvides support for handling HTTP Basic Authentication.\nGiven a function returning Some[T]an Optional<T> with a value upon successful authentication and Nonean empty Optional<T> otherwise, respectively applies the inner route or rejects the request with a AuthenticationFailedRejectionAuthenticationFailedRejection rejection, which by default is mapped to an 401 Unauthorized response.\nLonger-running authentication tasks (like looking up credentials in a database) should use the authenticateBasicAsync variant of this directive which allows it to run without blocking routing layer of Apache Pekko HTTP, freeing it for other requests.\nStandard HTTP-based authentication which uses the WWW-Authenticate header containing challenge data and AuthorizationAuthorization header for receiving credentials is implemented in authenticateOrRejectWithChallenge.\nSee Credentials and password timing attacks for details about verifying the secret.\nWarning Make sure to use basic authentication only over SSL/TLS because credentials are transferred in plaintext.","title":"Description"},{"location":"/routing-dsl/directives/security-directives/authenticateBasic.html#example","text":"Scala copysourcedef myUserPassAuthenticator(credentials: Credentials): Option[String] =\n  credentials match {\n    case p @ Credentials.Provided(id) if p.verify(\"p4ssw0rd\") => Some(id)\n    case _                                                    => None\n  }\n\nval route =\n  Route.seal {\n    path(\"secured\") {\n      authenticateBasic(realm = \"secure site\", myUserPassAuthenticator) { userName =>\n        complete(s\"The user is '$userName'\")\n      }\n    }\n  }\n\n// tests:\nGet(\"/secured\") ~> route ~> check {\n  status shouldEqual StatusCodes.Unauthorized\n  responseAs[String] shouldEqual \"The resource requires authentication, which was not supplied with the request\"\n  header[`WWW-Authenticate`].get.challenges.head shouldEqual HttpChallenge(\"Basic\", Some(\"secure site\"),\n    Map(\"charset\" -> \"UTF-8\"))\n}\n\nval validCredentials = BasicHttpCredentials(\"John\", \"p4ssw0rd\")\nGet(\"/secured\") ~> addCredentials(validCredentials) ~> // adds Authorization header\nroute ~> check {\n  responseAs[String] shouldEqual \"The user is 'John'\"\n}\n\nval invalidCredentials = BasicHttpCredentials(\"Peter\", \"pan\")\nGet(\"/secured\") ~>\naddCredentials(invalidCredentials) ~> // adds Authorization header\nroute ~> check {\n  status shouldEqual StatusCodes.Unauthorized\n  responseAs[String] shouldEqual \"The supplied authentication is invalid\"\n  header[`WWW-Authenticate`].get.challenges.head shouldEqual HttpChallenge(\"Basic\", Some(\"secure site\"),\n    Map(\"charset\" -> \"UTF-8\"))\n} Java copysourceimport org.apache.pekko.http.javadsl.server.directives.SecurityDirectives.ProvidedCredentials;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.authenticateBasic;\nimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\n\nfinal Function<Optional<ProvidedCredentials>, Optional<String>> myUserPassAuthenticator =\n  credentials ->\n    credentials.filter(c -> c.verify(\"p4ssw0rd\")).map(ProvidedCredentials::identifier);\n\nfinal Route route = path(\"secured\", () ->\n  authenticateBasic(\"secure site\", myUserPassAuthenticator, userName ->\n    complete(\"The user is '\" + userName + \"'\")\n  )\n).seal();\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/secured\"))\n  .assertStatusCode(StatusCodes.UNAUTHORIZED)\n  .assertEntity(\"The resource requires authentication, which was not supplied with the request\")\n  .assertHeaderExists(\"WWW-Authenticate\", \"Basic realm=\\\"secure site\\\",charset=UTF-8\");\n\nfinal HttpCredentials validCredentials =\n  BasicHttpCredentials.createBasicHttpCredentials(\"John\", \"p4ssw0rd\");\ntestRoute(route).run(HttpRequest.GET(\"/secured\").addCredentials(validCredentials))\n  .assertEntity(\"The user is 'John'\");\n\nfinal HttpCredentials invalidCredentials =\n  BasicHttpCredentials.createBasicHttpCredentials(\"Peter\", \"pan\");\ntestRoute(route).run(HttpRequest.GET(\"/secured\").addCredentials(invalidCredentials))\n  .assertStatusCode(StatusCodes.UNAUTHORIZED)\n  .assertEntity(\"The supplied authentication is invalid\")\n  .assertHeaderExists(\"WWW-Authenticate\", \"Basic realm=\\\"secure site\\\",charset=UTF-8\");","title":"Example"},{"location":"/routing-dsl/directives/security-directives/authenticateBasicAsync.html","text":"","title":"authenticateBasicAsync"},{"location":"/routing-dsl/directives/security-directives/authenticateBasicAsync.html#authenticatebasicasync","text":"Signature type AsyncAuthenticator[T] = Credentials => Future[Option[T]] def authenticateBasicAsync[T](realm: String, authenticator: AsyncAuthenticator[T]): AuthenticationDirective[T]","title":"authenticateBasicAsync"},{"location":"/routing-dsl/directives/security-directives/authenticateBasicAsync.html#description","text":"Wraps the inner route with Http Basic authentication support using a given AsyncAuthenticator[T] AsyncAuthenticator<T> - function from Optional<ProvidedCredentials> to CompletionStage<Optional<T>>.\nThis variant of the authenticateBasic directive returns a Future[Option[T]]CompletionStage<Optional<T>> which allows freeing up the routing layer of Apache Pekko HTTP, freeing it for other requests. It should be used whenever an authentication is expected to take a longer amount of time (e.g. looking up the user in a database).\nIn case the returned option is Nonean empty Optional the request is rejected with a AuthenticationFailedRejectionAuthenticationFailedRejection, which by default is mapped to an 401 Unauthorized response.\nStandard HTTP-based authentication which uses the WWW-Authenticate header containing challenge data and AuthorizationAuthorization header for receiving credentials is implemented in authenticateOrRejectWithChallenge.\nSee Credentials and password timing attacks for details about verifying the secret.\nWarning Make sure to use basic authentication only over SSL/TLS because credentials are transferred in plaintext.","title":"Description"},{"location":"/routing-dsl/directives/security-directives/authenticateBasicAsync.html#example","text":"Scala copysourcedef myUserPassAuthenticator(credentials: Credentials): Future[Option[String]] =\n  credentials match {\n    case p @ Credentials.Provided(id) =>\n      Future {\n        // potentially\n        if (p.verify(\"p4ssw0rd\")) Some(id)\n        else None\n      }\n    case _ => Future.successful(None)\n  }\n\nval route =\n  Route.seal {\n    path(\"secured\") {\n      authenticateBasicAsync(realm = \"secure site\", myUserPassAuthenticator) { userName =>\n        complete(s\"The user is '$userName'\")\n      }\n    }\n  }\n\n// tests:\nGet(\"/secured\") ~> route ~> check {\n  status shouldEqual StatusCodes.Unauthorized\n  responseAs[String] shouldEqual \"The resource requires authentication, which was not supplied with the request\"\n  header[`WWW-Authenticate`].get.challenges.head shouldEqual HttpChallenge(\"Basic\", Some(\"secure site\"),\n    Map(\"charset\" -> \"UTF-8\"))\n}\n\nval validCredentials = BasicHttpCredentials(\"John\", \"p4ssw0rd\")\nGet(\"/secured\") ~> addCredentials(validCredentials) ~> // adds Authorization header\nroute ~> check {\n  responseAs[String] shouldEqual \"The user is 'John'\"\n}\n\nval invalidCredentials = BasicHttpCredentials(\"Peter\", \"pan\")\nGet(\"/secured\") ~>\naddCredentials(invalidCredentials) ~> // adds Authorization header\nroute ~> check {\n  status shouldEqual StatusCodes.Unauthorized\n  responseAs[String] shouldEqual \"The supplied authentication is invalid\"\n  header[`WWW-Authenticate`].get.challenges.head shouldEqual HttpChallenge(\"Basic\", Some(\"secure site\"),\n    Map(\"charset\" -> \"UTF-8\"))\n} Java copysourceimport org.apache.pekko.http.javadsl.server.directives.SecurityDirectives.ProvidedCredentials;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.authenticateBasicAsync;\nimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\n\nfinal Function<Optional<ProvidedCredentials>, CompletionStage<Optional<String>>> myUserPassAuthenticator = opt -> {\n  if (opt.filter(c -> (c != null) && c.verify(\"p4ssw0rd\")).isPresent()) {\n    return CompletableFuture.completedFuture(Optional.of(opt.get().identifier()));\n  } else {\n    return CompletableFuture.completedFuture(Optional.empty());\n  }\n};\n\nfinal Route route = path(\"secured\", () ->\n  authenticateBasicAsync(\"secure site\", myUserPassAuthenticator, userName ->\n    complete(\"The user is '\" + userName + \"'\")\n  )\n).seal();\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/secured\"))\n  .assertStatusCode(StatusCodes.UNAUTHORIZED)\n  .assertEntity(\"The resource requires authentication, which was not supplied with the request\")\n  .assertHeaderExists(\"WWW-Authenticate\", \"Basic realm=\\\"secure site\\\",charset=UTF-8\");\n\nfinal HttpCredentials validCredentials =\n  BasicHttpCredentials.createBasicHttpCredentials(\"John\", \"p4ssw0rd\");\ntestRoute(route).run(HttpRequest.GET(\"/secured\").addCredentials(validCredentials))\n  .assertEntity(\"The user is 'John'\");\n\nfinal HttpCredentials invalidCredentials =\n  BasicHttpCredentials.createBasicHttpCredentials(\"Peter\", \"pan\");\ntestRoute(route).run(HttpRequest.GET(\"/secured\").addCredentials(invalidCredentials))\n  .assertStatusCode(StatusCodes.UNAUTHORIZED)\n  .assertEntity(\"The supplied authentication is invalid\")\n  .assertHeaderExists(\"WWW-Authenticate\", \"Basic realm=\\\"secure site\\\",charset=UTF-8\");","title":"Example"},{"location":"/routing-dsl/directives/security-directives/authenticateBasicPF.html","text":"","title":"authenticateBasicPF"},{"location":"/routing-dsl/directives/security-directives/authenticateBasicPF.html#authenticatebasicpf","text":"Signature type AuthenticatorPF[T] = PartialFunction[Credentials, T] def authenticateBasicPF[T](realm: String, authenticator: AuthenticatorPF[T]): AuthenticationDirective[T]","title":"authenticateBasicPF"},{"location":"/routing-dsl/directives/security-directives/authenticateBasicPF.html#description","text":"Wraps the inner route with Http Basic authentication support using a given AuthenticatorPF[T]AuthenticatorPF<T> - Partial function from Optional<ProvidedCredentials> to String.\nProvides support for handling HTTP Basic Authentication.\nRefer to authenticateBasic for a detailed description of this directive.\nIts semantics are equivalent to authenticateBasicPF ’s, where not handling a case in the Partial Function (PF) leaves the request to be rejected with a AuthenticationFailedRejectionAuthenticationFailedRejection rejection.\nLonger-running authentication tasks (like looking up credentials in a database) should use authenticateBasicAsync or authenticateBasicPFAsync if you prefer to use the PartialFunction syntax.\nSee Credentials and password timing attacks for details about verifying the secret.\nWarning Make sure to use basic authentication only over SSL/TLS because credentials are transferred in plaintext.","title":"Description"},{"location":"/routing-dsl/directives/security-directives/authenticateBasicPF.html#example","text":"Scala copysourceval myUserPassAuthenticator: AuthenticatorPF[String] = {\n  case p @ Credentials.Provided(id) if p.verify(\"p4ssw0rd\")         => id\n  case p @ Credentials.Provided(id) if p.verify(\"p4ssw0rd-special\") => s\"$id-admin\"\n}\n\nval route =\n  Route.seal {\n    path(\"secured\") {\n      authenticateBasicPF(realm = \"secure site\", myUserPassAuthenticator) { userName =>\n        complete(s\"The user is '$userName'\")\n      }\n    }\n  }\n\n// tests:\nGet(\"/secured\") ~> route ~> check {\n  status shouldEqual StatusCodes.Unauthorized\n  responseAs[String] shouldEqual \"The resource requires authentication, which was not supplied with the request\"\n  header[`WWW-Authenticate`].get.challenges.head shouldEqual HttpChallenge(\"Basic\", Some(\"secure site\"),\n    Map(\"charset\" -> \"UTF-8\"))\n}\n\nval validCredentials = BasicHttpCredentials(\"John\", \"p4ssw0rd\")\nGet(\"/secured\") ~> addCredentials(validCredentials) ~> // adds Authorization header\nroute ~> check {\n  responseAs[String] shouldEqual \"The user is 'John'\"\n}\n\nval validAdminCredentials = BasicHttpCredentials(\"John\", \"p4ssw0rd-special\")\nGet(\"/secured\") ~> addCredentials(validAdminCredentials) ~> // adds Authorization header\nroute ~> check {\n  responseAs[String] shouldEqual \"The user is 'John-admin'\"\n}\n\nval invalidCredentials = BasicHttpCredentials(\"Peter\", \"pan\")\nGet(\"/secured\") ~>\naddCredentials(invalidCredentials) ~> // adds Authorization header\nroute ~> check {\n  status shouldEqual StatusCodes.Unauthorized\n  responseAs[String] shouldEqual \"The supplied authentication is invalid\"\n  header[`WWW-Authenticate`].get.challenges.head shouldEqual HttpChallenge(\"Basic\", Some(\"secure site\"),\n    Map(\"charset\" -> \"UTF-8\"))\n} Java copysourceimport org.apache.pekko.http.javadsl.server.directives.SecurityDirectives.ProvidedCredentials;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.authenticateBasicPF;\nimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\n\nfinal PartialFunction<Optional<ProvidedCredentials>, String> myUserPassAuthenticator =\n  new JavaPartialFunction<Optional<ProvidedCredentials>, String>() {\n    @Override\n    public String apply(Optional<ProvidedCredentials> opt, boolean isCheck) throws Exception {\n      if (opt.filter(c -> (c != null) && c.verify(\"p4ssw0rd\")).isPresent()) {\n        if (isCheck) return null;\n        else return opt.get().identifier();\n      } else if (opt.filter(c -> (c != null) && c.verify(\"p4ssw0rd-special\")).isPresent()) {\n        if (isCheck) return null;\n        else return opt.get().identifier() + \"-admin\";\n      } else {\n        throw noMatch();\n      }\n    }\n  };\n\nfinal Route route = path(\"secured\", () ->\n  authenticateBasicPF(\"secure site\", myUserPassAuthenticator, userName ->\n    complete(\"The user is '\" + userName + \"'\")\n  )\n).seal();\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/secured\"))\n  .assertStatusCode(StatusCodes.UNAUTHORIZED)\n  .assertEntity(\"The resource requires authentication, which was not supplied with the request\")\n  .assertHeaderExists(\"WWW-Authenticate\", \"Basic realm=\\\"secure site\\\",charset=UTF-8\");\n\nfinal HttpCredentials validCredentials =\n  BasicHttpCredentials.createBasicHttpCredentials(\"John\", \"p4ssw0rd\");\ntestRoute(route).run(HttpRequest.GET(\"/secured\").addCredentials(validCredentials))\n  .assertEntity(\"The user is 'John'\");\n\nfinal HttpCredentials validAdminCredentials =\n  BasicHttpCredentials.createBasicHttpCredentials(\"John\", \"p4ssw0rd-special\");\ntestRoute(route).run(HttpRequest.GET(\"/secured\").addCredentials(validAdminCredentials))\n  .assertEntity(\"The user is 'John-admin'\");\n\nfinal HttpCredentials invalidCredentials =\n  BasicHttpCredentials.createBasicHttpCredentials(\"Peter\", \"pan\");\ntestRoute(route).run(HttpRequest.GET(\"/secured\").addCredentials(invalidCredentials))\n  .assertStatusCode(StatusCodes.UNAUTHORIZED)\n  .assertEntity(\"The supplied authentication is invalid\")\n  .assertHeaderExists(\"WWW-Authenticate\", \"Basic realm=\\\"secure site\\\",charset=UTF-8\");","title":"Example"},{"location":"/routing-dsl/directives/security-directives/authenticateBasicPFAsync.html","text":"","title":"authenticateBasicPFAsync"},{"location":"/routing-dsl/directives/security-directives/authenticateBasicPFAsync.html#authenticatebasicpfasync","text":"Signature type AsyncAuthenticatorPF[T] = PartialFunction[Credentials, Future[T]] def authenticateBasicPFAsync[T](realm: String, authenticator: AsyncAuthenticatorPF[T]): AuthenticationDirective[T]","title":"authenticateBasicPFAsync"},{"location":"/routing-dsl/directives/security-directives/authenticateBasicPFAsync.html#description","text":"Wraps the inner route with Http Basic authentication support using a given AsyncAuthenticatorPF[T]AsyncAuthenticatorPF<T> - Partial function from Optional<ProvidedCredentials> to CompletionStage<User>.\nProvides support for handling HTTP Basic Authentication.\nRefer to authenticateBasic for a detailed description of this directive.\nIts semantics are equivalent to authenticateBasicPF ’s, where not handling a case in the Partial Function (PF) leaves the request to be rejected with a AuthenticationFailedRejectionAuthenticationFailedRejection rejection.\nSee Credentials and password timing attacks for details about verifying the secret.\nWarning Make sure to use basic authentication only over SSL/TLS because credentials are transferred in plaintext.","title":"Description"},{"location":"/routing-dsl/directives/security-directives/authenticateBasicPFAsync.html#example","text":"Scala copysourcecase class User(id: String)\ndef fetchUser(id: String): Future[User] = {\n  // some fancy logic to obtain a User\n  Future.successful(User(id))\n}\n\nval myUserPassAuthenticator: AsyncAuthenticatorPF[User] = {\n  case p @ Credentials.Provided(id) if p.verify(\"p4ssw0rd\") =>\n    fetchUser(id)\n}\n\nval route =\n  Route.seal {\n    path(\"secured\") {\n      authenticateBasicPFAsync(realm = \"secure site\", myUserPassAuthenticator) { user =>\n        complete(s\"The user is '${user.id}'\")\n      }\n    }\n  }\n\n// tests:\nGet(\"/secured\") ~> route ~> check {\n  status shouldEqual StatusCodes.Unauthorized\n  responseAs[String] shouldEqual \"The resource requires authentication, which was not supplied with the request\"\n  header[`WWW-Authenticate`].get.challenges.head shouldEqual HttpChallenge(\"Basic\", Some(\"secure site\"),\n    Map(\"charset\" -> \"UTF-8\"))\n}\n\nval validCredentials = BasicHttpCredentials(\"John\", \"p4ssw0rd\")\nGet(\"/secured\") ~> addCredentials(validCredentials) ~> // adds Authorization header\nroute ~> check {\n  responseAs[String] shouldEqual \"The user is 'John'\"\n}\n\nval invalidCredentials = BasicHttpCredentials(\"Peter\", \"pan\")\nGet(\"/secured\") ~>\naddCredentials(invalidCredentials) ~> // adds Authorization header\nroute ~> check {\n  status shouldEqual StatusCodes.Unauthorized\n  responseAs[String] shouldEqual \"The supplied authentication is invalid\"\n  header[`WWW-Authenticate`].get.challenges.head shouldEqual HttpChallenge(\"Basic\", Some(\"secure site\"),\n    Map(\"charset\" -> \"UTF-8\"))\n} Java copysourceimport org.apache.pekko.http.javadsl.server.directives.SecurityDirectives.ProvidedCredentials;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.authenticateBasicPFAsync;\nimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\n\nclass User {\n  private final String id;\n  public User(String id) {\n    this.id = id;\n  }\n  public String getId() {\n    return id;\n  }\n}\n\nfinal PartialFunction<Optional<ProvidedCredentials>, CompletionStage<User>> myUserPassAuthenticator =\n  new JavaPartialFunction<Optional<ProvidedCredentials>,CompletionStage<User>>() {\n    @Override\n    public CompletionStage<User> apply(Optional<ProvidedCredentials> opt, boolean isCheck) throws Exception {\n      if (opt.filter(c -> (c != null) && c.verify(\"p4ssw0rd\")).isPresent()) {\n        if (isCheck) return CompletableFuture.completedFuture(null);\n        else return CompletableFuture.completedFuture(new User(opt.get().identifier()));\n      } else {\n        throw noMatch();\n      }\n    }\n  };\n\nfinal Route route = path(\"secured\", () ->\n  authenticateBasicPFAsync(\"secure site\", myUserPassAuthenticator, user ->\n    complete(\"The user is '\" + user.getId() + \"'\"))\n).seal();\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/secured\"))\n  .assertStatusCode(StatusCodes.UNAUTHORIZED)\n  .assertEntity(\"The resource requires authentication, which was not supplied with the request\")\n  .assertHeaderExists(\"WWW-Authenticate\", \"Basic realm=\\\"secure site\\\",charset=UTF-8\");\n\nfinal HttpCredentials validCredentials =\n  BasicHttpCredentials.createBasicHttpCredentials(\"John\", \"p4ssw0rd\");\ntestRoute(route).run(HttpRequest.GET(\"/secured\").addCredentials(validCredentials))\n  .assertEntity(\"The user is 'John'\");\n\nfinal HttpCredentials invalidCredentials =\n  BasicHttpCredentials.createBasicHttpCredentials(\"Peter\", \"pan\");\ntestRoute(route).run(HttpRequest.GET(\"/secured\").addCredentials(invalidCredentials))\n  .assertStatusCode(StatusCodes.UNAUTHORIZED)\n  .assertEntity(\"The supplied authentication is invalid\")\n  .assertHeaderExists(\"WWW-Authenticate\", \"Basic realm=\\\"secure site\\\",charset=UTF-8\");","title":"Example"},{"location":"/routing-dsl/directives/security-directives/authenticateOrRejectWithChallenge.html","text":"","title":"authenticateOrRejectWithChallenge"},{"location":"/routing-dsl/directives/security-directives/authenticateOrRejectWithChallenge.html#authenticateorrejectwithchallenge","text":"Signature type AuthenticationResult[+T] = Either[HttpChallenge, T] def authenticateOrRejectWithChallenge[T]( authenticator: Option[HttpCredentials] \ndef authenticateOrRejectWithChallenge[C <: HttpCredentials: ClassTag, T]( authenticator: Option[C]","title":"authenticateOrRejectWithChallenge"},{"location":"/routing-dsl/directives/security-directives/authenticateOrRejectWithChallenge.html#description","text":"Lifts an authenticator function into a directive.\nThis directive allows implementing the low level challenge-response type of authentication that some services may require.\nMore details about challenge-response authentication are available in the RFC 2617, RFC 7616 and RFC 7617.","title":"Description"},{"location":"/routing-dsl/directives/security-directives/authenticateOrRejectWithChallenge.html#example","text":"Scala copysourceval challenge = HttpChallenge(\"MyAuth\", Some(\"MyRealm\"))\n\n// your custom authentication logic:\ndef auth(creds: HttpCredentials): Boolean = true\n\ndef myUserPassAuthenticator(credentials: Option[HttpCredentials]): Future[AuthenticationResult[String]] =\n  Future {\n    credentials match {\n      case Some(creds) if auth(creds) => Right(\"some-user-name-from-creds\")\n      case _                          => Left(challenge)\n    }\n  }\n\nval route =\n  Route.seal {\n    path(\"secured\") {\n      authenticateOrRejectWithChallenge(myUserPassAuthenticator _) { userName =>\n        complete(\"Authenticated!\")\n      }\n    }\n  }\n\n// tests:\nGet(\"/secured\") ~> route ~> check {\n  status shouldEqual StatusCodes.Unauthorized\n  responseAs[String] shouldEqual \"The resource requires authentication, which was not supplied with the request\"\n  header[`WWW-Authenticate`].get.challenges.head shouldEqual HttpChallenge(\"MyAuth\", Some(\"MyRealm\"))\n}\n\nval validCredentials = BasicHttpCredentials(\"John\", \"p4ssw0rd\")\nGet(\"/secured\") ~> addCredentials(validCredentials) ~> // adds Authorization header\nroute ~> check {\n  status shouldEqual StatusCodes.OK\n  responseAs[String] shouldEqual \"Authenticated!\"\n} Java copysourceimport org.apache.pekko.http.javadsl.model.headers.HttpChallenge;\nimport org.apache.pekko.http.javadsl.model.headers.HttpCredentials;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.authenticateOrRejectWithChallenge;\nimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\n\nfinal HttpChallenge challenge = HttpChallenge.create(\"MyAuth\", new Option.Some<>(\"MyRealm\"));\n\n// your custom authentication logic:\nfinal Function<HttpCredentials, Boolean> auth = credentials -> true;\n\nfinal Function<Optional<HttpCredentials>, CompletionStage<Either<HttpChallenge, String>>> myUserPassAuthenticator =\n  opt -> {\n    if (opt.isPresent() && auth.apply(opt.get())) {\n      return CompletableFuture.completedFuture(Right.apply(\"some-user-name-from-creds\"));\n    } else {\n      return CompletableFuture.completedFuture(Left.apply(challenge));\n    }\n  };\n\nfinal Route route = path(\"secured\", () ->\n  authenticateOrRejectWithChallenge(myUserPassAuthenticator, userName ->\n    complete(\"Authenticated!\")\n  )\n).seal();\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/secured\"))\n  .assertStatusCode(StatusCodes.UNAUTHORIZED)\n  .assertEntity(\"The resource requires authentication, which was not supplied with the request\")\n  .assertHeaderExists(\"WWW-Authenticate\", \"MyAuth realm=\\\"MyRealm\\\"\");\n\nfinal HttpCredentials validCredentials =\n  BasicHttpCredentials.createBasicHttpCredentials(\"John\", \"p4ssw0rd\");\ntestRoute(route).run(HttpRequest.GET(\"/secured\").addCredentials(validCredentials))\n  .assertStatusCode(StatusCodes.OK)\n  .assertEntity(\"Authenticated!\");","title":"Example"},{"location":"/routing-dsl/directives/security-directives/authenticateOAuth2.html","text":"","title":"authenticateOAuth2"},{"location":"/routing-dsl/directives/security-directives/authenticateOAuth2.html#authenticateoauth2","text":"Signature type Authenticator[T] = Credentials => Option[T] def authenticateOAuth2[T](realm: String, authenticator: Authenticator[T]): AuthenticationDirective[T]","title":"authenticateOAuth2"},{"location":"/routing-dsl/directives/security-directives/authenticateOAuth2.html#description","text":"Wraps the inner route with OAuth Bearer Token authentication support using a given Authenticator[T]Authenticator<T> - function from Optional<ProvidedCredentials> to Optional<T>.\nProvides support for extracting the so-called “Bearer Token” from the AuthorizationAuthorization HTTP Header, which is used to initiate an OAuth2 authorization. The directive also supports extracting the Bearer Token from URI query parameter access_token, as described in RFC 6750.\nWarning This directive does not implement the complete OAuth2 protocol, but instead enables implementing it, by extracting the needed token from the HTTP headers.\nGiven a function returning Some[T]a non emptyOptional<T> upon successful authentication and Nonean empty Optional<T> otherwise, respectively applies the inner route or rejects the request with a AuthenticationFailedRejectionAuthenticationFailedRejection rejection, which by default is mapped to an 401 Unauthorized response.\nLonger-running authentication tasks (like looking up credentials in a database) should use the authenticateOAuth2Async variant of this directive which allows it to run without blocking routing layer of Apache Pekko HTTP, freeing it for other requests.\nSee Credentials and password timing attacks for details about verifying the secret.\nFor more information on how OAuth2 works see RFC 6750.","title":"Description"},{"location":"/routing-dsl/directives/security-directives/authenticateOAuth2.html#example","text":"Usage in code is exactly the same as authenticateBasic, with the difference that one must validate the token as OAuth2 dictates (which is currently not part of Apache Pekko HTTP itself).","title":"Example"},{"location":"/routing-dsl/directives/security-directives/authenticateOAuth2Async.html","text":"","title":"authenticateOAuth2Async"},{"location":"/routing-dsl/directives/security-directives/authenticateOAuth2Async.html#authenticateoauth2async","text":"Signature type AsyncAuthenticator[T] = Credentials => Future[Option[T]] def authenticateOAuth2Async[T](realm: String, authenticator: AsyncAuthenticator[T]): AuthenticationDirective[T]","title":"authenticateOAuth2Async"},{"location":"/routing-dsl/directives/security-directives/authenticateOAuth2Async.html#description","text":"Wraps the inner route with OAuth Bearer Token authentication support using a given AsyncAuthenticator[T] AsyncAuthenticator<T> - function from Optional<ProvidedCredentials> to CompletionStage<Optional<T>>.\nProvides support for extracting the so-called “Bearer Token” from the AuthorizationAuthorization HTTP Header, which is used to initiate an OAuth2 authorization.\nWarning This directive does not implement the complete OAuth2 protocol, but instead enables implementing it, by extracting the needed token from the HTTP headers.\nGiven a function returning Some[T]a non empty Optional<T> upon successful authentication and Nonean empty Optional<T> otherwise, respectively applies the inner route or rejects the request with a AuthenticationFailedRejectionAuthenticationFailedRejection rejection, which by default is mapped to an 401 Unauthorized response.\nSee also authenticateOAuth2 if the authorization operation is rather quick, and does not have to execute asynchronously.\nSee Credentials and password timing attacks for details about verifying the secret.\nFor more information on how OAuth2 works see RFC 6750.","title":"Description"},{"location":"/routing-dsl/directives/security-directives/authenticateOAuth2Async.html#example","text":"Usage in code is exactly the same as authenticateBasicAsync, with the difference that one must validate the token as OAuth2 dictates (which is currently not part of Apache Pekko HTTP itself).","title":"Example"},{"location":"/routing-dsl/directives/security-directives/authenticateOAuth2PF.html","text":"","title":"authenticateOAuth2PF"},{"location":"/routing-dsl/directives/security-directives/authenticateOAuth2PF.html#authenticateoauth2pf","text":"Signature type AuthenticatorPF[T] = PartialFunction[Credentials, T] def authenticateOAuth2PF[T](realm: String, authenticator: AuthenticatorPF[T]): AuthenticationDirective[T]","title":"authenticateOAuth2PF"},{"location":"/routing-dsl/directives/security-directives/authenticateOAuth2PF.html#description","text":"Wraps the inner route with OAuth Bearer Token authentication support using a given AuthenticatorPF[T]AuthenticatorPF<T> - Partial function from Optional<ProvidedCredentials> to String.\nProvides support for extracting the so-called “Bearer Token” from the AuthorizationAuthorization HTTP Header, which is used to initiate an OAuth2 authorization.\nWarning This directive does not implement the complete OAuth2 protocol, but instead enables implementing it, by extracting the needed token from the HTTP headers.\nRefer to authenticateOAuth2 for a detailed description of this directive.\nIts semantics are equivalent to authenticateOAuth2PF ’s, where not handling a case in the Partial Function (PF) leaves the request to be rejected with a AuthenticationFailedRejectionAuthenticationFailedRejection rejection.\nLonger-running authentication tasks (like looking up credentials in a database) should use the authenticateOAuth2Async variant of this directive which allows it to run without blocking routing layer of Apache Pekko HTTP, freeing it for other requests.\nSee Credentials and password timing attacks for details about verifying the secret.\nFor more information on how OAuth2 works see RFC 6750.","title":"Description"},{"location":"/routing-dsl/directives/security-directives/authenticateOAuth2PF.html#example","text":"Usage in code is exactly the same as authenticateBasicPF, with the difference that one must validate the token as OAuth2 dictates (which is currently not part of Apache Pekko HTTP itself).","title":"Example"},{"location":"/routing-dsl/directives/security-directives/authenticateOAuth2PFAsync.html","text":"","title":"authenticateOAuth2PFAsync"},{"location":"/routing-dsl/directives/security-directives/authenticateOAuth2PFAsync.html#authenticateoauth2pfasync","text":"Signature type AsyncAuthenticatorPF[T] = PartialFunction[Credentials, Future[T]] def authenticateOAuth2PFAsync[T](realm: String, authenticator: AsyncAuthenticatorPF[T]): AuthenticationDirective[T]","title":"authenticateOAuth2PFAsync"},{"location":"/routing-dsl/directives/security-directives/authenticateOAuth2PFAsync.html#description","text":"Wraps the inner route with OAuth Bearer Token authentication support using a given AsyncAuthenticatorPF[T]AsyncAuthenticatorPF<T> - Partial function from Optional<ProvidedCredentials> to CompletionStage<User>.\nProvides support for extracting the so-called “Bearer Token” from the AuthorizationAuthorization HTTP Header, which is used to initiate an OAuth2 authorization.\nWarning This directive does not implement the complete OAuth2 protocol, but instead enables implementing it, by extracting the needed token from the HTTP headers.\nRefer to authenticateOAuth2 for a detailed description of this directive.\nIts semantics are equivalent to authenticateOAuth2PF ’s, where not handling a case in the Partial Function (PF) leaves the request to be rejected with a AuthenticationFailedRejectionAuthenticationFailedRejection rejection.\nSee also authenticateOAuth2PF if the authorization operation is rather quick, and does not have to execute asynchronously.\nSee Credentials and password timing attacks for details about verifying the secret.\nFor more information on how OAuth2 works see RFC 6750.","title":"Description"},{"location":"/routing-dsl/directives/security-directives/authenticateOAuth2PFAsync.html#example","text":"Usage in code is exactly the same as authenticateBasicPFAsync, with the difference that one must validate the token as OAuth2 dictates (which is currently not part of Apache Pekko HTTP itself).","title":"Example"},{"location":"/routing-dsl/directives/security-directives/authorize.html","text":"","title":"authorize"},{"location":"/routing-dsl/directives/security-directives/authorize.html#authorize","text":"Applies the given authorization check to the request.\nSignature def authorize(check: \ndef authorize(check: RequestContext","title":"authorize"},{"location":"/routing-dsl/directives/security-directives/authorize.html#description","text":"The user-defined authorization check can either be supplied as a => BooleanSupplier<Boolean> value which is calculated just from information out of the lexical scope, or as a function RequestContext => BooleanFunction[RequestContext, Boolean] which can also take information from the request itself into account.\nIf the check returns true the request is passed on to the inner route unchanged, otherwise an AuthorizationFailedRejectionAuthorizationFailedRejection is created, triggering a 403 Forbidden response by default (the same as in the case of an AuthenticationFailedRejectionAuthenticationFailedRejection).\nIn a common use-case you would check if a user (e.g. supplied by any of the authenticate* family of directives, e.g. authenticateBasic) is allowed to access the inner routes, e.g. by checking if the user has the needed permissions.\nSee also authorizeAsync for the asynchronous version of this directive.\nNote See also Authentication vs. Authorization to understand the differences between those.","title":"Description"},{"location":"/routing-dsl/directives/security-directives/authorize.html#example","text":"Scala copysourcecase class User(name: String)\n\n// authenticate the user:\ndef myUserPassAuthenticator(credentials: Credentials): Option[User] =\n  credentials match {\n    case Credentials.Provided(id) => Some(User(id))\n    case _                        => None\n  }\n\n// check if user is authorized to perform admin actions:\nval admins = Set(\"Peter\")\ndef hasAdminPermissions(user: User): Boolean =\n  admins.contains(user.name)\n\nval route =\n  Route.seal {\n    authenticateBasic(realm = \"secure site\", myUserPassAuthenticator) { user =>\n      path(\"peters-lair\") {\n        authorize(hasAdminPermissions(user)) {\n          complete(s\"'${user.name}' visited Peter's lair\")\n        }\n      }\n    }\n  }\n\n// tests:\nval johnsCred = BasicHttpCredentials(\"John\", \"p4ssw0rd\")\nGet(\"/peters-lair\") ~> addCredentials(johnsCred) ~> // adds Authorization header\nroute ~> check {\n  status shouldEqual StatusCodes.Forbidden\n  responseAs[String] shouldEqual \"The supplied authentication is not authorized to access this resource\"\n}\n\nval petersCred = BasicHttpCredentials(\"Peter\", \"pan\")\nGet(\"/peters-lair\") ~> addCredentials(petersCred) ~> // adds Authorization header\nroute ~> check {\n  responseAs[String] shouldEqual \"'Peter' visited Peter's lair\"\n} Java copysourceimport org.apache.pekko.http.javadsl.server.directives.SecurityDirectives.ProvidedCredentials;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.authorize;\nimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\nclass User {\n  private final String name;\n  public User(String name) {\n    this.name = name;\n  }\n  public String getName() {\n    return name;\n  }\n}\n\n// authenticate the user:\nfinal Function<Optional<ProvidedCredentials>, Optional<User>> myUserPassAuthenticator =\n  opt -> {\n    if (opt.isPresent()) {\n      return Optional.of(new User(opt.get().identifier()));\n    } else {\n      return Optional.empty();\n    }\n  };\n\n// check if user is authorized to perform admin actions:\nfinal Set<String> admins = new HashSet<>();\nadmins.add(\"Peter\");\nfinal Function<User, Boolean> hasAdminPermissions = user -> admins.contains(user.getName());\n\nfinal Route route = authenticateBasic(\"secure site\", myUserPassAuthenticator, user ->\n  path(\"peters-lair\", () ->\n    authorize(() -> hasAdminPermissions.apply(user), () ->\n      complete(\"'\" + user.getName() +\"' visited Peter's lair\")\n    )\n  )\n).seal();\n\n// tests:\nfinal HttpCredentials johnsCred =\n  BasicHttpCredentials.createBasicHttpCredentials(\"John\", \"p4ssw0rd\");\ntestRoute(route).run(HttpRequest.GET(\"/peters-lair\").addCredentials(johnsCred))\n  .assertStatusCode(StatusCodes.FORBIDDEN)\n  .assertEntity(\"The supplied authentication is not authorized to access this resource\");\n\nfinal HttpCredentials petersCred =\n  BasicHttpCredentials.createBasicHttpCredentials(\"Peter\", \"pan\");\ntestRoute(route).run(HttpRequest.GET(\"/peters-lair\").addCredentials(petersCred))\n  .assertEntity(\"'Peter' visited Peter's lair\");","title":"Example"},{"location":"/routing-dsl/directives/security-directives/authorizeAsync.html","text":"","title":"authorizeAsync"},{"location":"/routing-dsl/directives/security-directives/authorizeAsync.html#authorizeasync","text":"Applies the given authorization check to the request.\nSignature def authorizeAsync(check: \ndef authorizeAsync(check: RequestContext","title":"authorizeAsync"},{"location":"/routing-dsl/directives/security-directives/authorizeAsync.html#description","text":"The user-defined authorization check can either be supplied as a => Future[Boolean]Supplier<CompletionStage<Boolean>> value which is calculated just from information out of the lexical scope, or as a function RequestContext => Future[Boolean]Function<RequestContext,CompletionStage<Boolean>> which can also take information from the request itself into account.\nIf the check returns true, the request is passed on to the inner route unchanged; if it returns false or the FutureCompletionStage is failed, an AuthorizationFailedRejectionAuthorizationFailedRejection is created, triggering a 403 Forbidden response by default (the same as in the case of an AuthenticationFailedRejectionAuthenticationFailedRejection).\nIn a common use-case you would check if a user (e.g. supplied by any of the authenticate* family of directives, e.g. authenticateBasic) is allowed to access the inner routes, e.g. by checking if the user has the needed permissions.\nSee also authorize for the synchronous version of this directive.\nNote See also Authentication vs. Authorization to understand the differences between those.","title":"Description"},{"location":"/routing-dsl/directives/security-directives/authorizeAsync.html#example","text":"Scala copysourcecase class User(name: String)\n\n// authenticate the user:\ndef myUserPassAuthenticator(credentials: Credentials): Option[User] =\n  credentials match {\n    case Credentials.Provided(id) => Some(User(id))\n    case _                        => None\n  }\n\n// check if user is authorized to perform admin actions,\n// this could potentially be a long operation so it would return a Future\nval admins = Set(\"Peter\")\ndef hasAdminPermissions(user: User): Future[Boolean] =\n  Future.successful(admins.contains(user.name))\n\nval route =\n  Route.seal {\n    authenticateBasic(realm = \"secure site\", myUserPassAuthenticator) { user =>\n      path(\"peters-lair\") {\n        authorizeAsync(_ => hasAdminPermissions(user)) {\n          complete(s\"'${user.name}' visited Peter's lair\")\n        }\n      }\n    }\n  }\n\n// tests:\nval johnsCred = BasicHttpCredentials(\"John\", \"p4ssw0rd\")\nGet(\"/peters-lair\") ~> addCredentials(johnsCred) ~> // adds Authorization header\nroute ~> check {\n  status shouldEqual StatusCodes.Forbidden\n  responseAs[String] shouldEqual \"The supplied authentication is not authorized to access this resource\"\n}\n\nval petersCred = BasicHttpCredentials(\"Peter\", \"pan\")\nGet(\"/peters-lair\") ~> addCredentials(petersCred) ~> // adds Authorization header\nroute ~> check {\n  responseAs[String] shouldEqual \"'Peter' visited Peter's lair\"\n} Java copysourceimport org.apache.pekko.http.javadsl.server.directives.SecurityDirectives.ProvidedCredentials;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.authorizeAsync;\nimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\nclass User {\n  private final String name;\n  public User(String name) {\n    this.name = name;\n  }\n  public String getName() {\n    return name;\n  }\n}\n\n// authenticate the user:\nfinal Function<Optional<ProvidedCredentials>, Optional<User>> myUserPassAuthenticator =\n  opt -> {\n    if (opt.isPresent()) {\n      return Optional.of(new User(opt.get().identifier()));\n    } else {\n      return Optional.empty();\n    }\n  };\n\n// check if user is authorized to perform admin actions,\n// this could potentially be a long operation so it would return a Future\nfinal Set<String> admins = new HashSet<>();\nadmins.add(\"Peter\");\nfinal Set<String> synchronizedAdmins = Collections.synchronizedSet(admins);\n\nfinal Function<User, CompletionStage<Object>> hasAdminPermissions =\n  user -> CompletableFuture.completedFuture(synchronizedAdmins.contains(user.getName()));\n\nfinal Route route = authenticateBasic(\"secure site\", myUserPassAuthenticator, user ->\n  path(\"peters-lair\", () ->\n    authorizeAsync(() -> hasAdminPermissions.apply(user), () ->\n      complete(\"'\" + user.getName() +\"' visited Peter's lair\")\n    )\n  )\n).seal();\n\n// tests:\nfinal HttpCredentials johnsCred =\n  BasicHttpCredentials.createBasicHttpCredentials(\"John\", \"p4ssw0rd\");\ntestRoute(route).run(HttpRequest.GET(\"/peters-lair\").addCredentials(johnsCred))\n  .assertStatusCode(StatusCodes.FORBIDDEN)\n  .assertEntity(\"The supplied authentication is not authorized to access this resource\");\n\nfinal HttpCredentials petersCred =\n  BasicHttpCredentials.createBasicHttpCredentials(\"Peter\", \"pan\");\ntestRoute(route).run(HttpRequest.GET(\"/peters-lair\").addCredentials(petersCred))\n  .assertEntity(\"'Peter' visited Peter's lair\");","title":"Example"},{"location":"/routing-dsl/directives/security-directives/extractCredentials.html","text":"","title":"extractCredentials"},{"location":"/routing-dsl/directives/security-directives/extractCredentials.html#extractcredentials","text":"Signature def extractCredentials: Directive1[Option[HttpCredentials]]","title":"extractCredentials"},{"location":"/routing-dsl/directives/security-directives/extractCredentials.html#description","text":"Extracts the potentially present HttpCredentialsHttpCredentials provided with the request’s AuthorizationAuthorization header, which can be then used to implement some custom authentication or authorization logic.\nSee Credentials and password timing attacks for details about verifying the secret.","title":"Description"},{"location":"/routing-dsl/directives/security-directives/extractCredentials.html#example","text":"Scala copysourceval route =\n  extractCredentials { creds =>\n    complete {\n      creds match {\n        case Some(c) => \"Credentials: \" + c\n        case _       => \"No credentials\"\n      }\n    }\n  }\n\n// tests:\nval johnsCred = BasicHttpCredentials(\"John\", \"p4ssw0rd\")\nGet(\"/\") ~> addCredentials(johnsCred) ~> // adds Authorization header\nroute ~> check {\n  responseAs[String] shouldEqual \"Credentials: Basic Sm9objpwNHNzdzByZA==\"\n}\n\nGet(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"No credentials\"\n} Java copysourceimport org.apache.pekko.http.javadsl.model.headers.HttpCredentials;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.extractCredentials;\n\nfinal Route route = extractCredentials(optCreds -> {\n  if (optCreds.isPresent()) {\n    return complete(\"Credentials: \" + optCreds.get());\n  } else {\n    return complete(\"No credentials\");\n  }\n});\n\n// tests:\nfinal HttpCredentials johnsCred =\n  BasicHttpCredentials.createBasicHttpCredentials(\"John\", \"p4ssw0rd\");\ntestRoute(route).run(HttpRequest.GET(\"/\").addCredentials(johnsCred))\n  .assertEntity(\"Credentials: Basic Sm9objpwNHNzdzByZA==\");\n\ntestRoute(route).run(HttpRequest.GET(\"/\"))\n  .assertEntity(\"No credentials\");","title":"Example"},{"location":"/routing-dsl/directives/websocket-directives/index.html","text":"","title":"WebSocketDirectives"},{"location":"/routing-dsl/directives/websocket-directives/index.html#websocketdirectives","text":"extractOfferedWsProtocols extractUpgradeToWebSocket extractWebSocketUpgrade handleWebSocketMessages handleWebSocketMessagesForOptionalProtocol handleWebSocketMessagesForProtocol","title":"WebSocketDirectives"},{"location":"/routing-dsl/directives/websocket-directives/extractOfferedWsProtocols.html","text":"","title":"extractOfferedWsProtocols"},{"location":"/routing-dsl/directives/websocket-directives/extractOfferedWsProtocols.html#extractofferedwsprotocols","text":"Signature def extractOfferedWsProtocols: Directive1[immutable.Seq[String]]","title":"extractOfferedWsProtocols"},{"location":"/routing-dsl/directives/websocket-directives/extractOfferedWsProtocols.html#description","text":"Extracts the list of WebSocket subprotocols as offered by the client in the Sec-WebSocket-Protocol header if this is a WebSocket request. Rejects with an ExpectedWebSocketRequestRejectionExpectedWebSocketRequestRejection, otherwise.\nThe extractOfferedWsProtocols directive is used as a building block for Custom Directives to provide the extracted protocols to the inner route.","title":"Description"},{"location":"/routing-dsl/directives/websocket-directives/extractOfferedWsProtocols.html#example","text":"Scala copysourcedef echoService: Flow[Message, Message, Any] =\n  Flow[Message]\n    // needed because a noop flow hasn't any buffer that would start processing in tests\n    .buffer(1, OverflowStrategy.backpressure)\n\ndef route =\n  path(\"services\") {\n    extractOfferedWsProtocols { protocols =>\n      handleWebSocketMessagesForOptionalProtocol(echoService, protocols.headOption)\n    }\n  }\n\n// tests:\nval wsClient = WSProbe()\n\n// WS creates a WebSocket request for testing\nWS(\"/services\", wsClient.flow, List(\"echo\", \"alfa\", \"kilo\")) ~> route ~> check {\n  expectWebSocketUpgradeWithProtocol { protocol =>\n    protocol shouldEqual \"echo\"\n    wsClient.sendMessage(\"ping\")\n    wsClient.expectMessage(\"ping\")\n    wsClient.sendCompletion()\n    wsClient.expectCompletion()\n  }\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.extractOfferedWsProtocols;\nimport static org.apache.pekko.http.javadsl.server.Directives.handleWebSocketMessagesForOptionalProtocol;\n\nfinal Flow<Message, Message, NotUsed> echoService = Flow.of(Message.class).buffer(1, OverflowStrategy.backpressure());\n\nfinal Route websocketRoute = path(\"services\", () ->\n  concat(\n    extractOfferedWsProtocols(protocols ->\n      handleWebSocketMessagesForOptionalProtocol(echoService, protocols.stream().findFirst())\n    )\n  )\n);\n\n// tests:\n// create a testing probe representing the client-side\nfinal WSProbe wsClient = WSProbe.create(system(), materializer());\n\ntestRoute(websocketRoute)\n  .run(WS(Uri.create(\"/services\"), wsClient.flow(), materializer(), Arrays.asList(\"echo\", \"alfa\", \"kilo\")))\n  .assertHeaderExists(SecWebSocketProtocol.create(\"echo\"));\n\nwsClient.sendMessage(\"ping\");\nwsClient.expectMessage(\"ping\");\n\nwsClient.sendCompletion();\nwsClient.expectCompletion();","title":"Example"},{"location":"/routing-dsl/directives/websocket-directives/extractUpgradeToWebSocket.html","text":"","title":"extractUpgradeToWebSocket"},{"location":"/routing-dsl/directives/websocket-directives/extractUpgradeToWebSocket.html#extractupgradetowebsocket","text":"Signature def extractUpgradeToWebSocket: Directive1[UpgradeToWebSocket]","title":"extractUpgradeToWebSocket"},{"location":"/routing-dsl/directives/websocket-directives/extractUpgradeToWebSocket.html#description","text":"This directive is deprecated, see extractWebSocketUpgrade instead.\nIf you are looking for a building block for Custom Directives to provide the websocket upgrade information to the inner route, we recommend using the WebSocketUpgradeWebSocketUpgrade attribute instead:\nScala copysourceimport org.apache.pekko.http.scaladsl.model.AttributeKeys.webSocketUpgrade\n\ndef echoService: Flow[Message, Message, Any] =\n  Flow[Message]\n    // needed because a noop flow hasn't any buffer that would start processing in tests\n    .buffer(1, OverflowStrategy.backpressure)\n\ndef route =\n  path(\"services\") {\n    extractWebSocketUpgrade { upgrade =>\n      complete(upgrade.handleMessages(echoService, Some(\"echo\")))\n    }\n  }\n\n// tests:\nval wsClient = WSProbe()\n\n// WS creates a WebSocket request for testing\nWS(\"/services\", wsClient.flow, Nil) ~> route ~> check {\n  expectWebSocketUpgradeWithProtocol { protocol =>\n    protocol shouldEqual \"echo\"\n    wsClient.sendMessage(\"ping\")\n    wsClient.expectMessage(\"ping\")\n    wsClient.sendCompletion()\n    wsClient.expectCompletion()\n  }\n} Java copysourcefinal Flow<Message, Message, NotUsed> echoService = Flow.of(Message.class).buffer(1, OverflowStrategy.backpressure());\n\nfinal Route websocketRoute = path(\"services\", () ->\n  concat(\n    extractWebSocketUpgrade(upgrade ->\n      complete(upgrade.handleMessagesWith(echoService, \"echo\"))\n    )\n  )\n);\n\n// tests:\n// create a testing probe representing the client-side\nfinal WSProbe wsClient = WSProbe.create(system(), materializer());\n\n// WS creates a WebSocket request for testing\ntestRoute(websocketRoute)\n  .run(WS(Uri.create(\"/services\"), wsClient.flow(), materializer(), Collections.emptyList()))\n  .assertHeaderExists(SecWebSocketProtocol.create(\"echo\"));\n\nwsClient.sendMessage(\"ping\");\nwsClient.expectMessage(\"ping\");\n\nwsClient.sendCompletion();\nwsClient.expectCompletion();","title":"Description"},{"location":"/routing-dsl/directives/websocket-directives/extractWebSocketUpgrade.html","text":"","title":"extractWebSocketUpgrade"},{"location":"/routing-dsl/directives/websocket-directives/extractWebSocketUpgrade.html#extractwebsocketupgrade","text":"Signature def extractWebSocketUpgrade: Directive1[WebSocketUpgrade]","title":"extractWebSocketUpgrade"},{"location":"/routing-dsl/directives/websocket-directives/extractWebSocketUpgrade.html#description","text":"The extractWebSocketUpgrade directive is used as a building block for Custom Directives to provide the websocket upgrade information to the inner route.","title":"Description"},{"location":"/routing-dsl/directives/websocket-directives/extractWebSocketUpgrade.html#example","text":"Scala copysourceimport org.apache.pekko.http.scaladsl.model.AttributeKeys.webSocketUpgrade\n\ndef echoService: Flow[Message, Message, Any] =\n  Flow[Message]\n    // needed because a noop flow hasn't any buffer that would start processing in tests\n    .buffer(1, OverflowStrategy.backpressure)\n\ndef route =\n  path(\"services\") {\n    extractWebSocketUpgrade { upgrade =>\n      complete(upgrade.handleMessages(echoService, Some(\"echo\")))\n    }\n  }\n\n// tests:\nval wsClient = WSProbe()\n\n// WS creates a WebSocket request for testing\nWS(\"/services\", wsClient.flow, Nil) ~> route ~> check {\n  expectWebSocketUpgradeWithProtocol { protocol =>\n    protocol shouldEqual \"echo\"\n    wsClient.sendMessage(\"ping\")\n    wsClient.expectMessage(\"ping\")\n    wsClient.sendCompletion()\n    wsClient.expectCompletion()\n  }\n} Java copysourcefinal Flow<Message, Message, NotUsed> echoService = Flow.of(Message.class).buffer(1, OverflowStrategy.backpressure());\n\nfinal Route websocketRoute = path(\"services\", () ->\n  concat(\n    extractWebSocketUpgrade(upgrade ->\n      complete(upgrade.handleMessagesWith(echoService, \"echo\"))\n    )\n  )\n);\n\n// tests:\n// create a testing probe representing the client-side\nfinal WSProbe wsClient = WSProbe.create(system(), materializer());\n\n// WS creates a WebSocket request for testing\ntestRoute(websocketRoute)\n  .run(WS(Uri.create(\"/services\"), wsClient.flow(), materializer(), Collections.emptyList()))\n  .assertHeaderExists(SecWebSocketProtocol.create(\"echo\"));\n\nwsClient.sendMessage(\"ping\");\nwsClient.expectMessage(\"ping\");\n\nwsClient.sendCompletion();\nwsClient.expectCompletion();","title":"Example"},{"location":"/routing-dsl/directives/websocket-directives/handleWebSocketMessages.html","text":"","title":"handleWebSocketMessages"},{"location":"/routing-dsl/directives/websocket-directives/handleWebSocketMessages.html#handlewebsocketmessages","text":"Signature def handleWebSocketMessages(handler: Flow[Message, Message, Any]): Route","title":"handleWebSocketMessages"},{"location":"/routing-dsl/directives/websocket-directives/handleWebSocketMessages.html#description","text":"The directive first checks if the request was a valid WebSocket handshake request and if yes, it completes the request with the passed handler. Otherwise, the request is rejected with an ExpectedWebSocketRequestRejectionExpectedWebSocketRequestRejection.\nWebSocket subprotocols offered in the Sec-WebSocket-Protocol header of the request are ignored. If you want to support several protocols use the handleWebSocketMessagesForProtocol directive, instead.\nFor more information about the WebSocket support, see Server-Side WebSocket Support.","title":"Description"},{"location":"/routing-dsl/directives/websocket-directives/handleWebSocketMessages.html#example","text":"Scala copysourcedef greeter: Flow[Message, Message, Any] =\n  Flow[Message].mapConcat {\n    case tm: TextMessage =>\n      TextMessage(Source.single(\"Hello \") ++ tm.textStream ++ Source.single(\"!\")) :: Nil\n    case bm: BinaryMessage =>\n      // ignore binary messages but drain content to avoid the stream being clogged\n      bm.dataStream.runWith(Sink.ignore)\n      Nil\n  }\nval websocketRoute =\n  path(\"greeter\") {\n    handleWebSocketMessages(greeter)\n  }\n\n// tests:\n// create a testing probe representing the client-side\nval wsClient = WSProbe()\n\n// WS creates a WebSocket request for testing\nWS(\"/greeter\", wsClient.flow) ~> websocketRoute ~>\ncheck {\n  // check response for WS Upgrade headers\n  isWebSocketUpgrade shouldEqual true\n\n  // manually run a WS conversation\n  wsClient.sendMessage(\"Peter\")\n  wsClient.expectMessage(\"Hello Peter!\")\n\n  wsClient.sendMessage(BinaryMessage(ByteString(\"abcdef\")))\n  wsClient.expectNoMessage(100.millis)\n\n  wsClient.sendMessage(\"John\")\n  wsClient.expectMessage(\"Hello John!\")\n\n  wsClient.sendCompletion()\n  wsClient.expectCompletion()\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.path;\nimport static org.apache.pekko.http.javadsl.server.Directives.handleWebSocketMessages;\n\nfinal Flow<Message, Message, NotUsed> greeter = Flow.of(Message.class).mapConcat(msg -> {\n  if (msg instanceof TextMessage) {\n    final TextMessage tm = (TextMessage) msg;\n    final TextMessage ret = TextMessage.create(Source.single(\"Hello \").concat(tm.getStreamedText()).concat(Source.single(\"!\")));\n    return Collections.singletonList(ret);\n  } else if (msg instanceof BinaryMessage) {\n    final BinaryMessage bm = (BinaryMessage) msg;\n    bm.getStreamedData().runWith(Sink.ignore(), materializer());\n    return Collections.emptyList();\n  } else {\n    throw new IllegalArgumentException(\"Unsupported message type!\");\n  }\n});\n\nfinal Route websocketRoute = path(\"greeter\", () ->\n  handleWebSocketMessages(greeter)\n);\n\n// create a testing probe representing the client-side\nfinal WSProbe wsClient = WSProbe.create(system(), materializer());\n\n// WS creates a WebSocket request for testing\ntestRoute(websocketRoute).run(WS(Uri.create(\"/greeter\"), wsClient.flow(), materializer()))\n  .assertStatusCode(StatusCodes.SWITCHING_PROTOCOLS);\n\n// manually run a WS conversation\nwsClient.sendMessage(\"Peter\");\nwsClient.expectMessage(\"Hello Peter!\");\n\nwsClient.sendMessage(BinaryMessage.create(ByteString.fromString(\"abcdef\")));\nwsClient.expectNoMessage(FiniteDuration.create(100, TimeUnit.MILLISECONDS));\n\nwsClient.sendMessage(\"John\");\nwsClient.expectMessage(\"Hello John!\");\n\nwsClient.sendCompletion();\nwsClient.expectCompletion();","title":"Example"},{"location":"/routing-dsl/directives/websocket-directives/handleWebSocketMessagesForOptionalProtocol.html","text":"","title":"handleWebSocketMessagesForOptionalProtocol"},{"location":"/routing-dsl/directives/websocket-directives/handleWebSocketMessagesForOptionalProtocol.html#handlewebsocketmessagesforoptionalprotocol","text":"Signature def handleWebSocketMessagesForOptionalProtocol( handler: Flow[Message, Message, Any], subprotocol: Option[String]): Route","title":"handleWebSocketMessagesForOptionalProtocol"},{"location":"/routing-dsl/directives/websocket-directives/handleWebSocketMessagesForOptionalProtocol.html#description","text":"Handles WebSocket requests with the given handler and rejects other requests with an ExpectedWebSocketRequestRejectionExpectedWebSocketRequestRejection.\nIf the subprotocol parameter is Noneempty any WebSocket request is accepted. If the subprotocol parameter is Some(protocol)a non-empty Optional a WebSocket request is only accepted if the list of subprotocols supported by the client (as announced in the WebSocket request) contains protocolmatches the contained subprotocol. If the client did not offer the protocol in question the request is rejected with an UnsupportedWebSocketSubprotocolRejectionUnsupportedWebSocketSubprotocolRejection.\nTo support several subprotocols you may chain several handleWebSocketMessagesForOptionalProtocol routes.\nThe handleWebSocketMessagesForOptionalProtocol directive is used as a building block for WebSocket Directives to handle websocket messages.\nFor more information about the WebSocket support, see Server-Side WebSocket Support.","title":"Description"},{"location":"/routing-dsl/directives/websocket-directives/handleWebSocketMessagesForProtocol.html","text":"","title":"handleWebSocketMessagesForProtocol"},{"location":"/routing-dsl/directives/websocket-directives/handleWebSocketMessagesForProtocol.html#handlewebsocketmessagesforprotocol","text":"Signature def handleWebSocketMessagesForProtocol(handler: Flow[Message, Message, Any], subprotocol: String): Route","title":"handleWebSocketMessagesForProtocol"},{"location":"/routing-dsl/directives/websocket-directives/handleWebSocketMessagesForProtocol.html#description","text":"Handles WebSocket requests with the given handler if the given subprotocol is offered in the Sec-WebSocket-Protocol header of the request and rejects other requests with an ExpectedWebSocketRequestRejectionExpectedWebSocketRequestRejection or an UnsupportedWebSocketSubprotocolRejectionUnsupportedWebSocketSubprotocolRejection.\nThe directive first checks if the request was a valid WebSocket handshake request and if the request offers the passed subprotocol name. If yes, the directive completes the request with the passed handler. Otherwise, the request is either rejected with an ExpectedWebSocketRequestRejectionExpectedWebSocketRequestRejection or an UnsupportedWebSocketSubprotocolRejectionUnsupportedWebSocketSubprotocolRejection.\nTo support several subprotocols, for example at the same path, several instances of handleWebSocketMessagesForProtocol can be chained using ~ as you can see in the below example.\nFor more information about the WebSocket support, see Server-Side WebSocket Support.","title":"Description"},{"location":"/routing-dsl/directives/websocket-directives/handleWebSocketMessagesForProtocol.html#example","text":"Scala copysourcedef greeterService: Flow[Message, Message, Any] =\n  Flow[Message].mapConcat {\n    case tm: TextMessage =>\n      TextMessage(Source.single(\"Hello \") ++ tm.textStream ++ Source.single(\"!\")) :: Nil\n    case bm: BinaryMessage =>\n      // ignore binary messages but drain content to avoid the stream being clogged\n      bm.dataStream.runWith(Sink.ignore)\n      Nil\n  }\n\ndef echoService: Flow[Message, Message, Any] =\n  Flow[Message]\n    // needed because a noop flow hasn't any buffer that would start processing in tests\n    .buffer(1, OverflowStrategy.backpressure)\n\ndef websocketMultipleProtocolRoute =\n  path(\"services\") {\n    handleWebSocketMessagesForProtocol(greeterService, \"greeter\") ~\n    handleWebSocketMessagesForProtocol(echoService, \"echo\")\n  }\n\n// tests:\nval wsClient = WSProbe()\n\n// WS creates a WebSocket request for testing\nWS(\"/services\", wsClient.flow, List(\"other\", \"echo\")) ~>\nwebsocketMultipleProtocolRoute ~>\ncheck {\n  expectWebSocketUpgradeWithProtocol { protocol =>\n    protocol shouldEqual \"echo\"\n\n    wsClient.sendMessage(\"Peter\")\n    wsClient.expectMessage(\"Peter\")\n\n    wsClient.sendMessage(BinaryMessage(ByteString(\"abcdef\")))\n    wsClient.expectMessage(ByteString(\"abcdef\"))\n\n    wsClient.sendMessage(\"John\")\n    wsClient.expectMessage(\"John\")\n\n    wsClient.sendCompletion()\n    wsClient.expectCompletion()\n  }\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.handleWebSocketMessagesForProtocol;\n\nfinal Flow<Message, Message, NotUsed> greeterService = Flow.of(Message.class).mapConcat(msg -> {\n  if (msg instanceof TextMessage) {\n    final TextMessage tm = (TextMessage) msg;\n    final TextMessage ret = TextMessage.create(Source.single(\"Hello \").concat(tm.getStreamedText()).concat(Source.single(\"!\")));\n    return Collections.singletonList(ret);\n  } else if (msg instanceof BinaryMessage) {\n    final BinaryMessage bm = (BinaryMessage) msg;\n    bm.getStreamedData().runWith(Sink.ignore(), materializer());\n    return Collections.emptyList();\n  } else {\n    throw new IllegalArgumentException(\"Unsupported message type!\");\n  }\n});\n\nfinal Flow<Message, Message, NotUsed> echoService = Flow.of(Message.class).buffer(1, OverflowStrategy.backpressure());\n\nfinal Route websocketMultipleProtocolRoute = path(\"services\", () ->\n  concat(\n    handleWebSocketMessagesForProtocol(greeterService, \"greeter\"),\n    handleWebSocketMessagesForProtocol(echoService, \"echo\")\n  )\n);\n\n// create a testing probe representing the client-side\nfinal WSProbe wsClient = WSProbe.create(system(), materializer());\n\n// WS creates a WebSocket request for testing\ntestRoute(websocketMultipleProtocolRoute)\n  .run(WS(Uri.create(\"/services\"), wsClient.flow(), materializer(), Arrays.asList(\"other\", \"echo\")))\n  .assertHeaderExists(SecWebSocketProtocol.create(\"echo\"));\n\nwsClient.sendMessage(\"Peter\");\nwsClient.expectMessage(\"Peter\");\n\nwsClient.sendMessage(BinaryMessage.create(ByteString.fromString(\"abcdef\")));\nwsClient.expectMessage(ByteString.fromString(\"abcdef\"));\n\nwsClient.sendMessage(\"John\");\nwsClient.expectMessage(\"John\");\n\nwsClient.sendCompletion();\nwsClient.expectCompletion();","title":"Example"},{"location":"/routing-dsl/directives/timeout-directives/index.html","text":"","title":"TimeoutDirectives"},{"location":"/routing-dsl/directives/timeout-directives/index.html#timeoutdirectives","text":"extractRequestTimeout withRequestTimeout withoutRequestTimeout withRequestTimeoutResponse","title":"TimeoutDirectives"},{"location":"/routing-dsl/directives/timeout-directives/extractRequestTimeout.html","text":"","title":"extractRequestTimeout"},{"location":"/routing-dsl/directives/timeout-directives/extractRequestTimeout.html#extractrequesttimeout","text":"Signature def extractRequestTimeout: Directive1[Duration]","title":"extractRequestTimeout"},{"location":"/routing-dsl/directives/timeout-directives/extractRequestTimeout.html#description","text":"This directive extracts the currently set request timeout.\nWarning Please note that this extracts the request timeout at the current moment, but the timeout can be changed concurrently. See other timeout directives about raciness inherent to timeout directives.\nFor more information about various timeouts in Apache Pekko HTTP see Pekko HTTP Timeouts.","title":"Description"},{"location":"/routing-dsl/directives/timeout-directives/extractRequestTimeout.html#example","text":"Scala copysourceval timeout1 = 500.millis\nval timeout2 = 1000.millis\nval route =\n  path(\"timeout\") {\n    withRequestTimeout(timeout1) {\n      extractRequestTimeout { t1 =>\n        withRequestTimeout(timeout2) {\n          extractRequestTimeout { t2 =>\n            complete(\n              if (t1 == timeout1 && t2 == timeout2) StatusCodes.OK\n              else StatusCodes.InternalServerError)\n          }\n        }\n      }\n    }\n  } Java copysourceDuration timeout1 = Duration.create(500, TimeUnit.MILLISECONDS);\nDuration timeout2 = Duration.create(1000, TimeUnit.MILLISECONDS);\nRoute route =\n  path(\"timeout\", () ->\n    withRequestTimeout(timeout1, () ->\n      extractRequestTimeout( t1 ->\n        withRequestTimeout(timeout2, () ->\n          extractRequestTimeout( t2 -> {\n            if (t1 == timeout1 && t2 == timeout2)\n              return complete(StatusCodes.OK);\n            else\n              return complete(StatusCodes.INTERNAL_SERVER_ERROR);\n          })\n        )\n      )\n    )\n  );","title":"Example"},{"location":"/routing-dsl/directives/timeout-directives/withRequestTimeout.html","text":"","title":"withRequestTimeout"},{"location":"/routing-dsl/directives/timeout-directives/withRequestTimeout.html#withrequesttimeout","text":"Signature def withRequestTimeout(timeout: Duration): Directive0 \ndef withRequestTimeout(timeout: Duration, handler: HttpRequest \ndef withRequestTimeout(timeout: Duration, handler: Option[HttpRequest","title":"withRequestTimeout"},{"location":"/routing-dsl/directives/timeout-directives/withRequestTimeout.html#description","text":"This directive enables “late” (during request processing) control over the Request timeout feature in Apache Pekko HTTP.\nThe timeout can be either loosened or made more tight using this directive, however one should be aware that it is inherently racy (which may especially show with very tight timeouts) since a timeout may already have been triggered when this directive executes.\nIn case of pipelined HTTP requests (multiple requests being accepted on the same connection before sending the first response) a the request timeout failure of the n-th request will shut down the connection causing the already enqueued requests to be dropped. This is by-design, as the request timeout feature serves as a “safety net” in case of programming errors (e.g. a Future that never completes thus potentially blocking the entire connection forever) or malicious attacks on the server.\nOptionally, a timeout handler may be provided in which is called when a time-out is triggered and must produce an HttpResponseHttpResponse that will be sent back to the client instead of the “too late” response (in case it’d ever arrive). See also withRequestTimeoutResponse if only looking to customise the timeout response without changing the timeout itself.\nWarning Please note that setting the timeout from within a directive is inherently racy (as the “point in time from which we’re measuring the timeout” is already in the past (the moment we started handling the request), so if the existing timeout already was triggered before your directive had the chance to change it, an timeout may still be logged. It is recommended to use a larger statically configured timeout (think of it as a “safety net” against programming errors or malicious attackers) and if needed tighten it using the directives – not the other way around.\nFor more information about various timeouts in Apache Pekko HTTP see Pekko HTTP Timeouts.","title":"Description"},{"location":"/routing-dsl/directives/timeout-directives/withRequestTimeout.html#example","text":"Scala copysourceval route =\n  path(\"timeout\") {\n    withRequestTimeout(1.seconds) { // modifies the global pekko.http.server.request-timeout for this request\n      val response: Future[String] = slowFuture() // very slow\n      complete(response)\n    }\n  }\n\n// check\nGet(\"/timeout\") ~!> route ~> check {\n  status should ===(StatusCodes.ServiceUnavailable) // the timeout response\n} Java copysourcefinal Duration timeout = Duration.create(1, TimeUnit.SECONDS);\nCompletionStage<String> slowFuture = new CompletableFuture<>();\n\nfinal Route route = path(\"timeout\", () ->\n        withRequestTimeout(timeout, () -> {\n            return completeOKWithFutureString(slowFuture); // very slow\n        })\n);\n\n// test:\nStatusCode statusCode = runRoute(route, \"timeout\").get().status();\nassert (StatusCodes.SERVICE_UNAVAILABLE.equals(statusCode));\nWith setting the handler at the same time:\nScala copysourceval timeoutResponse = HttpResponse(\n  StatusCodes.EnhanceYourCalm,\n  entity = \"Unable to serve response within time limit, please enhance your calm.\")\n\nval route =\n  path(\"timeout\") {\n    // updates timeout and handler at\n    withRequestTimeout(1.milli, request => timeoutResponse) {\n      val response: Future[String] = slowFuture() // very slow\n      complete(response)\n    }\n  }\n\n// check\nGet(\"/timeout\") ~!> route ~> check {\n  status should ===(StatusCodes.EnhanceYourCalm) // the timeout response\n} Java copysourcefinal Duration timeout = Duration.create(1, TimeUnit.MILLISECONDS);\nCompletionStage<String> slowFuture = new CompletableFuture<>();\n\nHttpResponse enhanceYourCalmResponse = HttpResponse.create()\n        .withStatus(StatusCodes.ENHANCE_YOUR_CALM)\n        .withEntity(\"Unable to serve response within time limit, please enhance your calm.\");\n\nfinal Route route = path(\"timeout\", () ->\n        withRequestTimeout(timeout, (request) -> enhanceYourCalmResponse, () -> {\n            return completeOKWithFutureString(slowFuture); // very slow\n        })\n);\n\n// test:\nStatusCode statusCode = runRoute(route, \"timeout\").get().status();\nassert (StatusCodes.ENHANCE_YOUR_CALM.equals(statusCode));","title":"Example"},{"location":"/routing-dsl/directives/timeout-directives/withoutRequestTimeout.html","text":"","title":"withoutRequestTimeout"},{"location":"/routing-dsl/directives/timeout-directives/withoutRequestTimeout.html#withoutrequesttimeout","text":"Signature def withoutRequestTimeout: Directive0","title":"withoutRequestTimeout"},{"location":"/routing-dsl/directives/timeout-directives/withoutRequestTimeout.html#description","text":"This directive enables “late” (during request processing) control over the Request timeout feature in Apache Pekko HTTP.\nIt is not recommended to turn off request timeouts using this method as it is inherently racy and disabling request timeouts basically turns off the safety net against programming mistakes that it provides.\nWarning Please note that setting the timeout from within a directive is inherently racy (as the “point in time from which we’re measuring the timeout” is already in the past (the moment we started handling the request), so if the existing timeout already was triggered before your directive had the chance to change it, an timeout may still be logged.\nFor more information about various timeouts in Apache Pekko HTTP see Pekko HTTP Timeouts.","title":"Description"},{"location":"/routing-dsl/directives/timeout-directives/withoutRequestTimeout.html#example","text":"Scala copysourceval route =\n  path(\"timeout\") {\n    withoutRequestTimeout {\n      val response: Future[String] = slowFuture() // very slow\n      complete(response)\n    }\n  }\n\n// no check as there is no time-out, the future would time out failing the test Java copysourceCompletionStage<String> slowFuture = new CompletableFuture<>();\n\nfinal Route route = path(\"timeout\", () ->\n        withoutRequestTimeout(() -> {\n            return completeOKWithFutureString(slowFuture); // very slow\n        })\n);\n\n// test:\nBoolean receivedReply = runRoute(route, \"timeout\").isPresent();\nassert (!receivedReply); // timed-out","title":"Example"},{"location":"/routing-dsl/directives/timeout-directives/withRequestTimeoutResponse.html","text":"","title":"withRequestTimeoutResponse"},{"location":"/routing-dsl/directives/timeout-directives/withRequestTimeoutResponse.html#withrequesttimeoutresponse","text":"Signature def withRequestTimeoutResponse(handler: HttpRequest","title":"withRequestTimeoutResponse"},{"location":"/routing-dsl/directives/timeout-directives/withRequestTimeoutResponse.html#description","text":"Allows customising the HttpResponseHttpResponse that will be sent to clients in case of a Request timeout.\nSee also withRequestTimeout or withoutRequestTimeout if interested in dynamically changing the timeout for a given route instead.\nWarning Please note that setting handler is inherently racy as the timeout is measured from starting to handle the request to its deadline, thus if the timeout triggers before the withRequestTimeoutResponse executed it would have emitted the default timeout HttpResponse. In practice this can only be a problem with very tight timeouts, so with default settings of request timeouts being measured in seconds it shouldn’t be a problem in reality (though certainly a possibility still).\nTo learn more about various timeouts in Apache Pekko HTTP and how to configure them see Pekko HTTP Timeouts.","title":"Description"},{"location":"/routing-dsl/directives/timeout-directives/withRequestTimeoutResponse.html#example","text":"Scala copysourceval timeoutResponse = HttpResponse(\n  StatusCodes.EnhanceYourCalm,\n  entity = \"Unable to serve response within time limit, please enhance your calm.\")\n\nval route =\n  path(\"timeout\") {\n    withRequestTimeout(100.milli) { // racy! for a very short timeout like 1.milli you can still get 503\n      withRequestTimeoutResponse(request => timeoutResponse) {\n        val response: Future[String] = slowFuture() // very slow\n        complete(response)\n      }\n    }\n  }\n\n// check\nGet(\"/timeout\") ~!> route ~> check {\n  status should ===(StatusCodes.EnhanceYourCalm) // the timeout response\n} Java copysourcefinal Duration timeout = Duration.create(100, TimeUnit.MILLISECONDS);\nCompletionStage<String> slowFuture = new CompletableFuture<>();\n\nHttpResponse enhanceYourCalmResponse = HttpResponse.create()\n        .withStatus(StatusCodes.ENHANCE_YOUR_CALM)\n        .withEntity(\"Unable to serve response within time limit, please enhance your calm.\");\n\nfinal Route route = path(\"timeout\", () ->\n        withRequestTimeout(timeout, () ->\n                // racy! for a very short timeout like 1.milli you can still get 503\n                withRequestTimeoutResponse((request) -> enhanceYourCalmResponse, () -> {\n                    return completeOKWithFutureString(slowFuture); // very slow\n                }))\n);\n\n// test:\nStatusCode statusCode = runRoute(route, \"timeout\").get().status();\nassert (StatusCodes.ENHANCE_YOUR_CALM.equals(statusCode));","title":"Example"},{"location":"/routing-dsl/directives/custom-directives.html","text":"","title":"Custom Directives"},{"location":"/routing-dsl/directives/custom-directives.html#custom-directives","text":"Part of the power of pekko-http directives comes from the ease with which it’s possible to define custom directives at differing levels of abstraction.\nThere are essentially three ways of creating custom directives:\nBy introducing new “labels” for configurations of existing directives By transforming existing directives By writing a directive “from scratch”","title":"Custom Directives"},{"location":"/routing-dsl/directives/custom-directives.html#configuration-labeling","text":"The easiest way to create a custom directive is to simply assign a new name for a certain configuration of one or more existing directives. In fact, most of the predefined pekko-http directives can be considered named configurations of more low-level directives.\nThe basic technique is explained in the chapter about Composing Directives, where, for example, a new directive getOrPut is defined like this:\nScala copysourceval getOrPut = get | put\n\n// tests:\nval route = getOrPut { complete(\"ok\") }\n\nGet(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"ok\"\n}\n\nPut(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"ok\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.get;\nimport static org.apache.pekko.http.javadsl.server.Directives.put;\nimport static org.apache.pekko.http.javadsl.server.Directives.complete;\n\npublic Route getOrPut(Supplier<Route> inner) {\n  return get(inner).orElse(put(inner));\n}\nRoute route = getOrPut(() -> complete(\"ok\"));\nMultiple directives can be nested to produce a single directive out of multiple like this: copysourceimport static org.apache.pekko.http.javadsl.server.Directives.headerValueByName;\n\n// the composed custom directive\n/**\n * @param authenticate A function returns a set of roles for the credentials of a user\n * @param inner Inner route to execute if the provided credentials has the given role\n *              if not, the request is completed with a\n */\npublic Route headerBasedAuth(Function<MyCredentials, Set<MyRole>> authenticate, MyRole requiredRole, Supplier<Route> inner) {\n  return headerValueByName(\"X-My-User-Id\", (userId) -> {\n    return headerValueByName(\"X-My-User-Secret\", (secret) -> {\n      Set<MyRole> userRoles = authenticate.apply(new MyCredentials(userId, secret));\n      if (userRoles.contains(requiredRole)) {\n        return inner.get();\n      } else {\n        return complete(StatusCodes.FORBIDDEN, \"Role \" + requiredRole + \" required for access\");\n      }\n    });\n  });\n}\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\n\n// a function for authentication\nFunction<MyCredentials, Set<MyRole>> authLogic =\n  (credentials) -> {\n    if (credentials.userId.equals(\"admin\") && credentials.safeSecretVerification(\"secret\"))\n      return new HashSet<>(Arrays.asList(MyRole.USER, MyRole.ADMIN));\n    else\n      return Collections.emptySet();\n  };\n\n// and then using the custom route\nRoute route = get(() ->\n  path(\"admin\", () ->\n    headerBasedAuth(authLogic, MyRole.ADMIN, () -> complete(StatusCodes.OK, \"admin stuff\"))\n  )\n);\nAnother example is the MethodDirectives which are simply instances of a preconfigured method directive. The low-level directives that most often form the basis of higher-level “named configuration” directives are grouped together in the BasicDirectives trait.\nTransforming Directives The second option for creating new directives is to transform an existing one using one of the “transformation methods”, which are defined on the Directive class, the base class of all “regular” directives. Apart from the combinator operators (| and &) and the case-class extractor (as[T]) the following transformations are also defined on all Directive instances: map/tmap flatMap/tflatMap require/trequire recover/recoverPF map and tmap If the Directive is a single-value Directive, the map method allows for simple transformations: copysourceval textParam: Directive1[String] =\n  parameter(\"text\".as[String])\n\nval lengthDirective: Directive1[Int] =\n  textParam.map(text => text.length)\n\n// tests:\nGet(\"/?text=abcdefg\") ~> lengthDirective(x => complete(x.toString)) ~> check {\n  responseAs[String] shouldEqual \"7\"\n} One example of a predefined directive relying on map is the optionalHeaderValue directive. The tmap modifier has this signature (somewhat simplified): def tmap[R](f: L => R): Directive[Out]\n It can be used to transform the Tuple of extractions into another Tuple. The number and/or types of the extractions can be changed arbitrarily. For example if R is Tuple2[A, B] then the result will be a Directive[(A, B)]. Here is a somewhat contrived example: copysourceval twoIntParameters: Directive[(Int, Int)] =\n  parameters(\"a\".as[Int], \"b\".as[Int])\n\nval myDirective: Directive1[String] =\n  twoIntParameters.tmap {\n    case (a, b) => (a + b).toString\n  }\n\n// tests:\nGet(\"/?a=2&b=5\") ~> myDirective(x => complete(x)) ~> check {\n  responseAs[String] shouldEqual \"7\"\n} flatMap and tflatMap With map and tmap you can transform the values a directive extracts but you cannot change the “extracting” nature of the directive. For example, if you have a directive extracting an Int you can use map to turn it into a directive that extracts that Int and doubles it, but you cannot transform it into a directive, that doubles all positive Int values and rejects all others. In order to do the latter you need flatMap or tflatMap. The tflatMap modifier has this signature: def tflatMap[R: Tuple](f: L => Directive[R]): Directive[R]\n The given function produces a new directive depending on the Tuple of extractions of the underlying one. As in the case of map/tmap there is also a single-value variant called flatMap, which simplifies the operation for Directives only extracting one single value. Here is the (contrived) example from above, which doubles positive Int values and rejects all others: copysourceval intParameter: Directive1[Int] = parameter(\"a\".as[Int])\n\nval myDirective: Directive1[Int] =\n  intParameter.flatMap {\n    case a if a > 0 => provide(2 * a)\n    case _          => reject\n  }\n\n// tests:\nGet(\"/?a=21\") ~> myDirective(i => complete(i.toString)) ~> check {\n  responseAs[String] shouldEqual \"42\"\n}\nGet(\"/?a=-18\") ~> myDirective(i => complete(i.toString)) ~> check {\n  handled shouldEqual false\n} A common pattern that relies on flatMap is to first extract a value from the RequestContext with the extract directive and then flatMap with some kind of filtering logic. For example, this is the implementation of the method directive: copysourcedef method(httpMethod: HttpMethod): Directive0 =\n  extractMethod.flatMap[Unit] {\n    case `httpMethod` => pass\n    case _            => reject(MethodRejection(httpMethod))\n  } & cancelRejections(classOf[MethodRejection]) The explicit type parameter [Unit] on the flatMap is needed in this case because the result of the flatMap is directly concatenated with the cancelAllRejections directive, thereby preventing “outside-in” inference of the type parameter value. require and trequire The require modifier transforms a single-extraction directive into a directive without extractions, which filters the requests according the a predicate function. All requests, for which the predicate is false are rejected, all others pass unchanged. The signature of require is this: def require(predicate: T => Boolean, rejections: Rejection*): Directive0\n One example of a predefined directive relying on require is the first overload of the host directive: copysource/**\n * Rejects all requests for whose host name the given predicate function returns false.\n *\n * @group host\n */\ndef host(predicate: String => Boolean): Directive0 = extractHost.require(predicate) You can only call require on single-extraction directives. The trequire modifier is the more general variant, which takes a predicate of type Tuple => Boolean. It can therefore also be used on directives with several extractions. recover and recoverPF The recover modifier allows you “catch” rejections produced by the underlying directive and, instead of rejecting, produce an alternative directive with the same type(s) of extractions. The signature of recover is this: def recover[R >: L: Tuple](recovery: Seq[Rejection] => Directive[R]): Directive[R] =\n In many cases the very similar recoverPF modifier might be little bit easier to use since it doesn’t require the handling of all rejections: def recoverPF[R >: L: Tuple](\n  recovery: PartialFunction[Seq[Rejection], Directive[R]]): Directive[R]\n One example of a predefined directive relying recoverPF is the optionalHeaderValue directive: def optionalHeaderValue[T](f: HttpHeader collect and tcollect With collect and tcollect you can filter and map in one go, it mimics the collect known from the regular Scala collections. Here is an example, first via map and filter and finally using collect: parameter(\"a\".as[Int]).filter(x => x != 0, MissingQueryParamRejection(\"a\")).map(x => 42 / x)\n\nparameter(\"a\".as[Int]).collect({ case x if x != 0 => 42 / x }, MissingQueryParamRejection(\"a\"))\n Directives from Scratch The third option for creating custom directives is to do it “from scratch”, either by using Directive.apply or by subclassing Directive class directly. The Directive is defined like this (leaving away operators and modifiers): copysourceabstract class Directive[L](implicit val ev: Tuple[L]) {\n\n  /**\n   * Calls the inner route with a tuple of extracted values of type `L`.\n   *\n   * `tapply` is short for \"tuple-apply\". Usually, you will use the regular `apply` method instead,\n   * which is added by an implicit conversion (see `Directive.addDirectiveApply`).\n   */\n  def tapply(f: L => Route): Route\n} It only has one abstract member that you need to implement, the tapply method, which creates the Route the directives presents to the outside from its inner Route building function (taking the extractions as parameters). Extractions are kept as a Tuple. Here are a few examples: A Directive[Unit] extracts nothing (like the get directive). Because this type is used quite frequently pekko-http defines a type alias for it: type Directive0 = Directive[Unit]\n A Directive[(String)] extracts one String value (like the hostName directive). The type alias for it is: type Directive1[T] = Directive[Tuple1[T]]\n A Directive[(String, Int)] extracts a String value and an Int value (like a parameters('a.as[String], 'b.as[Int]) directive). Such a directive can be defined to extract the hostname and port of a request: copysourcedef hostnameAndPort: Directive[(String, Int)] = Directive[(String, Int)] { inner => ctx =>\n  val authority = ctx.request.uri.authority\n  inner((authority.host.address(), authority.port))(ctx)\n}\n\n// test\nval route = hostnameAndPort {\n  (hostname, port) => complete(s\"The hostname is $hostname and the port is $port\")\n}\n\nGet() ~> Host(\"pekko.apache.org\", 8080) ~> route ~> check {\n  status shouldEqual OK\n  responseAs[String] shouldEqual \"The hostname is pekko.apache.org and the port is 8080\"\n} Beside using Directive.apply, you can also extending Directive directly(This is actually uncommon and the first is preferable for common use cases): copysourceobject hostnameAndPort extends Directive[(String, Int)] {\n  override def tapply(f: ((String, Int)) => Route): Route = { ctx =>\n    val authority = ctx.request.uri.authority\n    f((authority.host.address(), authority.port))(ctx)\n  }\n}\n\n// test\nval route = hostnameAndPort {\n  (hostname, port) => complete(s\"The hostname is $hostname and the port is $port\")\n}\n\nGet() ~> Host(\"pekko.apache.org\", 8080) ~> route ~> check {\n  status shouldEqual OK\n  responseAs[String] shouldEqual \"The hostname is pekko.apache.org and the port is 8080\"\n} Keeping extractions as Tuples has a lot of advantages, mainly great flexibility while upholding full type safety and “inferability”. However, the number of times where you’ll really have to fall back to defining a directive from scratch should be very small. In fact, if you find yourself in a position where a “from scratch” directive is your only option, we’d like to hear about it, so we can provide a higher-level “something” for other users.","title":"Configuration Labeling"},{"location":"/routing-dsl/rejections.html","text":"","title":"Rejections"},{"location":"/routing-dsl/rejections.html#rejections","text":"In the chapter about constructing Routes the ~ operatorRouteDirectives.route() method was introduced, which connects two or more routes in a way that allows the next specified route to get a go at a request if the first route “rejected” it. The concept of “rejections” is used by Apache Pekko HTTP for maintaining a more functional overall architecture and in order to be able to properly handle all kinds of error scenarios.\nWhen a filtering directive, like the get directive, cannot let the request pass through to its inner route because the filter condition is not satisfied (e.g. because the incoming request is not a GET request) the directive doesn’t immediately complete the request with an error response. Doing so would make it impossible for other routes chained in after the failing filter to get a chance to handle the request. Rather, failing filters “reject” the request in the same way as by explicitly calling requestContext.reject(...).\nAfter having been rejected by a route the request will continue to flow through the routing structure and possibly find another route that can complete it. If there are more rejections all of them will be picked up and collected.\nIf the request cannot be completed by (a branch of) the route structure an enclosing handleRejections directive can be used to convert a set of rejections into an HttpResponseHttpResponse - which typically would be an error response. Route.seal() internally wraps its argument route with the handleRejections directive in order to “catch” and handle any rejection.","title":"Rejections"},{"location":"/routing-dsl/rejections.html#predefined-rejections","text":"A rejection encapsulates a specific reason why a route was not able to handle a request. It is modeled as an object of type RejectionRejection. Apache Pekko HTTP comes with a set of predefined rejectionspredefined rejections, which are used by the many predefined directives.\nRejections are gathered up over the course of a Route evaluation and finally converted to HttpResponseHttpResponse replies by the handleRejections directive if there was no way for the request to be completed.","title":"Predefined Rejections"},{"location":"/routing-dsl/rejections.html#the-rejectionhandler","text":"The handleRejections directive delegates the actual job of converting a list of rejections to the provided RejectionHandlerRejectionHandler, so it can choose whether it would like to handle the current set of rejections or not. Unhandled rejections will simply continue to flow through the route structure.\nThe default RejectionHandler applied by the top-level glue code that turns a RouteRoute into a FlowFlow or async handler function for the low-level API (via Route.toFlow or Route.toFunction) will handle all rejections that reach it.\nNote Please note that the default RejectionHandler will also discard the entity bytes automatically. If you want to change this behavior, please refer to Customising rejection HTTP Responses; however, might cause connections to stall if the entity is not properly rejected or cancelled on the client side.","title":"The RejectionHandler"},{"location":"/routing-dsl/rejections.html#rejection-cancellation","text":"As mentioned above, the RejectionHandler doesn’t handle single rejections but a whole list of them. This is because some route structure produce several “reasons” why a request could not be handled.\nTake this route structure for example:\nScala copysourceimport org.apache.pekko.http.scaladsl.coding.Coders\n\nval route =\n  path(\"order\") {\n    concat(\n      get {\n        complete(\"Received GET\")\n      },\n      post {\n        decodeRequestWith(Coders.Gzip) {\n          complete(\"Received compressed POST\")\n        }\n      })\n  } Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.decodeRequestWith;\nimport static org.apache.pekko.http.javadsl.server.Directives.get;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\nimport static org.apache.pekko.http.javadsl.server.Directives.post;\nfinal Route route = path(\"order\", () ->\n  concat(\n    get(() ->\n      complete(\"Received GET\")\n    ),\n    post(() ->\n      decodeRequestWith(Coder.Gzip, () ->\n        complete(\"Received compressed POST\")\n      )\n    )\n  ));\nFor uncompressed POST requests this route structure would initially yield two rejections:\na MethodRejectionMethodRejection produced by the get directive (which rejected because the request is not a GET request) an UnsupportedRequestEncodingRejectionUnsupportedRequestEncodingRejection produced by the decodeRequestWith directive (which only accepts gzip-compressed requests here)\nIn reality the route even generates one more rejection, a TransformationRejectionTransformationRejection produced by the post directive. It “cancels” all other potentially existing MethodRejections, since they are invalid after the post directive allowed the request to pass (after all, the route structure can deal with POST requests). These types of rejection cancellations are resolved before a RejectionHandler is called with any rejection. So, for the example above the RejectionHandler will be presented with only one single rejection, the UnsupportedRequestEncodingRejectionUnsupportedRequestEncodingRejection.","title":"Rejection Cancellation"},{"location":"/routing-dsl/rejections.html#empty-rejections","text":"Internally rejections are stored in an immutable list, so you might ask yourself what the semantics of an empty rejection list are. In fact, empty rejection lists have well defined semantics. They signal that a request was not handled because the respective resource could not be found. Apache Pekko HTTP reserves the special status of “empty rejection” to this most common failure a service is likely to produce.\nSo, for example, if the path directive rejects a request it does so with an empty rejection list. The host directive behaves in the same way.","title":"Empty Rejections"},{"location":"/routing-dsl/rejections.html#customizing-rejection-handling","text":"If you’d like to customize the way certain rejections are handled you’ll have to write a custom RejectionHandler. Here is an example:\nScala copysourceimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.model._\nimport pekko.http.scaladsl.server._\nimport StatusCodes._\nimport Directives._\n\nobject MyApp extends App {\n  def myRejectionHandler =\n    RejectionHandler.newBuilder()\n      .handle {\n        case MissingCookieRejection(cookieName) =>\n          complete(HttpResponse(BadRequest, entity = \"No cookies, no service!!!\"))\n      }\n      .handle {\n        case AuthorizationFailedRejection =>\n          complete(Forbidden, \"You're out of your depth!\")\n      }\n      .handle {\n        case ValidationRejection(msg, _) =>\n          complete(InternalServerError, \"That wasn't valid! \" + msg)\n      }\n      .handleAll[MethodRejection] { methodRejections =>\n        val names = methodRejections.map(_.supported.name)\n        complete(MethodNotAllowed, s\"Can't do that! Supported: ${names.mkString(\" or \")}!\")\n      }\n      .handleNotFound { complete((NotFound, \"Not here!\")) }\n      .result()\n\n  implicit val system = ActorSystem()\n\n  val route: Route = handleRejections(myRejectionHandler) {\n    // ... some route structure\n  }\n\n  Http().newServerAt(\"localhost\", 8080).bind(route)\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\nimport static org.apache.pekko.http.javadsl.server.Directives.handleRejections;\n\nfinal RejectionHandler rejectionHandler = RejectionHandler.newBuilder()\n  .handle(MissingCookieRejection.class, rej ->\n    complete(StatusCodes.BAD_REQUEST, \"No cookies, no service!!!\")\n  )\n  .handle(AuthorizationFailedRejection.class, rej ->\n    complete(StatusCodes.FORBIDDEN, \"You're out of your depth!\")\n  )\n  .handle(ValidationRejection.class, rej ->\n    complete(StatusCodes.INTERNAL_SERVER_ERROR, \"That wasn't valid! \" + rej.message())\n  )\n  .handleAll(MethodRejection.class, rejections -> {\n    String supported = rejections.stream()\n      .map(rej -> rej.supported().name())\n      .collect(Collectors.joining(\" or \"));\n    return complete(StatusCodes.METHOD_NOT_ALLOWED, \"Can't do that! Supported: \" + supported + \"!\");\n  })\n  .handleNotFound(complete(StatusCodes.NOT_FOUND, \"Not here!\"))\n  .build();\n\n// Route that will be bound to the Http\nfinal Route wrapped = handleRejections(rejectionHandler,\n  this::getRoute); // Some route structure for this Server\nThe easiest way to construct a RejectionHandler is with RejectionHandler.newBuilder() that Apache Pekko HTTP provides. After having created a new Builder instance you can attach handling logic for certain types of rejections through three helper methods:\nhandle(PartialFunction[Rejection, Route])handle(Class, Function<T, Route>) Handles the provided type of rejections with the given function. The provided function simply produces a RouteRoute which is run when the rejection is “caught”. This makes the full power of the Routing DSL available for defining rejection handlers and even allows for recursing back into the main route structure if required. handleAll[T <: Rejection: ClassTag](f: immutable.Seq[T] => Route)handleAll(Class, Function<List, Route>) Handles all rejections of a certain type at the same time. This is useful for cases where your need access to more than the first rejection of a certain type, e.g. for producing the error message to an unsupported request method. handleNotFound(Route) As described above “Resource Not Found” is special as it is represented with an empty rejection set. The handleNotFound helper let’s you specify the “recovery route” for this case.\nEven though you could handle several different rejection types in a single partial function supplied to handle by “listening” to the Rejection.class, it is recommended to split these up into distinct handle attachments instead. This way the priority between rejections is properly defined via the order of your handle clauses rather than the (sometimes hard to predict or control) order of rejections in the rejection set.\nOnce you have defined your custom RejectionHandler you have two options for “activating” it:\nBring it into implicit scope at the top-levelPass it to the seal() method of the Route class Supply it as an argument to the handleRejections directive\nIn the first case your handler will be “sealed” (which means that it will receive the default handler as a fallback for all cases your handler doesn’t handle itself) and used for all rejections that are not handled within the route structure itself.\nThe second case allows you to restrict the applicability of your handler to certain branches of your route structure.","title":"Customizing Rejection Handling"},{"location":"/routing-dsl/rejections.html#customising-rejection-http-responses","text":"It is also possible to customise just the responses that are returned by a defined rejection handler. This can be useful for example if you like the rejection messages and status codes of the default handler, however you’d like to wrap those responses in JSON or some other content type.\nPlease note that since those are not 200 responses, a different content type than the one that was sent in a client’s AcceptAccept header is legal. Thus the default handler renders such rejections as text/plain.\nIn order to customise the HTTP Responses of an existing handler you can call the mapRejectionResponse method on such handler as shown in the example below:\nScala copysourceimport org.apache.pekko\nimport pekko.http.scaladsl.model._\nimport pekko.http.scaladsl.server.RejectionHandler\n\nimplicit def myRejectionHandler =\n  RejectionHandler.default\n    .mapRejectionResponse {\n      case res @ HttpResponse(_, _, ent: HttpEntity.Strict, _) =>\n        // since all Akka default rejection responses are Strict this will handle all rejections\n        val message = ent.data.utf8String.replaceAll(\"\\\"\", \"\"\"\\\"\"\"\")\n\n        // we copy the response in order to keep all headers and status code, wrapping the message as hand rolled JSON\n        // you could the entity using your favourite marshalling library (e.g. spray json or anything else)\n        res.withEntity(HttpEntity(ContentTypes.`application/json`, s\"\"\"{\"rejection\": \"$message\"}\"\"\"))\n\n      case x => x // pass through all other types of responses\n    }\n\nval route =\n  Route.seal(\n    path(\"hello\") {\n      complete(\"Hello there\")\n    })\n\n// tests:\nGet(\"/nope\") ~> route ~> check {\n  status shouldEqual StatusCodes.NotFound\n  contentType shouldEqual ContentTypes.`application/json`\n  responseAs[String] shouldEqual \"\"\"{\"rejection\": \"The requested resource could not be found.\"}\"\"\"\n}\n\nval anotherRoute =\n  Route.seal(\n    validate(check = false, \"Whoops, bad request!\") {\n      complete(\"Hello there\")\n    })\n\n// tests:\nGet(\"/hello\") ~> anotherRoute ~> check {\n  status shouldEqual StatusCodes.BadRequest\n  contentType shouldEqual ContentTypes.`application/json`\n  responseAs[String] shouldEqual \"\"\"{\"rejection\": \"Whoops, bad request!\"}\"\"\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\nimport static org.apache.pekko.http.javadsl.server.Directives.handleRejections;\nimport static org.apache.pekko.http.javadsl.server.Directives.validate;\n\nfinal RejectionHandler rejectionHandler = RejectionHandler.defaultHandler()\n  .mapRejectionResponse(response -> {\n    if (response.entity() instanceof HttpEntity.Strict) {\n      // since all Akka default rejection responses are Strict this will handle all rejections\n      String message = ((HttpEntity.Strict) response.entity()).getData().utf8String()\n        .replaceAll(\"\\\"\", \"\\\\\\\"\");\n      // we create a new copy the response in order to keep all headers and status code,\n      // replacing the original entity with a custom message as hand rolled JSON you could the\n      // entity using your favourite marshalling library (e.g. spray json or anything else)\n      return response.withEntity(ContentTypes.APPLICATION_JSON,\n        \"{\\\"rejection\\\": \\\"\" + message + \"\\\"}\");\n    } else {\n      // pass through all other types of responses\n      return response;\n    }\n  });\n\nRoute route = handleRejections(rejectionHandler, () ->\n  path(\"hello\", () ->\n    complete(\"Hello there\")\n  ));\n\n// tests:\ntestRoute(route)\n  .run(HttpRequest.GET(\"/nope\"))\n  .assertStatusCode(StatusCodes.NOT_FOUND)\n  .assertContentType(ContentTypes.APPLICATION_JSON)\n  .assertEntity(\"{\\\"rejection\\\": \\\"The requested resource could not be found.\\\"}\");\n\nRoute anotherOne = handleRejections(rejectionHandler, () ->\n  validate(() -> false, \"Whoops, bad request!\", () ->\n    complete(\"Hello there\")\n));\n\n// tests:\ntestRoute(anotherOne)\n  .run(HttpRequest.GET(\"/hello\"))\n  .assertStatusCode(StatusCodes.BAD_REQUEST)\n  .assertContentType(ContentTypes.APPLICATION_JSON)\n  .assertEntity(\"{\\\"rejection\\\": \\\"Whoops, bad request!\\\"}\");","title":"Customising rejection HTTP Responses"},{"location":"/routing-dsl/rejections.html#adding-the-unmatched-route-in-handlenotfound","text":"Since rejection handlers are routes themselves, it is possible to do anything you could possibly want inside such handler. For example you may want to include the path which was not found in the response to the client, this is as simple as using the extractUnmatchedPath and completing the route with it.\nScala copysourceimport org.apache.pekko\nimport pekko.http.scaladsl.model.StatusCodes._\nimport pekko.http.scaladsl.server._\nimport Directives._\n\nimplicit def myRejectionHandler =\n  RejectionHandler.newBuilder()\n    .handleNotFound {\n      extractUnmatchedPath { p =>\n        complete(NotFound, s\"The path you requested [${p}] does not exist.\")\n      }\n    }\n    .result() Java copysourceimport org.apache.pekko.http.javadsl.server.Directives;\n\nimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.extractUnmatchedPath;\nimport static org.apache.pekko.http.javadsl.server.Directives.handleRejections;\nimport static org.apache.pekko.http.javadsl.server.Directives.reject;\n\nfinal RejectionHandler totallyMissingHandler = RejectionHandler.newBuilder()\n  .handleNotFound(\n    extractUnmatchedPath(path ->\n      complete(StatusCodes.NOT_FOUND, \"The path \" + path + \" was not found!\")\n    )\n  )\n  .build();\n\nfinal Route route = \n  handleRejections(totallyMissingHandler, () ->\n  pathPrefix(\"handled\", () ->\n    Directives.concat(\n      path(\"existing\", () -> complete(\"This path exists\"))\n    )\n  )\n);\n\n// tests:\ntestRoute(route).run(HttpRequest.GET(\"/handled/existing\"))\n  .assertEntity(\"This path exists\");\n// applies default handler\ntestRoute(route).run(HttpRequest.GET(\"/missing\"))\n  .assertStatusCode(StatusCodes.NOT_FOUND)\n  .assertEntity(\"The path /missing was not found!\");\ntestRoute(route).run(HttpRequest.GET(\"/handled/missing\"))\n  .assertStatusCode(StatusCodes.NOT_FOUND)\n  .assertEntity(\"The path /handled/missing was not found!\");\nIf you want to add even more information you can obtain the full request by using extractRequest as well.","title":"Adding the unmatched route in handleNotFound"},{"location":"/routing-dsl/exception-handling.html","text":"","title":"Exception Handling"},{"location":"/routing-dsl/exception-handling.html#exception-handling","text":"Exceptions thrown during route execution bubble up through the route structure to the next enclosing handleExceptions directive or the top of your route structure.\nSimilarly to the way that Rejections are handled the handleExceptions directive delegates the actual job of converting an exception to its argument, an ExceptionHandlerExceptionHandler, which is defined like this:.\ntrait ExceptionHandler extends PartialFunction[Throwable, Route]\nSince an ExceptionHandlerExceptionHandler is a partial function, it can choose which exceptions it would like to handle and which not. Unhandled exceptions will simply continue to bubble up in the route structure. At the root of the route tree any still unhandled exception will be dealt with by the top-level handler which always handles all exceptions.\nRoute.seal internally wraps its argument route with the handleExceptions directive in order to “catch” and handle any exception.\nSo, if you’d like to customize the way certain exceptions are handled you need to write a custom ExceptionHandlerExceptionHandler. Once you have defined your custom ExceptionHandlerExceptionHandler you have two options for “activating” it:\nBring it into implicit scope at the top-level.Pass it to the seal() method of the Route Supply it as argument to the handleExceptions directive.\nIn the first case your handler will be “sealed” (which means that it will receive the default handler as a fallback for all cases your handler doesn’t handle itself) and used for all exceptions that are not handled within the route structure itself. Here you can see an example of it:\nScala copysourceimport org.apache.pekko\nimport pekko.http.scaladsl.model.HttpResponse\nimport pekko.http.scaladsl.model.StatusCodes._\nimport pekko.http.scaladsl.server._\nimport Directives._\n\nobject SealedRouteWithCustomExceptionHandler {\n\n  implicit def myExceptionHandler: ExceptionHandler =\n    ExceptionHandler {\n      case _: ArithmeticException =>\n        extractUri { uri =>\n          println(s\"Request to $uri could not be handled normally\")\n          complete(HttpResponse(InternalServerError, entity = \"Bad numbers, bad result!!!\"))\n        }\n    }\n\n  val route: Route = Route.seal(\n    path(\"divide\") {\n      complete((1 / 0).toString) //Will throw ArithmeticException\n    }\n  ) // this one takes `myExceptionHandler` implicitly\n\n} Java copysourceimport org.apache.pekko.http.javadsl.model.StatusCodes;\nimport org.apache.pekko.http.javadsl.server.AllDirectives;\nimport org.apache.pekko.http.javadsl.server.ExceptionHandler;\nimport org.apache.pekko.http.javadsl.server.PathMatchers;\nimport org.apache.pekko.http.javadsl.server.RejectionHandler;\nimport org.apache.pekko.http.javadsl.server.Route;\n\nimport static org.apache.pekko.http.javadsl.server.PathMatchers.integerSegment;\n\npublic class ExceptionHandlerInSealExample extends AllDirectives {\n\n  public Route createRoute() {\n    final ExceptionHandler divByZeroHandler = ExceptionHandler.newBuilder()\n      .match(ArithmeticException.class, x ->\n        complete(StatusCodes.BAD_REQUEST, \"You've got your arithmetic wrong, fool!\"))\n      .build();\n\n    final RejectionHandler defaultHandler = RejectionHandler.defaultHandler();\n\n    return path(PathMatchers.segment(\"divide\").slash(integerSegment()).slash(integerSegment()), (a, b) ->\n      complete(\"The result is \" + (a / b))\n    ).seal(defaultHandler, divByZeroHandler);\n  }\n}\nThe second case allows you to restrict the applicability of your handler to certain branches of your route structure.\nHere is an example for wiring up a custom handler via handleExceptions:\nScala copysourceimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.model._\nimport StatusCodes._\nimport pekko.http.scaladsl.server._\nimport Directives._\n\nval myExceptionHandler = ExceptionHandler {\n  case _: ArithmeticException =>\n    extractUri { uri =>\n      println(s\"Request to $uri could not be handled normally\")\n      complete(HttpResponse(InternalServerError, entity = \"Bad numbers, bad result!!!\"))\n    }\n}\n\nobject MyApp extends App {\n\n  implicit val system = ActorSystem()\n\n  val route: Route =\n    handleExceptions(myExceptionHandler) {\n      // ... some route structure\n    }\n\n  Http().newServerAt(\"localhost\", 8080).bind(route)\n}\n Java copysource import org.apache.pekko.actor.ActorSystem;\nimport org.apache.pekko.http.javadsl.Http;\nimport org.apache.pekko.http.javadsl.ServerBinding;\nimport org.apache.pekko.http.javadsl.model.StatusCodes;\nimport org.apache.pekko.http.javadsl.server.AllDirectives;\nimport org.apache.pekko.http.javadsl.server.ExceptionHandler;\nimport org.apache.pekko.http.javadsl.server.PathMatchers;\nimport org.apache.pekko.http.javadsl.server.Route;\n\nimport java.util.concurrent.CompletionStage;\n\nimport static org.apache.pekko.http.javadsl.server.PathMatchers.integerSegment;\n\npublic class ExceptionHandlerExample extends AllDirectives {\n  public static void main(String[] args) {\n    final ActorSystem system = ActorSystem.create();\n    final Http http = Http.get(system);\n\n    final ExceptionHandlerExample app = new ExceptionHandlerExample();\n\n    final CompletionStage<ServerBinding> binding = http.newServerAt(\"localhost\", 8080).bind(app.createRoute());\n  }\n\n\n  public Route createRoute() {\n    final ExceptionHandler divByZeroHandler = ExceptionHandler.newBuilder()\n      .match(ArithmeticException.class, x ->\n        complete(StatusCodes.BAD_REQUEST, \"You've got your arithmetic wrong, fool!\"))\n      .build();\n\n    return path(PathMatchers.segment(\"divide\").slash(integerSegment()).slash(integerSegment()), (a, b) ->\n      handleExceptions(divByZeroHandler, () -> complete(\"The result is \" + (a / b)))\n    );\n  }\n}\nAnd this is how to do it implicitly: copysourceimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.model._\nimport StatusCodes._\nimport pekko.http.scaladsl.server._\nimport Directives._\n\nimplicit def myExceptionHandler: ExceptionHandler =\n  ExceptionHandler {\n    case _: ArithmeticException =>\n      extractUri { uri =>\n        println(s\"Request to $uri could not be handled normally\")\n        complete(HttpResponse(InternalServerError, entity = \"Bad numbers, bad result!!!\"))\n      }\n  }\n\nobject MyApp extends App {\n\n  implicit val system = ActorSystem()\n\n  val route: Route =\n  // ... some route structure\n\n  Http().newServerAt(\"localhost\", 8080).bind(route)\n}","title":"Exception Handling"},{"location":"/routing-dsl/exception-handling.html#default-exception-handler","text":"A default ExceptionHandlerExceptionHandler is used if no custom instance is provided.\nIt will handle every NonFatal throwable, write its stack trace and complete the request with InternalServerError (500) status code.\nThe message body will contain a string obtained via Throwable#getMessage call on the exception caught.\nIn case getMessage returns null (which is true for e.g. NullPointerException instances), the class name and a remark about the message being null are included in the response body.\nNote that IllegalRequestExceptions’ stack traces are not logged, since instances of this class normally contain enough information to provide a useful error message.\nNote Users are strongly encouraged not to rely on using the ExceptionHandlerExceptionHandler as a means of handling errors. By errors, we mean things that are an expected part of normal operations: for example, issues discovered during input validation. The ExceptionHandlerExceptionHandler is meant to be a means of handling failures. See Failure vs Error in the glossary of the Reactive Manifesto. Distinguishing between errors and failures (i.e. thrown Exceptions handled via the ExceptionHandlerExceptionHandler) provides a much better mental model but also leads to performance improvements. This is because exceptions are known to have a negative performance impact for cases when the depth of the call stack is significant (stack trace construction cost) and when the handler is located far from the place of the throwable instantiation (stack unwinding costs). In a typical Apache Pekko application both these conditions are frequently true, so as a rule of thumb, you should try to minimize the number of Throwable instances reaching the exception handler. To understand the performance implications of (mis-)using exceptions, have a read at this excellent post by A. Shipilёv: The Exceptional Performance of Lil’ Exception.\nNote Please note that the default ExceptionHandler will also discard the entity bytes automatically. If you want to change this behavior, please refer to the section above; however, might cause connections to stall if the entity is not properly rejected or cancelled on the client side.","title":"Default Exception Handler"},{"location":"/routing-dsl/exception-handling.html#including-sensitive-data-in-exceptions","text":"To prevent certain types of attack, it is not recommended to include arbitrary invalid user input in the response. However, sometimes it can be useful to include it in the exception and logging for diagnostic reasons. In such cases, you can use exceptions that extend ExceptionWithErrorInfo, such as IllegalHeaderException:\nScala copysourceimport org.apache.pekko.http.scaladsl.model.IllegalHeaderException\n\nval route = get {\n  throw IllegalHeaderException(\"Value of header Foo was illegal\", \"Found illegal value \\\"<script>alert('evil_xss_or_xsrf_reflection')</script>\\\"\")\n}\n\n// Test:\nGet(\"/\") ~> route ~> check {\n  responseAs[String] should include(\"header Foo was illegal\")\n  responseAs[String] shouldNot include(\"evil_xss_or_xsrf_reflection\")\n} Java copysourceTestRoute route = testRoute(\n  get(() -> {\n      throw new IllegalHeaderException(new ErrorInfo(\n        \"Value of header Foo was illegal\",\n        \"Found illegal value \\\"<script>alert('evil_xss_or_xsrf_reflection')</script>\\\"\"));\n  })\n);\n\nString response = route\n  .run(HttpRequest.GET(\"/\"))\n  .entityString();\nassertTrue(response.contains(\"header Foo was illegal\"));\nassertTrue(!response.contains(\"evil_xss_or_xsrf_reflection\"));","title":"Including sensitive data in exceptions"},{"location":"/routing-dsl/exception-handling.html#respond-with-headers-and-exception-handler","text":"If you wrap an ExceptionHandler inside a different directive, then that directive will still apply. Example below shows that wrapping an ExceptionHandler inside a respondWithHeader directive will still add the header to the response.\nScala copysourceimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.model.HttpResponse\nimport pekko.http.scaladsl.model.StatusCodes._\nimport pekko.http.scaladsl.model.headers.RawHeader\nimport pekko.http.scaladsl.server._\nimport Directives._\nimport pekko.http.scaladsl.Http\nimport RespondWithHeaderExceptionHandler.route\n\n\nobject RespondWithHeaderExceptionHandler {\n  def myExceptionHandler: ExceptionHandler =\n    ExceptionHandler {\n      case _: ArithmeticException =>\n        extractUri { uri =>\n          println(s\"Request to $uri could not be handled normally\")\n          complete(HttpResponse(InternalServerError, entity = \"Bad numbers, bad result!!!\"))\n        }\n    }\n\n  val greetingRoutes: Route = path(\"greetings\") {\n    complete(\"Hello!\")\n  }\n\n  val divideRoutes: Route = path(\"divide\") {\n    complete((1 / 0).toString) //Will throw ArithmeticException\n  }\n\n  val route: Route =\n    respondWithHeader(RawHeader(\"X-Outer-Header\", \"outer\")) { // will apply, since it gets the response from the handler\n      handleExceptions(myExceptionHandler) {\n        greetingRoutes ~ divideRoutes ~ respondWithHeader(RawHeader(\"X-Inner-Header\", \"inner\")) {\n          throw new Exception(\"Boom!\") //Will cause Internal server error,\n          // only ArithmeticExceptions are handled by myExceptionHandler.\n        }\n      }\n    }\n}\n\nobject MyApp extends App {\n  implicit val system = ActorSystem()\n\n  Http().newServerAt(\"localhost\", 8080).bind(route)\n} Java copysource import org.apache.pekko.actor.ActorSystem;\nimport org.apache.pekko.http.javadsl.Http;\nimport org.apache.pekko.http.javadsl.ServerBinding;\nimport org.apache.pekko.http.javadsl.model.HttpRequest;\nimport org.apache.pekko.http.javadsl.model.StatusCodes;\nimport org.apache.pekko.http.javadsl.model.headers.RawHeader;\nimport org.apache.pekko.http.javadsl.server.AllDirectives;\nimport org.apache.pekko.http.javadsl.server.ExceptionHandler;\nimport org.apache.pekko.http.javadsl.server.Route;\nimport org.apache.pekko.http.javadsl.testkit.JUnitRouteTest;\nimport org.apache.pekko.http.javadsl.testkit.TestRoute;\nimport org.apache.pekko.http.scaladsl.model.ErrorInfo;\nimport org.apache.pekko.http.scaladsl.model.IllegalHeaderException;\nimport org.junit.Test;\n\nimport java.io.IOException;\nimport java.util.concurrent.CompletionStage;\n\nimport static junit.framework.TestCase.assertTrue;\n\nclass RespondWithHeaderHandlerExample extends AllDirectives {\n    public static void main(String[] args) throws IOException {\n        final ActorSystem system = ActorSystem.create();\n        final Http http = Http.get(system);\n\n        final RespondWithHeaderHandlerExample app = new RespondWithHeaderHandlerExample();\n\n        final CompletionStage<ServerBinding> binding = http.newServerAt(\"localhost\", 8080).bind(app.createRoute());\n    }\n\n    public Route createRoute() {\n        final ExceptionHandler divByZeroHandler = ExceptionHandler.newBuilder()\n                .match(ArithmeticException.class, x ->\n                        complete(StatusCodes.BAD_REQUEST, \"Error! You tried to divide with zero!\"))\n                .build();\n\n        return respondWithHeader(RawHeader.create(\"X-Outer-Header\", \"outer\"), () -> //will apply for handled exceptions\n                handleExceptions(divByZeroHandler, () -> concat(\n                        path(\"greetings\", () -> complete(\"Hello!\")),\n                        path(\"divide\", () -> complete(\"Dividing with zero: \" + (1 / 0))),\n                        respondWithHeader(RawHeader.create(\"X-Inner-Header\", \"inner\"), () -> {\n                            // Will cause Internal server error,\n                            // only ArithmeticExceptions are handled by divByZeroHandler.\n                            throw new RuntimeException(\"Boom!\");\n                        })\n                ))\n        );\n    }\n}","title":"Respond with headers and Exception Handler"},{"location":"/routing-dsl/case-class-extraction.html","text":"This section is only relevant when using the Scala API\nCase Class Extraction The value extraction performed by Directives is a nice way of providing your route logic with interesting request properties, all with proper type-safety and error handling. However, in some case you might want even more. Consider this example: copysourcecase class Color(red: Int, green: Int, blue: Int)\n\nval route =\n  path(\"color\") {\n    parameters(\"red\".as[Int], \"green\".as[Int], \"blue\".as[Int]) { (red, green, blue) =>\n      val color = Color(red, green, blue)\n      // ... route working with the `color` instance\n    }\n  } Here the parameters directives is employed to extract three Int values, which are then used to construct an instance of the Color case class. So far so good. However, if the model classes we’d like to work with have more than just a few parameters the overhead introduced by capturing the arguments as extractions only to feed them into the model class constructor directly afterwards can somewhat clutter up your route definitions. If your model classes are case classes, as in our example, Apache Pekko HTTP supports an even shorter and more concise syntax. You can also write the example above like this: copysourcecase class Color(red: Int, green: Int, blue: Int)\n\nval route =\n  path(\"color\") {\n    parameters(\"red\".as[Int], \"green\".as[Int], \"blue\".as[Int]).as(Color.apply _) { color =>\n      // ... route working with the `color` instance\n    }\n  } You can postfix any directive with extractions with an as(...) call. By simply passing the companion object of your model case class to the as modifier method the underlying directive is transformed into an equivalent one, which extracts only one value of the type of your model class. Note that there is no reflection involved and your case class does not have to implement any special interfaces. The only requirement is that the directive you attach the as call to produces the right number of extractions, with the right types and in the right order. If you’d like to construct a case class instance from extractions produced by several directives you can first join the directives with the & operator before using the as call: copysourcecase class Color(name: String, red: Int, green: Int, blue: Int)\n\nval route =\n  (path(\"color\" / Segment) & parameters(\"r\".as[Int], \"g\".as[Int], \"b\".as[Int]))\n    .as(Color.apply _) { color =>\n      // ... route working with the `color` instance\n    } Here the Color class has gotten another member, name, which is supplied not as a parameter but as a path element. By joining the path and parameters directives with & you create a directive extracting 4 values, which directly fit the member list of the Color case class. Therefore you can use the as modifier to convert the directive into one extracting only a single Color instance. Generally, when you have routes that work with, say, more than 3 extractions it’s a good idea to introduce a case class for these and resort to case class extraction. Especially since it supports another nice feature: validation. Caution There is one quirk to look out for when using case class extraction: If you create an explicit companion object for your case class, no matter whether you actually add any members to it or not, the syntax presented above will not (quite) work anymore. Instead of as(Color) you will then have to say as(Color.apply). This behavior appears as if it’s not really intended, so this might be improved in future Scala versions. Case Class Validation In many cases your web service needs to verify input parameters according to some logic before actually working with them. E.g. in the example above the restriction might be that all color component values must be between 0 and 255. You could get this done with a few validate directives but this would quickly become cumbersome and hard to read. If you use case class extraction you can put the verification logic into the constructor of your case class, where it should be: copysourcecase class Color(name: String, red: Int, green: Int, blue: Int) {\n  require(!name.isEmpty, \"color name must not be empty\")\n  require(0 <= red && red <= 255, \"red color component must be between 0 and 255\")\n  require(0 <= green && green <= 255, \"green color component must be between 0 and 255\")\n  require(0 <= blue && blue <= 255, \"blue color component must be between 0 and 255\")\n} If you write your validations like this Apache Pekko HTTP’s case class extraction logic will properly pick up all error messages and generate a ValidationRejectionValidationRejection if something goes wrong. By default, ValidationRejections are converted into 400 Bad Request error response by the default RejectionHandler, if no subsequent route successfully handles the request.","title":"Case Class Extraction"},{"location":"/routing-dsl/source-streaming-support.html","text":"","title":"Source Streaming"},{"location":"/routing-dsl/source-streaming-support.html#source-streaming","text":"Apache Pekko HTTP supports completing a request with an Apache Pekko Source<T, ?>Source[T, _], which makes it possible to easily build and consume streaming end-to-end APIs which apply back pressure throughout the entire stack.\nIt is possible to complete requests with raw Source<ByteString, ?>Source[ByteString, _], however often it is more convenient to stream on an element-by-element basis, and allow Apache Pekko HTTP to handle the rendering internally - for example as a JSON array, or CSV stream (where each element is followed by a newline).\nIn the following sections we investigate how to make use of the JSON Streaming infrastructure, however the general hints apply to any kind of element-by-element streaming you could imagine.","title":"Source Streaming"},{"location":"/routing-dsl/source-streaming-support.html#json-streaming","text":"JSON Streaming is a term referring to streaming a (possibly infinite) stream of element as independent JSON objects as a continuous HTTP request or response. The elements are most often separated using newlines, however do not have to be. Concatenating elements side-by-side or emitting “very long” JSON array is also another use case.\nIn the below examples, we’ll be referring to the Tweet case class as our model, which is defined as:\nScala copysourcecase class Tweet(uid: Int, txt: String) Java copysourceprivate static final class JavaTweet {\n  private int id;\n  private String message;\n\n  public JavaTweet(int id, String message) {\n    this.id = id;\n    this.message = message;\n  }\n\n  public int getId() {\n    return id;\n  }\n\n  public void setId(int id) {\n    this.id = id;\n  }\n\n  public void setMessage(String message) {\n    this.message = message;\n  }\n\n  public String getMessage() {\n    return message;\n  }\n}\nAnd as always with spray-json, we provide our marshaller and unmarshaller instances as implicit values using the jsonFormat## method to generate them statically: Scala copysourceobject MyTweetJsonProtocol\n    extends pekko.http.scaladsl.marshallers.sprayjson.SprayJsonSupport\n    with spray.json.DefaultJsonProtocol {\n\n  implicit val tweetFormat = jsonFormat2(Tweet.apply)\n}","title":"JSON Streaming"},{"location":"/routing-dsl/source-streaming-support.html#responding-with-json-streams","text":"In this example we implement an API representing an infinite stream of tweets, very much like Twitter’s Streaming API.\nFirstly, we’ll need to get some additional marshalling infrastructure set up, that is able to marshal to and from an Apache Pekko Streams Source<T, ?>Source[T, _]. One such trait, containing the needed marshallers is SprayJsonSupport, which uses spray-json (a high performance JSON parser library), and is shipped as part of Apache Pekko HTTP in the pekko-http-spray-json module. Once the general infrastructure is prepared, we import our model’s marshallers, generated by spray-json (Step 1) and enable JSON Streaming by making an implicit EntityStreamingSupportEntityStreamingSupport instance available (Step 2). Apache Pekko HTTP pre-packages JSON and CSV entity streaming support, however it is simple to add your own, in case you’d like to stream a different content type (for example plists or protobuf).\nFirstly, we’ll need to get some additional marshalling infrastructure set up, that is able to marshal to and from an Apache Pekko Streams Source<T, ?>Source[T, ?]. Here we’ll use the Jackson helper class from pekko-http-jackson (a separate library that you should add as a dependency if you want to use Jackson with Apache Pekko HTTP). First we enable JSON Streaming by making an implicit EntityStreamingSupportEntityStreamingSupport instance available (Step 1). The default mode of rendering a SourceSource is to represent it as an JSON Array. If you want to change this representation for example to use Twitter style new-line separated JSON objects, you can do so by configuring the support trait accordingly. In Step 1.1. we demonstrate how to configure the rendering to be new-line separated, and also how parallel marshalling can be applied. We configure the Support object to render the JSON as series of new-line separated JSON objects, simply by appending a ByteString consisting of a single new-line character to each ByteString in the stream. Although this format is not valid JSON, it is pretty popular since parsing it is relatively simple - clients need only to find the new-lines and apply JSON unmarshalling for an entire line of JSON.\nThe final step is simply completing a request using a Source of tweets, as simple as that:\nScala copysource// [1] import \"my protocol\", for marshalling Tweet objects:\nimport MyTweetJsonProtocol._\n\n// [2] pick a Source rendering support trait:\n// Note that the default support renders the Source as JSON Array\nimplicit val jsonStreamingSupport: JsonEntityStreamingSupport = EntityStreamingSupport.json()\n\nval route =\n  path(\"tweets\") {\n    // [3] simply complete a request with a source of tweets:\n    val tweets: Source[Tweet, NotUsed] = getTweets\n    complete(tweets)\n  }\n\n// tests ------------------------------------------------------------\nval AcceptJson = Accept(MediaRange(MediaTypes.`application/json`))\nval AcceptXml = Accept(MediaRange(MediaTypes.`text/xml`))\n\nGet(\"/tweets\").withHeaders(AcceptJson) ~> route ~> check {\n  responseAs[String] shouldEqual\n  \"\"\"[\"\"\" +\n  \"\"\"{\"txt\":\"#Pekko rocks!\",\"uid\":1},\"\"\" +\n  \"\"\"{\"txt\":\"Streaming is so hot right now!\",\"uid\":2},\"\"\" +\n  \"\"\"{\"txt\":\"You cannot enter the same river twice.\",\"uid\":3}\"\"\" +\n  \"\"\"]\"\"\"\n}\n\n// endpoint can only marshal Json, so it will *reject* requests for application/xml:\nGet(\"/tweets\").withHeaders(AcceptXml) ~> route ~> check {\n  handled should ===(false)\n  rejection should ===(UnacceptedResponseContentTypeRejection(Set(ContentTypes.`application/json`)))\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.completeOKWithSource;\nimport static org.apache.pekko.http.javadsl.server.Directives.get;\nimport static org.apache.pekko.http.javadsl.server.Directives.parameter;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\n\n\n// Step 1: Enable JSON streaming\n// we're not using this in the example, but it's the simplest way to start:\n// The default rendering is a JSON array: `[el, el, el , ...]`\nfinal JsonEntityStreamingSupport jsonStreaming = EntityStreamingSupport.json();\n\n// Step 1.1: Enable and customise how we'll render the JSON, as a compact array:\nfinal ByteString start = ByteString.fromString(\"[\");\nfinal ByteString between = ByteString.fromString(\",\");\nfinal ByteString end = ByteString.fromString(\"]\");\nfinal Flow<ByteString, ByteString, NotUsed> compactArrayRendering =\n  Flow.of(ByteString.class).intersperse(start, between, end);\n\nfinal JsonEntityStreamingSupport compactJsonSupport = EntityStreamingSupport.json()\n  .withFramingRendererFlow(compactArrayRendering);\n\n\n// Step 2: implement the route\nfinal Route responseStreaming = path(\"tweets\", () ->\n  get(() ->\n    parameter(StringUnmarshallers.INTEGER, \"n\", n -> {\n      final Source<JavaTweet, NotUsed> tws =\n        Source.repeat(new JavaTweet(12, \"Hello World!\")).take(n);\n\n      // Step 3: call complete* with your source, marshaller, and stream rendering mode\n      return completeOKWithSource(tws, Jackson.marshaller(), compactJsonSupport);\n    })\n  )\n);\n// tests:\nfinal TestRoute routes = testRoute(tweets());\n\n// test happy path\nfinal Accept acceptApplication = Accept.create(MediaRanges.create(MediaTypes.APPLICATION_JSON));\nroutes.run(HttpRequest.GET(\"/tweets?n=2\").addHeader(acceptApplication))\n  .assertStatusCode(200)\n  .assertEntity(\"[{\\\"id\\\":12,\\\"message\\\":\\\"Hello World!\\\"},{\\\"id\\\":12,\\\"message\\\":\\\"Hello World!\\\"}]\");\n\n// test responses to potential errors\nfinal Accept acceptText = Accept.create(MediaRanges.ALL_TEXT);\nroutes.run(HttpRequest.GET(\"/tweets?n=3\").addHeader(acceptText))\n  .assertStatusCode(StatusCodes.NOT_ACCEPTABLE) // 406\n  .assertEntity(\"Resource representation is only available with these types:\\napplication/json\");\n// tests --------------------------------------------\nfinal TestRoute routes = testRoute(csvTweets());\n\n// test happy path\nfinal Accept acceptCsv = Accept.create(MediaRanges.create(MediaTypes.TEXT_CSV));\nroutes.run(HttpRequest.GET(\"/tweets?n=2\").addHeader(acceptCsv))\n  .assertStatusCode(200)\n  .assertEntity(\"12,Hello World!\\n\" +\n    \"12,Hello World!\\n\");\n\n// test responses to potential errors\nfinal Accept acceptText = Accept.create(MediaRanges.ALL_APPLICATION);\nroutes.run(HttpRequest.GET(\"/tweets?n=3\").addHeader(acceptText))\n  .assertStatusCode(StatusCodes.NOT_ACCEPTABLE) // 406\n  .assertEntity(\"Resource representation is only available with these types:\\ntext/csv; charset=UTF-8\");\nThe reason the EntityStreamingSupportEntityStreamingSupport has to be enabled explicitly is that one might want to configure how the stream should be rendered. We’ll discuss this in depth in the next section though.\nCustomising response rendering mode Since it is not always possible to directly and confidently answer the question of how a stream of T should look on the wire, the EntityStreamingSupportEntityStreamingSupport traits come into play and allow fine-tuning the stream’s rendered representation. For example, in case of JSON Streaming, there isn’t really one standard about rendering the response. Some APIs prefer to render multiple JSON objects in a line-by-line fashion (Twitter’s streaming APIs for example), while others simply return very large arrays, which could be streamed as well. Apache Pekko defaults to the second one (streaming a JSON Array), as it is correct JSON and clients not expecting a streaming API would still be able to consume it in a naive way if they’d want to. The line-by-line approach however is also pretty popular even though it is not valid JSON. Its simplicity for client-side parsing is a strong point in case to pick this format for your Streaming APIs. Below we demonstrate how to reconfigure the support trait to render the JSON line-by-line. Scala copysourceimport MyTweetJsonProtocol._\n\n// Configure the EntityStreamingSupport to render the elements as:\n// {\"example\":42}\n// {\"example\":43}\n// ...\n// {\"example\":1000}\nval newline = ByteString(\"\\n\")\n\nimplicit val jsonStreamingSupport = EntityStreamingSupport.json()\n  .withFramingRenderer(Flow[ByteString].map(bs => bs ++ newline))\n\nval route =\n  path(\"tweets\") {\n    // [3] simply complete a request with a source of tweets:\n    val tweets: Source[Tweet, NotUsed] = getTweets\n    complete(tweets)\n  }\n\n// tests ------------------------------------------------------------\nval AcceptJson = Accept(MediaRange(MediaTypes.`application/json`))\n\nGet(\"/tweets\").withHeaders(AcceptJson) ~> route ~> check {\n  responseAs[String] shouldEqual\n  \"\"\"{\"txt\":\"#Pekko rocks!\",\"uid\":1}\"\"\" + \"\\n\" +\n  \"\"\"{\"txt\":\"Streaming is so hot right now!\",\"uid\":2}\"\"\" + \"\\n\" +\n  \"\"\"{\"txt\":\"You cannot enter the same river twice.\",\"uid\":3}\"\"\" + \"\\n\"\n} Another interesting feature is parallel marshalling. Since marshalling can potentially take much time, it is possible to marshal multiple elements of the stream in parallel. This is simply a configuration option on EntityStreamingSupportEntityStreamingSupport and is configurable like this: Scala copysourceimport MyTweetJsonProtocol._\nimplicit val jsonStreamingSupport: JsonEntityStreamingSupport =\n  EntityStreamingSupport.json()\n    .withParallelMarshalling(parallelism = 8, unordered = false)\n\npath(\"tweets\") {\n  val tweets: Source[Tweet, NotUsed] = getTweets\n  complete(tweets)\n} The above shown mode preserves ordering of the Source’s elements, which may sometimes be a required property, for example when streaming a strictly ordered dataset. Sometimes the concept of strict order does not apply to the data being streamed, though, which allows us to exploit this property and use an unordered rendering. This unordered rendering can be enabled via a configuration option as shown below. Effectively, this allows Apache Pekko HTTP’s marshalling infrastructure to concurrently marshall up to as many elements as defined in parallelism and emit the first one which is marshalled into the HttpResponseHttpResponse: Scala copysourceimport MyTweetJsonProtocol._\nimplicit val jsonStreamingSupport: JsonEntityStreamingSupport =\n  EntityStreamingSupport.json()\n    .withParallelMarshalling(parallelism = 8, unordered = true)\n\npath(\"tweets\" / \"unordered\") {\n  val tweets: Source[Tweet, NotUsed] = getTweets\n  complete(tweets)\n} This allows us to potentially render elements faster into the HttpResponse, since it can avoid “head of line blocking”, in case one element in front of the stream takes a long time to marshall, yet others after it are very quick to marshall.","title":"Responding with JSON Streams"},{"location":"/routing-dsl/source-streaming-support.html#consuming-json-streaming-uploads","text":"Sometimes a client sends a streaming request. For example, an embedded device initiated a connection with the server and is feeding it with one line of measurement data.\nIn this example, we want to consume this data in a streaming fashion from the request entity and also apply back pressure to the underlying TCP connection should the server be unable to cope with the rate of incoming data. Back pressure is automatically applied thanks to Apache Pekko Streams.\nScala copysourcecase class Measurement(id: String, value: Int)\n\nobject MyMeasurementJsonProtocol\n    extends pekko.http.scaladsl.marshallers.sprayjson.SprayJsonSupport\n    with spray.json.DefaultJsonProtocol {\n\n  implicit val measurementFormat = jsonFormat2(Measurement.apply)\n} Java copysourceprivate static final class Measurement {\n  private String id;\n  private int value;\n\n  public Measurement(String id, int value) {\n    this.id = id;\n    this.value = value;\n  }\n\n  public String getId() {\n    return id;\n  }\n\n  public void setId(String id) {\n    this.id = id;\n  }\n\n  public void setValue(int value) {\n    this.value = value;\n  }\n\n  public int getValue() {\n    return value;\n  }\n}\n\nfinal Unmarshaller<ByteString, Measurement> Measurements = Jackson.byteStringUnmarshaller(Measurement.class);\nScala copysource// [1] import \"my protocol\", for unmarshalling Measurement objects:\nimport MyMeasurementJsonProtocol._\n\n// [2] enable Json Streaming\nimplicit val jsonStreamingSupport = EntityStreamingSupport.json()\n\n// prepare your persisting logic here\nval persistMetrics = Flow[Measurement]\n\nval route =\n  path(\"metrics\") {\n    // [3] extract Source[Measurement, _]\n    entity(asSourceOf[Measurement]) { measurements =>\n      // alternative syntax:\n      // entity(as[Source[Measurement, NotUsed]]) { measurements =>\n      val measurementsSubmitted: Future[Int] =\n        measurements\n          .via(persistMetrics)\n          .runFold(0) { (cnt, _) => cnt + 1 }\n\n      complete {\n        measurementsSubmitted.map(n => Map(\"msg\" -> s\"\"\"Total metrics received: $n\"\"\"))\n      }\n    }\n  }\n\n// tests ------------------------------------------------------------\n// uploading an array or newline separated values works out of the box\nval data = HttpEntity(\n  ContentTypes.`application/json`,\n  \"\"\"\n    |{\"id\":\"temp\",\"value\":32}\n    |{\"id\":\"temp\",\"value\":31}\n    |\n  \"\"\".stripMargin)\n\nPost(\"/metrics\", entity = data) ~> route ~> check {\n  status should ===(StatusCodes.OK)\n  responseAs[String] should ===(\"\"\"{\"msg\":\"Total metrics received: 2\"}\"\"\")\n}\n\n// the FramingWithContentType will reject any content type that it does not understand:\nval xmlData = HttpEntity(\n  ContentTypes.`text/xml(UTF-8)`,\n  \"\"\"|<data id=\"temp\" value=\"32\"/>\n     |<data id=\"temp\" value=\"31\"/>\"\"\".stripMargin)\n\nPost(\"/metrics\", entity = xmlData) ~> route ~> check {\n  handled should ===(false)\n  rejection should ===(\n    UnsupportedRequestContentTypeRejection(\n      Set(ContentTypes.`application/json`),\n      Some(ContentTypes.`text/xml(UTF-8)`)))\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.complete;\nimport static org.apache.pekko.http.javadsl.server.Directives.entityAsSourceOf;\nimport static org.apache.pekko.http.javadsl.server.Directives.extractMaterializer;\nimport static org.apache.pekko.http.javadsl.server.Directives.onComplete;\nimport static org.apache.pekko.http.javadsl.server.Directives.post;\n\nfinal Route incomingStreaming = path(\"metrics\", () ->\n  post(() ->\n    extractMaterializer(mat -> {\n        final JsonEntityStreamingSupport jsonSupport = EntityStreamingSupport.json();\n\n        return entityAsSourceOf(Measurements, jsonSupport, sourceOfMeasurements -> {\n          final CompletionStage<Integer> measurementCount = sourceOfMeasurements.runFold(0, (acc, measurement) -> acc + 1, mat);\n          return onComplete(measurementCount, c -> complete(\"Total number of measurements: \" + c));\n        });\n      }\n    )\n  )\n);","title":"Consuming JSON Streaming uploads"},{"location":"/routing-dsl/source-streaming-support.html#simple-csv-streaming-example","text":"Apache Pekko HTTP provides another EntityStreamingSupportEntityStreamingSupport out of the box, namely csv (comma-separated values). For completeness, we demonstrate its usage in the snippet below. As you’ll notice, switching between streaming modes is fairly simple: You only have to make sure that an implicit MarshallerMarshaller of the requested type is available and that the streaming support operates on the same Content-Type as the rendered values. Otherwise, you’ll see an error during runtime that the marshaller did not expose the expected content type and thus we can’t render the streaming response).\nScala copysource// [1] provide a marshaller to ByteString\nimplicit val tweetAsCsv = Marshaller.strict[Tweet, ByteString] { t =>\n  Marshalling.WithFixedContentType(ContentTypes.`text/csv(UTF-8)`,\n    () => {\n      val txt = t.txt.replaceAll(\",\", \".\")\n      val uid = t.uid.toString\n      ByteString(List(uid, txt).mkString(\",\"))\n    })\n}\n\n// [2] enable csv streaming:\nimplicit val csvStreaming = EntityStreamingSupport.csv()\n\nval route =\n  path(\"tweets\") {\n    val tweets: Source[Tweet, NotUsed] = getTweets\n    complete(tweets)\n  }\n\n// tests ------------------------------------------------------------\nval AcceptCsv = Accept(MediaRange(MediaTypes.`text/csv`))\n\nGet(\"/tweets\").withHeaders(AcceptCsv) ~> route ~> check {\n  responseAs[String] shouldEqual\n  \"1,#Pekko rocks!\" + \"\\n\" +\n  \"2,Streaming is so hot right now!\" + \"\\n\" +\n  \"3,You cannot enter the same river twice.\" + \"\\n\"\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.get;\nimport static org.apache.pekko.http.javadsl.server.Directives.path;\nimport static org.apache.pekko.http.javadsl.server.Directives.completeWithSource;\n\nfinal Marshaller<JavaTweet, ByteString> renderAsCsv =\n  Marshaller.withFixedContentType(ContentTypes.TEXT_CSV_UTF8, t ->\n    ByteString.fromString(t.getId() + \",\" + t.getMessage())\n  );\n\nfinal CsvEntityStreamingSupport compactJsonSupport = EntityStreamingSupport.csv();\n\nfinal Route responseStreaming = path(\"tweets\", () ->\n  get(() ->\n    parameter(StringUnmarshallers.INTEGER, \"n\", n -> {\n      final Source<JavaTweet, NotUsed> tws =\n        Source.repeat(new JavaTweet(12, \"Hello World!\")).take(n);\n      return completeWithSource(tws, renderAsCsv, compactJsonSupport);\n    })\n  )\n);","title":"Simple CSV streaming example"},{"location":"/routing-dsl/source-streaming-support.html#implementing-custom-entitystreamingsupport-traits","text":"The EntityStreamingSupportEntityStreamingSupport infrastructure is open for extension and not bound to any single format, content type, or marshalling library. The provided JSON support does not rely on spray-json directly, but uses Marshaller<T, ByteString>Marshaller[T, ByteString] instances, which can be provided using any JSON marshalling library (such as Circe, Jawn or Play JSON).\nWhen implementing a custom support trait, one should simply extend the EntityStreamingSupportEntityStreamingSupport abstract class and implement all of its methods. It’s best to use the existing implementations as a guideline.","title":"Implementing custom EntityStreamingSupport traits"},{"location":"/routing-dsl/source-streaming-support.html#supporting-custom-content-types","text":"In order to marshal into custom content types, both a MarshallerMarshaller that can handle that content type as well as an EntityStreamingSupportEntityStreamingSupport of matching content type is required.\nRefer to the complete example below, showcasing how to configure a custom marshaller and change the entity streaming support’s content type to be compatible. This is an area that would benefit from additional type safety, which we hope to add in a future release.\nScala copysourceimport org.apache.pekko\nimport pekko.NotUsed\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.common.{ EntityStreamingSupport, JsonEntityStreamingSupport }\nimport pekko.http.scaladsl.model.{ HttpEntity, _ }\nimport pekko.http.scaladsl.server.Directives._\nimport pekko.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._\nimport pekko.http.scaladsl.marshalling.{ Marshaller, ToEntityMarshaller }\nimport pekko.stream.scaladsl.Source\nimport spray.json.DefaultJsonProtocol\n\nimport scala.io.StdIn\nimport scala.util.Random\n\nfinal case class User(name: String, id: String)\n\ntrait UserProtocol extends DefaultJsonProtocol {\n\n  import spray.json._\n\n  implicit val userFormat = jsonFormat2(User)\n\n  val `vnd.example.api.v1+json` =\n    MediaType.applicationWithFixedCharset(\"vnd.example.api.v1+json\", HttpCharsets.`UTF-8`)\n  val ct = ContentType.apply(`vnd.example.api.v1+json`)\n\n  implicit def userMarshaller: ToEntityMarshaller[User] = Marshaller.oneOf(\n    Marshaller.withFixedContentType(`vnd.example.api.v1+json`) { organisation =>\n      HttpEntity(`vnd.example.api.v1+json`, organisation.toJson.compactPrint)\n    })\n}\n\nobject ApiServer extends App with UserProtocol {\n  implicit val system = ActorSystem(\"api\")\n  implicit val executionContext = system.dispatcher\n\n  implicit val jsonStreamingSupport: JsonEntityStreamingSupport = EntityStreamingSupport.json()\n    .withContentType(ct)\n    .withParallelMarshalling(parallelism = 10, unordered = false)\n\n  // (fake) async database query api\n  def dummyUser(id: String) = User(s\"User $id\", id.toString)\n\n  def fetchUsers(): Source[User, NotUsed] = Source.fromIterator(() =>\n    Iterator.fill(10000) {\n      val id = Random.nextInt()\n      dummyUser(id.toString)\n    })\n\n  val route =\n    pathPrefix(\"users\") {\n      get {\n        complete(fetchUsers())\n      }\n    }\n\n  val bindingFuture = Http().newServerAt(\"localhost\", 8080).bind(route)\n\n  println(s\"Server online at http://localhost:8080/\\nPress RETURN to stop...\")\n  StdIn.readLine()\n  bindingFuture.flatMap(_.unbind()).onComplete(_ => system.terminate())\n}\n Java copysourceimport org.apache.pekko.NotUsed;\nimport org.apache.pekko.actor.ActorSystem;\nimport org.apache.pekko.http.javadsl.Http;\nimport org.apache.pekko.http.javadsl.common.EntityStreamingSupport;\nimport org.apache.pekko.http.javadsl.marshalling.Marshaller;\nimport org.apache.pekko.http.javadsl.model.*;\nimport org.apache.pekko.http.javadsl.server.AllDirectives;\nimport org.apache.pekko.http.javadsl.server.Route;\nimport org.apache.pekko.stream.javadsl.Source;\n\nimport java.util.Random;\nimport java.util.stream.Stream;\n\npublic class JsonStreamingFullExample extends AllDirectives {\n\n    public Route createRoute() {\n        final MediaType.WithFixedCharset mediaType =\n                MediaTypes.applicationWithFixedCharset(\"vnd.example.api.v1+json\", HttpCharsets.UTF_8);\n\n        final ContentType.WithFixedCharset contentType = ContentTypes.create(mediaType);\n\n        final Marshaller<User, RequestEntity> userMarshaller =\n                Marshaller.withFixedContentType(contentType, (User user) -> HttpEntities.create(contentType, user.toJson()));\n\n        final EntityStreamingSupport jsonStreamingSupport = EntityStreamingSupport.json()\n                .withContentType(contentType)\n                .withParallelMarshalling(10, false);\n\n        return get(() ->\n                pathPrefix(\"users\", () ->\n                        completeOKWithSource(fetchUsers(), userMarshaller, jsonStreamingSupport)\n                )\n        );\n    }\n\n    private Source<User, NotUsed> fetchUsers() {\n        final Random rnd = new Random();\n        return Source.fromIterator(() -> Stream.generate(rnd::nextInt).map(this::dummyUser).limit(10000).iterator());\n    }\n\n    private User dummyUser(int id) {\n        return new User(id, \"User \" + id);\n    }\n\n    static final class User {\n        int id;\n        String name;\n\n        User(int id, String name) {\n            this.id = id;\n            this.name = name;\n        }\n\n        String toJson() {\n            return \"{\\\"id\\\":\\\"\" + id + \"\\\", \\\"name\\\":\\\"\" + name + \"\\\"}\";\n        }\n    }\n\n    public static void main(String[] args) {\n        ActorSystem system = ActorSystem.create();\n        final JsonStreamingFullExample app = new JsonStreamingFullExample();\n        final Http http = Http.get(system);\n\n        http.newServerAt(\"localhost\", 8080).bind(app.createRoute());\n    }\n}","title":"Supporting custom content types"},{"location":"/routing-dsl/source-streaming-support.html#consuming-streaming-json-on-client-side","text":"For consuming such streaming APIs with, for example, JSON responses refer to Consuming JSON Streaming style APIs documentation in the JSON support section.","title":"Consuming streaming JSON on client-side"},{"location":"/routing-dsl/style-guide.html","text":"","title":"Routing DSL style guide"},{"location":"/routing-dsl/style-guide.html#routing-dsl-style-guide","text":"Apache Pekko HTTP’s routing DSL is at the center of most Apache Pekko HTTP-based servers. It’s where the incoming requests diverge into the different parts of the implemented services.\nKeeping all routing in one big structure will easily become hard to grasp and maintain. This page gives a few hints for how you may want to break down the routing logic.","title":"Routing DSL style guide"},{"location":"/routing-dsl/style-guide.html#main-recommendations","text":"Most Routes consist of multiple Routes in themselves, isolate them into values or methods. Directives combine into other directives, isolate repeated combinations into values. Keep the most static part of a route outermost (eg. the fixed path segments), end with the HTTP methods. Encapsulate patterns you want to establish into helpers.","title":"Main recommendations"},{"location":"/routing-dsl/style-guide.html#structure","text":"","title":"Structure"},{"location":"/routing-dsl/style-guide.html#routes-are-built-out-of-directives","text":"Think of a route as a function describing how an incoming request maps to a reply (technically RequestContext => Future[RouteResult]RequestContext -> CompletionStage<RouteResult>) (see Routes). A route is expressed in directives. Directives compose into new directives (see Composing directives).","title":"Routes are built out of directives"},{"location":"/routing-dsl/style-guide.html#paths","text":"Keep the most static part of a route outermost (eg. the fixed path segments), end with the HTTP methods.\nScala copysource// prefer\nval prefer = path(\"item\" / \"listing\") & get\n// over\nval over = get & path(\"item\" / \"listing\") Java copysourceimport static org.apache.pekko.http.javadsl.server.PathMatchers.*;\nimport static org.apache.pekko.http.javadsl.server.Directives.*;\n\nimport org.apache.pekko.http.javadsl.server.Route;\n\n// prefer\nRoute prefer =\n    path(segment(\"item\").slash(\"listing\"), () ->\n        get(() ->\n            complete(\"\")\n        )\n    );\n// over\nRoute over =\n    get(() ->\n        path(segment(\"item\").slash(\"listing\"), () ->\n            complete(\"\")\n        )\n    );\nGroup routes with a pathPrefix where possible, use path for the last bit.\nScala copysource// prefer\nval prefer =\n  pathPrefix(\"item\") {\n    concat(\n      path(\"listing\") {\n        get {\n          complete(\"\")\n        }\n      },\n      path(\"show\" / Segment) { itemId =>\n        get {\n          complete(\"\")\n        }\n      })\n  }\n// over\nval over: Route =\n  concat(\n    path(\"item\" / \"listing\") {\n      get {\n        complete(\"\")\n      }\n    },\n    path(\"item\" / \"show\" / Segment) { itemId =>\n      get {\n        complete(\"\")\n      }\n    }) Java copysourceimport static org.apache.pekko.http.javadsl.server.PathMatchers.*;\nimport static org.apache.pekko.http.javadsl.server.Directives.*;\n\nimport org.apache.pekko.http.javadsl.server.Route;\n\n// prefer\nRoute prefer =\n    pathPrefix(\"item\", () ->\n        concat(\n            path(\"listing\", () ->\n                get(() ->\n                    complete(\"\")\n                )\n            ),\n            path(segment(\"show\").slash(segment()), itemId ->\n                get(() ->\n                    complete(\"\")\n                )\n            )\n        )\n    );\n// over\nRoute over = concat(\n    path(segment(\"item\").slash(\"listing\"), () ->\n        get(() ->\n            complete(\"\")\n        )),\n    path(segment(\"item\").slash(\"show\").slash(segment()), itemId ->\n        get(() ->\n            complete(\"\")\n        )\n    )\n);\nCreate “sub-routes” independently and stitch them together with their prefixes.\nScala copysource// prefer\n// 1. First, create partial matchers (with a relative path)\nval itemRoutes: Route =\n  concat(\n    path(\"listing\") {\n      get {\n        complete(\"\")\n      }\n    },\n    path(\"show\" / Segment) { itemId =>\n      get {\n        complete(\"\")\n      }\n    })\n\nval customerRoutes: Route =\n  concat(\n    path(IntNumber) { customerId =>\n      complete(\"\")\n    }\n    // ...\n  )\n\n// 2. Then compose the relative routes under their corresponding path prefix\nval prefer: Route =\n  concat(\n    pathPrefix(\"item\")(itemRoutes),\n    pathPrefix(\"customer\")(customerRoutes))\n\n// over\nval over: Route =\n  concat(\n    pathPrefix(\"item\") {\n      concat(\n        path(\"listing\") {\n          get {\n            complete(\"\")\n          }\n        },\n        path(\"show\" / Segment) { itemId =>\n          get {\n            complete(\"\")\n          }\n        })\n    },\n    pathPrefix(\"customer\") {\n      concat(\n        path(IntNumber) { customerId =>\n          complete(\"\")\n        }\n        // ...\n      )\n    }) Java copysourceimport static org.apache.pekko.http.javadsl.server.PathMatchers.*;\nimport static org.apache.pekko.http.javadsl.server.Directives.*;\n\nimport org.apache.pekko.http.javadsl.server.Route;\n\n// prefer\n// 1. First, create partial matchers (with a relative path)\nRoute itemRoutes =\n    concat(\n        path(\"listing\", () ->\n            get(() ->\n                complete(\"\")\n            )\n        ),\n        path(segment(\"show\").slash(segment()), itemId ->\n            get(() ->\n                complete(\"\")\n            )\n        )\n    );\n\nRoute customerRoutes =\n    concat(\n        path(integerSegment(), customerId ->\n            complete(\"\")\n        )\n        // ...\n    );\n\n// 2. Then compose the relative routes under their corresponding path prefix\nRoute prefer =\n    concat(\n        pathPrefix(\"item\", () -> itemRoutes),\n        pathPrefix(\"customer\", () -> customerRoutes)\n    );\n\n// over\nRoute over = concat(\n    pathPrefix(\"item\", () ->\n        concat(\n            path(\"listing\", () ->\n                get(() ->\n                    complete(\"\")\n                )\n            ),\n            path(segment(\"show\").slash(segment()), itemId ->\n                get(() ->\n                    complete(\"\")\n                )\n            )\n        )\n    ),\n    pathPrefix(\"customer\", () ->\n        concat(\n            path(integerSegment(), customerId ->\n                complete(\"\")\n            )\n            // ...\n        )\n    )\n);","title":"Paths"},{"location":"/routing-dsl/style-guide.html#directives","text":"If you find yourself repeating certain directives in combination at lot, combine them to a new directive. Directives that extract values always produce a tuple.\nScala copysourceval useCustomerIdForResponse: Long => Route = customerId => complete(customerId.toString)\nval completeWithResponse: Route = complete(\"\")\n\n// prefer\nval getOrPost: Directive0 = get | post\nval withCustomerId: Directive1[Long] =\n  parameter(\"customerId\".as[Long])\n\nval prefer: Route =\n  concat(\n    pathPrefix(\"data\") {\n      concat(\n        path(\"customer\") {\n          withCustomerId(useCustomerIdForResponse)\n        },\n        path(\"engagement\") {\n          withCustomerId(useCustomerIdForResponse)\n        })\n    },\n    pathPrefix(\"pages\") {\n      concat(\n        path(\"page1\") {\n          getOrPost(completeWithResponse)\n        },\n        path(\"page2\") {\n          getOrPost(completeWithResponse)\n        })\n    })\n// over\nval over: Route =\n  concat(\n    pathPrefix(\"data\") {\n      concat(\n        (pathPrefix(\"customer\") & parameter(\"customerId\".as[Long])) { customerId =>\n          useCustomerIdForResponse(customerId)\n        },\n        (pathPrefix(\"engagement\") & parameter(\"customerId\".as[Long])) { customerId =>\n          useCustomerIdForResponse(customerId)\n        })\n    },\n    pathPrefix(\"pages\") {\n      concat(\n        path(\"page1\") {\n          concat(\n            get {\n              complete(\"\")\n            },\n            post {\n              complete(\"\")\n            })\n        },\n        path(\"page2\") {\n          (get | post) {\n            complete(\"\")\n          }\n        })\n    }) Java copysourceimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport org.apache.pekko.http.javadsl.unmarshalling.StringUnmarshallers;\n\n// prefer\nRoute getOrPost(Supplier<Route> inner) {\n    return get(inner)\n        .orElse(post(inner));\n}\n\nRoute withCustomerId(Function<Long, Route> useCustomerId) {\n    return parameter(StringUnmarshallers.LONG, \"customerId\", useCustomerId);\n}\n\n    Function<Long, Route> useCustomerIdForResponse = (customerId) -> complete(customerId.toString());\n    Supplier<Route> completeWithResponse = () -> complete(\"\");\n\n    Route prefer =\n        concat(\n            pathPrefix(\"data\", () ->\n                concat(\n                    path(\"customer\", () ->\n                        withCustomerId(useCustomerIdForResponse)\n                    ),\n                    path(\"engagement\", () ->\n                        withCustomerId(useCustomerIdForResponse)\n                    )\n                )\n            ),\n            pathPrefix(\"pages\", () ->\n                concat(\n                    path(\"page1\", () ->\n                        getOrPost(completeWithResponse)\n                    ),\n                    path(\"page2\", () ->\n                        getOrPost(completeWithResponse)\n                    )\n                )\n            )\n        );\n    // over\n    Route over =\n        concat(\n            pathPrefix(\"data\", () ->\n                concat(\n                    pathPrefix(\"customer\", () ->\n                        parameter(StringUnmarshallers.LONG, \"customerId\", customerId ->\n                            complete(customerId.toString())\n                        )\n                    ),\n                    pathPrefix(\"engagement\", () ->\n                        parameter(StringUnmarshallers.LONG, \"customerId\", customerId ->\n                            complete(customerId.toString())\n                        )\n                    )\n                )\n            ),\n            pathPrefix(\"pages\", () ->\n                concat(\n                    path(\"page1\", () ->\n                        concat(\n                            get(() ->\n                                complete(\"\")\n                            ),\n                            post(() ->\n                                complete(\"\")\n                            )\n                        )\n                    ),\n                    path(\"page2\", () ->\n                        get(() ->\n                            complete(\"\")\n                        ).orElse(post(() ->\n                            complete(\"\")))\n                    )\n                )\n            )\n        );","title":"Directives"},{"location":"/routing-dsl/testkit.html","text":"","title":"Route TestKit"},{"location":"/routing-dsl/testkit.html#route-testkit","text":"One of Apache Pekko HTTP’s design goals is good testability of the created services. For services built with the Routing DSL Apache Pekko HTTP provides a dedicated testkit that makes efficient testing of route logic easy and convenient. This “route test DSL” is made available with the pekko-http-testkit module.","title":"Route TestKit"},{"location":"/routing-dsl/testkit.html#dependency","text":"To use Apache Pekko HTTP TestKit, add the module to your project:\nsbt val PekkoVersion = \"0.0.0+26602-317cbb52-SNAPSHOT\"\nval PekkoHttpVersion = \"0.0.0+4308-98f0ff9c-SNAPSHOT\"\nlibraryDependencies ++= Seq(\n  \"org.apache.pekko\" %% \"pekko-stream-testkit\" % PekkoVersion,\n  \"org.apache.pekko\" %% \"pekko-http-testkit\" % PekkoHttpVersion\n) Gradle def versions = [\n  PekkoVersion: \"0.0.0+26602-317cbb52-SNAPSHOT\",\n  ScalaBinary: \"2.13\"\n]\ndependencies {\n  implementation platform(\"org.apache.pekko:pekko-http-bom_${versions.ScalaBinary}:0.0.0+4308-98f0ff9c-SNAPSHOT\")\n\n  implementation \"org.apache.pekko:pekko-stream-testkit_${versions.ScalaBinary}:${versions.PekkoVersion}\"\n  implementation \"org.apache.pekko:pekko-http-testkit_${versions.ScalaBinary}\"\n} Maven <properties>\n  <pekko.version>0.0.0+26602-317cbb52-SNAPSHOT</pekko.version>\n  <scala.binary.version>2.13</scala.binary.version>\n</properties>\n<dependencyManagement>\n  <dependencies>\n    <dependency>\n      <groupId>org.apache.pekko</groupId>\n      <artifactId>pekko-http-bom_${scala.binary.version}</artifactId>\n      <version>0.0.0+4308-98f0ff9c-SNAPSHOT</version>\n      <type>pom</type>\n      <scope>import</scope>\n    </dependency>\n  </dependencies>\n</dependencyManagement>\n<dependencies>\n  <dependency>\n    <groupId>org.apache.pekko</groupId>\n    <artifactId>pekko-stream-testkit_${scala.binary.version}</artifactId>\n    <version>${pekko.version}</version>\n  </dependency>\n  <dependency>\n    <groupId>org.apache.pekko</groupId>\n    <artifactId>pekko-http-testkit_${scala.binary.version}</artifactId>\n  </dependency>\n</dependencies>","title":"Dependency"},{"location":"/routing-dsl/testkit.html#usage","text":"Here is an example of what a simple test with the routing testkit might look like using the built-in support for scalatest and specs2: ScalaTest copysourceimport org.apache.pekko\nimport pekko.http.scaladsl.model.StatusCodes\nimport pekko.http.scaladsl.testkit.ScalatestRouteTest\nimport pekko.http.scaladsl.server._\nimport Directives._\nimport org.scalatest.matchers.should.Matchers\nimport org.scalatest.wordspec.AnyWordSpec\n\nclass FullTestKitExampleSpec extends AnyWordSpec with Matchers with ScalatestRouteTest {\n\n  val smallRoute =\n    get {\n      concat(\n        pathSingleSlash {\n          complete {\n            \"Captain on the bridge!\"\n          }\n        },\n        path(\"ping\") {\n          complete(\"PONG!\")\n        })\n    }\n\n  \"The service\" should {\n\n    \"return a greeting for GET requests to the root path\" in {\n      // tests:\n      Get() ~> smallRoute ~> check {\n        responseAs[String] shouldEqual \"Captain on the bridge!\"\n      }\n    }\n\n    \"return a 'PONG!' response for GET requests to /ping\" in {\n      // tests:\n      Get(\"/ping\") ~> smallRoute ~> check {\n        responseAs[String] shouldEqual \"PONG!\"\n      }\n    }\n\n    \"leave GET requests to other paths unhandled\" in {\n      // tests:\n      Get(\"/kermit\") ~> smallRoute ~> check {\n        handled shouldBe false\n      }\n    }\n\n    \"return a MethodNotAllowed error for PUT requests to the root path\" in {\n      // tests:\n      Put() ~> Route.seal(smallRoute) ~> check {\n        status shouldEqual StatusCodes.MethodNotAllowed\n        responseAs[String] shouldEqual \"HTTP method not allowed, supported methods: GET\"\n      }\n    }\n  }\n} specs2 copysourceimport org.specs2.mutable.Specification\nimport org.apache.pekko\nimport pekko.http.scaladsl.model.StatusCodes\nimport pekko.http.scaladsl.testkit.Specs2RouteTest\nimport pekko.http.scaladsl.server._\nimport Directives._\n\nclass FullSpecs2TestKitExampleSpec extends Specification with Specs2RouteTest {\n\n  val smallRoute =\n    get {\n      concat(\n        pathSingleSlash {\n          complete {\n            \"Captain on the bridge!\"\n          }\n        },\n        path(\"ping\") {\n          complete(\"PONG!\")\n        })\n    }\n\n  \"The service\" should {\n\n    \"return a greeting for GET requests to the root path\" in {\n      // tests:\n      Get() ~> smallRoute ~> check {\n        responseAs[String] shouldEqual \"Captain on the bridge!\"\n      }\n    }\n\n    \"return a 'PONG!' response for GET requests to /ping\" in {\n      // tests:\n      Get(\"/ping\") ~> smallRoute ~> check {\n        responseAs[String] shouldEqual \"PONG!\"\n      }\n    }\n\n    \"leave GET requests to other paths unhandled\" in {\n      // tests:\n      Get(\"/kermit\") ~> smallRoute ~> check {\n        handled should beFalse\n      }\n    }\n\n    \"return a MethodNotAllowed error for PUT requests to the root path\" in {\n      // tests:\n      Put() ~> Route.seal(smallRoute) ~> check {\n        status shouldEqual StatusCodes.MethodNotAllowed\n        responseAs[String] shouldEqual \"HTTP method not allowed, supported methods: GET\"\n      }\n    }\n  }\n} The basic structure of a test built with the testkit is this (expression placeholder in all-caps): REQUEST ~> ROUTE ~> check {\n  ASSERTIONS\n}\n In this template REQUEST is an expression evaluating to an HttpRequestHttpRequest instance. In most cases your test will, in one way or another, extend from RouteTestRouteTest which itself mixes in the org.apache.pekko.http.scaladsl.client.RequestBuilding trait, which gives you a concise and convenient way of constructing test requests. [1] ROUTE is an expression evaluating to a Route. You can specify one inline or simply refer to the route structure defined in your service. The final element of the ~> chain is a check call, which takes a block of assertions as parameter. In this block you define your requirements onto the result produced by your route after having processed the given request. Typically you use one of the defined “inspectors” to retrieve a particular element of the routes response and express assertions against it using the test DSL provided by your test framework. For example, with scalatest, in order to verify that your route responds to the request with a status 200 response, you’d use the status inspector and express an assertion like this: status shouldEqual 200\n The following inspectors are defined: Table of Inspectors Inspector Description charset: HttpCharset Identical to contentType.charset chunks: Seq[HttpEntity.ChunkStreamPart] Returns the entity chunks produced by the route. If the entity is not chunked returns Nil. closingExtension: String Returns chunk extensions the route produced with its last response chunk. If the response entity is unchunked returns the empty string. contentType: ContentType Identical to responseEntity.contentType definedCharset: Option[HttpCharset] Identical to contentType.definedCharset entityAs[T :FromEntityUnmarshaller]: T Unmarshals the response entity using the in-scope FromEntityUnmarshaller for the given type. Any errors in the process trigger a test failure. handled: Boolean Indicates whether the route produced an HttpResponseHttpResponse for the request. If the route rejected the request handled evaluates to false. header(name: String): Option[HttpHeader] Returns the response header with the given name or None if no such header is present in the response. header[T <: HttpHeader]: Option[T] Identical to response.header[T] headers: Seq[HttpHeader] Identical to response.headers mediaType: MediaType Identical to contentType.mediaType rejection: Rejection The rejection produced by the route. If the route did not produce exactly one rejection a test failure is triggered. rejections: Seq[Rejection] The rejections produced by the route. If the route did not reject the request a test failure is triggered. response: HttpResponse The HttpResponseHttpResponse returned by the route. If the route did not return an HttpResponseHttpResponse instance (e.g. because it rejected the request) a test failure is triggered. responseAs[T: FromResponseUnmarshaller]: T Unmarshals the response entity using the in-scope FromResponseUnmarshaller for the given type. Any errors in the process trigger a test failure. responseEntity: HttpEntity Returns the response entity. status: StatusCode Identical to response.status trailer: Seq[HttpHeader] Returns the list of trailer headers the route produced with its last chunk. If the response entity is unchunked returns Nil. [1] If the request URI is relative it will be made absolute using an implicitly available instance of DefaultHostInfo whose value is “http://example.com” by default. This mirrors the behavior of pekko-http-core which always produces absolute URIs for incoming request based on the request URI and the Host-header of the request. You can customize this behavior by bringing a custom instance of DefaultHostInfo into scope.\nTo use the testkit you need to take these steps: add a dependency to the pekko-http-testkit module derive the test class from JUnitRouteTest wrap the route under test with RouteTest.testRoute to create a TestRoute run requests against the route using TestRoute.run(request) which will return a TestResponse use the methods of TestResponse to assert on properties of the response Example To see the testkit in action consider the following simple calculator app service: Java copysource import org.apache.pekko.actor.ActorSystem;\nimport org.apache.pekko.http.javadsl.Http;\nimport org.apache.pekko.http.javadsl.server.AllDirectives;\nimport org.apache.pekko.http.javadsl.server.Route;\nimport org.apache.pekko.http.javadsl.server.examples.simple.SimpleServerApp;\nimport org.apache.pekko.http.javadsl.unmarshalling.StringUnmarshallers;\n\nimport java.io.IOException;\n\npublic class MyAppService extends AllDirectives {\n\n  public String add(double x, double y) {\n    return \"x + y = \" + (x + y);\n  }\n\n  public Route createRoute() {\n    return\n      get(() ->\n        pathPrefix(\"calculator\", () ->\n          path(\"add\", () ->\n            parameter(StringUnmarshallers.DOUBLE, \"x\", x ->\n              parameter(StringUnmarshallers.DOUBLE, \"y\", y ->\n                complete(add(x, y))\n              )\n            )\n          )\n        )\n      );\n  }\n\n  public static void main(String[] args) throws IOException {\n    final ActorSystem system = ActorSystem.create();\n\n    final SimpleServerApp app = new SimpleServerApp();\n\n    Http.get(system).newServerAt(\"127.0.0.1\", 8080).bind(app.createRoute());\n\n    System.console().readLine(\"Type RETURN to exit...\");\n    system.terminate();\n  }\n} MyAppService extends from AllDirectives which brings all of the directives into scope. We define a method called createRoute that provides the routes to serve to bind. Here’s how you would test that service: Java copysourceimport org.apache.pekko.http.javadsl.model.HttpRequest;\nimport org.apache.pekko.http.javadsl.model.StatusCodes;\nimport org.apache.pekko.http.javadsl.testkit.JUnitRouteTest;\nimport org.apache.pekko.http.javadsl.testkit.TestRoute;\nimport org.junit.Test;\n\npublic class TestkitExampleTest extends JUnitRouteTest {\n    TestRoute appRoute = testRoute(new MyAppService().createRoute());\n\n    @Test\n    public void testCalculatorAdd() {\n        // test happy path\n        appRoute.run(HttpRequest.GET(\"/calculator/add?x=4.2&y=2.3\"))\n            .assertStatusCode(200)\n            .assertEntity(\"x + y = 6.5\");\n\n        // test responses to potential errors\n        appRoute.run(HttpRequest.GET(\"/calculator/add?x=3.2\"))\n            .assertStatusCode(StatusCodes.NOT_FOUND) // 404\n            .assertEntity(\"Request is missing required query parameter 'y'\");\n\n        // test responses to potential errors\n        appRoute.run(HttpRequest.GET(\"/calculator/add?x=3.2&y=three\"))\n            .assertStatusCode(StatusCodes.BAD_REQUEST)\n            .assertEntity(\"The query parameter 'y' was malformed:\\n\" +\n                    \"'three' is not a valid 64-bit floating point value\");\n    }\n} Writing Asserting against the HttpResponse The testkit supports a fluent DSL to write compact assertions on the response by chaining assertions using “dot-syntax”. To simplify working with streamed responses the entity of the response is first “strictified”, i.e. entity data is collected into a single ByteStringByteString and provided the entity is supplied as an HttpEntityStrict. This allows to write several assertions against the same entity data which wouldn’t (necessarily) be possible for the streamed version. All of the defined assertions provide HTTP specific error messages aiding in diagnosing problems. Currently, these methods are defined on TestResponse to assert on the response: Inspector Description assertStatusCode(int expectedCode) Asserts that the numeric response status code equals the expected one assertStatusCode(StatusCode expectedCode) Asserts that the response StatusCodeStatusCode equals the expected one assertMediaType(String expectedType) Asserts that the media type part of the response’s content type matches the given String assertMediaType(MediaType expectedType) Asserts that the media type part of the response’s content type matches the given MediaTypeMediaType assertEntity(String expectedStringContent) Asserts that the entity data interpreted as UTF8 equals the expected String assertEntityBytes(ByteString expectedBytes) Asserts that the entity data bytes equal the expected ones assertEntityAs(Unmarshaller<T> unmarshaller, expectedValue: T) Asserts that the entity data if unmarshalled with the given marshaller equals the given value assertHeaderExists(HttpHeader expectedHeader) Asserts that the response contains an HttpHeader instance equal to the expected one assertHeaderKindExists(String expectedHeaderName) Asserts that the response contains a header with the expected name assertHeader(String name, String expectedValue) Asserts that the response contains a header with the given name and value. It’s, of course, possible to use any other means of writing assertions by inspecting the properties the response manually. As written above, TestResponse.entity and TestResponse.response return strict versions of the entity data. Supporting Custom Test Frameworks Adding support for a custom test framework is achieved by creating new superclass analogous to JUnitRouteTest for writing tests with the custom test framework deriving from org.apache.pekko.http.javadsl.testkit.RouteTest and implementing its abstract methods. This will allow users of the test framework to use testRoute and to write assertions using the assertion methods defined on TestResponse.","title":"Usage"},{"location":"/routing-dsl/testkit.html#testing-sealed-routes","text":"The section above describes how to test a “regular” branch of your route structure, which reacts to incoming requests with HTTP response parts or rejections. Sometimes, however, you will want to verify that your service also translates Rejections to HTTP responses in the way you expect.\nYou do this by calling the Route.seal() method. The Route.seal() method applies the logic of the in-scope ExceptionHandler and RejectionHandler passed as method arguments to all exceptions and rejections coming back from the route, and translates them to the respective HttpResponseHttpResponse.\nNote that explicit call on the Route.seal method is needed in test code, but in your application code it is not necessary. As described in Sealing a Route, your application code only needs to bring implicit rejection and exception handlers in scope.","title":"Testing sealed Routes"},{"location":"/routing-dsl/testkit.html#testing-route-fragments","text":"Since the testkit is request-based, you cannot test requests that are illegal or impossible in HTTP. One such instance is testing a route that begins with the pathEnd directive, such as routeFragment here:\nScala copysourcepathEnd {\n  get {\n    complete {\n      \"Fragments of imagination\"\n    }\n  }\n} Java copysourcepathEnd(() ->\n        get(() ->\n                complete(\"Fragments of imagination\")\n        )\n);\nYou might create a route such as this to be able to compose it into another route such as:\nScala copysourceimport org.apache.pekko\nimport pekko.http.scaladsl.server.Directives._\nimport pekko.http.scaladsl.server.Route\n\nobject RouteFragment {\n  val route: Route = pathEnd {\n    get {\n      complete(\"example\")\n    }\n  }\n}\n\nobject API {\n  pathPrefix(\"version\") {\n    RouteFragment.route\n  }\n} Java copysourceimport org.apache.pekko.http.javadsl.server.AllDirectives;\nimport org.apache.pekko.http.javadsl.server.Route;\n\npublic class MyAppFragment extends AllDirectives {\n\n    public Route createRoute() {\n        return\n                pathEnd(() ->\n                        get(() ->\n                                complete(\"Fragments of imagination\")\n                        )\n                );\n    }\n\n}\nHowever, it is impossible to unit test this Route directly using testkit, since it is impossible to create an empty HTTP request. To test this type of route, embed it in a synthetic route in your test, such as testRoute in the example above.\nThis is what the full working test looks like:\nScala copysourceimport org.apache.pekko\nimport pekko.http.scaladsl.model.StatusCodes\nimport pekko.http.scaladsl.testkit.ScalatestRouteTest\nimport pekko.http.scaladsl.server._\nimport Directives._\nimport org.scalatest.matchers.should.Matchers\nimport org.scalatest.wordspec.AnyWordSpec\n\nclass TestKitFragmentSpec extends AnyWordSpec with Matchers with ScalatestRouteTest {\n\n  val routeFragment =\n      pathEnd {\n        get {\n          complete {\n            \"Fragments of imagination\"\n          }\n        }\n      }\n\n  // Synthetic route to enable pathEnd testing\n  val testRoute = {\n    pathPrefix(\"test\") {\n      routeFragment\n    }\n  }\n\n  \"The service\" should {\n    \"return a greeting for GET requests\" in {\n      // tests:\n      Get(\"/test\") ~> testRoute ~> check {\n        responseAs[String] shouldEqual \"Fragments of imagination\"\n      }\n    }\n\n    \"return a MethodNotAllowed error for PUT requests to the root path\" in {\n      // tests:\n      Put(\"/test\") ~> Route.seal(testRoute) ~> check {\n        status shouldEqual StatusCodes.MethodNotAllowed\n      }\n    }\n  }\n} Java copysourceimport org.apache.pekko.http.javadsl.model.HttpRequest;\nimport org.apache.pekko.http.javadsl.model.StatusCodes;\nimport org.apache.pekko.http.javadsl.server.AllDirectives;\nimport org.apache.pekko.http.javadsl.server.Route;\nimport org.apache.pekko.http.javadsl.testkit.JUnitRouteTest;\nimport org.apache.pekko.http.javadsl.testkit.TestRoute;\nimport org.junit.Test;\n\npublic class TestKitFragmentTest extends JUnitRouteTest {\n    class FragmentTester extends AllDirectives {\n        public Route createRoute(Route fragment) {\n            return\n                    pathPrefix(\"test\", () ->\n                            fragment\n                    );\n        }\n    }\n\n    TestRoute fragment = testRoute(new MyAppFragment().createRoute());\n    TestRoute testRoute = testRoute(new FragmentTester().createRoute(fragment.underlying()));\n\n    @Test\n    public void testFragment() {\n        testRoute.run(HttpRequest.GET(\"/test\"))\n                .assertStatusCode(200)\n                .assertEntity(\"Fragments of imagination\");\n\n        testRoute.run(HttpRequest.PUT(\"/test\"))\n                .assertStatusCode(StatusCodes.METHOD_NOT_ALLOWED);\n    }\n}","title":"Testing Route fragments"},{"location":"/routing-dsl/testkit.html#accounting-for-slow-test-systems","text":"The timeouts you consciously defined on your lightning fast development environment might be too tight for your, most probably, high-loaded Continuous Integration server, invariably causing spurious failures. To account for such situations, timeout durations can be scaled by a given factor on such environments. Check the Apache Pekko Docs for further information.","title":"Accounting for Slow Test Systems"},{"location":"/routing-dsl/testkit.html#increase-timeout","text":"The default timeout when testing your routes using the testkit is 1 second3 seconds second. Sometimes, though, this might not be enough. In order to extend this default timeout, to say 5 seconds, just add the following implicit in scope:\nScala copysourceimport scala.concurrent.duration._\nimport pekko.http.scaladsl.testkit.RouteTestTimeout\nimport pekko.testkit.TestDuration\n\nimplicit val timeout = RouteTestTimeout(5.seconds.dilated) Java copysource@Override\npublic FiniteDuration awaitDuration() {\n    return FiniteDuration.create(5, TimeUnit.SECONDS);\n}\nRemember to configure the timeout using dilated if you want to account for slow test systems.","title":"Increase Timeout"},{"location":"/routing-dsl/testkit.html#testing-actor-integration","text":"The ScalatestRouteTestJUnitRouteTest still provides a Classic ActorSystemActorSystem, so if you are not using the Classic API you will need to adapt it:\nScala copysourceimport scala.concurrent.duration._\nimport scala.util.{ Failure, Success }\n\nimport org.apache.pekko\nimport pekko.actor.testkit.typed.scaladsl.TestProbe\nimport pekko.actor.typed.{ ActorRef, Scheduler }\nimport pekko.actor.typed.scaladsl.AskPattern._\nimport pekko.http.scaladsl.server.Directives._\nimport pekko.http.scaladsl.testkit.ScalatestRouteTest\nimport pekko.util.Timeout\n\nimport org.scalatest.matchers.should.Matchers\nimport org.scalatest.wordspec.AnyWordSpec\n\nobject RouteUnderTest {\n  case class Ping(replyTo: ActorRef[String])\n\n  // Your route under test, scheduler is only needed as ask is used\n  def route(someActor: ActorRef[Ping])(implicit scheduler: Scheduler, timeout: Timeout) = get {\n    path(\"ping\") {\n      complete(someActor ? Ping)\n    }\n  }\n}\n\nclass TestKitWithActorSpec extends AnyWordSpec with Matchers with ScalatestRouteTest {\n  import RouteUnderTest._\n\n  // This test does not use the classic APIs,\n  // so it needs to adapt the system:\n  import pekko.actor.typed.scaladsl.adapter._\n  implicit val typedSystem = system.toTyped\n  implicit val timeout = Timeout(500.milliseconds)\n  implicit val scheduler = system.scheduler\n\n  \"The service\" should {\n    \"return a 'PONG!' response for GET requests to /ping\" in {\n      val probe = TestProbe[Ping]()\n      val test = Get(\"/ping\") ~> RouteUnderTest.route(probe.ref)\n      val ping = probe.expectMessageType[Ping]\n      ping.replyTo ! \"PONG!\"\n      test ~> check {\n        responseAs[String] shouldEqual \"PONG!\"\n      }\n    }\n  }\n} Java copysourceimport org.apache.pekko.actor.testkit.typed.javadsl.TestProbe;\nimport org.apache.pekko.actor.typed.ActorSystem;\nimport org.apache.pekko.actor.typed.javadsl.Adapter;\nimport org.apache.pekko.http.javadsl.model.HttpRequest;\nimport org.apache.pekko.http.javadsl.testkit.JUnitRouteTest;\n\nimport org.apache.pekko.http.javadsl.testkit.TestRoute;\nimport org.apache.pekko.http.javadsl.testkit.TestRouteResult;\nimport org.junit.Test;\n\npublic class TestKitWithActorTest extends JUnitRouteTest {\n\n    @Test\n    public void returnPongForGetPing() {\n        // This test does not use the classic APIs,\n        // so it needs to adapt the system:\n        ActorSystem<Void> system = Adapter.toTyped(system());\n\n        TestProbe<MyAppWithActor.Ping> probe = TestProbe.create(system);\n        TestRoute testRoute = testRoute(new MyAppWithActor().createRoute(probe.getRef(), system.scheduler()));\n\n        TestRouteResult result = testRoute.run(HttpRequest.GET(\"/ping\"));\n        MyAppWithActor.Ping ping = probe.expectMessageClass(MyAppWithActor.Ping.class);\n        ping.replyTo.tell(\"PONG!\");\n        result.assertEntity(\"PONG!\");\n    }\n}","title":"Testing Actor integration"},{"location":"/routing-dsl/testkit.html#integration-testing-routes","text":"Use ~!> to test a route running in full HTTP server mode:\nREQUEST ~!> ROUTE ~> check {\n  ASSERTIONS\n}\nCertain routes can only be tested with ~!>, for example routes that use the withRequestTimeout directive.\nNote Using ~!> adds considerable extra overhead since each test will start a server and bind to a port so use it only when necessary.","title":"Integration Testing Routes"},{"location":"/routing-dsl/testkit.html#examples","text":"A great pool of examples are the tests for all the predefined directives in Apache Pekko HTTP. They can be found herehere.","title":"Examples"},{"location":"/server-side/low-level-api.html","text":"","title":"Core Server API"},{"location":"/server-side/low-level-api.html#core-server-api","text":"The core Server API is scoped with a clear focus on the essential functionality of an HTTP/1.1 server:\nConnection management Parsing and rendering of messages and headers Timeout management (for requests and connections) Response ordering (for transparent pipelining support)\nAll non-core features of typical HTTP servers (like request routing, file serving, compression, etc.) are left to the higher layers, they are not implemented by the pekko-http-core-level server itself. Apart from general focus this design keeps the server core small and light-weight as well as easy to understand and maintain.\nNote It is recommended to read the Implications of the streaming nature of Request/Response Entities section, as it explains the underlying full-stack streaming concepts, which may be unexpected when coming from a background with non-“streaming first” HTTP Servers.","title":"Core Server API"},{"location":"/server-side/low-level-api.html#streams-and-http","text":"The Apache Pekko HTTP server is implemented on top of Streams and makes heavy use of it - in its implementation as well as on all levels of its API.\nOn the connection level, Apache Pekko HTTP offers basically the same kind of interface as Working with streaming IO: A socket binding is represented as a stream of incoming connections. The application pulls connections from this stream source and, for each of them, provides a Flow<HttpRequest, HttpResponse, ?>Flow[HttpRequest, HttpResponse, _] to “translate” requests into responses.\nApart from regarding a socket bound on the server-side as a Source<IncomingConnection, ?>Source[IncomingConnection, _] and each connection as a Source<HttpRequest, ?>Source[HttpRequest, _] with a Sink<HttpResponse, ?>Sink[HttpResponse, _] the stream abstraction is also present inside a single HTTP message: The entities of HTTP requests and responses are generally modeled as a Source<ByteString, ?>Source[ByteString, _]. See also the HTTP Model for more information on how HTTP messages are represented in Apache Pekko HTTP.","title":"Streams and HTTP"},{"location":"/server-side/low-level-api.html#starting-and-stopping","text":"On the most basic level an Apache Pekko HTTP server is bound by invoking the bind method of the org.apache.pekko.http.scaladsl.Httporg.apache.pekko.http.javadsl.Http extension:\nScala copysourceimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.Http\nimport pekko.stream.scaladsl._\n\nimplicit val system = ActorSystem()\nimplicit val executionContext = system.dispatcher\n\nval serverSource: Source[Http.IncomingConnection, Future[Http.ServerBinding]] =\n  Http().newServerAt(\"localhost\", 8080).connectionSource()\nval bindingFuture: Future[Http.ServerBinding] =\n  serverSource.to(Sink.foreach { connection => // foreach materializes the source\n    println(\"Accepted new connection from \" + connection.remoteAddress)\n    // ... and then actually handle the connection\n  }).run() Java copysourceActorSystem system = ActorSystem.create();\nMaterializer materializer = ActorMaterializer.create(system);\n\nSource<IncomingConnection, CompletionStage<ServerBinding>> serverSource =\n  Http.get(system).bind(ConnectHttp.toHost(\"localhost\", 8080));\n\nCompletionStage<ServerBinding> serverBindingFuture =\n  serverSource.to(Sink.foreach(connection -> {\n      System.out.println(\"Accepted new connection from \" + connection.remoteAddress());\n      // ... and then actually handle the connection\n    }\n  )).run(materializer);\nArguments to the Http().bind method specify the interface and port to bind to and register interest in handling incoming HTTP connections. Additionally, the method also allows for the definition of socket options as well as a larger number of settings for configuring the server according to your needs.\nThe result of the bind method is a Source<Http.IncomingConnection>Source[Http.IncomingConnection] which must be drained by the application in order to accept incoming connections. The actual binding is not performed before this source is materialized as part of a processing pipeline. In case the bind fails (e.g. because the port is already busy) the materialized stream will immediately be terminated with a respective exception. The binding is released (i.e. the underlying socket unbound) when the subscriber of the incoming connection source has cancelled its subscription. Alternatively one can use the unbind() method of the Http.ServerBinding instance that is created as part of the connection source’s materialization process. The Http.ServerBinding also provides a way to get a hold of the actual local address of the bound socket, which is useful for example when binding to port zero (and thus letting the OS pick an available port).","title":"Starting and Stopping"},{"location":"/server-side/low-level-api.html#request-response-cycle","text":"When a new connection has been accepted it will be published as an Http.IncomingConnection which consists of the remote address and methods to provide a Flow<HttpRequest, HttpResponse, ?>Flow[HttpRequest, HttpResponse, _] to handle requests coming in over this connection.\nRequests are handled by calling one of the handleWithXXX methods with a handler, which can either be\na Flow<HttpRequest, HttpResponse, ?>Flow[HttpRequest, HttpResponse, _] for handleWith, a function HttpRequest => HttpResponseFunction<HttpRequest, HttpResponse> for handleWithSyncHandler, a function HttpRequest => Future[HttpResponse]Function<HttpRequest, CompletionStage<HttpResponse>> for handleWithAsyncHandler.\nHere is a complete example:\nScala copysourceimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.model.HttpMethods._\nimport pekko.http.scaladsl.model._\nimport pekko.stream.scaladsl.Sink\n\nimplicit val system = ActorSystem()\nimplicit val executionContext = system.dispatcher\n\nval serverSource = Http().newServerAt(\"localhost\", 8080).connectionSource()\n\nval requestHandler: HttpRequest => HttpResponse = {\n  case HttpRequest(GET, Uri.Path(\"/\"), _, _, _) =>\n    HttpResponse(entity = HttpEntity(\n      ContentTypes.`text/html(UTF-8)`,\n      \"<html><body>Hello world!</body></html>\"))\n\n  case HttpRequest(GET, Uri.Path(\"/ping\"), _, _, _) =>\n    HttpResponse(entity = \"PONG!\")\n\n  case HttpRequest(GET, Uri.Path(\"/crash\"), _, _, _) =>\n    sys.error(\"BOOM!\")\n\n  case r: HttpRequest =>\n    r.discardEntityBytes() // important to drain incoming HTTP Entity stream\n    HttpResponse(404, entity = \"Unknown resource!\")\n}\n\nval bindingFuture: Future[Http.ServerBinding] =\n  serverSource.to(Sink.foreach { connection =>\n    println(\"Accepted new connection from \" + connection.remoteAddress)\n\n    connection.handleWithSyncHandler(requestHandler)\n  // this is equivalent to\n  // connection handleWith { Flow[HttpRequest] map requestHandler }\n  }).run() Java copysourceActorSystem system = ActorSystem.create();\n  final Materializer materializer = ActorMaterializer.create(system);\n\n  Source<IncomingConnection, CompletionStage<ServerBinding>> serverSource =\n    Http.get(system).bind(ConnectHttp.toHost(\"localhost\", 8080));\n\n  final Function<HttpRequest, HttpResponse> requestHandler =\n    new Function<HttpRequest, HttpResponse>() {\n      private final HttpResponse NOT_FOUND =\n        HttpResponse.create()\n          .withStatus(404)\n          .withEntity(\"Unknown resource!\");\n\n\n      @Override\n      public HttpResponse apply(HttpRequest request) throws Exception {\n        Uri uri = request.getUri();\n        if (request.method() == HttpMethods.GET) {\n          if (uri.path().equals(\"/\")) {\n            return\n              HttpResponse.create()\n                .withEntity(ContentTypes.TEXT_HTML_UTF8,\n                  \"<html><body>Hello world!</body></html>\");\n          } else if (uri.path().equals(\"/hello\")) {\n            String name = uri.query().get(\"name\").orElse(\"Mister X\");\n\n            return\n              HttpResponse.create()\n                .withEntity(\"Hello \" + name + \"!\");\n          } else if (uri.path().equals(\"/ping\")) {\n            return HttpResponse.create().withEntity(\"PONG!\");\n          } else {\n            return NOT_FOUND;\n          }\n        } else {\n          return NOT_FOUND;\n        }\n      }\n    };\n\n  CompletionStage<ServerBinding> serverBindingFuture =\n    serverSource.to(Sink.foreach(connection -> {\n      System.out.println(\"Accepted new connection from \" + connection.remoteAddress());\n\n      connection.handleWithSyncHandler(requestHandler, materializer);\n      // this is equivalent to\n      //connection.handleWith(Flow.of(HttpRequest.class).map(requestHandler), materializer);\n    })).run(materializer);\nIn this example, a request is handled by transforming the request stream with a function HttpRequest => HttpResponseFunction<HttpRequest, HttpResponse> using handleWithSyncHandler (or equivalently, Apache Pekko Stream’s map operator). Depending on the use case many other ways of providing a request handler are conceivable using Apache Pekko Stream’s combinators. If the application provides a FlowFlow it is also the responsibility of the application to generate exactly one response for every request and that the ordering of responses matches the ordering of the associated requests (which is relevant if HTTP pipelining is enabled where processing of multiple incoming requests may overlap). When relying on handleWithSyncHandler or handleWithAsyncHandler, or the map or mapAsync stream operators, this requirement will be automatically fulfilled.\nSee Routing DSL Overview for a more convenient high-level DSL to create request handlers.","title":"Request-Response Cycle"},{"location":"/server-side/low-level-api.html#streaming-request-response-entities","text":"Streaming of HTTP message entities is supported through subclasses of HttpEntityHttpEntity. The application needs to be able to deal with streamed entities when receiving a request as well as, in many cases, when constructing responses. See HttpEntity for a description of the alternatives.\nIf you rely on the Marshalling and/or Unmarshalling facilities provided by Apache Pekko HTTP then the conversion of custom types to and from streamed entities can be quite convenient.","title":"Streaming Request/Response Entities"},{"location":"/server-side/low-level-api.html#closing-a-connection","text":"The HTTP connection will be closed when the handling FlowFlow cancels its upstream subscription or the peer closes the connection. An often times more convenient alternative is to explicitly add a Connection: close header to an HttpResponseHttpResponse. This response will then be the last one on the connection and the server will actively close the connection when it has been sent out.\nConnection will also be closed if request entity has been cancelled (e.g. by attaching it to Sink.cancelled() or consumed only partially (e.g. by using take combinator). In order to prevent this behaviour entity should be explicitly drained by attaching it to Sink.ignore().","title":"Closing a connection"},{"location":"/server-side/low-level-api.html#configuring-server-side-https","text":"For detailed documentation about configuring and using HTTPS on the server-side refer to Server-Side HTTPS Support.","title":"Configuring Server-side HTTPS"},{"location":"/server-side/low-level-api.html#stand-alone-http-layer-usage","text":"Due to its Reactive-Streams-based nature, the Apache Pekko HTTP layer is fully detachable from the underlying TCP interface. While in most applications this “feature” will not be crucial it can be useful in certain cases to be able to “run” the HTTP layer (and, potentially, higher-layers) against data that do not come from the network but rather some other source. Potential scenarios where this might be useful include tests, debugging or low-level event-sourcing (e.g by replaying network traffic).\nOn the server-side the stand-alone HTTP layer forms a BidiFlowBidiFlow that is defined like this: copysource/**\n * The type of the server-side HTTP layer as a stand-alone BidiFlow\n * that can be put atop the TCP layer to form an HTTP server.\n *\n * {{{\n *                +------+\n * HttpResponse ~>|      |~> SslTlsOutbound\n *                | bidi |\n * HttpRequest  <~|      |<~ SslTlsInbound\n *                +------+\n * }}}\n */\ntype ServerLayer = BidiFlow[HttpResponse, SslTlsOutbound, SslTlsInbound, HttpRequest, NotUsed] You create an instance of Http.ServerLayer by calling one of the two overloads of the Http().serverLayer method, which also allows for varying degrees of configuration.\nOn the server-side the stand-alone HTTP layer forms a BidiFlow<HttpResponse, SslTlsOutbound, SslTlsInbound, HttpRequest, NotUsed>BidiFlow[HttpResponse, SslTlsOutbound, SslTlsInbound, HttpRequest, NotUsed], that is a stage that “upgrades” a potentially encrypted raw connection to the HTTP level. You create an instance of the layer by calling one of the two overloads of the Http.get(system).serverLayer method, which also allows for varying degrees of configuration. Note, that the returned instance is not reusable and can only be materialized once.","title":"Stand-Alone HTTP Layer Usage"},{"location":"/server-side/low-level-api.html#controlling-server-parallelism","text":"Request handling can be parallelized on two axes, by handling several connections in parallel and by relying on HTTP pipelining to send several requests on one connection without waiting for a response first. In both cases the client controls the number of ongoing requests. To prevent being overloaded by too many requests, Apache Pekko HTTP can limit the number of requests it handles in parallel.\nTo limit the number of simultaneously open connections, use the pekko.http.server.max-connections setting. This setting applies to all of Http.bindAndHandle* methods. If you use Http.bind, incoming connections are represented by a Source<IncomingConnection, ...>Source[IncomingConnection, ...]. Use Apache Pekko Stream’s combinators to apply backpressure to control the flow of incoming connections, e.g. by using throttle or mapAsync.\nHTTP pipelining is generally discouraged (and disabled by most browsers) but is nevertheless fully supported in Apache Pekko HTTP. The limit is applied on two levels. First, there’s the pekko.http.server.pipelining-limit config setting which prevents that more than the given number of outstanding requests is ever given to the user-supplied handler-flow. On the other hand, the handler flow itself can apply any kind of throttling itself. If you use the Http.bindAndHandleAsync entry-point, you can specify the parallelism argument (which defaults to 1, which means that pipelining is disabled) to control the number of concurrent requests per connection. If you use Http.bindAndHandle or Http.bind, the user-supplied handler flow has full control over how many request it accepts simultaneously by applying backpressure. In this case, you can e.g. use Apache Pekko Stream’s mapAsync combinator with a given parallelism to limit the number of concurrently handled requests. Effectively, the more constraining one of these two measures, config setting and manual flow shaping, will determine how parallel requests on one connection are handled.","title":"Controlling server parallelism"},{"location":"/server-side/low-level-api.html#handling-http-server-failures-in-the-low-level-api","text":"There are various situations when failure may occur while initialising or running an Apache Pekko HTTP server. Apache Pekko by default will log all these failures, however sometimes one may want to react to failures in addition to them just being logged, for example by shutting down the actor system, or notifying some external monitoring end-point explicitly.\nThere are multiple things that can fail when creating and materializing an HTTP Server (similarly, the same applied to a plain streaming Tcp() server). The types of failures that can happen on different layers of the stack, starting from being unable to start the server, and ending with failing to unmarshal an HttpRequest, examples of failures include (from outer-most, to inner-most):\nFailure to bind to the specified address/port, Failure while accepting new IncomingConnections, for example when the OS has run out of file descriptors or memory, Failure while handling a connection, for example if the incoming HttpRequestHttpRequest is malformed.\nThis section describes how to handle each failure situation, and in which situations these failures may occur.","title":"Handling HTTP Server failures in the Low-Level API"},{"location":"/server-side/low-level-api.html#bind-failures","text":"The first type of failure is when the server is unable to bind to the given port. For example when the port is already taken by another application, or if the port is privileged (i.e. only usable by root). In this case the “binding future” will fail immediately, and we can react to it by listening on the Future’sCompletionStage’s completion:\nScala copysourceimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.Http.ServerBinding\n\nimport scala.concurrent.Future\n\nimplicit val system = ActorSystem()\n// needed for the future foreach in the end\nimplicit val executionContext = system.dispatcher\n\n// let's say the OS won't allow us to bind to 80.\nval (host, port) = (\"localhost\", 80)\nval serverSource = Http().newServerAt(host, port).connectionSource()\n\nval bindingFuture: Future[ServerBinding] = serverSource\n  .to(handleConnections) // Sink[Http.IncomingConnection, _]\n  .run()\n\nbindingFuture.failed.foreach { ex =>\n  log.error(ex, \"Failed to bind to {}:{}!\", host, port)\n} Java copysourceActorSystem system = ActorSystem.create();\nMaterializer materializer = ActorMaterializer.create(system);\n\nSource<IncomingConnection, CompletionStage<ServerBinding>> serverSource =\n  Http.get(system).bind(ConnectHttp.toHost(\"localhost\", 80));\n\nCompletionStage<ServerBinding> serverBindingFuture =\n  serverSource.to(Sink.foreach(connection -> {\n      System.out.println(\"Accepted new connection from \" + connection.remoteAddress());\n      // ... and then actually handle the connection\n    }\n  )).run(materializer);\n\nserverBindingFuture.whenCompleteAsync((binding, failure) -> {\n  // possibly report the failure somewhere...\n}, system.dispatcher());\nOnce the server has successfully bound to a port, the Source<IncomingConnection, ?>Source[IncomingConnection, _] starts running and emitting new incoming connections. This source technically can signal a failure as well, however this should only happen in very dramatic situations such as running out of file descriptors or memory available to the system, such that it’s not able to accept a new incoming connection. Handling failures in Apache Pekko Streams is pretty straight forward, as failures are signaled through the stream starting from the stage which failed, all the way downstream to the final stages.","title":"Bind failures"},{"location":"/server-side/low-level-api.html#connections-source-failures","text":"In the example below we add a custom GraphStageGraphStage in order to react to the stream’s failure. See Custom stream processing for more on custom stages. We signal a failureMonitor actor with the cause why the stream is going down, and let the Actor handle the rest – maybe it’ll decide to restart the server or shutdown the ActorSystem, that however is not our concern anymore.\nScala copysourceimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.actor.ActorRef\nimport pekko.http.scaladsl.Http\nimport pekko.stream.scaladsl.Flow\n\nimplicit val system = ActorSystem()\nimplicit val executionContext = system.dispatcher\n\nimport Http._\nval (host, port) = (\"localhost\", 8080)\nval serverSource = Http().newServerAt(host, port).connectionSource()\n\nval failureMonitor: ActorRef = system.actorOf(MyExampleMonitoringActor.props)\n\nval reactToTopLevelFailures = Flow[IncomingConnection]\n  .watchTermination()((_, termination) =>\n    termination.failed.foreach {\n      cause => failureMonitor ! cause\n    })\n\nserverSource\n  .via(reactToTopLevelFailures)\n  .to(handleConnections) // Sink[Http.IncomingConnection, _]\n  .run() Java copysourceActorSystem system = ActorSystem.create();\nMaterializer materializer = ActorMaterializer.create(system);\n\nSource<IncomingConnection, CompletionStage<ServerBinding>> serverSource =\n  Http.get(system).bind(ConnectHttp.toHost(\"localhost\", 8080));\n\nFlow<IncomingConnection, IncomingConnection, NotUsed> failureDetection =\n  Flow.of(IncomingConnection.class).watchTermination((notUsed, termination) -> {\n    termination.whenComplete((done, cause) -> {\n      if (cause != null) {\n        // signal the failure to external monitoring service!\n      }\n    });\n    return NotUsed.getInstance();\n  });\n\nCompletionStage<ServerBinding> serverBindingFuture =\n  serverSource\n    .via(failureDetection) // feed signals through our custom stage\n    .to(Sink.foreach(connection -> {\n      System.out.println(\"Accepted new connection from \" + connection.remoteAddress());\n      // ... and then actually handle the connection\n    }))\n    .run(materializer);","title":"Connections Source failures"},{"location":"/server-side/low-level-api.html#connection-failures","text":"The third type of failure that can occur is when the connection has been properly established, however afterwards is terminated abruptly – for example by the client aborting the underlying TCP connection.\nTo handle this failure we can use the same pattern as in the previous snippet, however apply it to the connection’s Flow:\nScala copysourceimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.model._\nimport pekko.stream.scaladsl.Flow\n\nimplicit val system = ActorSystem()\nimplicit val executionContext = system.dispatcher\n\nval (host, port) = (\"localhost\", 8080)\nval serverSource = Http().newServerAt(host, port).connectionSource()\n\nval reactToConnectionFailure = Flow[HttpRequest]\n  .recover[HttpRequest] {\n    case ex =>\n      // handle the failure somehow\n      throw ex\n  }\n\nval httpEcho = Flow[HttpRequest]\n  .via(reactToConnectionFailure)\n  .map { request =>\n    // simple streaming (!) \"echo\" response:\n    HttpResponse(entity = HttpEntity(ContentTypes.`text/plain(UTF-8)`, request.entity.dataBytes))\n  }\n\nserverSource\n  .runForeach { con =>\n    con.handleWith(httpEcho)\n  } Java copysourceActorSystem system = ActorSystem.create();\nMaterializer materializer = ActorMaterializer.create(system);\n\nSource<IncomingConnection, CompletionStage<ServerBinding>> serverSource =\n  Http.get(system).bind(ConnectHttp.toHost(\"localhost\", 8080));\n\nFlow<HttpRequest, HttpRequest, NotUsed> failureDetection =\n  Flow.of(HttpRequest.class)\n    .watchTermination((notUsed, termination) -> {\n      termination.whenComplete((done, cause) -> {\n        if (cause != null) {\n          // signal the failure to external monitoring service!\n        }\n      });\n      return NotUsed.getInstance();\n    });\n\nFlow<HttpRequest, HttpResponse, NotUsed> httpEcho =\n  Flow.of(HttpRequest.class)\n    .via(failureDetection)\n    .map(request -> {\n      Source<ByteString, Object> bytes = request.entity().getDataBytes();\n      HttpEntity.Chunked entity = HttpEntities.create(ContentTypes.TEXT_PLAIN_UTF8, bytes);\n\n      return HttpResponse.create()\n        .withEntity(entity);\n    });\n\nCompletionStage<ServerBinding> serverBindingFuture =\n  serverSource.to(Sink.foreach(conn -> {\n      System.out.println(\"Accepted new connection from \" + conn.remoteAddress());\n      conn.handleWith(httpEcho, materializer);\n    }\n  )).run(materializer);\nNote that this is when the TCP connection is closed correctly, if the client just goes away, for example because of a network failure, it will not be seen as this kind of stream failure. It will instead be detected through the idle timeout).\nThese failures can be described more or less infrastructure related, they are failing bindings or connections. Most of the time you won’t need to dive into those very deeply, as Apache Pekko will simply log errors of this kind anyway, which is a reasonable default for such problems.\nIn order to learn more about handling exceptions in the actual routing layer, which is where your application code comes into the picture, refer to Exception Handling which focuses explicitly on explaining how exceptions thrown in routes can be handled and transformed into HttpResponseHttpResponse s with appropriate error codes and human-readable failure descriptions.","title":"Connection failures"},{"location":"/server-side/websocket-support.html","text":"","title":"Server WebSocket Support"},{"location":"/server-side/websocket-support.html#server-websocket-support","text":"WebSocket is a protocol that provides a bi-directional channel between browser and webserver usually run over an upgraded HTTP(S) connection. Data is exchanged in messages whereby a message can either be binary data or Unicode text.\nApache Pekko HTTP provides a stream-based implementation of the WebSocket protocol that hides the low-level details of the underlying binary framing wire-protocol and provides a simple API to implement services using WebSocket.","title":"Server WebSocket Support"},{"location":"/server-side/websocket-support.html#model","text":"The basic unit of data exchange in the WebSocket protocol is a message. A message can either be binary message, i.e. a sequence of octets or a text message, i.e. a sequence of Unicode code points.\nIn the data model the two kinds of messages, binary and text messages, are represented by the two classes BinaryMessageBinaryMessage and TextMessageTextMessage deriving from a common superclass MessageMessage. The subclasses BinaryMessageBinaryMessage and TextMessageTextMessage contain methods to access the data. The superclass Message contains isText and isBinary methods to distinguish a message and asBinaryMessage and asTextMessage methods to cast a message.] Take the API of TextMessageTextMessage as an example (BinaryMessageBinaryMessage is very similar with String replaced by ByteStringByteString):\nScala copysource/**\n * The ADT for WebSocket messages. A message can either be a binary or a text message.\n */\nsealed trait Message extends pekko.http.javadsl.model.ws.Message\n\n/**\n * Represents a WebSocket text message. A text message can either be a [[TextMessage.Strict]] in which case\n * the complete data is already available or it can be [[TextMessage.Streamed]] in which case `textStream`\n * will return a Source streaming the data as it comes in.\n */\nsealed trait TextMessage extends pekko.http.javadsl.model.ws.TextMessage with Message {\n\n  /**\n   * The contents of this message as a stream.\n   */\n  def textStream: Source[String, _]\n\n  /**\n   * Collects all possible parts and returns a potentially future Strict Message for easier processing.\n   * The Future is failed with an TimeoutException if the stream isn't completed after the given timeout.\n   */\n  def toStrict(timeout: FiniteDuration)(implicit fm: Materializer): Future[TextMessage.Strict] =\n    this match {\n      case TextMessage.Strict(text) => Future.successful(TextMessage.Strict(text))\n      case TextMessage.Streamed(textStream) => textStream\n          .completionTimeout(timeout)\n          .runFold(new StringBuilder())((b, s) => b.append(s))\n          .map(b => b.toString)(fm.executionContext)\n          .map(text => TextMessage.Strict(text))(fm.executionContext)\n    }\n\n  /** Java API */\n  override def getStreamedText: javadsl.Source[String, _] = textStream.asJava\n  override def asScala: TextMessage = this\n  override def toStrict(timeoutMillis: Long, materializer: Materializer): CompletionStage[TextMessage.Strict] =\n    toStrict(timeoutMillis.millis)(materializer).toJava\n}\nsealed trait BinaryMessage extends pekko.http.javadsl.model.ws.BinaryMessage with Message {\n\n  /**\n   * The contents of this message as a stream.\n   */\n  def dataStream: Source[ByteString, _]\n\n  /**\n   * Collects all possible parts and returns a potentially future Strict Message for easier processing.\n   * The Future is failed with an TimeoutException if the stream isn't completed after the given timeout.\n   */\n  def toStrict(timeout: FiniteDuration)(implicit fm: Materializer): Future[BinaryMessage.Strict] =\n    this match {\n      case BinaryMessage.Strict(binary) => Future.successful(BinaryMessage.Strict(binary))\n      case BinaryMessage.Streamed(binaryStream) => binaryStream\n          .completionTimeout(timeout)\n          .runFold(new ByteStringBuilder())((b, e) => b.append(e))\n          .map(b => b.result())(fm.executionContext)\n          .map(binary => BinaryMessage.Strict(binary))(fm.executionContext)\n    }\n\n  /** Java API */\n  override def getStreamedData: javadsl.Source[ByteString, _] = dataStream.asJava\n  override def asScala: BinaryMessage = this\n  override def toStrict(timeoutMillis: Long, materializer: Materializer): CompletionStage[BinaryMessage.Strict] =\n    toStrict(timeoutMillis.millis)(materializer).toJava\n} Java copysourceabstract class TextMessage extends Message {\n\n  /**\n   * Returns a source of the text message data.\n   */\n  def getStreamedText: Source[String, _]\n\n  /**\n   * Returns the strict message text if this message is strict, throws otherwise.\n   */\n  def getStrictText: String\n}\nThe data of a message is provided as a stream because WebSocket messages do not have a predefined size and could (in theory) be infinitely long. However, only one message can be open per direction of the WebSocket connection, so that many application level protocols will want to make use of the delineation into (small) messages to transport single application-level data units like “one event” or “one chat message”.\nMany messages are small enough to be sent or received in one go. As an opportunity for optimization, the model provides the notion of a “strict” message to represent cases where a whole message was received in one go. Strict messages are represented with the Strict subclass for each kind of message which contains data as a strict, i.e. non-streamed, ByteStringByteString or String. If TextMessage.isStrict returns true, the complete data is already available and can be accessed with TextMessage.getStrictText (analogously for BinaryMessageBinaryMessage).\nWhen receiving data from the network connection the WebSocket implementation tries to create a strict message whenever possible, i.e. when the complete data was received in one chunk. However, the actual chunking of messages over a network connection and through the various streaming abstraction layers is not deterministic from the perspective of the application. Therefore, application code must be able to handle both streamed and strict messages and not expect certain messages to be strict. (Particularly, note that tests against localhost will behave differently than tests against remote peers where data is received over a physical network connection.)\nFor sending data, you can use TextMessage.apply(text: String)TextMessage.create(String) to create a strict message if the complete message has already been assembled. Otherwise, use TextMessage.apply(textStream: Source[String, \\_])TextMessage.create(Source<String, ?>) to create a streaming message from an Apache Pekko Stream source.","title":"Model"},{"location":"/server-side/websocket-support.html#routing-support","text":"To handle websocket requests, you can either use the directive described in this section, or use the more low-level WebSocketUpgrade attribute described in the next section.\nThe routing DSL provides the handleWebSocketMessages directive to install a WebSocket handler if a request is a WebSocket request. Otherwise, the directive rejects the request.\nLet’s look at how the above example can be rewritten using the high-level routing DSL.\nInstead of writing the request handler manually, the routing behavior of the app is defined by a route that uses the handleWebSocketMessages directive:\nScala copysourcedef greeter: Flow[Message, Message, Any] =\n  Flow[Message].mapConcat {\n    case tm: TextMessage =>\n      TextMessage(Source.single(\"Hello \") ++ tm.textStream ++ Source.single(\"!\")) :: Nil\n    case bm: BinaryMessage =>\n      // ignore binary messages but drain content to avoid the stream being clogged\n      bm.dataStream.runWith(Sink.ignore)\n      Nil\n  }\nval websocketRoute =\n  path(\"greeter\") {\n    handleWebSocketMessages(greeter)\n  }\n\n// tests:\n// create a testing probe representing the client-side\nval wsClient = WSProbe()\n\n// WS creates a WebSocket request for testing\nWS(\"/greeter\", wsClient.flow) ~> websocketRoute ~>\ncheck {\n  // check response for WS Upgrade headers\n  isWebSocketUpgrade shouldEqual true\n\n  // manually run a WS conversation\n  wsClient.sendMessage(\"Peter\")\n  wsClient.expectMessage(\"Hello Peter!\")\n\n  wsClient.sendMessage(BinaryMessage(ByteString(\"abcdef\")))\n  wsClient.expectNoMessage(100.millis)\n\n  wsClient.sendMessage(\"John\")\n  wsClient.expectMessage(\"Hello John!\")\n\n  wsClient.sendCompletion()\n  wsClient.expectCompletion()\n} Java copysourcepublic Route createRoute() {\n  return\n    path(\"greeter\", () ->\n      handleWebSocketMessages(greeter())\n    );\n}\nThe handling code itself will be the same as with using the low-level API.\nThe example also includes code demonstrating the testkit support for WebSocket services. It allows to create WebSocket requests to run against a route using WS which can be used to provide a mock WebSocket probe that allows manual testing of the WebSocket handler’s behavior if the request was accepted.\nSee the full routing example.","title":"Routing support"},{"location":"/server-side/websocket-support.html#websocketupgrade","text":"To handle websocket requests, you can either use the WebSocketUpgradeWebSocketUpgrade attribute directly, or use the more high-level Routing Support described above.\nThe entrypoint for the WebSocket API is the WebSocketUpgradeWebSocketUpgrade attribute which is added to a request if Apache Pekko HTTP encounters a WebSocket upgrade request.\nThe WebSocket specification mandates that details of the WebSocket connection are negotiated by placing special-purpose HTTP headers into request and response of the HTTP upgrade. In Apache Pekko HTTP these HTTP-level details of the WebSocket handshake are hidden from the application and don’t need to be managed manually.\nInstead, the WebSocketUpgradeWebSocketUpgrade attribute represents a valid WebSocket upgrade request. An application can detect a WebSocket upgrade request by looking for the WebSocketUpgradeWebSocketUpgrade attribute. It can choose to accept the upgrade and start a WebSocket connection by responding to that request with an HttpResponseHttpResponse generated by one of the WebSocketUpgradeWebSocketUpgrade.handleMessagesWith methods. In its most general form this method expects two arguments: first, a handler Flow<Message, Message, Any>Flow[Message, Message, Any]Flow<Message, Message, ?>Flow[Message, Message, ?] that will be used to handle WebSocket messages on this connection. Second, the application can optionally choose one of the proposed application-level sub-protocols by inspecting the values of WebSocketUpgrade.requestedProtocolsWebSocketUpgrade.getRequestedProtocols and pass the chosen protocol value to handleMessageshandleMessagesWith.","title":"WebSocketUpgrade"},{"location":"/server-side/websocket-support.html#handling-messages","text":"A message handler is expected to be implemented as a Flow<Message, Message, Any>Flow[Message, Message, Any]Flow<Message, Message, ?>Flow[Message, Message, ?]. For typical request-response scenarios this fits very well and such a FlowFlow can be constructed from a simple function by using Flow[Message].map or Flow[Message].mapAsyncFlow.<Message>create().map or Flow.<Message>create().mapAsync.\nThere are other use-cases, e.g. in a server-push model, where a server message is sent spontaneously, or in a true bi-directional scenario where input and output aren’t logically connected. Providing the handler as a FlowFlow in these cases may not fit. Another method named WebSocketUpgrade.handleMessagesWithSinkSourceAn overload of WebSocketUpgrade.handleMessagesWith is provided, instead, which allows to pass an output-generating Source<Message, ?>Source[Message, _] and an input-receiving Sink<Message, ?>Sink[Message, _] independently.\nNote that a handler is required to consume the data stream of each message to make place for new messages. Otherwise, subsequent messages may be stuck and message traffic in this direction will stall.","title":"Handling Messages"},{"location":"/server-side/websocket-support.html#example","text":"Let’s look at an exampleexample.\nWebSocket requests come in like any other requests. In the example, requests to /greeter are expected to be WebSocket requests:\nScala copysourceval requestHandler: HttpRequest => HttpResponse = {\n  case req @ HttpRequest(GET, Uri.Path(\"/greeter\"), _, _, _) =>\n    req.attribute(AttributeKeys.webSocketUpgrade) match {\n      case Some(upgrade) => upgrade.handleMessages(greeterWebSocketService)\n      case None          => HttpResponse(400, entity = \"Not a valid websocket request!\")\n    }\n  case r: HttpRequest =>\n    r.discardEntityBytes() // important to drain incoming HTTP Entity stream\n    HttpResponse(404, entity = \"Unknown resource!\")\n} Java copysourcepublic static HttpResponse handleRequest(HttpRequest request) {\n  System.out.println(\"Handling request to \" + request.getUri());\n\n  if (request.getUri().path().equals(\"/greeter\")) {\n    return request.getAttribute(AttributeKeys.webSocketUpgrade())\n      .map(upgrade -> {\n        Flow<Message, Message, NotUsed> greeterFlow = greeter();\n        HttpResponse response = upgrade.handleMessagesWith(greeterFlow);\n        return response;\n      })\n      .orElse(\n        HttpResponse.create().withStatus(StatusCodes.BAD_REQUEST).withEntity(\"Expected WebSocket request\")\n      );\n  } else {\n    return HttpResponse.create().withStatus(404);\n  }\n}\nIt uses pattern matching onlooks at the path and then inspects the request to query for the WebSocketUpgradeWebSocketUpgrade attribute. If such an attribute is found, it is used to generate a response by passing a handler for WebSocket messages to the handleMessageshandleMessagesWith method. If no such attribute is found a 400 Bad Request response is generated.\nYou can also use the WebSocket.handleWebSocketRequestWith helper method which can be used if only WebSocket requests are expected. The method looks for the WebSocketUpgradeWebSocketUpgrade attribute and returns a response that will install the passed WebSocket handler if the header is found. If the request is no WebSocket request it will return a 400 Bad Request error response.\nIn the example, the passed handler expects text messages where each message is expected to contain a (person’s) name and then responds with another text message that contains a greeting:\nScala copysource// The Greeter WebSocket Service expects a \"name\" per message and\n// returns a greeting message for that name\nval greeterWebSocketService =\n  Flow[Message]\n    .mapConcat {\n      // we match but don't actually consume the text message here,\n      // rather we simply stream it back as the tail of the response\n      // this means we might start sending the response even before the\n      // end of the incoming message has been received\n      case tm: TextMessage   => TextMessage(Source.single(\"Hello \") ++ tm.textStream) :: Nil\n      case bm: BinaryMessage =>\n        // ignore binary messages but drain content to avoid the stream being clogged\n        bm.dataStream.runWith(Sink.ignore)\n        Nil\n    } Java copysource /**\n * A handler that treats incoming messages as a name,\n * and responds with a greeting to that name\n */\npublic static Flow<Message, Message, NotUsed> greeter() {\n  return\n    Flow.<Message>create()\n      .collect(new JavaPartialFunction<Message, Message>() {\n        @Override\n        public Message apply(Message msg, boolean isCheck) throws Exception {\n          if (isCheck) {\n            if (msg.isText()) {\n              return null;\n            } else {\n              throw noMatch();\n            }\n          } else {\n            return handleTextMessage(msg.asTextMessage());\n          }\n        }\n      });\n}\n\npublic static TextMessage handleTextMessage(TextMessage msg) {\n  if (msg.isStrict()) // optimization that directly creates a simple response...\n  {\n    return TextMessage.create(\"Hello \" + msg.getStrictText());\n  } else // ... this would suffice to handle all text messages in a streaming fashion\n  {\n    return TextMessage.create(Source.single(\"Hello \").concat(msg.getStreamedText()));\n  }\n}\nNote Inactive WebSocket connections will be dropped according to the idle-timeout settings. In case you need to keep inactive connections alive, you can either tweak your idle-timeout or inject ‘keep-alive’ messages regularly.","title":"Example"},{"location":"/server-side/websocket-support.html#automatic-keep-alive-ping-support","text":"For long running websocket connections it may be beneficial to enable automatic heartbeat using Ping frames. Those are often used as a way to keep otherwise idle connections from being closed and also a way of ensuring the connection remains usable even after no data frames are communicated over a longer period of time. Such heartbeat may be initiated by either side of the connection, and the choice which side performs the heart beating is use-case dependent.\nThis is supported in a transparent way via configuration in Apache Pekko HTTP, and you can enable it by setting the: pekko.http.server.websocket.periodic-keep-alive-max-idle = 1 second to a specified max idle timeout. The keep alive triggers when no other messages are in-flight during the such configured period. Apache Pekko HTTP will then automatically send a Ping frame for each of such idle intervals.\nBy default, the automatic keep-alive feature is disabled.","title":"Automatic keep-alive Ping support"},{"location":"/server-side/websocket-support.html#custom-keep-alive-data-payloads","text":"By default, pings do not carry any payload, as it is often enough to simply push any frame over the connection to ensure the connection stays healthy (or detect if it was severed), however you may configure them to carry a custom payload, to do this you can provide a function that will be asked to emit the payload for each of the ping messages generated:\nScala copysourceval defaultSettings = ServerSettings(system)\n\nval pingCounter = new AtomicInteger()\n\nHttp().newServerAt(\"127.0.0.1\", 0)\n  .adaptSettings(_.mapWebsocketSettings(\n    _.withPeriodicKeepAliveData(() => ByteString(s\"debug-${pingCounter.incrementAndGet()}\"))))\n  .bind(route) Java copysourceServerSettings defaultSettings = ServerSettings.create(system);\n\nAtomicInteger pingCounter = new AtomicInteger();\n\nWebSocketSettings customWebsocketSettings = defaultSettings.getWebsocketSettings()\n    .withPeriodicKeepAliveData(() ->\n        ByteString.fromString(String.format(\"debug-%d\", pingCounter.incrementAndGet()))\n    );\n\n\nServerSettings customServerSettings = defaultSettings.withWebsocketSettings(customWebsocketSettings);\n\nHttp http = Http.get(system);\nhttp.newServerAt(\"127.0.0.1\", 8080)\n    .withSettings(customServerSettings)\n    .bindFlow(handler);","title":"Custom keep-alive data payloads"},{"location":"/server-side/websocket-support.html#uni-directional-pong-keep-alive","text":"A Ping response will always be replied to by the client-side with an appropriate Pong reply, carrying the same payload. It is also possible to configure the keep-alive mechanism to send Pong frames instead of Ping frames, which enables an uni-directional heartbeat mechanism (in which case the client side will not reply to such heartbeat). You can configure this mode by setting: pekko.http.server.websocket.periodic-keep-alive-mode = pong.","title":"Uni-directional Pong keep-alive"},{"location":"/server-side/server-https-support.html","text":"","title":"Server HTTPS Support"},{"location":"/server-side/server-https-support.html#server-https-support","text":"Apache Pekko HTTP supports TLS encryption on the server-side as well as on the client-side.\nThe central vehicle for configuring encryption is the HttpsConnectionContextHttpsConnectionContext, which can be created using the static method ConnectionContext.httpsServer which is defined like this:\nScala copysource/**\n *  Creates an HttpsConnectionContext for server-side use from the given SSLContext.\n */\ndef httpsServer(sslContext: SSLContext): HttpsConnectionContext = // ... Java copysource/**\n * Creates an HttpsConnectionContext for server-side use from the given SSLContext.\n */\ndef httpsServer(sslContext: SSLContext): HttpsConnectionContext = // ...\nOn the server-side, the ServerBuilderServerBuilder defines a method enableHttps with an httpsContext parameter, which can receive the HTTPS configuration in the form of an HttpsConnectionContext instance.\nFor detailed documentation for client-side HTTPS support refer to Client-Side HTTPS Support.","title":"Server HTTPS Support"},{"location":"/server-side/server-https-support.html#obtaining-ssl-tls-certificates","text":"In order to run an HTTPS server a certificate has to be provided, which usually is either obtained from a signing authority or created by yourself for local or staging environment purposes.\nSigning authorities often provide instructions on how to create a Java keystore (typically with reference to Tomcat configuration). If you want to generate your own certificates, the official Oracle documentation on how to generate a keystore using the JDK keytool utility can be found here.\nSSL-Config provides a more targeted guide on generating certificates, so we recommend you start with the guide titled Generating X.509 Certificates.","title":"Obtaining SSL/TLS Certificates"},{"location":"/server-side/server-https-support.html#using-https","text":"Once you have obtained the server certificate, using it is as simple as preparing an HttpsConnectionContextHttpsConnectionContext and passing it to enableHttps when binding the server.\nThe below example shows how setting up HTTPS works. First, you create and configure an instance of HttpsConnectionContextHttpsConnectionContext :\nScala copysourceimport java.io.InputStream\nimport java.security.{ KeyStore, SecureRandom }\n\nimport javax.net.ssl.{ KeyManagerFactory, SSLContext, TrustManagerFactory }\nimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.server.{ Directives, Route }\nimport pekko.http.scaladsl.{ ConnectionContext, Http, HttpsConnectionContext }\nimplicit val system = ActorSystem()\nimplicit val dispatcher = system.dispatcher\n\n// Manual HTTPS configuration\n\nval password: Array[Char] = \"change me\".toCharArray // do not store passwords in code, read them from somewhere safe!\n\nval ks: KeyStore = KeyStore.getInstance(\"PKCS12\")\nval keystore: InputStream = getClass.getClassLoader.getResourceAsStream(\"server.p12\")\n\nrequire(keystore != null, \"Keystore required!\")\nks.load(keystore, password)\n\nval keyManagerFactory: KeyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\")\nkeyManagerFactory.init(ks, password)\n\nval tmf: TrustManagerFactory = TrustManagerFactory.getInstance(\"SunX509\")\ntmf.init(ks)\n\nval sslContext: SSLContext = SSLContext.getInstance(\"TLS\")\nsslContext.init(keyManagerFactory.getKeyManagers, tmf.getTrustManagers, new SecureRandom)\nval https: HttpsConnectionContext = ConnectionContext.httpsServer(sslContext) Java copysource // ** CONFIGURING ADDITIONAL SETTINGS ** //\n\npublic static HttpsConnectionContext createHttpsContext(ActorSystem system) {\n    try {\n      // initialise the keystore\n      // !!! never put passwords into code !!!\n      final char[] password = new char[]{'a', 'b', 'c', 'd', 'e', 'f'};\n\n      final KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n      final InputStream keystore = SimpleServerApp.class.getClassLoader().getResourceAsStream(\"httpsDemoKeys/keys/server.p12\");\n      if (keystore == null) {\n        throw new RuntimeException(\"Keystore required!\");\n      }\n      ks.load(keystore, password);\n\n      final KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\n      keyManagerFactory.init(ks, password);\n\n      final TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n      tmf.init(ks);\n\n      final SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n      sslContext.init(keyManagerFactory.getKeyManagers(), tmf.getTrustManagers(), new SecureRandom());\n\n      return ConnectionContext.httpsServer(sslContext);\n\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\nAfter that you can pass it to enableHttps, like displayed below:\nScala copysourceval routes: Route = get { complete(\"Hello world!\") }\nHttp().newServerAt(\"127.0.0.1\", 8080).enableHttps(https).bind(routes) Java copysourceHttp.get(system).newServerAt(\"localhost\", 8080)\n    .enableHttps(createHttpsContext(system))\n    .bind(app.createRoute());","title":"Using HTTPS"},{"location":"/server-side/server-https-support.html#running-both-http-and-https","text":"If you want to run HTTP and HTTPS servers in a single application, you first create an instance of HttpsConnectionContext as explained above and then create two server bindings for different ports, one with https enabled and one without:\nScala copysource// you can run both HTTP and HTTPS in the same application as follows:\nval commonRoutes: Route = get { complete(\"Hello world!\") }\nHttp().newServerAt(\"127.0.0.1\", 443).enableHttps(https).bind(commonRoutes)\nHttp().newServerAt(\"127.0.0.1\", 80).bind(commonRoutes) Java copysourcefinal Http http = Http.get(system);\n//Run HTTP server firstly\nhttp.newServerAt(\"localhost\", 80).bind(route);\n\n//get configured HTTPS context\nHttpsConnectionContext httpsContext = SimpleServerApp.createHttpsContext(system);\n\n//Then run HTTPS server\nhttp.newServerAt(\"localhost\", 443).enableHttps(httpsContext).bind(route);","title":"Running both HTTP and HTTPS"},{"location":"/server-side/server-https-support.html#mutual-authentication","text":"To require clients to authenticate themselves when connecting, you must set this on the SSLEngine:\nScala copysourceval sslContext: SSLContext = ???\nConnectionContext.httpsServer(() => {\n  val engine = sslContext.createSSLEngine()\n  engine.setUseClientMode(false)\n\n  engine.setNeedClientAuth(true)\n  // or: engine.setWantClientAuth(true)\n\n  engine\n}) Java copysourceConnectionContext.httpsServer(() -> {\n        SSLEngine engine = sslContext.createSSLEngine();\n        engine.setUseClientMode(false);\n\n        engine.setNeedClientAuth(true);\n        // or: engine.setWantClientAuth(true);\n\n        return engine;\n});\nFor further (custom) certificate checks, you can access the javax.net.ssl.SSLSession via the sslSession attribute.\nAt this point dynamic renegotiation of the certificates to be used is not implemented. For details see issue #18351 and some preliminary work in PR #19787.","title":"Mutual authentication"},{"location":"/server-side/server-https-support.html#further-reading","text":"The topic of properly configuring HTTPS for your web server is an always changing one, thus we recommend staying up to date with various security breach news and of course keep your JVM at the latest version possible, as the default settings are often updated by Oracle in reaction to various security updates and known issues.\nWe also recommend having a look at the Play documentation about securing your app, as well as the techniques described in the Play documentation about setting up a reverse proxy to terminate TLS in front of your application instead of terminating TLS inside the JVM, and therefore Apache Pekko HTTP, itself.\nOther excellent articles on the subject:\nOracle Java SE 8: Creating a Keystore using JSSE Java PKI Programmer’s Guide Fixing X.509 Certificates","title":"Further reading"},{"location":"/server-side/graceful-termination.html","text":"","title":"Graceful termination"},{"location":"/server-side/graceful-termination.html#graceful-termination","text":"","title":"Graceful termination"},{"location":"/server-side/graceful-termination.html#pekko-coordinated-shutdown","text":"Coordinated shutdown is Apache Pekko’s managed way of shutting down multiple modules / sub-systems (persistence, cluster, http etc) in a predictable and ordered fashion. For example, in a typical Apache Pekko application you will want to stop accepting new HTTP connections, and then shut down the cluster etc.\nThe recommended Apache Pekko HTTP server shutdown consists of three steps:\nstop accepting new connections (ServerBinding.unbindServerBinding.unbind) try to finish handling of ongoing requests until the hardTerminationDeadline hits (see below for details) close open connections (ServerBinding.terminateServerBinding.terminate)\nThis recommended sequence can be added to Pekko’s coordinated shutdown via ServerBinding.addToCoordinatedShutdownServerBinding.addToCoordinatedShutdown like this:\nScala copysourceval bindingFuture = Http().newServerAt(\"localhost\", 8080).bind(routes)\n  .map(_.addToCoordinatedShutdown(hardTerminationDeadline = 10.seconds)) Java copysourceCompletionStage<ServerBinding> bindingFuture = Http\n    .get(system)\n    .newServerAt(\"localhost\", 8080)\n    .bind(routes)\n    .thenApply(binding -> binding.addToCoordinatedShutdown(Duration.ofSeconds(10), system));\nYou may initiate the Pekko shutdown via ActorSystem.terminate(), or run runAll on the CoordinatedShutdown extension and pass it a class implementing CoordinatedShutdown.ReasonCoordinatedShutdown.Reason for informational purposes\nScala copysource// shut down with `ActorSystemTerminateReason`\nsystem.terminate()\n\n// or define a specific reason\ncase object UserInitiatedShutdown extends CoordinatedShutdown.Reason\n\nCoordinatedShutdown(system).run(UserInitiatedShutdown) Java copysource// shut down with `ActorSystemTerminateReason`\nsystem.terminate();\n\n// or define a specific reason\nfinal class UserInitiatedShutdown implements CoordinatedShutdown.Reason {\n    @Override\n    public String toString() {\n        return \"UserInitiatedShutdown\";\n    }\n}\n\nCoordinatedShutdown.get(system).run(new UserInitiatedShutdown());","title":"Pekko Coordinated Shutdown"},{"location":"/server-side/graceful-termination.html#graceful-termination-using-serverterminator","text":"Apache Pekko HTTP provides two APIs to “stop” the server, either of them are available via the ServerBinding ServerBinding obtained from starting the server (by using any of the bind... methods on the HttpHttp extension).\nThe first method, called unbind() causes the server to stop accepting new connections, however any existing connections that are still being used will remain active until the client chooses to close them. It only unbinds the port on which the http server has been listening. This allows HTTP server to finish streaming any responses that might be still in flight and eventually terminate the entire system. If your application uses long-lived connections, this does mean that these can delay the termination of your system indefinitely.\nA better and more graceful solution to terminate an Apache Pekko HTTP server is to use the ServerBinding.terminate(Duration) ServerBinding.terminate(FiniteDuration) method, which not only performs the unbinding, but also handles replying to new incoming requests with (configurable) “terminating” HTTP responses. It also allows setting a deadline after which any connections that are still alive will be shut down forcefully. More precisely, termination works by following these steps:\nFirst, the server port is unbound and no new connections will be accepted (same as invoking unbind()). Immediately the ServerBinding#whenTerminationSignalIssued CompletionStage ServerBinding#whenTerminationSignalIssued Future is completed. This can be used to signal parts of the application that the HTTP server is shutting down and they should clean up as well. Note also that for more advanced shut down scenarios you may want to use the Coordinated Shutdown capabilities of Apache Pekko.\nNext, all in flight requests will be handled. If a request is “in-flight” (being handled by user code), it is given hardDeadline time to complete.\nif a connection has no “in-flight” request, it is terminated immediately if user code emits a response within the timeout, then this response is sent to the client with a Connection: close header and connection is closed. if it is a streaming response, it is also mandated that it shall complete within the deadline, and if it does not the connection will be terminated regardless of status of the streaming response. This is because such response could be infinite, which could trap the server in a situation where it could not terminate if it were to wait for a response to “finish”. existing streaming responses must complete before the deadline as well. When the deadline is reached the connection will be terminated regardless of status of the streaming responses. if user code does not reply with a response within the deadline we produce a special org.apache.pekko.http.javadsl.settings.ServerSettings.getTerminationDeadlineExceededResponseorg.apache.pekko.http.scaladsl.settings.ServerSettings.terminationDeadlineExceededResponse HTTP response (e.g. 503 Service Unavailable) with a Connection: close header and close connection.\nDuring that time incoming requests continue to be served. The existing connections will remain alive until the hardDeadline is exceeded, yet no new requests will be delivered to the user handler. All such drained responses will be replied to with an termination response (as explained in step 2).\nFinally, all remaining alive connections are forcefully terminated once the hardDeadline is exceeded. The whenTerminated (exposed by ServerBinding) CompletionStagefuture is completed as well, so the graceful termination (of the ActorSystem or entire JVM itself can be safely performed, as by then it is known that no connections remain alive to this server).\nNote that the termination response is configurable in ServerSettings, and by default is an 503 Service Unavailable, with an empty response entity.\nStarting a graceful termination is as simple as invoking the terminate() method on the server binding:\nScala copysourceimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.server.Directives._\nimport pekko.http.scaladsl.server.Route\nimport scala.concurrent.duration._\n\nimplicit val system = ActorSystem()\nimplicit val dispatcher = system.dispatcher\n\nval routes = get {\n  complete(\"Hello world!\")\n}\n\nval binding: Future[Http.ServerBinding] =\n  Http().newServerAt(\"127.0.0.1\", 8080).bind(routes)\n\n// ...\n// once ready to terminate the server, invoke terminate:\nval onceAllConnectionsTerminated: Future[Http.HttpTerminated] =\n  Await.result(binding, 10.seconds)\n    .terminate(hardDeadline = 3.seconds)\n\n// once all connections are terminated,\n// - you can invoke coordinated shutdown to tear down the rest of the system:\nonceAllConnectionsTerminated.flatMap { _ =>\n  system.terminate()\n}\n Java copysourceActorSystem system = ActorSystem.create();\nMaterializer materializer = ActorMaterializer.create(system);\n\n\nCompletionStage<ServerBinding> binding = Http.get(system).bindAndHandle(\n    Directives.complete(\"Hello world!\").flow(system, materializer),\n    ConnectHttp.toHost(\"localhost\", 8080), materializer);\n\nServerBinding serverBinding = binding.toCompletableFuture().get(3, TimeUnit.SECONDS);\n\n// ...\n// once ready to terminate the server, invoke terminate:\nCompletionStage<HttpTerminated> onceAllConnectionsTerminated =\n    serverBinding.terminate(Duration.ofSeconds(3));\n\n// once all connections are terminated,\nonceAllConnectionsTerminated.toCompletableFuture().\n    thenAccept(terminated -> system.terminate());","title":"Graceful termination using ServerTerminator"},{"location":"/server-side/http2.html","text":"","title":"Server-Side HTTP/2 (Preview)"},{"location":"/server-side/http2.html#server-side-http-2-preview-","text":"Warning Server-Side HTTP/2 support in pekko-http is currently available as a preview. This means it is ready to be evaluated, but the APIs and behavior are likely to change.","title":"Server-Side HTTP/2 (Preview)"},{"location":"/server-side/http2.html#enable-http-2-support","text":"HTTP/2 can then be enabled through configuration:\npekko.http.server.preview.enable-http2 = on","title":"Enable HTTP/2 support"},{"location":"/server-side/http2.html#use-newserverat-bind-and-https","text":"HTTP/2 is primarily used over a secure HTTPS connection which takes care of protocol negotiation and falling back to HTTP/1.1 over TLS when the client does not support HTTP/2. See the HTTPS section for how to set up HTTPS.\nYou can use Http().newServerAt(...).bind()Http().get(system).newServerAt(...).bind() as long as you followed the above steps:\nScala copysourceimport scala.concurrent.Future\n\nimport org.apache.pekko\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.HttpsConnectionContext\nHttp().newServerAt(interface = \"localhost\", port = 8443).enableHttps(httpsServerContext).bind(asyncHandler) Java copysourceimport org.apache.pekko.http.javadsl.Http;\n\nHttp.get(system)\n  .newServerAt(\"127.0.0.1\", 8443)\n  .enableHttps(httpsConnectionContext)\n  .bind(asyncHandler);\nNote that currently only newServerAt(...).bind and newServerAt(...).bindSync support HTTP/2 but not bindFlow or connectionSource(): Source.\nHTTP/2 over TLS needs Application-Layer Protocol Negotiation (ALPN) to negotiate whether both client and server support HTTP/2. The JVM provides ALPN support starting from JDK 8u252. Make sure to use at least that version.","title":"Use newServerAt(...).bind() and HTTPS"},{"location":"/server-side/http2.html#http-2-without-https","text":"While un-encrypted connections are allowed by HTTP/2, this is sometimes discouraged.\nThere are 2 ways to implement un-encrypted HTTP/2 connections: by using the HTTP Upgrade mechanism or by starting communication in HTTP/2 directly which requires the client to have Prior Knowledge of HTTP/2 support.\nWe support both approaches transparently on the same port. This feature is automatically enabled when HTTP/2 is enabled:\nScala copysourceimport org.apache.pekko\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.HttpConnectionContext\n\nHttp().newServerAt(\"localhost\", 8080).bind(handler) Java copysourceimport org.apache.pekko.http.javadsl.Http;\n\nHttp.get(system)\n  .newServerAt(\"127.0.0.1\", 8443)\n  .bind(asyncHandler);","title":"HTTP/2 without HTTPS"},{"location":"/server-side/http2.html#h2c-upgrade","text":"The advantage of switching from HTTP/1.1 to HTTP/2 using the HTTP Upgrade mechanism is that both HTTP/1.1 and HTTP/2 clients can connect to the server on the same port, without being aware beforehand which protocol the server supports.\nThe disadvantage is that relatively few clients support switching to HTTP/2 in this way. Additionally, HTTP/2 communication cannot start until the first request has been completely sent. This means if your first request may be large, it might be worth it to start with an empty OPTIONS request to switch to HTTP/2 before sending your first ‘real’ request, at the cost of a roundtrip.","title":"h2c Upgrade"},{"location":"/server-side/http2.html#h2c-with-prior-knowledge","text":"The other option is to connect and start communicating in HTTP/2 immediately. The downside of this approach is the client must know beforehand that the server supports HTTP/2. For the reason this approach is known as h2c with Prior Knowledge of HTTP/2 support.","title":"h2c with prior knowledge"},{"location":"/server-side/http2.html#trailing-headers","text":"Like in the HTTP/1.1 ‘Chunked’ transfer encoding, HTTP/2 supports a trailer part containing headers after the body. Apache Pekko HTTP currently doesn’t expose the trailing headers of the request. For the response, you can either model the trailing headers as the HttpEntity.LastChunklast chunk of a HttpEntity.Chunkedchunked response entity, or use the trailertrailer attribute:\nScala copysourceimport org.apache.pekko\nimport pekko.http.scaladsl.model.ContentTypes\nimport pekko.http.scaladsl.model.HttpEntity\nimport pekko.http.scaladsl.model.Trailer\nimport pekko.http.scaladsl.model.AttributeKeys.trailer\nimport pekko.http.scaladsl.model.headers.RawHeader\nimport pekko.util.ByteString\n\nHttpResponse(StatusCodes.OK, entity = HttpEntity.Strict(ContentTypes.`text/plain(UTF-8)`, ByteString(\"Tralala\")))\n  .addAttribute(trailer, Trailer(RawHeader(\"name\", \"value\"))) Java copysourceimport org.apache.pekko.http.javadsl.model.Trailer;\nimport org.apache.pekko.http.javadsl.model.headers.RawHeader;\nimport static org.apache.pekko.http.javadsl.model.AttributeKeys.trailer;\n\nHttpResponse.create()\n        .withStatus(200)\n        .addAttribute(trailer, Trailer.create().addHeader(RawHeader.create(\"name\", \"value\")));\nHaving both a trailingHeaders attribute and a LastChunk element is not supported.","title":"Trailing headers"},{"location":"/server-side/http2.html#testing-with-curl","text":"At this point you should be able to connect, but HTTP/2 may still not be available.\nYou’ll need a recent version of cURL compiled with HTTP/2 support (for OSX see this article). You can check whether your version supports HTTP2 with curl --version, look for the nghttp2 extension and the HTTP2 feature:\ncurl 7.52.1 (x86_64-pc-linux-gnu) libcurl/7.52.1 OpenSSL/1.0.2l zlib/1.2.8 libidn2/0.16 libpsl/0.17.0 (+libidn2/0.16) libssh2/1.8.0 nghttp2/1.23.1 librtmp/2.3\nProtocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtmp rtsp scp sftp smb smbs smtp smtps telnet tftp\nFeatures: AsynchDNS IDN IPv6 Largefile GSS-API Kerberos SPNEGO NTLM NTLM_WB SSL libz TLS-SRP HTTP2 UnixSockets HTTPS-proxy PSL\nWhen you connect to your service you may now see something like:\n$ curl -k -v https://localhost:8443\n(...)\n* ALPN, offering h2\n* ALPN, offering http/1.1\n(...)\n* ALPN, server accepted to use h2\n(...)\n> GET / HTTP/1.1\n(...)\n< HTTP/2 200\n(...)\nIf your curl output looks like above, you have successfully configured HTTP/2. However, on JDKs up to version 9, it is likely to look like this instead:\n$ curl -k -v https://localhost:8443\n(...)\n* ALPN, offering h2\n* ALPN, offering http/1.1\n(...)\n* ALPN, server did not agree to a protocol\n(...)\n> GET / HTTP/1.1\n(...)\n< HTTP/1.1 200 OK\n(...)\nThis shows curl declaring it is ready to speak h2 (the shorthand name of HTTP/2), but could not determine whether the server is ready to, so it fell back to HTTP/1.1. To make this negotiation work you’ll have to configure ALPN as described below.","title":"Testing with cURL"},{"location":"/client-side/index.html","text":"","title":"5. Client API"},{"location":"/client-side/index.html#5-client-api","text":"All client-side functionality of Apache Pekko HTTP, for consuming HTTP-based services offered by other endpoints, is currently provided by the pekko-http-core module.\nIt is recommended to first read the Implications of the streaming nature of Request/Response Entities section, as it explains the underlying full-stack streaming concepts, which may be unexpected when coming from a background with non-“streaming first” HTTP Clients.\nAll of the APIs deal with HttpRequest and HttpResponse objects.\nDepending on your application’s specific needs you can choose from three different API levels:\nRequest-Level Client-Side API for letting Apache Pekko HTTP perform all connection management. Recommended for most usages. Host-Level Client-Side API for letting Apache Pekko HTTP manage a connection-pool to one specific host/port endpoint. Recommended when the user can supply a Source<HttpRequest, ?>Source[HttpRequest, _] with requests to run against a single host over multiple pooled connections. Connection-Level Client-Side API for full control over when HTTP connections are opened/closed and how requests are scheduled across them. Only recommended for particular use cases.\nYou can interact with different API levels at the same time and, independently of which API level you choose, Apache Pekko HTTP will happily handle many thousand concurrent connections to a single or many different hosts.\nConfiguration Basic Client Settings Pool Settings Per Host Overrides Precedence of settings HttpRequest and HttpResponse Creating requests Processing responses Request-Level Client-Side API Future-Based Variant Example Using the Future-Based API in Actors Flow-Based Variant Collecting headers from a server response Host-Level Client-Side API Requesting a Host Connection Pool Configuring a Host Connection Pool Using a Host Connection Pool Connection Allocation Logic Retrying a Request Pool Shutdown Examples Using the host-level API with a queue Using the host-level API in a streaming fashion Connection-Level Client-Side API Opening HTTP Connections Request-Response Cycle Closing Connections Timeouts Stand-Alone HTTP Layer Usage Pool overflow and the max-open-requests setting Common causes of pool overload Why does this happen only with Apache Pekko Http and not with [insert other client] Client-Side HTTPS Support Detailed configuration and workarounds Disabling hostname verification Pluggable Client Transports / HTTP(S) proxy Support Configuring Client Transports Predefined Transports TCP HTTP(S) Proxy Use HTTP(S) proxy with Http().singleRequestHttp.get(...).singleRequest Use HTTP(S) proxy that requires authentication Use HTTP(S) proxy with Http().singleWebSocketRequestHttp.get(…).singleWebSocketRequest Use HTTP(S) proxy that requires authentication for Web Sockets Custom Host Name Resolution Transport Implementing Custom Transports Client-Side WebSocket Support Message singleWebSocketRequest webSocketClientFlow webSocketClientLayer Half-Closed WebSockets Automatic keep-alive Ping support Custom keep-alive data payloads Uni-directional Pong keep-alive Client-Side HTTP/2 (Preview) Create the client HTTP/2 over TLS h2c with prior knowledge HTTP Upgrade mechanism Request-response ordering","title":"5. Client API"},{"location":"/client-side/configuration.html","text":"","title":"Configuration"},{"location":"/client-side/configuration.html#configuration","text":"HTTP client settings are split into different sections\npekko.http.client: basic client settings pekko.http.host-connection-pool: pool settings","title":"Configuration"},{"location":"/client-side/configuration.html#basic-client-settings","text":"These settings influence the basic library behavior for each HTTP connection. When changed in the application’s application.conf they globally affect the default client behavior.\nBasic client settings can be overridden in multiple ways:\nby passing custom ClientConnectionSettingsClientConnectionSettings instances to APIs in HttpHttp by overriding settings in pekko.http.host-connection-pool.client, these overrides will take effect whenever a pool is used like with Http().singleRequest by putting custom ClientConnectionSettingsClientConnectionSettings into ConnectionPoolSettingsConnectionPoolSettings and passing those to APIs in Http by using per-host overrides\ncopysourceclient {\n  # The default value of the `User-Agent` header to produce if no\n  # explicit `User-Agent`-header was included in a request.\n  # If this value is the empty string and no header was included in\n  # the request, no `User-Agent` header will be rendered at all.\n  user-agent-header = pekko-http/${pekko.http.version}\n\n  # The time period within which the TCP connecting process must be completed.\n  connecting-timeout = 10s\n\n  # The time after which an idle connection will be automatically closed.\n  # Set to `infinite` to completely disable idle timeouts.\n  idle-timeout = 60 s\n\n  # The initial size of the buffer to render the request headers in.\n  # Can be used for fine-tuning request rendering performance but probably\n  # doesn't have to be fiddled with in most applications.\n  request-header-size-hint = 512\n\n  # Socket options to set for the listening socket. If a setting is left\n  # undefined, it will use whatever the default on the system is.\n  socket-options {\n    so-receive-buffer-size = undefined\n    so-send-buffer-size = undefined\n    so-reuse-address = undefined\n    so-traffic-class = undefined\n    tcp-keep-alive = undefined\n    tcp-oob-inline = undefined\n    tcp-no-delay = undefined\n  }\n\n  # Client https proxy options. When using ClientTransport.httpsProxy() with or without credentials,\n  # host/port must be either passed explicitly or set here. If a host is not set, the proxy will not be used.\n  proxy {\n    https {\n      host = \"\"\n      port = 443\n    }\n  }\n\n  # Modify to tweak parsing settings on the client-side only.\n  parsing {\n    # no overrides by default, see `pekko.http.parsing` for default values\n\n    # Default maximum content length which should not be exceeded by incoming response entities.\n    # Can be changed at runtime (to a higher or lower value) via the `HttpEntity::withSizeLimit` method.\n    # Note that it is not necessarily a problem to set this to a high value as all stream operations\n    # are always properly backpressured.\n    #\n    # On the client-side, this limit is disabled by default because a client controls the requests it runs.\n    #\n    # Set to `infinite` to completely disable entity length checks. (Even then you can still apply one\n    # programmatically via `withSizeLimit`.)\n    max-content-length = infinite\n  }\n\n  # Enables/disables the logging of unencrypted HTTP traffic to and from the HTTP\n  # client for debugging reasons.\n  #\n  # Note: Use with care. Logging of unencrypted data traffic may expose secret data.\n  #\n  # Incoming and outgoing traffic will be logged in hexdump format. To enable logging,\n  # specify the number of bytes to log per chunk of data (the actual chunking depends\n  # on implementation details and networking conditions and should be treated as\n  # arbitrary).\n  #\n  # For logging on the server side, see pekko.http.server.log-unencrypted-network-bytes.\n  #\n  # `off` : no log messages are produced\n  # Int   : determines how many bytes should be logged per data chunk\n  log-unencrypted-network-bytes = off\n\n  websocket {\n    # periodic keep alive may be implemented using by sending Ping frames\n    # upon which the other side is expected to reply with a Pong frame,\n    # or by sending a Pong frame, which serves as unidirectional heartbeat.\n    # Valid values:\n    #   ping - default, for bi-directional ping/pong keep-alive heartbeating\n    #   pong - for uni-directional pong keep-alive heartbeating\n    #\n    # See https://tools.ietf.org/html/rfc6455#section-5.5.2\n    # and https://tools.ietf.org/html/rfc6455#section-5.5.3 for more information\n    periodic-keep-alive-mode = ping\n\n    # Interval for sending periodic keep-alives\n    # The frame sent will be the one configured in pekko.http.server.websocket.periodic-keep-alive-mode\n    # `infinite` by default, or a duration that is the max idle interval after which an keep-alive frame should be sent\n    periodic-keep-alive-max-idle = infinite\n\n    # Enable verbose debug logging for all ingoing and outgoing frames\n    log-frames = false\n  }\n\n  # Cancellation in the HTTP streams is delayed by this duration to prevent race conditions between cancellation\n  # and stream completion / failure. In most cases, the value chosen here should make no difference because\n  # HTTP streams are loops where completion and failures should propagate immediately and make the handling of\n  # cancellations redundant.\n  #\n  # In most cases, there should be no reason to change this setting.\n  #\n  # Set to 0 to disable the delay.\n  stream-cancellation-delay = 100 millis\n}","title":"Basic Client Settings"},{"location":"/client-side/configuration.html#pool-settings","text":"Pool settings influence the behavior of client connection pools as used with APIs like Http.singleRequest (see request-level and host-level).\nThis includes the amount of total concurrent connections a pool should open to a target host and other settings. These settings include a (by default empty) section client that can be used to override basic client settings when used in the context of a pool.\nPool settings can be overridden on a per-target-host basis.\ncopysourcehost-connection-pool {\n  # The maximum number of parallel connections that a connection pool to a\n  # single host endpoint is allowed to establish. Must be greater than zero.\n  max-connections = 4\n\n  # The minimum number of parallel connections that a pool should keep alive (\"hot\").\n  # If the number of connections is falling below the given threshold, new ones are being spawned.\n  # You can use this setting to build a hot pool of \"always on\" connections.\n  # Default is 0, meaning there might be no active connection at given moment.\n  # Keep in mind that `min-connections` should be smaller than `max-connections` or equal\n  min-connections = 0\n\n  # The maximum number of times failed requests are attempted again,\n  # (if the request can be safely retried) before giving up and returning an error.\n  # Set to zero to completely disable request retries.\n  max-retries = 5\n\n  # The maximum number of open requests accepted into the pool across all\n  # materializations of any of its client flows.\n  # Protects against (accidentally) overloading a single pool with too many client flow materializations.\n  # Note that with N concurrent materializations the max number of open request in the pool\n  # will never exceed N * max-connections * pipelining-limit.\n  # Must be a power of 2 and > 0!\n  max-open-requests = 32\n\n  # The maximum duration for a connection to be kept alive\n  # This amount gets modified by a 10 percent fuzzyness to avoid the simultanous reconnections\n  # defaults to 'infinite'\n  # Note that this is only implemented in the new host connection pool\n  max-connection-lifetime = infinite\n\n  # Client-side pipelining is not currently supported. See https://github.com/apache/incubator-pekko-http/issues/32\n  pipelining-limit = 1\n\n  # The minimum duration to backoff new connection attempts after the previous connection attempt failed.\n  #\n  # The pool uses an exponential randomized backoff scheme. After the first failure, the next attempt will only be\n  # tried after a random duration between the base connection backoff and twice the base connection backoff. If that\n  # attempt fails as well, the next attempt will be delayed by twice that amount. The total delay is capped using the\n  # `max-connection-backoff` setting.\n  #\n  # The backoff applies for the complete pool. I.e. after one failed connection attempt, further connection attempts\n  # to that host will backoff for all connections of the pool. After the service recovered, connections will come out\n  # of backoff one by one due to the random extra backoff time. This is to avoid overloading just recently recovered\n  # services with new connections (\"thundering herd\").\n  #\n  # Example: base-connection-backoff = 100ms, max-connection-backoff = 10 seconds\n  #   - After 1st failure, backoff somewhere between 100ms and 200ms\n  #   - After 2nd, between  200ms and  400ms\n  #   - After 3rd, between  200ms and  400ms\n  #   - After 4th, between  400ms and  800ms\n  #   - After 5th, between  800ms and 1600ms\n  #   - After 6th, between 1600ms and 3200ms\n  #   - After 7th, between 3200ms and 6400ms\n  #   - After 8th, between 5000ms and 10 seconds (max capped by max-connection-backoff, min by half of that)\n  #   - After 9th, etc., stays between 5000ms and 10 seconds\n  #\n  # This setting only applies to the new pool implementation and is ignored for the legacy one.\n  base-connection-backoff = 100ms\n\n  # Maximum backoff duration between failed connection attempts. For more information see the above comment for the\n  # `base-connection-backoff` setting.\n  #\n  # This setting only applies to the new pool implementation and is ignored for the legacy one.\n  max-connection-backoff = 2 min\n\n  # The time after which an idle connection pool (without pending requests)\n  # will automatically terminate itself. Set to `infinite` to completely disable idle timeouts.\n  idle-timeout = 30 s\n\n  # HTTP connections are commonly used for multiple requests, that is, they are kept alive between requests. The\n  # `pekko.http.host-connection-pool.keep-alive-timeout` setting configures how long a pool keeps a connection alive between\n  # requests before it closes the connection (and eventually reestablishes it).\n  #\n  # A common scenario where this setting is useful is to prevent a race-condition inherent in HTTP: in most cases, a server\n  # or reverse-proxy closes a persistent (kept-alive) connection after some time. HTTP does not define a protocol between\n  # client and server to negotiate a graceful teardown of an idle persistent connection. Therefore, it can happen that a server decides to\n  # close a connection at the same time that a client decides to send a new request. In that case, the request will fail to be processed,\n  # but the client cannot determine for which reason the server closed the connection and whether the request was (partly) processed or not.\n  # Such a condition can be observed when a request fails with an `UnexpectedConnectionClosureException` or a `StreamTcpException` stating\n  # \"Connection reset by peer\".\n  #\n  # To prevent this from happening, you can set the timeout to a lower value than the server-side keep-alive timeout\n  # (which you either have to know or find out experimentally).\n  #\n  # Set to `infinite` to allow the connection to remain open indefinitely (or be closed by the more general `idle-timeout`).\n  keep-alive-timeout = infinite\n\n  # The pool implementation will fail a connection early and clear the slot if a response entity was not\n  # subscribed during the given time period after the response was dispatched. In busy systems the timeout might be\n  # too tight if a response is not picked up quick enough after it was dispatched by the pool.\n  response-entity-subscription-timeout = 1.second\n\n  # Modify this section to tweak client settings only for host connection pools APIs like `Http().superPool` or\n  # `Http().singleRequest`.\n  client = {\n    # no overrides by default, see `pekko.http.client` for default values\n  }\n\n  # Allows overriding settings per host. The setting must be a list in which each entry\n  # is an object with a `host-pattern` entry that specifies for which hosts the overrides\n  # should take effect. All other entries have the same syntax as entries in the\n  # `host-connection-pool` section.\n  #\n  # The `host-pattern` can have these forms:\n  #  * `regex:<pattern>`: the host name is matched against the regular expression pattern\n  #  * `glob:<glob-pattern>` or just `<glob-pattern>`: the host is matched against the given\n  #    pattern. In the pattern the wildcard `*` stands for zero or more characters and `?`\n  #    for any single character\n  #\n  # In both cases, a pattern that matches `*.` at the beginning, i.e. every subdomain,\n  # is expanded to also cover the domain itself (without the leading dot).\n  #\n  # If patterns from multiple entries in the list are matched, only settings from the\n  # first entry found are applied.\n  #\n  # Example:\n  #\n  # per-host-override = [\n  # {\n  #   host-pattern = \"doc.akka.io\"\n  #   # Use the same entries as in the `host-connection-pool` section\n  #   max-connections = 10\n  # },\n  # {\n  #   # `*.akka.io` matches all subdomains like `repo.akka.io` but also `akka.io` itself.\n  #   # `doc.akka.io` is already covered by a previous entry, so these settings here\n  #   # will not apply to `doc.akka.io`.\n  #   host-pattern = \"*.akka.io\"\n  #   max-connections = 11\n  # }\n  # ]\n  per-host-override = []\n\n}","title":"Pool Settings"},{"location":"/client-side/configuration.html#per-host-overrides","text":"Settings can be overridden on a per-host basis by creating a list of host-patterns together with overridden settings in the pekko.http.host-connection-pool.per-host-override setting.\nNote that only the first matching entry is selected and used even if multiple entries would match.\ncopysource# Allows overriding settings per host. The setting must be a list in which each entry\n# is an object with a `host-pattern` entry that specifies for which hosts the overrides\n# should take effect. All other entries have the same syntax as entries in the\n# `host-connection-pool` section.\n#\n# The `host-pattern` can have these forms:\n#  * `regex:<pattern>`: the host name is matched against the regular expression pattern\n#  * `glob:<glob-pattern>` or just `<glob-pattern>`: the host is matched against the given\n#    pattern. In the pattern the wildcard `*` stands for zero or more characters and `?`\n#    for any single character\n#\n# In both cases, a pattern that matches `*.` at the beginning, i.e. every subdomain,\n# is expanded to also cover the domain itself (without the leading dot).\n#\n# If patterns from multiple entries in the list are matched, only settings from the\n# first entry found are applied.\n#\n# Example:\n#\n# per-host-override = [\n# {\n#   host-pattern = \"doc.akka.io\"\n#   # Use the same entries as in the `host-connection-pool` section\n#   max-connections = 10\n# },\n# {\n#   # `*.akka.io` matches all subdomains like `repo.akka.io` but also `akka.io` itself.\n#   # `doc.akka.io` is already covered by a previous entry, so these settings here\n#   # will not apply to `doc.akka.io`.\n#   host-pattern = \"*.akka.io\"\n#   max-connections = 11\n# }\n# ]\nper-host-override = []","title":"Per Host Overrides"},{"location":"/client-side/configuration.html#precedence-of-settings","text":"When using pool APIs, settings take precedence like this (highest precedence first):\nclient settings in first per-host-override entry whose host-pattern matches the given target host settings in pekko.http.host-connection-pool.client settings in pekko.http.client","title":"Precedence of settings"},{"location":"/client-side/request-and-response.html","text":"","title":"HttpRequest and HttpResponse"},{"location":"/client-side/request-and-response.html#httprequest-and-httpresponse","text":"All 3 Apache Pekko HTTP Client API levels use the same basic model of HttpRequestHttpRequest and HttpResponseHttpResponse.","title":"HttpRequest and HttpResponse"},{"location":"/client-side/request-and-response.html#creating-requests","text":"You can create simple GET requests:\nScala copysourceHttpRequest(uri = \"https://pekko.apache.org\")\n\n// or:\nimport org.apache.pekko.http.scaladsl.client.RequestBuilding.Get\nGet(\"https://pekko.apache.org\")\n\n// with query params\nGet(\"https://pekko.apache.org?foo=bar\")\n Java copysourceHttpRequest.create(\"https://pekko.apache.org\");\n\n// with query params\nHttpRequest.create(\"https://pekko.apache.org?foo=bar\");\nNote HttpRequestHttpRequest alsoHttpRequestHttpRequest’s method HttpRequest::withUri() takes UriUri as a parameter. Query String in URI section describes a fluent API for building URIs with query parameters.\nOr more complicated ones, like this POST:\nScala copysourceHttpRequest(\n  method = HttpMethods.POST,\n  uri = \"https://userservice.example/users\",\n  entity = HttpEntity(ContentTypes.`text/plain(UTF-8)`, \"data\"))\n\n// or:\nimport org.apache.pekko.http.scaladsl.client.RequestBuilding.Post\nPost(\"https://userservice.example/users\", \"data\") Java copysourceHttpRequest.POST(\"https://userservice.example/users\")\n  .withEntity(HttpEntities.create(ContentTypes.TEXT_PLAIN_UTF8, \"data\"));\nSee the API documentation of HttpRequestHttpRequest for more information on how to customize your requests.","title":"Creating requests"},{"location":"/client-side/request-and-response.html#processing-responses","text":"When you receive a response, you can use the Marshalling API to convert the response entity into an object:\nScala copysourceimport org.apache.pekko\nimport pekko.http.scaladsl.unmarshalling.Unmarshal\nimport pekko.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._\nimport spray.json.DefaultJsonProtocol._\n\ncase class Pet(name: String)\nimplicit val petFormat = jsonFormat1(Pet)\n\nval pet: Future[Pet] = Unmarshal(response).to[Pet] Java copysourceCompletionStage<Pet> pet = Jackson.unmarshaller(Pet.class).unmarshal(response.entity(), system);","title":"Processing responses"},{"location":"/client-side/request-level.html","text":"","title":"Request-Level Client-Side API"},{"location":"/client-side/request-level.html#request-level-client-side-api","text":"The request-level API is the recommended and most convenient way of using Apache Pekko HTTP’s client-side functionality. It internally builds upon the Host-Level Client-Side API to provide you with a simple and easy-to-use way of retrieving HTTP responses from remote servers. Depending on your preference you can pick the Future-based variant or Flow-based variant.\nNote It is recommended to first read the Implications of the streaming nature of Request/Response Entities section, as it explains the underlying full-stack streaming concepts, which may be unexpected when coming from a background with non-“streaming first” HTTP Clients.\nNote The request-level API is implemented on top of a connection pool that is shared inside the actor system. A consequence of using a pool is that long-running requests block a connection while running and starve other requests. Make sure not to use the request-level API for long-running requests like long-polling GET requests. Use the Connection-Level Client-Side API or an extra pool just for the long-running connection instead.","title":"Request-Level Client-Side API"},{"location":"/client-side/request-level.html#future-based-variant","text":"Most often, your HTTP client needs are very basic. You need the HTTP response for a certain request and don’t want to bother with setting up a full-blown streaming infrastructure.\nFor these cases Apache Pekko HTTP offers the Http().singleRequest(...)Http.get(system).singleRequest(...) method, which turns an HttpRequestHttpRequest instance into Future[HttpResponse]CompletionStage<HttpResponse>. Internally the request is dispatched across the (cached) host connection pool for the request’s effective URI.\nThe request must have either an absolute URI or a valid Host header, otherwise the returned future will be completed with an error.","title":"Future-Based Variant"},{"location":"/client-side/request-level.html#example","text":"Scala copysource/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * license agreements; and to You under the Apache License, version 2.0:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * This file is part of the Apache Pekko project, derived from Akka.\n */\n\n/*\n * Copyright (C) 2020-2022 Lightbend Inc. <https://www.lightbend.com>\n */\n\npackage docs.http.scaladsl\n\nimport org.apache.pekko\nimport pekko.actor.typed.ActorSystem\nimport pekko.actor.typed.scaladsl.Behaviors\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.model._\n\nimport scala.concurrent.Future\nimport scala.util.{ Failure, Success }\n\nobject HttpClientSingleRequest {\n  def main(args: Array[String]): Unit = {\n    implicit val system = ActorSystem(Behaviors.empty, \"SingleRequest\")\n    // needed for the future flatMap/onComplete in the end\n    implicit val executionContext = system.executionContext\n\n    val responseFuture: Future[HttpResponse] = Http().singleRequest(HttpRequest(uri = \"http://pekko.apache.org\"))\n\n    responseFuture\n      .onComplete {\n        case Success(res) => println(res)\n        case Failure(_)   => sys.error(\"something wrong\")\n      }\n  }\n} Java copysourcefinal ActorSystem system = ActorSystem.create();\n\nfinal CompletionStage<HttpResponse> responseFuture =\n  Http.get(system)\n      .singleRequest(HttpRequest.create(\"http://pekko.apache.org\"));","title":"Example"},{"location":"/client-side/request-level.html#using-the-future-based-api-in-actors","text":"When using the FutureCompletionStage based API from inside a classic Apache Pekko ActorActor, all the usual caveats apply to how one should deal with the futures completion. For example, you should not access the actor’s state from within the FutureCompletionStage’s callbacks (such as map, onComplete, …) and, instead, you should use the pipeTopipe pattern to pipe the result back to the actor as a message:\nScala copysourceimport org.apache.pekko\nimport pekko.actor.{ Actor, ActorLogging }\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.model._\nimport pekko.util.ByteString\n\nclass Myself extends Actor\n    with ActorLogging {\n\n  import pekko.pattern.pipe\n  import context.dispatcher\n\n  implicit val system = context.system\n  val http = Http(system)\n\n  override def preStart() = {\n    http.singleRequest(HttpRequest(uri = \"http://pekko.apache.org\"))\n      .pipeTo(self)\n  }\n\n  def receive = {\n    case HttpResponse(StatusCodes.OK, headers, entity, _) =>\n      entity.dataBytes.runFold(ByteString(\"\"))(_ ++ _).foreach { body =>\n        log.info(\"Got response, body: \" + body.utf8String)\n      }\n    case resp @ HttpResponse(code, _, _, _) =>\n      log.info(\"Request failed, response code: \" + code)\n      resp.discardEntityBytes()\n  }\n\n} Java copysourceimport org.apache.pekko.actor.AbstractActor;\nimport org.apache.pekko.http.javadsl.model.HttpRequest;\nimport org.apache.pekko.http.javadsl.model.HttpResponse;\nimport static org.apache.pekko.pattern.PatternsCS.pipe;\n\nclass SingleRequestInActorExample extends AbstractActor {\n  final Http http = Http.get(context().system());\n  final ExecutionContextExecutor dispatcher = context().dispatcher();\n\n  @Override\n  public Receive createReceive() {\n    return receiveBuilder()\n      .match(String.class, url -> pipe(fetch(url), dispatcher).to(self()))\n      .build();\n  }\n\n  CompletionStage<HttpResponse> fetch(String url) {\n    return http.singleRequest(HttpRequest.create(url));\n  }\n}\nWarning Always make sure you consume the response entity streams (of type Source<ByteString,Unit>Source[ByteString,Unit]Source<ByteString, Object>Source[ByteString, Object]). Connect the response entity Source to a SinkSink, or call response.discardEntityBytes()response.discardEntityBytes(Materializer) if you don’t care about the response entity. Read the Implications of the streaming nature of Request/Response Entities section for more details. If the application doesn’t subscribe to the response entity within pekko.http.host-connection-pool.response-entity-subscription-timeout, the stream will fail with a TimeoutException: Response entity was not subscribed after ....","title":"Using the Future-Based API in Actors"},{"location":"/client-side/request-level.html#flow-based-variant","text":"The Flow-based variant of the request-level client-side API is presented by the Http().superPool(...)Http.get(system).superPool(...) method. It creates a new “super connection pool flow”, which routes incoming requests to a (cached) host connection pool depending on their respective effective URIs.\nThe FlowFlow returned by Http().superPool(...)Http.get(system).superPool(...) is very similar to the one from the Host-Level Client-Side API, so the section on Using a Host Connection Pool also applies here.\nHowever, there is one notable difference between a “host connection pool client flow” for the Host-Level API and a “super-pool flow” from the Request-Level API:\nIn a “host connection pool client flow” the flow has an implicit target host context. Therefore, the requests it takes don’t need to have absolute URIs or a valid Host header because the host connection pool will automatically add a Host header if required.\nFor a “super-pool flow” in the Request-Level API this is not the case. All requests to a super-pool must either have an absolute URI or a valid Host header, because otherwise it’d be impossible to find out which target endpoint to direct the request to.","title":"Flow-Based Variant"},{"location":"/client-side/request-level.html#collecting-headers-from-a-server-response","text":"Sometimes we would like to get only headers of specific type which are sent from a server. In order to collect headers in a type safe way Apache Pekko HTTP API provides a type for each HTTP header. Here is an example for getting all cookies set by a server (Set-Cookie header):\nScala copysource/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * license agreements; and to You under the Apache License, version 2.0:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * This file is part of the Apache Pekko project, derived from Akka.\n */\n\n/*\n * Copyright (C) 2020-2022 Lightbend Inc. <https://www.lightbend.com>\n */\n\npackage docs.http.scaladsl\n\nimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.model.headers.`Set-Cookie`\nimport pekko.http.scaladsl.model._\n\nimport scala.concurrent.ExecutionContextExecutor\nimport scala.concurrent.Future\n\nclass HttpClientCollectingHeaders {\n  def main(args: Array[String]): Unit = {\n    implicit val system: ActorSystem = ActorSystem()\n    implicit val executionContext: ExecutionContextExecutor = system.dispatcher\n\n    val responseFuture: Future[HttpResponse] = Http().singleRequest(HttpRequest(uri = \"http://pekko.apache.org\"))\n\n    responseFuture.map {\n      case response @ HttpResponse(StatusCodes.OK, _, _, _) =>\n        val setCookies = response.headers[`Set-Cookie`]\n        println(s\"Cookies set by a server: $setCookies\")\n        response.discardEntityBytes()\n      case _ => sys.error(\"something wrong\")\n    }\n  }\n} Java copysourcefinal HttpResponse response = responseFromSomewhere();\n\nfinal Iterable<SetCookie> setCookies = response.getHeaders(SetCookie.class);\n\nSystem.out.println(\"Cookies set by a server: \" + setCookies);\nresponse.discardEntityBytes(system);","title":"Collecting headers from a server response"},{"location":"/client-side/host-level.html","text":"","title":"Host-Level Client-Side API"},{"location":"/client-side/host-level.html#host-level-client-side-api","text":"As opposed to the Connection-Level Client-Side API the host-level API relieves you from manually managing individual HTTP connections. It autonomously manages a configurable pool of connections to one particular target endpoint (i.e. host/port combination).\nNote It is recommended to first read the Implications of the streaming nature of Request/Response Entities section, as it explains the underlying full-stack streaming concepts, which may be unexpected when coming from a background with non-“streaming first” HTTP Clients.","title":"Host-Level Client-Side API"},{"location":"/client-side/host-level.html#requesting-a-host-connection-pool","text":"The best way to get a hold of a connection pool to a given target endpoint is the Http().cachedHostConnectionPool(...)Http.get(system).cachedHostConnectionPool(...) method, which returns a FlowFlow that can be “baked” into an application-level stream setup. This flow is also called a “pool client flow”.\nThe connection pool underlying a pool client flow is cached. For every ActorSystemActorSystem, target endpoint and pool configuration there will never be more than a single pool live at any time.\nAlso, the HTTP layer transparently manages idle shutdown and restarting of connection pools as configured. The client flow instances therefore remain valid throughout the lifetime of the application, i.e. they can be materialized as often as required and the time between individual materialization is of no importance.\nWhen you request a pool client flow with Http().cachedHostConnectionPool(...)Http.get(system).cachedHostConnectionPool(...), Apache Pekko HTTP will immediately start the pool, even before the first client flow materialization. However, this running pool will not actually open the first connection to the target endpoint until the first request has arrived.","title":"Requesting a Host Connection Pool"},{"location":"/client-side/host-level.html#configuring-a-host-connection-pool","text":"Apart from the connection-level config settings and socket options there are a number of settings that allow you to influence the behavior of the connection pool logic itself. Check out the pekko.http.host-connection-pool section of the Apache Pekko HTTP Configuration for more information about which settings are available and what they mean.\nNote that, if you request pools with different configurations for the same target host you will get independent pools. This means that, in total, your application might open more concurrent HTTP connections to the target endpoint than any of the individual pool’s max-connections settings allow!\nThere is one setting that likely deserves a bit deeper explanation: max-open-requests. This setting limits the maximum number of requests that can be in-flight at any time for a single connection pool. If an application calls Http().cachedHostConnectionPool(...)Http.get(system).cachedHostConnectionPool(...) 3 times (with the same endpoint and settings) it will get back 3 different client flow instances for the same pool. If each of these client flows is then materialized 4 times (concurrently) the application will have 12 concurrently running client flow materializations. All of these share the resources of the single pool.\nThis means that no more than 12 requests can be open at any time.\nThe max-open-requests config setting allows for applying a hard limit which serves mainly as a protection against erroneous connection pool use, e.g. because the application is materializing too many client flows that all compete for the same pooled connections.","title":"Configuring a Host Connection Pool"},{"location":"/client-side/host-level.html#using-a-host-connection-pool","text":"The “pool client flow” returned by Http().cachedHostConnectionPool(...)Http.get(system).cachedHostConnectionPool(...) has the following type:\nFlow[(HttpRequest, T), (Try[HttpResponse], T), HostConnectionPool]\nFlow<Pair<HttpRequest, T>, Pair<Try<HttpResponse>, T>, HostConnectionPool>\nThis means it consumes pairs of type (HttpRequest, T)Pair[HttpRequest, T]Pair<HttpRequest, T> and produces pairs of type (Try[HttpResponse], T)Pair<Try<HttpResponse>, T> which might appear more complicated than necessary on first sight. The reason why the pool API includes objects of custom type T on both ends lies in the fact that the underlying transport usually comprises more than a single connection and as such the pool client flow often generates responses in an order that doesn’t directly match the consumed requests. We could have built the pool logic in a way that reorders responses according to their requests before dispatching them to the application, but this would have meant that a single slow response could block the delivery of potentially many responses that would otherwise be ready for consumption by the application.\nIn order to prevent unnecessary head-of-line blocking the pool client-flow is allowed to dispatch responses as soon as they arrive, independently of the request order. Of course this means that there needs to be another way to associate a response with its respective request. The way that this is done is by allowing the application to pass along a custom “context” object with the request, which is then passed back to the application with the respective response. This context object of type T is completely opaque to Apache Pekko HTTP, i.e. you can pick whatever works best for your particular application scenario.\nNote A consequence of using a pool is that long-running requests block a connection while running and may starve other requests. Make sure not to use a connection pool for long-running requests like long-polling GET requests. Use the Connection-Level Client-Side API instead.","title":"Using a Host Connection Pool"},{"location":"/client-side/host-level.html#connection-allocation-logic","text":"This is how Apache Pekko HTTP allocates incoming requests to the available connection “slots”:\nIf there is a connection alive and currently idle then schedule the request across this connection. If no connection is idle and there is still an unconnected slot then establish a new connection. If all connections are already established and “loaded” with other requests then pick the connection with the least open requests that only has requests with idempotent methods scheduled to it, if there is one. Otherwise apply back-pressure to the request source, i.e. stop accepting new requests.","title":"Connection Allocation Logic"},{"location":"/client-side/host-level.html#retrying-a-request","text":"If the max-retries pool config setting is greater than zero the pool retries idempotent requests for which a response could not be successfully retrieved. Idempotent requests are those whose HTTP method is defined to be idempotent by the HTTP spec, which are all the ones currently modelled by Apache Pekko HTTP except for the POST, PATCH and CONNECT methods.\nWhen a response could not be received for a certain request there are essentially three possible error scenarios:\nThe request got lost on the way to the server. The server experiences a problem while processing the request. The response from the server got lost on the way back.\nSince the host connector cannot know which one of these possible reasons caused the problem and therefore PATCH and POST requests could have already triggered a non-idempotent action on the server these requests cannot be retried.\nIn these cases, as well as when all retries have not yielded a proper response, the pool produces a failed Try (i.e. a scala.util.Failure) together with the custom request context.\nIf a request fails during connecting to the server, for example, because the DNS name cannot be resolved or the server is currently unavailable, retries are attempted with exponential backoff delay. See the documentation of the pekko.http.host-connection-pool.base-connection-backoff setting in the configuration.","title":"Retrying a Request"},{"location":"/client-side/host-level.html#pool-shutdown","text":"Completing a pool client flow will simply detach the flow from the pool. The connection pool itself will continue to run as it may be serving other client flows concurrently or in the future. Only after the configured idle-timeout for the pool has expired will Apache Pekko HTTP automatically terminate the pool and free all its resources.\nIf a new client flow is requested with Http().cachedHostConnectionPool(...)Http.get(system).cachedHostConnectionPool(...) or if an already existing client flow is re-materialized the respective pool is automatically and transparently restarted.\nIn addition to the automatic shutdown via the configured idle timeouts it’s also possible to trigger the immediate shutdown of a specific pool by calling shutdown() on the HostConnectionPool instance that the pool client flow materializes into. This shutdown() call produces a Future[Unit]CompletionStage<Done> which is fulfilled when the pool termination has been completed.\nIt’s also possible to trigger the immediate termination of all connection pools in the ActorSystemActorSystem at the same time by calling Http().shutdownAllConnectionPools()Http.get(system).shutdownAllConnectionPools(). This call too produces a Future[Unit]CompletionStage<Done> which is fulfilled when all pools have terminated.\nHttp().addClientPoolsToCoordinatedShutdown()Http.get(system).addClientPoolsToCoordinatedShutdown() will add the client connection pool shutdown to Apache Pekko’s coordinated shutdown so it will be called before the actor system disappears.\nNote When encountering unexpected AbruptTerminationExceptionAbruptTerminationException exceptions during ActorSystemActorSystem shutdown please make sure that active connections are shut down before shutting down the entire system, this can be done by calling the Http().shutdownAllConnectionPools()Http.get(system).shutdownAllConnectionPools() method, and only once its FutureCompletionStage completes, shutting down the actor system.","title":"Pool Shutdown"},{"location":"/client-side/host-level.html#examples","text":"Note At this place we previously showed an example that used the Source.single(request).via(pool).runWith(Sink.head). In fact, this is an anti-pattern that doesn’t perform well. Please either supply requests using a queue or in a streamed fashion as shown below.\nUsing the host-level API with a queue In many cases, you just want to issue requests to a pool and receive responses when they are available. In most cases, you should use the Request-Level Client-Side API for this purpose. If you want to use a similar Future-based API with the host-level API, here’s how to do it. As explained above, Apache Pekko HTTP prevents to build up an unbounded buffer of requests and an unlimited number of connections. Therefore, it guards itself a) by applying backpressure to all request streams connected to the cached pool and b) by failing requests with a BufferOverflowExceptionBufferOverflowException when the internal buffer overflows when too many materializations exist or too many requests have been issued to the pool. To mimic the request-level API we can put an explicit queue in front of the pool and decide ourselves what to do when this explicit queue overflows. This example shows how to do this. (Thanks go to kazuhiro’s blog for the initial idea.) You can tweak the QueueSize setting according to your memory constraints. In any case, you need to think about a strategy about what to do when requests fail because the queue overflowed (e.g. try again later or just fail). copysourceimport scala.util.{ Failure, Success }\nimport scala.concurrent.{ Future, Promise }\n\nimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.model._\nimport pekko.stream.scaladsl._\n\nimport pekko.stream.{ OverflowStrategy, QueueOfferResult }\n\nimplicit val system = ActorSystem()\nimport system.dispatcher // to get an implicit ExecutionContext into scope\n\nval QueueSize = 10\n\n// This idea came initially from this blog post:\n// http://kazuhiro.github.io/scala/akka/akka-http/akka-streams/2016/01/31/connection-pooling-with-akka-http-and-source-queue.html\nval poolClientFlow = Http().cachedHostConnectionPool[Promise[HttpResponse]](\"pekko.apache.org\")\nval queue =\n  Source.queue[(HttpRequest, Promise[HttpResponse])](QueueSize, OverflowStrategy.dropNew)\n    .via(poolClientFlow)\n    .to(Sink.foreach {\n      case ((Success(resp), p)) => p.success(resp)\n      case ((Failure(e), p))    => p.failure(e)\n    })\n    .run()\n\ndef queueRequest(request: HttpRequest): Future[HttpResponse] = {\n  val responsePromise = Promise[HttpResponse]()\n  queue.offer(request -> responsePromise).flatMap {\n    case QueueOfferResult.Enqueued    => responsePromise.future\n    case QueueOfferResult.Dropped     => Future.failed(new RuntimeException(\"Queue overflowed. Try again later.\"))\n    case QueueOfferResult.Failure(ex) => Future.failed(ex)\n    case QueueOfferResult.QueueClosed => Future.failed(\n        new RuntimeException(\"Queue was closed (pool shut down) while running the request. Try again later.\"))\n  }\n}\n\nval responseFuture: Future[HttpResponse] = queueRequest(HttpRequest(uri = \"/\")) Using the host-level API in a streaming fashion It is even better to use the streaming API directly. This will mostly prevent intermediate buffers as data can be generated “on-the-fly” while streaming the requests. You supply the requests as a stream, i.e. as a Source<(HttpRequest, ...)>Source[(HttpRequest, ...)], and the pool will “pull out” single requests when capacity is available on one of the connections to the host. copysourceimport java.nio.file.{ Path, Paths }\n\nimport scala.util.{ Failure, Success }\nimport scala.concurrent.Future\n\nimport org.apache.pekko\nimport pekko.NotUsed\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.model._\nimport pekko.stream.scaladsl._\n\nimport pekko.http.scaladsl.model.Multipart.FormData\nimport pekko.http.scaladsl.marshalling.Marshal\n\nimplicit val system = ActorSystem()\nimport system.dispatcher // to get an implicit ExecutionContext into scope\n\ncase class FileToUpload(name: String, location: Path)\n\ndef filesToUpload(): Source[FileToUpload, NotUsed] =\n  // This could even be a lazy/infinite stream. For this example we have a finite one:\n  Source(List(\n    FileToUpload(\"foo.txt\", Paths.get(\"./foo.txt\")),\n    FileToUpload(\"bar.txt\", Paths.get(\"./bar.txt\")),\n    FileToUpload(\"baz.txt\", Paths.get(\"./baz.txt\"))))\n\nval poolClientFlow =\n  Http().cachedHostConnectionPool[FileToUpload](\"pekko.apache.org\")\n\ndef createUploadRequest(fileToUpload: FileToUpload): Future[(HttpRequest, FileToUpload)] = {\n  val bodyPart =\n    // fromPath will use FileIO.fromPath to stream the data from the file directly\n    FormData.BodyPart.fromPath(fileToUpload.name, ContentTypes.`application/octet-stream`, fileToUpload.location)\n\n  val body = FormData(bodyPart) // only one file per upload\n  Marshal(body).to[RequestEntity].map { entity => // use marshalling to create multipart/formdata entity\n    // build the request and annotate it with the original metadata\n    HttpRequest(method = HttpMethods.POST, uri = \"http://example.com/uploader\", entity = entity) -> fileToUpload\n  }\n}\n\n// you need to supply the list of files to upload as a Source[...]\nfilesToUpload()\n  // The stream will \"pull out\" these requests when capacity is available.\n  // When that is the case we create one request concurrently\n  // (the pipeline will still allow multiple requests running at the same time)\n  .mapAsync(1)(createUploadRequest)\n  // then dispatch the request to the connection pool\n  .via(poolClientFlow)\n  // report each response\n  // Note: responses will not come in in the same order as requests. The requests will be run on one of the\n  // multiple pooled connections and may thus \"overtake\" each other.\n  .runForeach {\n    case (Success(response), fileToUpload) =>\n      // TODO: also check for response status code\n      println(s\"Result for file: $fileToUpload was successful: $response\")\n      response.discardEntityBytes() // don't forget this\n    case (Failure(ex), fileToUpload) =>\n      println(s\"Uploading file $fileToUpload failed with $ex\")\n  }\nFor now, please see the Scala examples in Scala Host-Level Client API. If you want to help with converting the examples see issue #836.","title":"Examples"},{"location":"/client-side/connection-level.html","text":"","title":"Connection-Level Client-Side API"},{"location":"/client-side/connection-level.html#connection-level-client-side-api","text":"The connection-level API is the lowest-level client-side API Apache Pekko HTTP provides. It gives you full control over when HTTP connections are opened and closed and how requests are to be sent across which connection. As such it offers the highest flexibility at the cost of providing the least convenience.\nNote It is recommended to first read the Implications of the streaming nature of Request/Response Entities section, as it explains the underlying full-stack streaming concepts, which may be unexpected when coming from a background with non-“streaming first” HTTP Clients.","title":"Connection-Level Client-Side API"},{"location":"/client-side/connection-level.html#opening-http-connections","text":"With the connection-level API you open a new HTTP connection to a target endpoint by materializing a FlowFlow returned by the builder returned by Http().connectionTo(...)Http.get(system).connectionTo(...) method. Here is an example:\nScala copysource/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * license agreements; and to You under the Apache License, version 2.0:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * This file is part of the Apache Pekko project, derived from Akka.\n */\n\n/*\n * Copyright (C) 2020-2022 Lightbend Inc. <https://www.lightbend.com>\n */\n\npackage docs.http.scaladsl\n\nimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.model._\nimport pekko.stream.scaladsl._\n\nimport scala.concurrent.Future\nimport scala.util.{ Failure, Success }\n\nobject HttpClientOutgoingConnection {\n  def main(args: Array[String]): Unit = {\n    implicit val system = ActorSystem()\n    implicit val executionContext = system.dispatcher\n\n    val connectionFlow: Flow[HttpRequest, HttpResponse, Future[Http.OutgoingConnection]] =\n      Http().connectionTo(\"pekko.apache.org\").http()\n\n    def dispatchRequest(request: HttpRequest): Future[HttpResponse] =\n      // This is actually a bad idea in general. Even if the `connectionFlow` was instantiated only once above,\n      // a new connection is opened every single time, `runWith` is called. Materialization (the `runWith` call)\n      // and opening up a new connection is slow.\n      //\n      // The `outgoingConnection` API is very low-level. Use it only if you already have a `Source[HttpRequest, _]`\n      // (other than Source.single) available that you want to use to run requests on a single persistent HTTP\n      // connection.\n      //\n      // Unfortunately, this case is so uncommon, that we couldn't come up with a good example.\n      //\n      // In almost all cases it is better to use the `Http().singleRequest()` API instead.\n      Source.single(request)\n        .via(connectionFlow)\n        .runWith(Sink.head)\n\n    val responseFuture: Future[HttpResponse] = dispatchRequest(HttpRequest(uri = \"/\"))\n\n    responseFuture.andThen {\n      case Success(_) => println(\"request succeeded\")\n      case Failure(_) => println(\"request failed\")\n    }.andThen {\n      case _ => system.terminate()\n    }\n  }\n} Java copysource final ActorSystem system = ActorSystem.create();\n\nfinal Flow<HttpRequest, HttpResponse, CompletionStage<OutgoingConnection>> connectionFlow =\n        Http.get(system).connectionTo(\"pekko.apache.org\").http();\nfinal CompletionStage<HttpResponse> responseFuture =\n        // This is actually a bad idea in general. Even if the `connectionFlow` was instantiated only once above,\n        // a new connection is opened every single time, `runWith` is called. Materialization (the `runWith` call)\n        // and opening up a new connection is slow.\n        //\n        // The `outgoingConnection` API is very low-level. Use it only if you already have a `Source[HttpRequest, _]`\n        // (other than Source.single) available that you want to use to run requests on a single persistent HTTP\n        // connection.\n        //\n        // Unfortunately, this case is so uncommon, that we couldn't come up with a good example.\n        //\n        // In almost all cases it is better to use the `Http().singleRequest()` API instead.\n        Source.single(HttpRequest.create(\"/\"))\n                .via(connectionFlow)\n                .runWith(Sink.<HttpResponse>head(), system);\nIn addition to the host name and port the builder OutgoingConnectionBuilderOutgoingConnectionBuilder returned by Http().connectionTo(...)Http.get(system).connectionTo(...) method also allows you to specify additional properties and as the final step deciding which protocol to use (HTTP/1, HTTP/1 over TLS, HTTP/2 over TLS or HTTP/2 with prior knowledge over a plaintext connection). For details on using HTTP/2 see Client-Side HTTP/2.\nNo connection is attempted until the returned flow is actually materialized! If the flow is materialized several times then several independent connections will be opened (one per materialization). If the connection attempt fails, for whatever reason, the materialized flow will be immediately terminated with a respective exception.","title":"Opening HTTP Connections"},{"location":"/client-side/connection-level.html#request-response-cycle","text":"Once the connection flow has been materialized it is ready to consume HttpRequestHttpRequest instances from the source it is attached to. Each request is sent across the connection and incoming responses dispatched to the downstream pipeline. Of course and as always, back-pressure is adequately maintained across all parts of the connection. This means that, if the downstream pipeline consuming the HTTP responses is slow, the request source will eventually be slowed down in sending requests.\nAny errors occurring on the underlying connection are surfaced as exceptions terminating the response stream (and canceling the request source).","title":"Request-Response Cycle"},{"location":"/client-side/connection-level.html#closing-connections","text":"Apache Pekko HTTP actively closes an established connection upon reception of a response containing Connection: close header. The connection can also be closed by the server.\nAn application can actively trigger the closing of the connection by completing the request stream. In this case the underlying TCP connection will be closed when the last pending response has been received.\nThe connection will also be closed if the response entity is cancelled (e.g. by attaching it to Sink.cancelled()) or consumed only partially (e.g. by using take combinator). In order to prevent this behaviour the entity should be explicitly drained by attaching it to Sink.ignore().","title":"Closing Connections"},{"location":"/client-side/connection-level.html#timeouts","text":"Currently Apache Pekko HTTP doesn’t implement client-side request timeout checking itself as this functionality can be regarded as a more general purpose streaming infrastructure feature.\nIt should be noted that Apache Pekko Streams provide various timeout functionality so any API that uses streams can benefit from the stream stages such as idleTimeout, backpressureTimeout, completionTimeout, initialTimeout and throttle. To learn more about these refer to their documentation in Apache Pekko Streams.\nFor more details about timeout support in Apache Pekko HTTP in general refer to Apache Pekko HTTP Timeouts.","title":"Timeouts"},{"location":"/client-side/connection-level.html#stand-alone-http-layer-usage","text":"Due to its Reactive-Streams-based nature the Apache Pekko HTTP layer is fully detachable from the underlying TCP interface. While in most applications this “feature” will not be crucial it can be useful in certain cases to be able to “run” the HTTP layer (and, potentially, higher-layers) against data that do not come from the network but rather some other source. Potential scenarios where this might be useful include tests, debugging or low-level event-sourcing (e.g. by replaying network traffic).\nOn the client-side the stand-alone HTTP layer forms a BidiStage stage that “upgrades” a potentially encrypted raw connection to the HTTP level. It is defined like this:\ncopysource/**\n * The type of the client-side HTTP layer as a stand-alone BidiFlow\n * that can be put atop the TCP layer to form an HTTP client.\n *\n * {{{\n *                +------+\n * HttpRequest  ~>|      |~> SslTlsOutbound\n *                | bidi |\n * HttpResponse <~|      |<~ SslTlsInbound\n *                +------+\n * }}}\n */\ntype ClientLayer = BidiFlow[HttpRequest, SslTlsOutbound, SslTlsInbound, HttpResponse, NotUsed]\nBidiFlow<HttpRequest, SslTlsOutbound, SslTlsInbound, HttpResponse, NotUsed>\nYou create an instance of Http.ClientLayerthe layer by calling one of the two overloads of the Http().clientLayerHttp.get(system).clientLayer method, which also allows for varying degrees of configuration.","title":"Stand-Alone HTTP Layer Usage"},{"location":"/client-side/pool-overflow.html","text":"","title":"Pool overflow and the max-open-requests setting"},{"location":"/client-side/pool-overflow.html#pool-overflow-and-the-max-open-requests-setting","text":"Request-Level Client-Side API and Host-Level Client-Side API use a connection pool underneath. The connection pool will open a limited number of concurrent connections to one host (see the pekko.http.host-connection-pool.max-connections setting). This will limit the rate of requests a pool to a single host can handle.\nWhen you use the stream-based host-level API stream semantics prevent that the pool is overloaded with requests. On the other side, when a new request is pushed either using Http().singleRequest()Http.get(system).singleRequest() or when materializing too many streams using the same Http().cachedHostConnectionPoolHttp.get(system).cachedHostConnectionPool, requests may start to queue up when the rate of new requests is greater than the rate at which the pool can process requests.\nIn such a situation max-open-requests per host connection pool will be queued to buffer short-term peaks of requests. Further requests will fail immediately with a BufferOverflowExceptionBufferOverflowException with a message like this:\nExceeded configured max-open-requests value of ...\nThis will usually happen under high load or when the pool has been running for some time with the processing speed being too slow to handle all the incoming requests.\nNote, that even if the pool can handle regular load, short-term hiccups (at the server, the network, or at the client) can make the queue overflow, so you need to treat this as an expected condition. Your application should be able to deal with it. In many cases, it makes sense to treat pool overflow the same as a 503 answer from the server which usually is used when the server is overloaded. A common way to treat it would be to retry the request after some while (using a viable backoff strategy).","title":"Pool overflow and the max-open-requests setting"},{"location":"/client-side/pool-overflow.html#common-causes-of-pool-overload","text":"As explained above the general explanation for pool overload is that the incoming request rate is higher that the request processing rate. This can have all kinds of causes (and hints for fixing them in parentheses):\nThe server is too slow (improve server performance) The network is too slow (improve network performance) The client issues requests too fast (slow down creation of requests if possible) There’s high latency between client and server (use more concurrent connections to hide latency with parallelism) There are peaks in the request rate (prevent peaks by tuning the client application or increase max-open-requests to buffer short-term peaks) Response entities were not read or discarded (see Implications of the streaming nature of Http entities) Some requests are slower than others blocking the connections of a pool for other requests (see below)\nThe last point may need a bit more explanation. If some requests are much slower than others, e.g. if the request is a long-running Server Sent Events request than this will block one of the connections of the pool for a long time. If there are multiple such requests going on at the same time it will lead to starvation and other requests cannot make any progress anymore. Make sure to run a long-running request on a dedicated connection (using the Connection-Level Client-Side API) to prevent such a situation.","title":"Common causes of pool overload"},{"location":"/client-side/pool-overflow.html#why-does-this-happen-only-with-apache-pekko-http-and-not-with-","text":"Many Java HTTP clients don’t set limits by default for some of the resources used. E.g. some clients will never queue a request but will just open another connection to the server if all the pooled connections are currently busy. However, this might just move the problem from the client to the server. Also using an excessive number of connections will lead to worse performance on the network as more connections will compete for bandwidth.","title":"Why does this happen only with Apache Pekko Http and not with [insert other client]"},{"location":"/client-side/client-https-support.html","text":"","title":"Client-Side HTTPS Support"},{"location":"/client-side/client-https-support.html#client-side-https-support","text":"Apache Pekko HTTP supports TLS encryption on the client-side as well as on the server-side.\nThe central vehicle for configuring encryption is the HttpsConnectionContextHttpsConnectionContext, which can be created using the static methods on ConnectionContextConnectionContext:\nScala copysource/**\n *  Creates an HttpsConnectionContext for client-side use from the given SSLContext.\n */\ndef httpsClient(context: SSLContext): HttpsConnectionContext = // ... Java copysource/**\n * Creates an HttpsConnectionContext for client-side use from the given SSLContext.\n */\ndef httpsClient(sslContext: SSLContext): HttpsConnectionContext = // ...\nIn addition to the outgoingConnection, newHostConnectionPool and cachedHostConnectionPool methods the org.apache.pekko.http.scaladsl.Httporg.apache.pekko.http.javadsl.Http extension also defines outgoingConnectionHttps, newHostConnectionPoolHttps and cachedHostConnectionPoolHttps. These methods work identically to their counterparts without the -Https suffix, with the exception that all connections will always be encrypted.\nThe singleRequest and superPool methods determine the encryption state via the scheme of the incoming request, i.e. requests to an “https” URI will be encrypted, while requests to an “http” URI won’t.\nThe encryption configuration for all HTTPS connections, i.e. the HttpsContext is determined according to the following logic:\nIf the optional httpsContext method parameter is defined it contains the configuration to be used (and thus takes precedence over any potentially set default client-side HttpsContext). If the optional httpsContext method parameter is undefined (which is the default) the default client-side HttpsContext is used, which can be set via the setDefaultClientHttpsContext on the HttpHttp extension. If no default client-side HttpsContext has been set via the setDefaultClientHttpsContext on the HttpHttp extension the default system configuration is used.\nUsually the process is, if the default system TLS configuration is not good enough for your application’s needs, that you configure a custom HttpsContext instance and set it via Http().setDefaultClientHttpsContextHttp.get(system).setDefaultClientHttpsContext. Afterwards you simply use outgoingConnectionHttps, newHostConnectionPoolHttps, cachedHostConnectionPoolHttps, superPool or singleRequest without a specific httpsContext argument, which causes encrypted connections to rely on the configured default client-side HttpsConnectionContextHttpsConnectionContext.\nIf no custom HttpsContext is defined the default context uses Java’s default TLS settings. Customizing the HttpsContext can make the Https client less secure. Understand what you are doing!","title":"Client-Side HTTPS Support"},{"location":"/client-side/client-https-support.html#detailed-configuration-and-workarounds","text":"Warning While it is possible to disable certain checks, we strongly recommend to instead attempt to solve these issues by properly configuring TLS–for example by adding trusted keys to the keystore. If however certain checks really need to be disabled because of misconfigured (or legacy) servers that your application has to speak to, instead of disabling the checks globally (by using setDefaultClientHttpsContext) we suggest configuring the loose settings for specific connections that are known to need them disabled (and trusted for some other reason). The pattern of doing so is documented in the following sub-sections.","title":"Detailed configuration and workarounds"},{"location":"/client-side/client-https-support.html#disabling-hostname-verification","text":"Hostname verification proves that the Apache Pekko HTTP client is actually communicating with the server it intended to communicate with. Without this check a man-in-the-middle attack is possible. In the attack scenario, an alternative certificate would be presented which was issued for another host name. Checking the host name in the certificate against the host name the connection was opened against is therefore vital.\nWhen you create your HttpsConnectionContextHttpsConnectionContext with ConnectionContext.httpsClientConnectionContext.httpsClient enables hostname verification. The following shows an example of disabling hostname verification for a given connection:\nScala copysourceimplicit val system = ActorSystem()\n\ndef createInsecureSslEngine(host: String, port: Int): SSLEngine = {\n  val engine = SSLContext.getDefault.createSSLEngine(host, port)\n  engine.setUseClientMode(true)\n\n  // WARNING: this creates an SSL Engine without enabling endpoint identification/verification procedures\n  // Disabling host name verification is a very bad idea, please don't unless you have a very good reason to.\n  // When in doubt, use the `ConnectionContext.httpsClient` that takes an `SSLContext` instead, or enable with:\n  // engine.setSSLParameters({\n  //  val params = engine.getSSLParameters\n  //  params.setEndpointIdentificationAlgorithm(\"https\")\n  //  params\n  // )\n\n  engine\n}\nval badCtx = ConnectionContext.httpsClient(createInsecureSslEngine _)\nHttp().outgoingConnectionHttps(unsafeHost, connectionContext = badCtx) Java copysourcefinal ActorSystem system = ActorSystem.create();\nfinal Http http = Http.get(system);\n\nfinal HttpsConnectionContext badCtx = ConnectionContext.httpsClient((host, port) -> {\n  SSLEngine engine = SSLContext.getDefault().createSSLEngine(host, port);\n  engine.setUseClientMode(true);\n\n  // WARNING: this creates an SSL Engine without enabling endpoint identification/verification procedures\n  // Disabling host name verification is a very bad idea, please don't unless you have a very good reason to.\n  // When in doubt, use the `ConnectionContext.httpsClient` that takes an `SSLContext` instead, or enable\n  // with:\n  // SSLParameters params = engine.getSSLParameters();\n  // params.setEndpointIdentificationAlgorithm(\"https\");\n  // engine.setSSLParameters(params);\n\n  return engine;\n});\n\nhttp.connectionTo(unsafeHost).withCustomHttpsConnectionContext(badCtx).https();","title":"Disabling hostname verification"},{"location":"/client-side/client-transport.html","text":"","title":"Pluggable Client Transports / HTTP(S) proxy Support"},{"location":"/client-side/client-transport.html#pluggable-client-transports-http-s-proxy-support","text":"The client side infrastructure has support to plug different transport mechanisms underneath (the API may still change in the future). A client side transport is represented by an instance of org.apache.pekko.http.scaladsl.ClientTransportorg.apache.pekko.http.javadsl.ClientTransport:\nScala copysource@ApiMayChange\ntrait ClientTransport {\n  def connectTo(host: String, port: Int, settings: ClientConnectionSettings)(\n      implicit system: ActorSystem): Flow[ByteString, ByteString, Future[OutgoingConnection]]\n} Java copysource@ApiMayChange\nabstract class ClientTransport {\n  def connectTo(host: String, port: Int, settings: ClientConnectionSettings, system: ActorSystem)\n      : Flow[ByteString, ByteString, CompletionStage[OutgoingConnection]]\n}\nA transport implementation defines how the client infrastructure should communicate with a given host.\nNote In our model, SSL/TLS runs on top of the client transport, even if you could theoretically see it as part of the transport layer itself.","title":"Pluggable Client Transports / HTTP(S) proxy Support"},{"location":"/client-side/client-transport.html#configuring-client-transports","text":"A ClientTransportClientTransport can be configured in the ClientConnectionSettingsClientConnectionSettings. Right now, this is not possible through config files but only by code. First, use ClientConnectionSettings.withTransport to configure a transport, then use ConnectionPoolSettings.withConnectionSettings. ClientConnectionSettingsClientConnectionSettings can be passed to all client-side entry points in HttpHttp.","title":"Configuring Client Transports"},{"location":"/client-side/client-transport.html#predefined-transports","text":"","title":"Predefined Transports"},{"location":"/client-side/client-transport.html#tcp","text":"The default transport is ClientTransport.TCP which simply opens a TCP connection to the target host.","title":"TCP"},{"location":"/client-side/client-transport.html#http-s-proxy","text":"A transport that connects to target servers via an HTTP(S) proxy. An HTTP(S) proxy uses the HTTP CONNECT method (as specified in RFC 7231 Section 4.3.6) to create tunnels to target servers. The proxy itself should transparently forward data to the target servers so that end-to-end encryption should still work (if TLS breaks, then the proxy might be fussing with your data).\nThis approach is commonly used to securely proxy requests to HTTPS endpoints. In theory it could also be used to proxy requests targeting HTTP endpoints, but we have not yet found a proxy that in fact allows this.\nInstantiate the HTTP(S) proxy transport using ClientTransport.httpsProxy(proxyAddress).\nThe proxy transport can also be setup using ClientTransport.httpsProxy() or ClientTransport.httpsProxy(basicHttpCredentials) In order to define the transport as such, you will need to set the proxy host / port in your conf file like the following.\npekko.http.client.proxy {\n https {\n   host = \"\"\n   port = 443\n }\n}\nIf host is left as \"\" and you attempt to setup an httpsProxy transport, an exception will be thrown.","title":"HTTP(S) Proxy"},{"location":"/client-side/client-transport.html#use-http-s-proxy-with-","text":"To make use of an HTTP proxy when using the singleRequest API you simply need to configure the proxy and pass the appropriate settings object when calling the single request method.\nScala copysourceimport java.net.InetSocketAddress\n\nimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.{ ClientTransport, Http }\n\nimplicit val system = ActorSystem()\n\nval proxyHost = \"localhost\"\nval proxyPort = 8888\n\nval httpsProxyTransport = ClientTransport.httpsProxy(InetSocketAddress.createUnresolved(proxyHost, proxyPort))\n\nval settings = ConnectionPoolSettings(system)\n  .withConnectionSettings(ClientConnectionSettings(system)\n    .withTransport(httpsProxyTransport))\nHttp().singleRequest(HttpRequest(uri = \"https://google.com\"), settings = settings) Java copysource final ActorSystem system = ActorSystem.create();\n\nClientTransport proxy = ClientTransport.httpsProxy(InetSocketAddress.createUnresolved(\"192.168.2.5\", 8080));\nConnectionPoolSettings poolSettingsWithHttpsProxy = ConnectionPoolSettings.create(system)\n    .withConnectionSettings(ClientConnectionSettings.create(system).withTransport(proxy));\n\nfinal CompletionStage<HttpResponse> responseFuture =\n    Http.get(system)\n        .singleRequest(\n              HttpRequest.create(\"https://github.com\"),\n              Http.get(system).defaultClientHttpsContext(),\n              poolSettingsWithHttpsProxy, // <- pass in the custom settings here\n              system.log());","title":"Use HTTP(S) proxy with Http().singleRequestHttp.get(...).singleRequest"},{"location":"/client-side/client-transport.html#use-http-s-proxy-that-requires-authentication","text":"In order to use an HTTP(S) proxy that requires authentication, you need to provide HttpCredentialsHttpCredentials that will be used when making the CONNECT request to the proxy:\nScala copysourceimport org.apache.pekko.http.scaladsl.model.headers\n\nval proxyAddress = InetSocketAddress.createUnresolved(proxyHost, proxyPort)\nval auth = headers.BasicHttpCredentials(\"proxy-user\", \"secret-proxy-pass-dont-tell-anyone\")\n\nval httpsProxyTransport = ClientTransport.httpsProxy(proxyAddress, auth)\n\nval settings = ConnectionPoolSettings(system)\n  .withConnectionSettings(ClientConnectionSettings(system)\n    .withTransport(httpsProxyTransport))\nHttp().singleRequest(HttpRequest(uri = \"http://pekko.apache.org\"), settings = settings) Java copysourceInetSocketAddress proxyAddress =\n  InetSocketAddress.createUnresolved(\"192.168.2.5\", 8080);\nHttpCredentials credentials =\n  HttpCredentials.createBasicHttpCredentials(\"proxy-user\", \"secret-proxy-pass-dont-tell-anyone\");\n\nClientTransport proxy = ClientTransport.httpsProxy(proxyAddress, credentials); // include credentials\nConnectionPoolSettings poolSettingsWithHttpsProxy = ConnectionPoolSettings.create(system)\n    .withConnectionSettings(ClientConnectionSettings.create(system).withTransport(proxy));\n\nfinal CompletionStage<HttpResponse> responseFuture =\n    Http.get(system)\n        .singleRequest(\n              HttpRequest.create(\"https://github.com\"),\n              Http.get(system).defaultClientHttpsContext(),\n              poolSettingsWithHttpsProxy, // <- pass in the custom settings here\n              system.log());","title":"Use HTTP(S) proxy that requires authentication"},{"location":"/client-side/client-transport.html#use-http-s-proxy-with-","text":"Making use of an HTTP proxy when using the singleWebSocketRequest is done like using singleRequest, except you set ClientConnectionSettings instead of ConnectionPoolSettings:\nScala copysourceimport java.net.InetSocketAddress\n\nimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.NotUsed\nimport pekko.http.scaladsl.{ ClientTransport, Http }\nimport pekko.http.scaladsl.settings.ClientConnectionSettings\nimport pekko.http.scaladsl.model.ws._\nimport pekko.stream.scaladsl._\n\nimplicit val system = ActorSystem()\n\nval flow: Flow[Message, Message, NotUsed] =\n  Flow.fromSinkAndSource(\n    Sink.foreach(println),\n    Source.single(TextMessage(\"hello world!\")))\n\nval proxyHost = \"localhost\"\nval proxyPort = 8888\n\nval httpsProxyTransport = ClientTransport.httpsProxy(InetSocketAddress.createUnresolved(proxyHost, proxyPort))\n\nval settings = ClientConnectionSettings(system).withTransport(httpsProxyTransport)\nHttp().singleWebSocketRequest(WebSocketRequest(uri = \"wss://example.com:8080/some/path\"), clientFlow = flow,\n  settings = settings) Java copysource final ActorSystem system = ActorSystem.create();\nfinal Materializer materializer = ActorMaterializer.create(system);\n\nfinal Flow<Message, Message, NotUsed> flow =\n  Flow.fromSinkAndSource(\n    Sink.foreach(System.out::println),\n    Source.single(TextMessage.create(\"hello world\")));\n\nClientTransport proxy = ClientTransport.httpsProxy(InetSocketAddress.createUnresolved(\"192.168.2.5\", 8080));\nClientConnectionSettings clientSettingsWithHttpsProxy = ClientConnectionSettings.create(system)\n  .withTransport(proxy);\n\nHttp.get(system)\n  .singleWebSocketRequest(\n    WebSocketRequest.create(\"wss://example.com:8080/some/path\"),\n    flow,\n    Http.get(system).defaultClientHttpsContext(),\n    null,\n    clientSettingsWithHttpsProxy, // <- pass in the custom settings here\n    system.log(),\n    materializer);","title":"Use HTTP(S) proxy with Http().singleWebSocketRequestHttp.get(…).singleWebSocketRequest"},{"location":"/client-side/client-transport.html#use-http-s-proxy-that-requires-authentication-for-web-sockets","text":"Here is an example for Web Socket:\nScala copysourceimport org.apache.pekko.http.scaladsl.model.headers\n\nval proxyAddress = InetSocketAddress.createUnresolved(proxyHost, proxyPort)\nval auth = headers.BasicHttpCredentials(\"proxy-user\", \"secret-proxy-pass-dont-tell-anyone\")\n\nval httpsProxyTransport = ClientTransport.httpsProxy(proxyAddress, auth)\n\nval settings = ClientConnectionSettings(system).withTransport(httpsProxyTransport)\nHttp().singleWebSocketRequest(WebSocketRequest(uri = \"wss://example.com:8080/some/path\"), clientFlow = flow,\n  settings = settings) Java copysourceInetSocketAddress proxyAddress =\n  InetSocketAddress.createUnresolved(\"192.168.2.5\", 8080);\nHttpCredentials credentials =\n  HttpCredentials.createBasicHttpCredentials(\"proxy-user\", \"secret-proxy-pass-dont-tell-anyone\");\n\nClientTransport proxy = ClientTransport.httpsProxy(proxyAddress, credentials); // include credentials\nClientConnectionSettings clientSettingsWithHttpsProxy = ClientConnectionSettings.create(system)\n  .withTransport(proxy);\n\nHttp.get(system)\n  .singleWebSocketRequest(\n    WebSocketRequest.create(\"wss://example.com:8080/some/path\"),\n    flow,\n    Http.get(system).defaultClientHttpsContext(),\n    null,\n    clientSettingsWithHttpsProxy, // <- pass in the custom settings here\n    system.log(),\n    materializer);","title":"Use HTTP(S) proxy that requires authentication for Web Sockets"},{"location":"/client-side/client-transport.html#custom-host-name-resolution-transport","text":"You can use ClientTransport.withCustomResolverClientTransport.withCustomResolver to customize host name resolution. The given resolution function will be called for every connection attempt to resolve a hostname / port combination (potentially asynchronously) to an InetSocketAddress.\nAs a backend to implement the resolution function you can use Apache Pekko’s Async DNS Resolution.\nPotential use cases:\nin a managed setting this can be used to query for SRV DNS records that contain both address and port for a service. if the DNS server returns multiple addresses, you can implement a load balancing algorithm to select a different target address for each connection","title":"Custom Host Name Resolution Transport"},{"location":"/client-side/client-transport.html#implementing-custom-transports","text":"Implement ClientTransport.connectTo to implement a custom client transport.\nHere are some ideas for custom (or future predefined) transports:\nSSH tunnel transport: connects to the target host through an SSH tunnel Per-host configurable transport: allows choosing transports per target host","title":"Implementing Custom Transports"},{"location":"/client-side/websocket-support.html","text":"","title":"Client-Side WebSocket Support"},{"location":"/client-side/websocket-support.html#client-side-websocket-support","text":"Client-side WebSocket support is available through Http().singleWebSocketRequestHttp.get(system).singleWebSocketRequest, Http().webSocketClientFlowHttp.get(system).webSocketClientFlow and Http().webSocketClientLayerHttp.get(system).webSocketClientLayer.\nA WebSocket consists of two streams of messages, incoming messages (a SinkSink) and outgoing messages (a SourceSource) where either may be signalled first; or even be the only direction in which messages flow during the lifetime of the connection. Therefore a WebSocket connection is modelled as either something you connect a Flow<Message, Message, Mat>Flow[Message, Message, Mat] to or a Flow<Message, Message, Mat>Flow[Message, Message, Mat] that you connect a Source<Message, Mat>Source[Message, Mat] and a Sink<Message, Mat>Sink[Message, Mat] to.\nA WebSocket request starts with a regular HTTP request which contains an Upgrade header (and possibly other regular HTTP request properties), so in addition to the flow of messages there also is an initial response from the server, this is modelled with WebSocketUpgradeResponseWebSocketUpgradeResponse.\nThe methods of the WebSocket client API handle the upgrade to WebSocket on connection success and materializes the connected WebSocket stream. If the connection fails, for example with a 404 NotFound error, this regular HTTP result can be found in WebSocketUpgradeResponse.response\nNote Make sure to read and understand the section about Half-Closed WebSockets as the behavior when using WebSockets for one-way communication may not be what you would expect.","title":"Client-Side WebSocket Support"},{"location":"/client-side/websocket-support.html#message","text":"Messages sent and received over a WebSocket can be either TextMessageTextMessage s or BinaryMessageBinaryMessage s and each of those has two subtypes Strict (all data in one chunk) or Streamed. In typical applications messages will be Strict as WebSockets are usually deployed to communicate using small messages not stream data, the protocol does however allow this (by not marking the first fragment as final, as described in RFC 6455 section 5.2).\nThe strict text is available from TextMessage.StrictTextMessage.getStrictText and strict binary data from BinaryMessage.StrictBinaryMessage.getStrictData.\nFor streamed messages BinaryMessage.StreamedBinaryMessage.getStreamedData and TextMessage.StreamedTextMessage.getStreamedText will be used. In these cases the data is provided as a Source<ByteString, ?>Source[ByteString, _] for binary and Source<String, ?>Source[String, _] for text messages.","title":"Message"},{"location":"/client-side/websocket-support.html#singlewebsocketrequest","text":"singleWebSocketRequest takes a WebSocketRequestWebSocketRequest and a flow it will connect to the source and sink of the WebSocket connection. It will trigger the request right away and returns a tuple containing the Future[WebSocketUpgradeResponse]CompletionStage<WebSocketUpgradeResponse> and the materialized value from the flow passed to the method.\nThe future will succeed when the WebSocket connection has been established or the server returned a regular HTTP response, or fail if the connection fails with an exception.\nSimple example sending a message and printing any incoming message:\nScala copysource/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * license agreements; and to You under the Apache License, version 2.0:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * This file is part of the Apache Pekko project, derived from Akka.\n */\n\n/*\n * Copyright (C) 2020-2022 Lightbend Inc. <https://www.lightbend.com>\n */\n\npackage docs.http.scaladsl\n\nimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.{ Done, NotUsed }\nimport pekko.http.scaladsl.Http\nimport pekko.stream.scaladsl._\nimport pekko.http.scaladsl.model._\nimport pekko.http.scaladsl.model.ws._\n\nimport scala.concurrent.Future\n\nobject SingleWebSocketRequest {\n  def main(args: Array[String]): Unit = {\n    implicit val system = ActorSystem()\n    import system.dispatcher\n\n    // print each incoming strict text message\n    val printSink: Sink[Message, Future[Done]] =\n      Sink.foreach {\n        case message: TextMessage.Strict =>\n          println(message.text)\n        case _ =>\n        // ignore other message types\n      }\n\n    val helloSource: Source[Message, NotUsed] =\n      Source.single(TextMessage(\"hello world!\"))\n\n    // the Future[Done] is the materialized value of Sink.foreach\n    // and it is completed when the stream completes\n    val flow: Flow[Message, Message, Future[Done]] =\n      Flow.fromSinkAndSourceMat(printSink, helloSource)(Keep.left)\n\n    // upgradeResponse is a Future[WebSocketUpgradeResponse] that\n    // completes or fails when the connection succeeds or fails\n    // and closed is a Future[Done] representing the stream completion from above\n    val (upgradeResponse, closed) =\n      Http().singleWebSocketRequest(WebSocketRequest(\"ws://echo.websocket.org\"), flow)\n\n    val connected = upgradeResponse.map { upgrade =>\n      // just like a regular http request we can access response status which is available via upgrade.response.status\n      // status code 101 (Switching Protocols) indicates that server support WebSockets\n      if (upgrade.response.status == StatusCodes.SwitchingProtocols) {\n        Done\n      } else {\n        throw new RuntimeException(s\"Connection failed: ${upgrade.response.status}\")\n      }\n    }\n\n    // in a real application you would not side effect here\n    // and handle errors more carefully\n    connected.onComplete(println)\n    closed.foreach(_ => println(\"closed\"))\n  }\n} Java copysourceActorSystem system = ActorSystem.create();\nMaterializer materializer = ActorMaterializer.create(system);\nHttp http = Http.get(system);\n\n// print each incoming text message\n// would throw exception on non strict or binary message\nfinal Sink<Message, CompletionStage<Done>> printSink =\n  Sink.foreach((message) ->\n    System.out.println(\"Got message: \" + message.asTextMessage().getStrictText())\n  );\n\n// send this as a message over the WebSocket\nfinal Source<Message, NotUsed> helloSource =\n  Source.single(TextMessage.create(\"hello world\"));\n\n// the CompletionStage<Done> is the materialized value of Sink.foreach\n// and it is completed when the stream completes\nfinal Flow<Message, Message, CompletionStage<Done>> flow =\n  Flow.fromSinkAndSourceMat(printSink, helloSource, Keep.left());\n\nfinal Pair<CompletionStage<WebSocketUpgradeResponse>, CompletionStage<Done>> pair =\n  http.singleWebSocketRequest(\n    WebSocketRequest.create(\"ws://echo.websocket.org\"),\n    flow,\n    materializer\n  );\n\n// The first value in the pair is a CompletionStage<WebSocketUpgradeResponse> that\n// completes when the WebSocket request has connected successfully (or failed)\nfinal CompletionStage<Done> connected = pair.first().thenApply(upgrade -> {\n  // just like a regular http request we can access response status which is available via upgrade.response.status\n  // status code 101 (Switching Protocols) indicates that server support WebSockets\n  if (upgrade.response().status().equals(StatusCodes.SWITCHING_PROTOCOLS)) {\n    return Done.getInstance();\n  } else {\n    throw new RuntimeException(\"Connection failed: \" + upgrade.response().status());\n  }\n});\n\n// the second value is the completion of the sink from above\n// in other words, it completes when the WebSocket disconnects\nfinal CompletionStage<Done> closed = pair.second();\n\n// in a real application you would not side effect here\n// and handle errors more carefully\nconnected.thenAccept(done -> System.out.println(\"Connected\"));\nclosed.thenAccept(done -> System.out.println(\"Connection closed\"));\nThe websocket request may also include additional headers, like in this example, HTTP Basic Auth:\nScala copysourceval (upgradeResponse, _) =\n  Http().singleWebSocketRequest(\n    WebSocketRequest(\n      \"ws://example.com:8080/some/path\",\n      extraHeaders = Seq(Authorization(\n        BasicHttpCredentials(\"johan\", \"correcthorsebatterystaple\")))),\n    flow) Java copysourcehttp.singleWebSocketRequest(\n  WebSocketRequest.create(\"ws://example.com:8080/some/path\")\n    .addHeader(Authorization.basic(\"johan\", \"correcthorsebatterystaple\")),\n  flow,\n  materializer);","title":"singleWebSocketRequest"},{"location":"/client-side/websocket-support.html#websocketclientflow","text":"webSocketClientFlow takes a request, and returns a Flow<Message, Message, Future<WebSocketUpgradeResponse>>Flow[Message, Message, Future[WebSocketUpgradeResponse]]Flow<Message, Message, CompletionStage<WebSocketUpgradeResponse>>Flow[Message, Message, CompletionStage[WebSocketUpgradeResponse]].\nThe future that is materialized from the flow will succeed when the WebSocket connection has been established or the server returned a regular HTTP response, or fail if the connection fails with an exception.\nNote The FlowFlow that is returned by this method can only be materialized once. For each request a new flow must be acquired by calling the method again.\nSimple example sending a message and printing any incoming message:\nScala copysource/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * license agreements; and to You under the Apache License, version 2.0:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * This file is part of the Apache Pekko project, derived from Akka.\n */\n\n/*\n * Copyright (C) 2020-2022 Lightbend Inc. <https://www.lightbend.com>\n */\n\npackage docs.http.scaladsl\n\nimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.Done\nimport pekko.http.scaladsl.Http\nimport pekko.stream.scaladsl._\nimport pekko.http.scaladsl.model._\nimport pekko.http.scaladsl.model.ws._\n\nimport scala.concurrent.Future\n\nobject WebSocketClientFlow {\n  def main(args: Array[String]): Unit = {\n    implicit val system = ActorSystem()\n    import system.dispatcher\n\n    // Future[Done] is the materialized value of Sink.foreach,\n    // emitted when the stream completes\n    val incoming: Sink[Message, Future[Done]] =\n      Sink.foreach[Message] {\n        case message: TextMessage.Strict =>\n          println(message.text)\n        case _ =>\n        // ignore other message types\n      }\n\n    // send this as a message over the WebSocket\n    val outgoing = Source.single(TextMessage(\"hello world!\"))\n\n    // flow to use (note: not re-usable!)\n    val webSocketFlow = Http().webSocketClientFlow(WebSocketRequest(\"ws://echo.websocket.org\"))\n\n    // the materialized value is a tuple with\n    // upgradeResponse is a Future[WebSocketUpgradeResponse] that\n    // completes or fails when the connection succeeds or fails\n    // and closed is a Future[Done] with the stream completion from the incoming sink\n    val (upgradeResponse, closed) =\n      outgoing\n        .viaMat(webSocketFlow)(Keep.right) // keep the materialized Future[WebSocketUpgradeResponse]\n        .toMat(incoming)(Keep.both) // also keep the Future[Done]\n        .run()\n\n    // just like a regular http request we can access response status which is available via upgrade.response.status\n    // status code 101 (Switching Protocols) indicates that server support WebSockets\n    val connected = upgradeResponse.flatMap { upgrade =>\n      if (upgrade.response.status == StatusCodes.SwitchingProtocols) {\n        Future.successful(Done)\n      } else {\n        throw new RuntimeException(s\"Connection failed: ${upgrade.response.status}\")\n      }\n    }\n\n    // in a real application you would not side effect here\n    connected.onComplete(println)\n    closed.foreach(_ => println(\"closed\"))\n  }\n} Java copysourceActorSystem system = ActorSystem.create();\nMaterializer materializer = ActorMaterializer.create(system);\nHttp http = Http.get(system);\n\n// print each incoming text message\n// would throw exception on non strict or binary message\nSink<Message, CompletionStage<Done>> printSink =\n  Sink.foreach((message) ->\n      System.out.println(\"Got message: \" + message.asTextMessage().getStrictText())\n  );\n\n// send this as a message over the WebSocket\nSource<Message, NotUsed> helloSource =\n  Source.single(TextMessage.create(\"hello world\"));\n\n\nFlow<Message, Message, CompletionStage<WebSocketUpgradeResponse>> webSocketFlow =\n  http.webSocketClientFlow(WebSocketRequest.create(\"ws://echo.websocket.org\"));\n\n\nPair<CompletionStage<WebSocketUpgradeResponse>, CompletionStage<Done>> pair =\n  helloSource.viaMat(webSocketFlow, Keep.right())\n    .toMat(printSink, Keep.both())\n    .run(materializer);\n\n\n// The first value in the pair is a CompletionStage<WebSocketUpgradeResponse> that\n// completes when the WebSocket request has connected successfully (or failed)\nCompletionStage<WebSocketUpgradeResponse> upgradeCompletion = pair.first();\n\n// the second value is the completion of the sink from above\n// in other words, it completes when the WebSocket disconnects\nCompletionStage<Done> closed = pair.second();\n\nCompletionStage<Done> connected = upgradeCompletion.thenApply(upgrade->\n{\n  // just like a regular http request we can access response status which is available via upgrade.response.status\n  // status code 101 (Switching Protocols) indicates that server support WebSockets\n  if (upgrade.response().status().equals(StatusCodes.SWITCHING_PROTOCOLS)) {\n    return Done.getInstance();\n  } else {\n    throw new RuntimeException((\"Connection failed: \" + upgrade.response().status()));\n  }\n});\n\n// in a real application you would not side effect here\n// and handle errors more carefully\nconnected.thenAccept(done -> System.out.println(\"Connected\"));\nclosed.thenAccept(done -> System.out.println(\"Connection closed\"));","title":"webSocketClientFlow"},{"location":"/client-side/websocket-support.html#websocketclientlayer","text":"Just like the Stand-Alone HTTP Layer Usage for regular HTTP requests, the WebSocket layer can be used fully detached from the underlying TCP interface. The same scenarios as described for regular HTTP requests apply here.\nThe returned layer forms a BidiFlow<Message, SslTlsOutbound, SslTlsInbound, Message, Future<WebSocketUpgradeResponse>>BidiFlow[Message, SslTlsOutbound, SslTlsInbound, Message, Future[WebSocketUpgradeResponse]]BidiFlow<Message, SslTlsOutbound, SslTlsInbound, Message, CompletionStage<WebSocketUpgradeResponse>>BidiFlow[Message, SslTlsOutbound, SslTlsInbound, Message, CompletionStage[WebSocketUpgradeResponse]].","title":"webSocketClientLayer"},{"location":"/client-side/websocket-support.html#half-closed-websockets","text":"The Apache Pekko HTTP WebSocket API does not support half-closed connections which means that if either stream completes the entire connection is closed (after a “Closing Handshake” has been exchanged or a timeout of 3 seconds has passed). This may lead to unexpected behavior, for example if we are trying to only consume messages coming from the server, like this:\nScala copysource // we may expect to be able to to just tail\n// the server websocket output like this\nval flow: Flow[Message, Message, NotUsed] =\n  Flow.fromSinkAndSource(\n    Sink.foreach(println),\n    Source.empty)\n\nHttp().singleWebSocketRequest(\n  WebSocketRequest(\"ws://example.com:8080/some/path\"),\n  flow)\n Java copysource // we may expect to be able to to just tail\n// the server websocket output like this\nfinal Flow<Message, Message, NotUsed> flow =\n  Flow.fromSinkAndSource(\n    Sink.foreach(System.out::println),\n    Source.empty());\n\nhttp.singleWebSocketRequest(\n  WebSocketRequest.create(\"ws://example.com:8080/some/path\"),\n  flow,\n  materializer);\nThis will in fact quickly close the connection because of the Source.emptySource.empty() being completed immediately when the stream is materialized. To solve this you can make sure to not complete the outgoing source by using for example Source.maybeSource.maybe() like this:\nScala copysource // using Source.maybe materializes into a promise\n// which will allow us to complete the source later\nval flow: Flow[Message, Message, Promise[Option[Message]]] =\n  Flow.fromSinkAndSourceMat(\n    Sink.foreach[Message](println),\n    Source.maybe[Message])(Keep.right)\n\nval (upgradeResponse, promise) =\n  Http().singleWebSocketRequest(\n    WebSocketRequest(\"ws://example.com:8080/some/path\"),\n    flow)\n\n// at some later time we want to disconnect\npromise.success(None) Java copysource // using Source.maybe materializes into a completable future\n// which will allow us to complete the source later\nfinal Flow<Message, Message, CompletableFuture<Optional<Message>>> flow =\n  Flow.fromSinkAndSourceMat(\n    Sink.foreach(System.out::println),\n    Source.maybe(),\n    Keep.right());\n\nfinal Pair<CompletionStage<WebSocketUpgradeResponse>, CompletableFuture<Optional<Message>>> pair =\n  http.singleWebSocketRequest(\n    WebSocketRequest.create(\"ws://example.com:8080/some/path\"),\n    flow,\n    materializer);\n\n// at some later time we want to disconnect\npair.second().complete(Optional.empty());\nThis will keep the outgoing source from completing, but without emitting any elements until the PromiseCompletableFuture is manually completed which makes the SourceSource complete and the connection to close.\nThe same problem holds true if emitting a finite number of elements, as soon as the last element is reached the SourceSource will close and cause the connection to close. To avoid that you can concatenate Source.maybeSource.maybe() to the finite stream:\nScala copysource // using emit \"one\" and \"two\" and then keep the connection open\nval flow: Flow[Message, Message, Promise[Option[Message]]] =\n  Flow.fromSinkAndSourceMat(\n    Sink.foreach[Message](println),\n    Source(List(TextMessage(\"one\"), TextMessage(\"two\")))\n      .concatMat(Source.maybe[Message])(Keep.right))(Keep.right)\n\nval (upgradeResponse, promise) =\n  Http().singleWebSocketRequest(\n    WebSocketRequest(\"ws://example.com:8080/some/path\"),\n    flow)\n\n// at some later time we want to disconnect\npromise.success(None) Java copysource // emit \"one\" and then \"two\" and then keep the source from completing\nfinal Source<Message, CompletableFuture<Optional<Message>>> source =\n  Source.from(Arrays.<Message>asList(TextMessage.create(\"one\"), TextMessage.create(\"two\")))\n    .concatMat(Source.maybe(), Keep.right());\n\nfinal Flow<Message, Message, CompletableFuture<Optional<Message>>> flow =\n  Flow.fromSinkAndSourceMat(\n    Sink.foreach(System.out::println),\n    source,\n    Keep.right());\n\nfinal Pair<CompletionStage<WebSocketUpgradeResponse>, CompletableFuture<Optional<Message>>> pair =\n  http.singleWebSocketRequest(\n    WebSocketRequest.create(\"ws://example.com:8080/some/path\"),\n    flow,\n    materializer);\n\n// at some later time we want to disconnect\npair.second().complete(Optional.empty());\nScenarios that exist with the two streams in a WebSocket and possible ways to deal with it:\nScenario Possible solution Two-way communication Flow.fromSinkAndSource, or Flow.map for a request-response protocol Infinite incoming stream, no outgoing Flow.fromSinkAndSource(someSink, Source.maybe)Flow.fromSinkAndSource(someSink, Source.maybe()) Infinite outgoing stream, no incoming Flow.fromSinkAndSource(Sink.ignore, yourSource)Flow.fromSinkAndSource(Sink.ignore(), yourSource)","title":"Half-Closed WebSockets"},{"location":"/client-side/websocket-support.html#automatic-keep-alive-ping-support","text":"Similar to the server-side kee-alive Ping support, it is possible to configure the client-side to perform automatic keep-alive using Ping (or Pong) frames.\nThis is supported in a transparent way via configuration by setting the: pekko.http.client.websocket.periodic-keep-alive-max-idle = 1 second to a specified max idle timeout. The keep-alive triggers when no other messages are in-flight during the such configured period. Apache Pekko HTTP will then automatically send a Ping frame for each of such idle intervals.\nBy default, the automatic keep-alive feature is disabled.","title":"Automatic keep-alive Ping support"},{"location":"/client-side/websocket-support.html#custom-keep-alive-data-payloads","text":"By default, pings do not carry any payload, as it is often enough to simply push any frame over the connection to ensure the connection stays healthy (or detect if it was severed), however you may configure them to carry a custom payload, to do this you can provide a function that will be asked to emit the payload for each of the ping messages generated:\nScala copysourceval defaultSettings = ClientConnectionSettings(system)\n\nval pingCounter = new AtomicInteger()\nval customWebsocketSettings =\n  defaultSettings.websocketSettings\n    .withPeriodicKeepAliveData(() => ByteString(s\"debug-${pingCounter.incrementAndGet()}\"))\n\nval customSettings =\n  defaultSettings.withWebsocketSettings(customWebsocketSettings)\n\nval request = WebSocketRequest(\"ws://127.0.0.1\")\n\nHttp().singleWebSocketRequest(\n  request,\n  Flow[Message],\n  Http().defaultClientHttpsContext,\n  None,\n  customSettings,\n  system.log) Java copysourceClientConnectionSettings defaultSettings = ClientConnectionSettings.create(system);\n\nAtomicInteger pingCounter = new AtomicInteger();\n\nWebSocketSettings customWebsocketSettings = defaultSettings.getWebsocketSettings()\n    .withPeriodicKeepAliveData(() ->\n        ByteString.fromString(String.format(\"debug-%d\", pingCounter.incrementAndGet()))\n    );\n\nClientConnectionSettings customSettings =\n    defaultSettings.withWebsocketSettings(customWebsocketSettings);\n\nHttp http = Http.get(system);\nhttp.singleWebSocketRequest(\n    WebSocketRequest.create(\"ws://127.0.0.1\"),\n    clientFlow,\n    ConnectionContext.noEncryption(),\n    Optional.empty(),\n    customSettings,\n    system.log(),\n    materializer\n);","title":"Custom keep-alive data payloads"},{"location":"/client-side/websocket-support.html#uni-directional-pong-keep-alive","text":"A Ping response will always be replied to by the client-side with an appropriate Pong reply, carrying the same payload. It is also possible to configure the keep-alive mechanism to send Pong frames instead of Ping frames, which enables an uni-directional heartbeat mechanism (in which case the client side will not reply to such heartbeat). You can configure this mode by setting: pekko.http.client.websocket.periodic-keep-alive-mode = pong.","title":"Uni-directional Pong keep-alive"},{"location":"/client-side/http2.html","text":"","title":"Client-Side HTTP/2 (Preview)"},{"location":"/client-side/http2.html#client-side-http-2-preview-","text":"Warning Client-Side HTTP/2 support in pekko-http is currently available as a preview. This means it is ready to be evaluated, but the APIs and behavior are likely to change.\nNote It is recommended to first read the Implications of the streaming nature of Request/Response Entities and Host-Level Client-Side API sections, as they explain the underlying full-stack streaming concepts, tuning the client settings and HTTPS context and how to handle the Request-Response Cycle, which may be unexpected when coming from a background with non-“streaming first” HTTP Clients.","title":"Client-Side HTTP/2 (Preview)"},{"location":"/client-side/http2.html#create-the-client","text":"There are three mechanisms for a client to establish an HTTP/2 connection. Apache Pekko HTTP supports:\nHTTP/2 over TLS HTTP/2 over a plain TCP connection (“h2c with prior knowledge”)\nApache Pekko HTTP doesn’t support:\nHTTP Upgrade mechanism","title":"Create the client"},{"location":"/client-side/http2.html#http-2-over-tls","text":"To create a client, use the Http() fluent API to connect and use the http2() creator:\nScala copysourceimport org.apache.pekko.http.scaladsl.Http\n\nHttp().connectionTo(\"localhost\").toPort(8443).http2() Java copysourceimport org.apache.pekko.http.javadsl.Http;\n\nHttp.get(system)\n        .connectionTo(\"127.0.0.1\")\n        .toPort(8443)\n        .http2();\nHTTP/2 over TLS needs Application-Layer Protocol Negotiation (ALPN) to negotiate whether both client and server support HTTP/2. The JVM provides ALPN support starting from JDK 8u252. Make sure to use at least that version.\nApache Pekko HTTP does not currently support protocol negotiation to fall back to HTTP/1.1 for this API. When the server does not support HTTP/2, the stream will fail.","title":"HTTP/2 over TLS"},{"location":"/client-side/http2.html#h2c-with-prior-knowledge","text":"The other option is to connect and start communicating in HTTP/2 immediately. You must know beforehand the target server supports HTTP/2 over a plain TCP connection. For this reason this approach is known as h2c with Prior Knowledge of HTTP/2 support.\nTo create a client, use the Http() fluent API to connect and use the http2WithPriorKnowledge() creator:\nScala copysourceimport org.apache.pekko.http.scaladsl.Http\n\nHttp().connectionTo(\"localhost\").toPort(8080).http2WithPriorKnowledge() Java copysourceimport org.apache.pekko.http.javadsl.Http;\n\nHttp.get(system)\n        .connectionTo(\"127.0.0.1\")\n        .toPort(8080)\n        .http2WithPriorKnowledge();","title":"h2c with prior knowledge"},{"location":"/client-side/http2.html#http-upgrade-mechanism","text":"The Apache Pekko HTTP client doesn’t support HTTP/1 to HTTP/2 negotiation over plaintext using the Upgrade mechanism.","title":"HTTP Upgrade mechanism"},{"location":"/client-side/http2.html#request-response-ordering","text":"For HTTP/2 connections the responses are not guaranteed to arrive in the same order that the requests were emitted to the server, for example a request with a quickly available response may outrun a previous request that the server is slower to respond to. For HTTP/2 it is therefore important to have a way to correlate the response with the request it was made for. This can be achieved through a RequestResponseAssociationRequestResponseAssociation set on the request, Apache Pekko HTTP will pass such association objects on to the response.\nIn this sample the built-in org.apache.pekko.http.scaladsl.model.ResponsePromiseorg.apache.pekko.http.javadsl.model.ResponseFuture RequestResponseAssociation is used to return a FutureCompletionStage for the response:\nScala copysourceval dispatch = singleRequest(Http().connectionTo(\"pekko.apache.org\").http2())\n\ndispatch(\n  HttpRequest(\n    uri = \"https://pekko.apache.org/api/akka/current/akka/actor/typed/scaladsl/index.html\",\n    headers = headers.`Accept-Encoding`(HttpEncodings.gzip) :: Nil)).onComplete { res =>\n  println(s\"[1] Got index.html: $res\")\n  res.get.entity.dataBytes.runWith(Sink.ignore).onComplete(res => println(s\"Finished reading [1] $res\"))\n}\n\ndef singleRequest(\n    connection: Flow[HttpRequest, HttpResponse, Any], bufferSize: Int = 100): HttpRequest => Future[HttpResponse] = {\n  val queue =\n    Source.queue(bufferSize, OverflowStrategy.dropNew)\n      .via(connection)\n      .to(Sink.foreach { response =>\n        // complete the response promise with the response when it arrives\n        val responseAssociation = response.attribute(ResponsePromise.Key).get\n        responseAssociation.promise.trySuccess(response)\n      })\n      .run()\n\n  req => {\n    // create a promise of the response for each request and set it as an attribute on the request\n    val p = Promise[HttpResponse]()\n    queue.offer(req.addAttribute(ResponsePromise.Key, ResponsePromise(p)))\n      // return the future response\n      .flatMap(_ => p.future)\n  }\n} Java copysource  Function<HttpRequest, CompletionStage<HttpResponse>> dispatch =\n      singleRequest(system, Http.get(system).connectionTo(\"pekko.apache.org\").http2());\n\n  dispatch.apply(\n      HttpRequest.create(\n          \"https://pekko.apache.org/api/akka/current/akka/actor/typed/scaladsl/index.html\").withHeaders(\n          Arrays.asList(AcceptEncoding.create(HttpEncodings.GZIP))\n      )\n  ).thenAccept(res -> {\n    System.out.println(\"[1] Got index.html: \" + res);\n    res.entity().getDataBytes().runWith(Sink.ignore(), mat)\n        .thenAccept(consumedRes -> System.out.println(\"Finished reading [1] \" + consumedRes));\n  });\n\nprivate static Function<HttpRequest, CompletionStage<HttpResponse>> singleRequest(ActorSystem system, Flow<HttpRequest, HttpResponse, ?> connection) {\n  SourceQueueWithComplete<HttpRequest> queue =\n      Source.<HttpRequest>queue(100, OverflowStrategy.dropNew())\n          .via(connection)\n          .to(Sink.foreach(res -> {\n            try {\n              // complete the future with the response when it arrives\n              ResponseFuture responseFuture = res.getAttribute(ResponseFuture.KEY()).get();\n              responseFuture.future().complete(res);\n            } catch (Exception ex) {\n              ex.printStackTrace();\n            }\n          }))\n      .run(SystemMaterializer.get(system).materializer());\n\n  return (HttpRequest req) -> {\n    // create a future of the response for each request and set it as an attribute on the request\n    CompletableFuture<HttpResponse> future = new CompletableFuture<>();\n    ResponseFuture attribute = new ResponseFuture(future);\n    return queue.offer(req.addAttribute(ResponseFuture.KEY(), attribute))\n        // return the future response\n        .thenCompose(__ -> attribute.future());\n  };\n}","title":"Request-response ordering"},{"location":"/extensions.html","text":"","title":"6. Extensions"},{"location":"/extensions.html#6-extensions","text":"There are several third party libraries that expand the functionality of Akka Http.\nAmong those, we want to highlight the following:\nakka-http-json: Integrate some of the best JSON libs in Scala with Akka HTTP swagger-akka-http: A Scala/Java library for generating Open API (a.k.a. Swagger) from annotated Akka HTTP code Guardrail: Guardrail is a code generation tool, capable of reading from OpenAPI/Swagger specification files and generating Akka HTTP code akka-http-cors: Akka Http directives implementing the CORS specifications defined by W3C akka-http-session: Web & mobile client-side akka-http sessions, with optional JWT support sttp: Library that provides a clean, programmer-friendly API to define HTTP requests and execute them using one of the wrapped backends, akka-http among them.\nSee the Scala Index for a more in-depth list of them.","title":"6. Extensions"},{"location":"/technologies.html","text":"","title":"7. Supported Technologies"},{"location":"/technologies.html#7-supported-technologies","text":"This page gives an overview over the technologies that Apache Pekko HTTP implements, supports, and integrates with. The page is still quite new. If you are looking for support of some technology and found information somewhere else, please help us fill out this page using the link at the bottom.","title":"7. Supported Technologies"},{"location":"/technologies.html#http","text":"Apache Pekko HTTP implements HTTP/1.1 including these features (non-exclusive list):\nPersistent connections HTTP Pipelining (currently not supported on the client-side) 100-Continue Client Connection Pooling","title":"HTTP"},{"location":"/technologies.html#https","text":"HTTPS is supported through the facilities that Java provides. See Server HTTPS Support and Client HTTPS Support for more information.","title":"HTTPS"},{"location":"/technologies.html#websocket","text":"Apache Pekko HTTP implements WebSocket on both the server side and the client side. See Server Websocket Support and Client Websocket Support for more information.","title":"WebSocket"},{"location":"/technologies.html#http-2","text":"Apache Pekko HTTP provides server-side HTTP/2 support currently in a preview version. See Server HTTP/2 Support for more information.","title":"HTTP/2"},{"location":"/technologies.html#dns","text":"Apache Pekko HTTP provides a pluggable client transport which can be used to customize host name resolution on the client side.","title":"DNS"},{"location":"/technologies.html#multipart","text":"Apache Pekko HTTP has modeled multipart/* payloads. It provides streaming multipart parsers and renderers e.g. for parsing file uploads and provides a typed model to access details of such a payload.","title":"Multipart"},{"location":"/technologies.html#server-sent-events-sse-","text":"Server-sent Events (SSE) are supported through marshalling that will provide or consume an (Apache Pekko Stream based) stream of events. See SSE Support for more information.","title":"Server-sent Events (SSE)"},{"location":"/technologies.html#json","text":"Marshalling to and from JSON is supported out of the box for spray-json-based model in Scala and Jackson-based models in Java. See JSON Support for more information.","title":"JSON"},{"location":"/technologies.html#xml","text":"Marshalling to and from XML is supported Scala XML literals. See XML Support for more information.","title":"XML"},{"location":"/technologies.html#gzip-and-deflate-content-encoding","text":"GZIP and Deflate content-encodings for automatic encoding / decoding of HTTP payloads are supported through directives. See CodingDirectives for more information.","title":"Gzip and Deflate Content-Encoding"},{"location":"/tipsandtricks.html","text":"","title":"8. Tips And Tricks"},{"location":"/tipsandtricks.html#8-tips-and-tricks","text":"There are few recurring questions that we want to answer in more depth.\nTroubleshooting Unsupported HTTP method: PRI Handling blocking operations in Apache Pekko HTTP Problem Solution: Dedicated dispatcher for blocking operations Implications of the streaming nature of Request/Response Entities Client-Side handling of streaming HTTP Entities Server-Side handling of streaming HTTP Entities","title":"8. Tips And Tricks"},{"location":"/troubleshooting/index.html","text":"","title":"Troubleshooting"},{"location":"/troubleshooting/index.html#troubleshooting","text":"Unsupported HTTP method: PRI","title":"Troubleshooting"},{"location":"/troubleshooting/unsupported-http-method-pri.html","text":"","title":"Unsupported HTTP method: PRI"},{"location":"/troubleshooting/unsupported-http-method-pri.html#unsupported-http-method-pri","text":"Illegal request, responding with status '501 Not Implemented': Unsupported HTTP method: PRI\nThis indicates that an HTTP/2 request was received, but the server was not correctly set up to handle those. You may have to:\nMake sure the pekko.http.server.preview.enable-http2 option is enabled Make sure you are running at least JDK version 8u252 Make sure you are not using Http().bindAndHandle()Http().bindAndHandle() or Http().newServerAt().bindFlow()Http().newServerAt().bindFlow(), but Http().newServerAt().bind()Http().newServerAt().bind().","title":"Unsupported HTTP method: PRI"},{"location":"/handling-blocking-operations-in-pekko-http-routes.html","text":"","title":"Handling blocking operations in Apache Pekko HTTP"},{"location":"/handling-blocking-operations-in-pekko-http-routes.html#handling-blocking-operations-in-apache-pekko-http","text":"Sometimes it is difficult to avoid performing the blocking operations and there are good chances that the blocking is done inside a Future execution, which may lead to problems. It is important to handle the blocking operations correctly.","title":"Handling blocking operations in Apache Pekko HTTP"},{"location":"/handling-blocking-operations-in-pekko-http-routes.html#problem","text":"Using context.dispatchercontext.dispatcher() as the dispatcher on which the blocking Future executes can be a problem - the same dispatcher is used by the routing infrastructure to actually handle the incoming requests.\nIf all of the available threads are blocked, the routing infrastructure will end up starving. Therefore, routing infrastructure should not be blocked. Instead, a dedicated dispatcher for blocking operations should be used.\nNote Blocking APIs should also be avoided if possible. Try to find or build Reactive APIs, such that blocking is minimised, or moved over to dedicated dispatchers. Often when integrating with existing libraries or systems it is not possible to avoid blocking APIs. The following solution explains how to handle blocking operations properly. Note that the same hints apply to managing blocking operations anywhere in Apache Pekko, including in Actors etc.\nIn the thread state diagrams below the colours have the following meaning:\nTurquoise - Sleeping state Orange - Waiting state Green - Runnable state\nThe thread information was recorded using the YourKit profiler, however any good JVM profiler has this feature (including the free and bundled with the Oracle JDK VisualVM, as well as Oracle Flight Recorder).","title":"Problem"},{"location":"/handling-blocking-operations-in-pekko-http-routes.html#problem-example-blocking-the-default-dispatcher","text":"Scala copysource// BAD (due to blocking in Future, on default dispatcher)\nimplicit val defaultDispatcher = system.dispatcher\n\nval routes: Route = post {\n  complete {\n    Future { // uses defaultDispatcher\n      Thread.sleep(5000) // will block on default dispatcher,\n      System.currentTimeMillis().toString // Starving the routing infrastructure\n    }\n  }\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.completeWithFuture;\nimport static org.apache.pekko.http.javadsl.server.Directives.post;\n\n// BAD (due to blocking in Future, on default dispatcher)\nfinal Route routes = post( () ->\n        completeWithFuture(CompletableFuture.supplyAsync(() -> { // uses defaultDispatcher\n            try {\n                Thread.sleep(5000L); // will block on default dispatcher,\n            } catch (InterruptedException e) {\n            }\n            return HttpResponse.create() // Starving the routing infrastructure\n                    .withEntity(Long.toString(System.currentTimeMillis()));\n        }))\n);\nHere the app is exposed to a load of continuous GET requests and large numbers of pekko.actor.default-dispatcher threads are handling requests. The orange portion of the thread shows that it is idle. Idle threads are fine - they’re ready to accept new work. However, large amounts of Turquoise (sleeping) threads are very bad!\nAfter some time, the app is exposed to the load of POST requests, which will block these threads.\nSince we’re using the Java CompletableFuture in this example, the blocking will happen on its default pool which is the global ForkJoinPool.commonPool(). With Scala Futures the in-scope provided dispatcher would be used. Both these dispatchers are ForkJoin pools by default, and are not best suited for blocking operations.\nFor example, the above screenshot shows an Apache Pekko FJP dispatchers threads, named “default-akka.default-dispatcher2,3,4” going into the blocking state, after having been idle. It can be observed that the number of new threads increases, “default-akka.actor.default-dispatcher 18,19,20,...” however they go to sleep state immediately, thus wasting the resources.\nThe number of such new threads depends on the default dispatcher configuration, but it will likely not exceed 50. Since many POST requests are being processed, the entire thread pool is starved. The blocking operations dominate such that the routing infra has no thread available to handle the other requests.\nIn essence, the Thread.sleepThread.sleep() operation has dominated all threads and caused anything executing on the default dispatcher to starve for resources (including any Actors that you have not configured an explicit dispatcher for).","title":"Problem example: blocking the default dispatcher"},{"location":"/handling-blocking-operations-in-pekko-http-routes.html#solution-dedicated-dispatcher-for-blocking-operations","text":"In application.conf, the dispatcher dedicated to blocking behaviour should be configured as follows:\nmy-blocking-dispatcher {\n  type = Dispatcher\n  executor = \"thread-pool-executor\"\n  thread-pool-executor {\n    fixed-pool-size = 16\n  }\n  throughput = 1\n}\nThere are many dispatcher options available which can be found in Dispatchers.\nHere thread-pool-executor is used, which has a hardcoded limit of threads. It keeps a set number of threads available that allow for safe isolation of the blocking operations. The size settings should depend on the app’s functionality and the number of cores the server has.\nWhenever blocking has to be done, use the above configured dispatcher instead of the default one:\nScala copysource// GOOD (the blocking is now isolated onto a dedicated dispatcher):\nimplicit val blockingDispatcher = system.dispatchers.lookup(\"my-blocking-dispatcher\")\n\nval routes: Route = post {\n  complete {\n    Future { // uses the good \"blocking dispatcher\" that we configured,\n      // instead of the default dispatcher to isolate the blocking.\n      Thread.sleep(5000)\n      System.currentTimeMillis().toString\n    }\n  }\n} Java copysourceimport static org.apache.pekko.http.javadsl.server.Directives.completeWithFuture;\nimport static org.apache.pekko.http.javadsl.server.Directives.post;\n\n// GOOD (the blocking is now isolated onto a dedicated dispatcher):\nfinal Route routes = post(() -> {\n    final MessageDispatcher dispatcher = system.dispatchers().lookup(\"my-blocking-dispatcher\");\n    return completeWithFuture(CompletableFuture.supplyAsync(() -> {\n                try {\n                    Thread.sleep(5000L);\n                } catch (InterruptedException e) {\n                }\n                return HttpResponse.create()\n                        .withEntity(Long.toString(System.currentTimeMillis()));\n            }, dispatcher // uses the good \"blocking dispatcher\" that we\n            // configured, instead of the default dispatcher to isolate the blocking.\n    ));\n});\nThis forces the app to use the same load, initially normal requests and then the blocking requests. The thread pool behaviour is shown in the figure.\nInitially, the normal requests are easily handled by the default dispatcher - the green lines, which represent the actual execution.\nWhen blocking operations are issued, the my-blocking-dispatcher starts up to the number of configured threads. It handles sleeping. After a certain period of nothing happening to the threads, it shuts them down.\nIf another bunch of operations have to be done, the pool will start new threads that will take care of putting them into sleep state, but the threads are not wasted.\nIn this case, the throughput of the normal GET requests was not impacted - they were still served on the default dispatcher.\nThis is the recommended way of dealing with any kind of blocking in reactive applications. It is referred to as “bulkheading” or “isolating” the bad behaving parts of an app. In this case, bad behaviour of blocking operations.\nThere is good documentation available in Apache Pekko docs section, Blocking needs careful management.","title":"Solution: Dedicated dispatcher for blocking operations"},{"location":"/implications-of-streaming-http-entity.html","text":"","title":"Implications of the streaming nature of Request/Response Entities"},{"location":"/implications-of-streaming-http-entity.html#implications-of-the-streaming-nature-of-request-response-entities","text":"Apache Pekko HTTP is streaming all the way through, which means that the back-pressure mechanisms enabled by Apache Pekko Streams are exposed through all layers–from the TCP layer, through the HTTP server, all the way up to the user-facing HttpRequestHttpRequest and HttpResponseHttpResponse and their HttpEntityHttpEntity APIs.\nThis has surprising implications if you are used to non-streaming / not-reactive HTTP clients. Specifically it means that: “lack of consumption of the HTTP Entity, is signaled as back-pressure to the other side of the connection”. This is a feature, as it allows one only to consume the entity, and back-pressure servers/clients from overwhelming our application, possibly causing unnecessary buffering of the entity in memory.\nPut another way: Streaming all the way through is a feature of Apache Pekko HTTP that allows consuming entities (and pulling them through the network) in a streaming fashion, and only on demand when the client is ready to consume the bytes. Therefore, you have to explicitly consume or discard the entity.\nOn a client, for example, if the application doesn’t subscribe to the response entity within pekko.http.host-connection-pool.response-entity-subscription-timeout, the stream will fail with a TimeoutException: Response entity was not subscribed after ....\nWarning Consuming (or discarding) the Entity of a request is mandatory! If accidentally left neither consumed or discarded Apache Pekko HTTP will assume the incoming data should remain back-pressured, and will stall the incoming data via TCP back-pressure mechanisms. A client should consume the Entity regardless of the status of the HttpResponseHttpResponse.","title":"Implications of the streaming nature of Request/Response Entities"},{"location":"/implications-of-streaming-http-entity.html#client-side-handling-of-streaming-http-entities","text":"","title":"Client-Side handling of streaming HTTP Entities"},{"location":"/implications-of-streaming-http-entity.html#consuming-the-http-response-entity-client-","text":"There are two use-cases to consume the entity of a response:\nprocess the bytes as the response arrives from the network buffer load all the bytes in memory first, and process them afterwards\nThe most common use-case, and recommended, of course, is consuming the response entity as a stream, which can be done via running the underlying dataBytes Source.\nIt is encouraged to use various streaming techniques to utilise the underlying infrastructure to its fullest, for example by framing the incoming chunks, parsing them line-by-line and then connecting the flow into another destination Sink, such as a File or other Apache Pekko Streams connector:\nScala copysourceimport java.io.File\n\nimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.model._\nimport pekko.stream.scaladsl.{ FileIO, Framing }\nimport pekko.util.ByteString\n\nimplicit val system = ActorSystem()\n\nval response: HttpResponse = ???\n\nresponse.entity.dataBytes\n  .via(Framing.delimiter(ByteString(\"\\n\"), maximumFrameLength = 256))\n  .map(transformEachLine)\n  .runWith(FileIO.toPath(new File(\"/tmp/example.out\").toPath))\n\ndef transformEachLine(line: ByteString): ByteString = ???\n Java copysourceimport java.io.File;\n\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Function;\nimport org.apache.pekko.stream.javadsl.Framing;\nimport org.apache.pekko.http.javadsl.model.*;\nimport scala.concurrent.duration.FiniteDuration;\n\nfinal ActorSystem system = ActorSystem.create();\nfinal ExecutionContextExecutor dispatcher = system.dispatcher();\n\nfinal HttpResponse response = responseFromSomewhere();\n\nfinal Function<ByteString, ByteString> transformEachLine = line -> line /* some transformation here */;\n\nfinal int maximumFrameLength = 256;\n\nresponse.entity().getDataBytes()\n  .via(Framing.delimiter(ByteString.fromString(\"\\n\"), maximumFrameLength, FramingTruncation.ALLOW))\n  .map(transformEachLine::apply)\n  .runWith(FileIO.toPath(new File(\"/tmp/example.out\").toPath()), system);\nHowever, sometimes the need may arise to consume the entire entity as Strict entity (which means that it is completely loaded into memory). Apache Pekko HTTP provides a special toStrict(timeout)toStrict(timeout, materializer) method which can be used to eagerly consume the entity and make it available in memory. Once in memory, data can be consumed as a ByteString or as a Source:\nScala copysourceimport scala.concurrent.Future\nimport scala.concurrent.duration._\n\nimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.model._\nimport pekko.util.ByteString\n\nimplicit val system = ActorSystem()\nimplicit val dispatcher = system.dispatcher\n\ncase class ExamplePerson(name: String)\ndef parse(line: ByteString): ExamplePerson = ???\n\nval response: HttpResponse = ???\n\n// toStrict to enforce all data be loaded into memory from the connection\nval strictEntity: Future[HttpEntity.Strict] = response.entity.toStrict(3.seconds)\n\n// You can now use the `data` directly...\nval person1: Future[ExamplePerson] = strictEntity.map(e => parse(e.data))\n\n// Though it is also still possible to use the streaming API to consume dataBytes,\n// even though now they're in memory:\nval person2: Future[ExamplePerson] =\n  strictEntity.flatMap { e =>\n    e.dataBytes\n      .runFold(ByteString.empty) { case (acc, b) => acc ++ b }\n      .map(parse)\n  }\n Java copysourcefinal class ExamplePerson {\n  final String name;\n  public ExamplePerson(String name) { this.name = name; }\n}\n\npublic ExamplePerson parse(ByteString line) {\n  return new ExamplePerson(line.utf8String());\n}\n\nfinal ActorSystem system = ActorSystem.create();\nfinal ExecutionContextExecutor dispatcher = system.dispatcher();\n\nfinal HttpResponse response = responseFromSomewhere();\n\n// toStrict to enforce all data be loaded into memory from the connection\nfinal CompletionStage<HttpEntity.Strict> strictEntity = response.entity()\n    .toStrict(FiniteDuration.create(3, TimeUnit.SECONDS).toMillis(), system);\n\n// You can now use `getData` to get the data directly...\nfinal CompletionStage<ExamplePerson> person1 =\n  strictEntity.thenApply(strict -> parse(strict.getData()));\n\n// Though it is also still possible to use the streaming API to consume dataBytes,\n// even though now they're in memory:\nfinal CompletionStage<ExamplePerson> person2 =\n  strictEntity\n    .thenCompose(strict ->\n      strict.getDataBytes()\n        .runFold(emptyByteString(), (acc, b) -> acc.concat(b), system)\n        .thenApply(this::parse)\n    );","title":"Consuming the HTTP Response Entity (Client)"},{"location":"/implications-of-streaming-http-entity.html#integrating-with-apache-pekko-streams","text":"In some cases, it is necessary to process the results of a series of Apache Pekko HTTP calls as Apache Pekko Streams. In order to ensure that the HTTP Response Entity is consumed in a timely manner, the Apache Pekko HTTP stream for each request must be executed and completely consumed, then sent along for further processing.\nFailing to account for this behavior can result in seemingly non-deterministic failures due to complex interactions between http and stream buffering. This manifests as errors such as the following:\nResponse entity was not subscribed after 1 second. Make sure to read the response `entity` body or call `entity.discardBytes()` on it -- in case you deal with `HttpResponse`, use the shortcut `response.discardEntityBytes()`.\nThis error indicates that the http response has been available for too long without being consumed. It can be partially worked around by increasing the subscription timeout, but you will still run the risk of running into network level timeouts and could still exceed the timeout under load so it’s best to resolve the issue properly such as in the examples below:\nScala copysourceimport scala.concurrent.Future\n\nimport org.apache.pekko\nimport pekko.NotUsed\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.Http\nimport pekko.http.scaladsl.model._\nimport pekko.util.ByteString\nimport pekko.stream.scaladsl.{ Flow, Sink, Source }\n\nimplicit val system = ActorSystem()\nimplicit val dispatcher = system.dispatcher\n\ncase class ExamplePerson(name: String)\n\ndef parse(line: ByteString): Option[ExamplePerson] =\n  line.utf8String.split(\" \").headOption.map(ExamplePerson)\n\nval requests: Source[HttpRequest, NotUsed] = Source\n  .fromIterator(() =>\n    Range(0, 10).map(i => HttpRequest(uri = Uri(s\"https://localhost/people/$i\"))).iterator)\n\nval processorFlow: Flow[Option[ExamplePerson], Int, NotUsed] =\n  Flow[Option[ExamplePerson]].map(_.map(_.name.length).getOrElse(0))\n\n// Run and completely consume a single akka http request\ndef runRequest(req: HttpRequest): Future[Option[ExamplePerson]] =\n  Http()\n    .singleRequest(req)\n    .flatMap { response =>\n      response.entity.dataBytes\n        .runReduce(_ ++ _)\n        .map(parse)\n    }\n\n// Run each akka http flow to completion, then continue processing. You'll want to tune the `parallelism`\n// parameter to mapAsync -- higher values will create more cpu and memory load which may or may not positively\n// impact performance.\nrequests\n  .mapAsync(2)(runRequest)\n  .via(processorFlow)\n  .runWith(Sink.ignore)\n Java copysourcefinal class ExamplePerson {\n  final String name;\n  public ExamplePerson(String name) { this.name = name; }\n}\n\npublic ExamplePerson parse(ByteString line) {\n  return new ExamplePerson(line.utf8String());\n}\n\nfinal ActorSystem system = ActorSystem.create();\nfinal ExecutionContextExecutor dispatcher = system.dispatcher();\n\n// run a single request, consuming it completely in a single stream\npublic CompletionStage<ExamplePerson> runRequest(HttpRequest request) {\n  return Http.get(system)\n    .singleRequest(request)\n    .thenCompose(response ->\n      response.entity().getDataBytes()\n        .runReduce((a, b) -> a.concat(b), system)\n        .thenApply(this::parse)\n    );\n}\n\nfinal List<HttpRequest> requests = new ArrayList<>();\n\nfinal Flow<ExamplePerson, Integer, NotUsed> exampleProcessingFlow = Flow\n        .fromFunction(person -> person.toString().length());\n\nfinal CompletionStage<Done> stream = Source\n        .from(requests)\n        .mapAsync(1, this::runRequest)\n        .via(exampleProcessingFlow)\n        .runWith(Sink.ignore(), system);","title":"Integrating with Apache Pekko Streams"},{"location":"/implications-of-streaming-http-entity.html#discarding-the-http-response-entity-client-","text":"Sometimes when calling HTTP services we do not care about their response payload (e.g. all we care about is the response code), yet as explained above entity still has to be consumed in some way, otherwise we’ll be exerting back-pressure on the underlying TCP connection.\nThe discardEntityBytes convenience method serves the purpose of easily discarding the entity if it has no purpose for us. It does so by piping the incoming bytes directly into an Sink.ignore.\nThe two snippets below are equivalent, and work the same way on the server-side for incoming HTTP Requests:\nScala copysourceimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.model.HttpMessage.DiscardedEntity\nimport pekko.http.scaladsl.model._\n\nimplicit val system = ActorSystem()\nimplicit val dispatcher = system.dispatcher\n\nval response1: HttpResponse = ??? // obtained from an HTTP call (see examples below)\n\nval discarded: DiscardedEntity = response1.discardEntityBytes()\ndiscarded.future.onComplete { done => println(\"Entity discarded completely!\") }\n Java copysourcefinal ActorSystem system = ActorSystem.create();\nfinal ExecutionContextExecutor dispatcher = system.dispatcher();\n\nfinal HttpResponse response = responseFromSomewhere();\n\nfinal HttpMessage.DiscardedEntity discarded = response.discardEntityBytes(system);\n\ndiscarded.completionStage().whenComplete((done, ex) -> {\n  System.out.println(\"Entity discarded completely!\");\n});\nOr the equivalent low-level code achieving the same result:\nScala copysourceval response1: HttpResponse = ??? // obtained from an HTTP call (see examples below)\n\nval discardingComplete: Future[Done] = response1.entity.dataBytes.runWith(Sink.ignore)\ndiscardingComplete.onComplete(done => println(\"Entity discarded completely!\")) Java copysourcefinal ActorSystem system = ActorSystem.create();\nfinal ExecutionContextExecutor dispatcher = system.dispatcher();\n\nfinal HttpResponse response = responseFromSomewhere();\n\nfinal CompletionStage<Done> discardingComplete = response.entity().getDataBytes().runWith(Sink.ignore(), system);\n\ndiscardingComplete.whenComplete((done, ex) -> {\n  System.out.println(\"Entity discarded completely!\");\n});","title":"Discarding the HTTP Response Entity (Client)"},{"location":"/implications-of-streaming-http-entity.html#server-side-handling-of-streaming-http-entities","text":"HTTP Entities of a request are directly linked to Streams fed by the underlying TCP connection. Thus, if request entities remain not consumed, the server will back-pressure the connection, expecting the user-code to eventually decide what to do with the incoming data.\nThe most common use-case is to consume the request entity using directives such as BasicDirectives.extractDataBytes. Some directives force an implicit toStrict operation, such as entity(as[String])entity(exampleUnmarshaller, example -> {}).","title":"Server-Side handling of streaming HTTP Entities"},{"location":"/implications-of-streaming-http-entity.html#consuming-the-http-request-entity-server-","text":"The simplest way of consuming the incoming request entity is to transform it into an actual domain object, for example by using the entity directive:\nScala copysourceimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.server.Directives._\nimport pekko.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._\nimport spray.json.DefaultJsonProtocol._\n\nimplicit val system = ActorSystem()\n// needed for the future flatMap/onComplete in the end\nimplicit val executionContext = system.dispatcher\n\nfinal case class Bid(userId: String, bid: Int)\n\n// these are from spray-json\nimplicit val bidFormat = jsonFormat2(Bid)\n\nval route =\n  path(\"bid\") {\n    put {\n      entity(as[Bid]) { bid =>\n        // incoming entity is fully consumed and converted into a Bid\n        complete(\"The bid was: \" + bid)\n      }\n    }\n  } Java copysourceclass Bid {\n  final String userId;\n  final int bid;\n\n  Bid(String userId, int bid) {\n    this.userId = userId;\n    this.bid = bid;\n  }\n}\n\nfinal ActorSystem system = ActorSystem.create();\nfinal ExecutionContextExecutor dispatcher = system.dispatcher();\nfinal ActorMaterializer materializer = ActorMaterializer.create(system);\n\nfinal Unmarshaller<HttpEntity, Bid> asBid = Jackson.unmarshaller(Bid.class);\n\nfinal Route s = path(\"bid\", () ->\n  put(() ->\n    entity(asBid, bid ->\n      // incoming entity is fully consumed and converted into a Bid\n      complete(\"The bid was: \" + bid)\n    )\n  )\n);\nYou can also access the raw dataBytes and run the underlying stream. For example, you could pipe the raw dataBytes into a FileIO Sink. The FileIO Sink signals completion via a Future[IoResult]CompletionStage<IoResult> once all the data has been written into the file:\nScala copysourceimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.stream.scaladsl.FileIO\nimport pekko.http.scaladsl.server.Directives._\nimport java.io.File\n\nimplicit val system = ActorSystem()\n// needed for the future flatMap/onComplete in the end\nimplicit val executionContext = system.dispatcher\n\nval route =\n  (put & path(\"lines\")) {\n    withoutSizeLimit {\n      extractDataBytes { bytes =>\n        val finishedWriting = bytes.runWith(FileIO.toPath(new File(\"/tmp/example.out\").toPath))\n\n        // we only want to respond once the incoming data has been handled:\n        onComplete(finishedWriting) { ioResult =>\n          complete(\"Finished writing data: \" + ioResult)\n        }\n      }\n    }\n  } Java copysourcefinal ActorSystem system = ActorSystem.create();\nfinal ExecutionContextExecutor dispatcher = system.dispatcher();\nfinal ActorMaterializer materializer = ActorMaterializer.create(system);\n\nfinal Route s =\n  put(() ->\n    path(\"lines\", () ->\n      withoutSizeLimit(() ->\n        extractDataBytes(bytes -> {\n          final CompletionStage<IOResult> res = bytes.runWith(FileIO.toPath(new File(\"/tmp/example.out\").toPath()), materializer);\n\n          return onComplete(() -> res, ioResult ->\n            // we only want to respond once the incoming data has been handled:\n            complete(\"Finished writing data :\" + ioResult));\n        })\n      )\n    )\n  );","title":"Consuming the HTTP Request Entity (Server)"},{"location":"/implications-of-streaming-http-entity.html#discarding-the-http-request-entity-server-","text":"You may want to discard the uploaded entity. For example, depending on some validation (e.g. “is user authorized to upload files?”).\nPlease note that “discarding the HTTP Request Entity” means that the entire upload will proceed, even though you are not interested in the data being streamed to the server. This is useful if you are simply not interested in the entity.\nIn order to discard the dataBytes explicitly you can invoke the discardEntityBytes bytes of the incoming HttpRequest:\nScala copysourceimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.http.scaladsl.server.Directives._\nimport pekko.http.scaladsl.model.HttpRequest\n\nimplicit val system = ActorSystem()\n// needed for the future flatMap/onComplete in the end\nimplicit val executionContext = system.dispatcher\n\nval route =\n  (put & path(\"lines\")) {\n    withoutSizeLimit {\n      extractRequest { r: HttpRequest =>\n        val finishedWriting = r.discardEntityBytes().future\n\n        // we only want to respond once the incoming data has been handled:\n        onComplete(finishedWriting) { done =>\n          complete(\"Drained all data from connection... (\" + done + \")\")\n        }\n      }\n    }\n  } Java copysourcefinal ActorSystem system = ActorSystem.create();\nfinal ExecutionContextExecutor dispatcher = system.dispatcher();\n\nfinal Route s =\n  put(() ->\n    path(\"lines\", () ->\n      withoutSizeLimit(() ->\n        extractRequest(r -> {\n          final CompletionStage<Done> res = r.discardEntityBytes(system).completionStage();\n\n          return onComplete(() -> res, done ->\n            // we only want to respond once the incoming data has been handled:\n            complete(\"Finished writing data :\" + done));\n        })\n      )\n    )\n  );\nA related concept is cancelling the incoming entity.dataBytesentity.getDataBytes() stream. Cancellation results in Apache Pekko HTTP abruptly closing the connection from the Client. This may be useful when you detect that the given user should not be allowed to make any uploads at all, and you want to drop the connection (instead of reading and ignoring the incoming data). This can be done by attaching the incoming entity.dataBytesentity.getDataBytes() to a Sink.cancelled() which will cancel the entity stream, which in turn will cause the underlying connection to be shut-down by the server – effectively hard-aborting the incoming request:\nScala copysourceimport org.apache.pekko\nimport pekko.actor.ActorSystem\nimport pekko.stream.scaladsl.Sink\nimport pekko.http.scaladsl.server.Directives._\nimport pekko.http.scaladsl.model.headers.Connection\n\nimplicit val system = ActorSystem()\n// needed for the future flatMap/onComplete in the end\nimplicit val executionContext = system.dispatcher\n\nval route =\n  (put & path(\"lines\")) {\n    withoutSizeLimit {\n      extractDataBytes { data =>\n        // Closing connections, method 1 (eager):\n        // we deem this request as illegal, and close the connection right away:\n        data.runWith(Sink.cancelled) // \"brutally\" closes the connection\n\n        // Closing connections, method 2 (graceful):\n        // consider draining connection and replying with `Connection: Close` header\n        // if you want the client to close after this request/reply cycle instead:\n        respondWithHeader(Connection(\"close\"))\n        complete(StatusCodes.Forbidden -> \"Not allowed!\")\n      }\n    }\n  } Java copysourcefinal ActorSystem system = ActorSystem.create();\nfinal ExecutionContextExecutor dispatcher = system.dispatcher();\nfinal ActorMaterializer materializer = ActorMaterializer.create(system);\n\nfinal Route s =\n  put(() ->\n    path(\"lines\", () ->\n      withoutSizeLimit(() ->\n        extractDataBytes(bytes -> {\n          // Closing connections, method 1 (eager):\n          // we deem this request as illegal, and close the connection right away:\n          bytes.runWith(Sink.cancelled(), materializer);  // \"brutally\" closes the connection\n\n          // Closing connections, method 2 (graceful):\n          // consider draining connection and replying with `Connection: Close` header\n          // if you want the client to close after this request/reply cycle instead:\n          return respondWithHeader(Connection.create(\"close\"), () ->\n            complete(StatusCodes.FORBIDDEN, \"Not allowed!\")\n          );\n        })\n      )\n    )\n  );\nSee also the Closing a connection section for an in-depth explanation on closing connection.","title":"Discarding the HTTP Request Entity (Server)"},{"location":"/implications-of-streaming-http-entity.html#pending-automatic-discarding-of-not-used-entities","text":"Under certain conditions it is possible to detect an entity is very unlikely to be used by the user for a given request, and issue warnings or discard the entity automatically. This advanced feature has not been implemented yet, see the below note and issues for further discussion and ideas.\nNote An advanced feature code named “auto draining” has been discussed and proposed for Apache Pekko HTTP, and we’re hoping to implement or help the community implement it. You can read more about it in issue #183 as well as issue #117 ; as always, contributions are very welcome!","title":"Pending: Automatic discarding of not used entities"},{"location":"/contributing.html","text":"","title":"9. Contributing"},{"location":"/contributing.html#9-contributing","text":"","title":"9. Contributing"},{"location":"/contributing.html#welcome-","text":"We follow the standard GitHub fork & pull approach to pull requests. Just fork the official repo, develop in a branch, and submit a PR!\nFor a more detailed description of our process, please refer to the CONTRIBUTING.md page on the github project.","title":"Welcome!"},{"location":"/contributing.html#snapshots","text":"Testing snapshot versions can help us find bugs before a release. We publish snapshot versions for every commit to the main branch.\nThe latest published snapshot version can be found in SonatypeSnapshots.","title":"Snapshots"},{"location":"/contributing.html#configure-repository","text":"sbt resolvers += \"pekko-http-snapshot-repository\" at \"https://repository.apache.org/content/repositories/snapshots\"\n Maven <project>\n...\n  <repositories>\n    <repository>\n      <id>pekko-http-snapshots</id>\n      <name>Pekko HTTP Snapshots</name>\n      <url>https://repository.apache.org/content/repositories/snapshots</url>\n    </repository>\n  </repositories>\n...\n</project>\n Gradle repositories {\n  maven {\n    url  \"https://repository.apache.org/content/repositories/snapshots\"\n  }\n}","title":"Configure repository"},{"location":"/reference.html","text":"","title":"10. Reference"},{"location":"/reference.html#10-reference","text":"","title":"10. Reference"},{"location":"/reference.html#api-documentation","text":"Scaladoc Javadoc","title":"API Documentation"},{"location":"/reference.html#directives","text":"Directives By Trait Directives Alphabetically","title":"Directives"},{"location":"/reference.html#books","text":"Start Building RESTful Microservices using Apache Pekko HTTP with Scala, by Ayush Kumar Mishra, Knoldus Software LLP, ISBN: 9781976762543, December 2017","title":"Books"}]}